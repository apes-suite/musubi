<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="A multi-level parallel lattice Boltzmann solver within the APES suite.">
    <meta name="author" content="University of Siegen" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; Musubi
</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <!-- Font Awesome -->
    <link href="../css/fontawesome.min.css" rel="stylesheet">
    <link href="../css/brands.min.css" rel="stylesheet">
    <link href="../css/regular.min.css" rel="stylesheet">
    <link href="../css/solid.min.css" rel="stylesheet">
    <link href="../css/v4-font-face.min.css" rel="stylesheet">
    <link href="../css/v4-shims.min.css" rel="stylesheet">
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async
            integrity="sha256-DViIOMYdwlM/axqoGDPeUyf0urLoHMN4QACBKyB58Uw=" crossorigin="anonymous"></script>
    <!-- Other scripts and stylesheets -->
    <link href="../css/local.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Musubi </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                <li class="nav-item"><a class="nav-link" href="../page/index.html">Documentation</a></li>
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/programs.html">Programs</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr>
                 <td><a href='../proc/access_bcfricvel_forelement.html'>access_bcFricVel_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns friction velocity computed in turbulent_wall bc and
stored in mus_turb_wallFunc_data_type routine.</p><a href="../proc/access_bcfricvel_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_bcnormal_forelement.html'>access_bcNormal_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the boundary normal pointing inside the domain</p><a href="../proc/access_bcnormal_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_bcnormdisttobnd_forelement.html'>access_bcNormDistToBnd_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns normal distance to boundary calculated in
mus_init_turbWallFunc and stored in mus_turb_wallFunc_data_type routine.</p><a href="../proc/access_bcnormdisttobnd_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_bcturbvisc_forelement.html'>access_bcTurbVisc_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns turbulent viscosity computed in turbulent_wall bc
according to RANS formulation and stored in mus_turb_wallFunc_data_type
routine.</p><a href="../proc/access_bcturbvisc_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_bcyplus_forelement.html'>access_bcYPlus_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns yPlus = distToBnd * fric_vel / visc</p><a href="../proc/access_bcyplus_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_kineomega_forelement.html'>access_kineOmega_forElement</a></td>
                 <td><a href='../module/mus_material_var_module.html'>mus_material_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the omega</p><a href="../proc/access_kineomega_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_kinevisc_forelement.html'>access_kineVisc_forElement</a></td>
                 <td><a href='../module/mus_material_var_module.html'>mus_material_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the kinematic viscosity</p><a href="../proc/access_kinevisc_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_pressref_forelement.html'>access_pressRef_forElement</a></td>
                 <td><a href='../module/mus_material_var_module.html'>mus_material_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the reference pressure</p><a href="../proc/access_pressref_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_qval_forelement.html'>access_qVal_forElement</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the boundary qValues</p><a href="../proc/access_qval_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/access_turbvisc_forelement.html'>access_turbVisc_forElement</a></td>
                 <td><a href='../module/mus_turbulence_var_module.html'>mus_turbulence_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the turbulent viscosity</p><a href="../proc/access_turbvisc_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/add_momentum_increment_to_auxfield.html'>add_Momentum_Increment_to_Auxfield</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Add a momentum increment to element with PosInTotal in total list</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/addcollisionforcetobuffer.html'>addCollisionForceToBuffer</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>addCollisionForceToBuffer adds DEM collision force Fcoll to the force buffer sent to
particle with id particleID on rank recvRankIndex.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/addforcetoauxfieldcell.html'>addForceToAuxFieldCell</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>ModifyAuxFieldCell is a helper routine that modifies the auxfield in the cell with
position elemPos in the total list. It takes the total force F_particle and the vector
r_lat (in lattice units) pointing from the particle location to the barycenter of the
fluid element, then computes the weight and modifies the auxField.
Performing addForceToAuxFieldCell over every neighboring cell around a particle
(including the one the particle is on) distributes the entire force.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/addparticlesourcetoauxfield_dps.html'>addParticleSourceToAuxfield_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to modify the auxField (velocity) with the forces exerted
by particles on the fluid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/advance_particles_dps.html'>advance_particles_DPS</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/advance_particles_mem.html'>advance_particles_MEM</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/allocate_mombuf.html'>allocate_momBuf</a></td>
                 <td><a href='../module/mus_pdf_module.html'>mus_pdf_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/allocatebclist.html'>allocateBCList</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Allocate BC lists, 2nd step in Build_BClists</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/allocateprocessmasks.html'>allocateProcessMasks</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/allocateprocessmasks~2.html'>allocateProcessMasks</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/allocateprocessmasks_dps.html'>allocateProcessMasks_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/allocateprocessmasks_mem.html'>allocateProcessMasks_MEM</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine for allocating the existsOnProc, addToProc and removeFromProc
masks used to determine when particles should be sent over to new processes
or which processes need to receive position, velocity updates etc.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_da_particle_dps.html'>append_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/append_da_particle_mem.html'>append_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applydragforce_dps.html'>applyDragForce_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to calculate the drag force according to
[1] S. Tenneti, R. Garg, and S. Subramaniam, “Drag law for monodisperse
gas–solid systems using particle-resolved direct numerical simulation of flow
past fixed assemblies of spheres,” International Journal of Multiphase Flow,
vol. 37, no. 9, pp. 1072–1092, Nov. 2011, doi:
10.1016/j.ijmultiphaseflow.2011.05.010.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applydragforce_dps_noeps.html'>applyDragForce_DPS_noeps</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applyhydrodynamicforces.html'>applyHydrodynamicForces</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>ApplyHydrodynamicForces performs the momentum transfer
from fluid TO particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applyliftforce_dps.html'>applyLiftForce_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>applyLiftForce_DPS computes the Saffman lift force on a particle according to
the paper :
  Saffman PG. The lift on a small sphere in a slow shear flow.
  J Fluid Mech 1965;22(2):385–400. doi:10.1017/S0 022112065000824.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applypressureforce_dps.html'>applyPressureForce_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the pressure gradient force on a particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_absorblayer.html'>applySrc_absorbLayer</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "absorb_layer".
absorb_layer is used to absorb the flow and gradually reduce the flow
quantities like pressure and velocity to a fixed value.
It is based on:
Xu, H., &amp; Sagaut, P. (2013). Analysis of the absorbing layers for the
weakly-compressible lattice Boltzmann methods. Journal of Computational
Physics, 245(x), 14–42.
Jacob, J.; Sagaut, P. (2019): Solid wall and open boundary conditions in
hybrid recursive regularized lattice Boltzmann method for compressible
flows. In Physics of Fluids 31 (12), p. 126103.</p><a href="../proc/applysrc_absorblayer.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_absorblayer_mrt.html'>applySrc_absorbLayer_MRT</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "absorb_layer".
absorb_layer is used to absorb the flow and gradually reduce the flow
quantities like pressure and velocity to a fixed value.
It is based on:
Xu, H., &amp; Sagaut, P. (2013). Analysis of the absorbing layers for the
weakly-compressible lattice Boltzmann methods. Journal of Computational
Physics, 245(x), 14–42.
Jacob, J.; Sagaut, P. (2019): Solid wall and open boundary conditions in
hybrid recursive regularized lattice Boltzmann method for compressible
flows. In Physics of Fluids 31 (12), p. 126103.</p><a href="../proc/applysrc_absorblayer_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_absorblayerdyn.html'>applySrc_absorbLayerDyn</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "absorb_layer".
absorb_layer is used to absorb the flow and gradually reduce the flow
quantities like pressure and velocity to a fixed value.
It is based on:
Xu, H., &amp; Sagaut, P. (2013). Analysis of the absorbing layers for the
weakly-compressible lattice Boltzmann methods. Journal of Computational
Physics, 245(x), 14–42.
Jacob, J.; Sagaut, P. (2019): Solid wall and open boundary conditions in
hybrid recursive regularized lattice Boltzmann method for compressible
flows. In Physics of Fluids 31 (12), p. 126103.</p><a href="../proc/applysrc_absorblayerdyn.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_absorblayerdyn_mrt.html'>applySrc_absorbLayerDyn_MRT</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "absorb_layer".
absorb_layer is used to absorb the flow and gradually reduce the flow
quantities like pressure and velocity to a fixed value.
It is based on:
Xu, H., &amp; Sagaut, P. (2013). Analysis of the absorbing layers for the
weakly-compressible lattice Boltzmann methods. Journal of Computational
Physics, 245(x), 14–42.
Jacob, J.; Sagaut, P. (2019): Solid wall and open boundary conditions in
hybrid recursive regularized lattice Boltzmann method for compressible
flows. In Physics of Fluids 31 (12), p. 126103.</p><a href="../proc/applysrc_absorblayerdyn_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_absorblayerincomp.html'>applySrc_absorbLayerIncomp</a></td>
                 <td><a href='../module/mus_derquanincomp_module.html'>mus_derQuanIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "absorb_layer".
absorb_layer is used to absorb the flow and gradually reduce the flow
quantities like pressure and velocity to a fixed value for incompressible
model. It is based on:
Xu, H., &amp; Sagaut, P. (2013). Analysis of the absorbing layers for the
weakly-compressible lattice Boltzmann methods. Journal of Computational
Physics, 245(x), 14–42.</p><a href="../proc/applysrc_absorblayerincomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_chargedensity_1stord.html'>applySrc_chargeDensity_1stOrd</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "ChargeDensity" with 1st order
integration of source Term.
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_chargedensity_1stord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_chargedensity_2ndord.html'>applySrc_chargeDensity_2ndOrd</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "ChargeDensity" with 2nd order
integration of source Term.
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for</p><a href="../proc/applysrc_chargedensity_2ndord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_electricfieldnp.html'>applySrc_electricFieldNP</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "electric field"</p><a href="../proc/applysrc_electricfieldnp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_electricmsliquid_1stord.html'>applySrc_electricMSLiquid_1stOrd</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "electric_field"
Simuilar to derive routine but it updates the state whereas derive
is used for tracking</p><a href="../proc/applysrc_electricmsliquid_1stord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_electricmsliquid_1stord_wtdf.html'>applySrc_electricMSLiquid_1stOrd_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "electric_field" with thermodynamic
factor.
Simuilar to derive routine but it updates the state whereas derive
is used for tracking</p><a href="../proc/applysrc_electricmsliquid_1stord_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_electricmsliquid_2ndord.html'>applySrc_electricMSLiquid_2ndOrd</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "electric_field" with 2nd order force
integration.
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_electricmsliquid_2ndord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_electricmsliquid_2ndord_wtdf.html'>applySrc_electricMSLiquid_2ndOrd_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "electric_field" with 2nd order
integration of force term in LBE with thermodynamic factor
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_electricmsliquid_2ndord_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_equalinjectionps.html'>applySrc_equalInjectionPS</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "equalInjection"
Simuilar to derive routine but it updates the state whereas derive
is used for tracking</p><a href="../proc/applysrc_equalinjectionps.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force.html'>applySrc_force</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force".
Force term used here is from:
"Discrete lattice effects on the forcing term in the lattice Boltzmann
 method", Zhaoli Guo, Chugung Zheng and Baochang Shi.
In the paper, use force term is referred as Method 2 as:
<script type="math/tex; mode=display"> F_i = w_i( (\vec{e}_i-\vec{u}*)/cs2 +
      (\vec{e}_i \cdot \vec{u}*)\vec{e}_i/cs4) \cdot \vec{F} </script>
Force must be defined as body force per unit volume
KM: If this force formula is used then velocity needs to be
computed as u = \sum c_i f_i + \vec{F}/2</p><a href="../proc/applysrc_force.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force1stord.html'>applySrc_force1stOrd</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force_1stOrd"
Force term used here is from:
"A D3Q27 multiple-relaxation-time lattice Boltzmann method for
turbulent flows", K. Suga, Y. Kuwata, K. Takashima, R. Chikasue</p><a href="../proc/applysrc_force1stord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force_gns.html'>applySrc_force_GNS</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for Generalized Navier-Stokes equations.
The implementation is taken from "Lattice Boltzmann model for incompressible flows
through porous media" by Z. Guo and T.S. Zhao (2002) Physical Review E.</p><a href="../proc/applysrc_force_gns.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force_mrt.html'>applySrc_force_MRT</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for MRT collision model.
Force term used here is from:
Chai, Z., &amp; Zhao, T. (2012). Effect of the forcing term in the
multiple-relaxation-time lattice Boltzmann equation on the shear stress
or the strain rate tensor. Physical Review E, 86(1), 1–11.
Force term for MRT is
<script type="math/tex; mode=display"> \bar{F} = M^-1 (I-0.5 S) M F' </script> and
<script type="math/tex; mode=display"> F'_i = w_i( (\vec{e}_i-\vec{u}*)/cs2 +
      (\vec{e}_i \cdot \vec{u}*)\vec{e}_i/cs4) \cdot \vec{F} </script>
</p><a href="../proc/applysrc_force_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force_mrt_d2q9.html'>applySrc_force_MRT_d2q9</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for d3q19 MRT collision model.
Force term used here is from:
Chai, Z., &amp; Zhao, T. (2012). Effect of the forcing term in the
multiple-relaxation-time lattice Boltzmann equation on the shear stress
or the strain rate tensor. Physical Review E, 86(1), 1–11.
Force term for MRT is
<script type="math/tex; mode=display"> \bar{F} = M^-1 (I-0.5 S) M F' </script> and
<script type="math/tex; mode=display"> F'_i = w_i( (\vec{e}_i-\vec{u}*)/cs2 +
      (\vec{e}_i \cdot \vec{u}*)\vec{e}_i/cs4) \cdot \vec{F} </script>
</p><a href="../proc/applysrc_force_mrt_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force_mrt_d3q19.html'>applySrc_force_MRT_d3q19</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for d3q19 MRT collision model.
Force term used here is from:
Chai, Z., &amp; Zhao, T. (2012). Effect of the forcing term in the
multiple-relaxation-time lattice Boltzmann equation on the shear stress
or the strain rate tensor. Physical Review E, 86(1), 1–11.
Force term for MRT is
<script type="math/tex; mode=display"> \bar{F} = M^-1 (I-0.5 S) M F' </script> and
<script type="math/tex; mode=display"> F'_i = w_i( (\vec{e}_i-\vec{u}*)/cs2 +
      (\vec{e}_i \cdot \vec{u}*)\vec{e}_i/cs4) \cdot \vec{F} </script>
</p><a href="../proc/applysrc_force_mrt_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_force_mrt_d3q27.html'>applySrc_force_MRT_d3q27</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for MRT collision model.
Force term used here is from:
Chai, Z., &amp; Zhao, T. (2012). Effect of the forcing term in the
multiple-relaxation-time lattice Boltzmann equation on the shear stress
or the strain rate tensor. Physical Review E, 86(1), 1–11.
Force term for MRT is
<script type="math/tex; mode=display"> \bar{F} = M^-1 (I-0.5 S) M F' </script> and
<script type="math/tex; mode=display"> F'_i = w_i( (\vec{e}_i-\vec{u}*)/cs2 +
      (\vec{e}_i \cdot \vec{u}*)\vec{e}_i/cs4) \cdot \vec{F} </script>
</p><a href="../proc/applysrc_force_mrt_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_forcemsliquid_1stord.html'>applySrc_forceMSLiquid_1stOrd</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" with 1st order integration
of force in lattice Boltzmann equation.
Simuilar to derive routine but it updates the state whereas derive
is used for tracking
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_forcemsliquid_1stord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_forcemsliquid_1stord_wtdf.html'>applySrc_forceMSLiquid_1stOrd_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" with thermodynamic factor
Simuilar to derive routine but it updates the state whereas derive
is used for tracking
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_forcemsliquid_1stord_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_forcemsliquid_2ndord.html'>applySrc_forceMSLiquid_2ndOrd</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" with 2nd order integration
of force in lattice Boltzmann equation.
Simuilar to derive routine but it updates the state whereas derive
is used for tracking
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_forcemsliquid_2ndord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_forcemsliquid_2ndord_wtdf.html'>applySrc_forceMSLiquid_2ndOrd_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" with 2nd order integration
of force in lattice Boltzmann equation with thermodynamic factor.
Simuilar to derive routine but it updates the state whereas derive
is used for tracking
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p><a href="../proc/applysrc_forcemsliquid_2ndord_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_injectionps.html'>applySrc_injectionPS</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "injection"
Similar to derive routine but it updates the state whereas derive
is used for tracking</p><a href="../proc/applysrc_injectionps.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_toelem.html'>applySrc_toElem</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_toelem_eps.html'>applySrc_toElem_eps</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_turbchanforce.html'>applySrc_turbChanForce</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "turb_channel_force" for BGK.</p><a href="../proc/applysrc_turbchanforce.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_turbchanforce_mrt.html'>applySrc_turbChanForce_MRT</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for generic MRT collision model
for turb_channel_force. It uses velocityX average in bulk to adapt the
driving force for turbulent channel.</p><a href="../proc/applysrc_turbchanforce_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_turbchanforce_mrt_d2q9.html'>applySrc_turbChanForce_MRT_d2q9</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for d3q19 MRT collision model
for turb_channel_force. It uses velocityX average in bulk to adapt the
driving force for turbulent channel.</p><a href="../proc/applysrc_turbchanforce_mrt_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_turbchanforce_mrt_d3q19.html'>applySrc_turbChanForce_MRT_d3q19</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for d3q19 MRT collision model
for turb_channel_force. It uses velocityX average in bulk to adapt the
driving force for turbulent channel.</p><a href="../proc/applysrc_turbchanforce_mrt_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applysrc_turbchanforce_mrt_d3q27.html'>applySrc_turbChanForce_MRT_d3q27</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update state with source variable "force" for generic MRT collision model
for turb_channel_force. It uses velocityX average in bulk to adapt the
driving force for turbulent channel.</p><a href="../proc/applysrc_turbchanforce_mrt_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/applyvelocitybounceback.html'>applyVelocityBounceback</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>ApplyVelocityBounceback adds the momentum exchange term to the
distribution function at the particle  neighboring fluid nodes
this term accounts for the moving boundary of the particle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/assign_intp_fluid.html'>assign_intp_fluid</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set up interpolation routines for fluid (weakly compressible) scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/assign_intp_fluidles.html'>assign_intp_fluidLES</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set up interpolation routines for fluid (weakly compressible) scheme and
turbulence active</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/assignbclist.html'>assignBCList</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns the BC lists
Run over all the elements with the property boundary
and check each direction.
Assign all common boundaries to the level-wise representation
3rd step in build_BCLists</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bc_pdf.html'>bc_pdf</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Boundary condition for APESMATE that supports pdfs as input variable
 Makes it possible to use pdf from, for example, the left to the right domain</p><a href="../proc/bc_pdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_d3q19_gns.html'>bgk_advRel_d3q19_GNS</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with BGK based on the !!
equilibrium distribution function for the generalized Navier Stokes equations
(GNS) aka Volume Averaged Navier-Stokes !! equations (VANS).
feq definition from: Z. Guo and T. S. Zhao, “Lattice Boltzmann model for
incompressible flows through porous media,” Phys. Rev. E, vol. 66, no. 3, p.
036304, Sep. 2002, doi: 10.1103/PhysRevE.66.036304.</p><a href="../proc/bgk_advrel_d3q19_gns.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_d3q19f3_msgas.html'>bgk_advRel_d3q19f3_MSGas</a></td>
                 <td><a href='../module/mus_msgas_module.html'>mus_MSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Optimized Advection relaxation routine for the MSGas BGK model
for d3q19 layout with three species.</p><a href="../proc/bgk_advrel_d3q19f3_msgas.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_d3q19f3_msliquid.html'>bgk_advRel_d3q19f3_MSLiquid</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Optimized Advection relaxation routine for the MSLiquid BGK model
for d3q19 layout with three species.</p><a href="../proc/bgk_advrel_d3q19f3_msliquid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_d3q19f3_msliquid_wtdf.html'>bgk_advRel_d3q19f3_MSLiquid_WTDF</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Semi-optimized Advection relaxation routine for the MSLiquid BGK model
for d3q19 layout with three species with thermodynamic factor.</p><a href="../proc/bgk_advrel_d3q19f3_msliquid_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_isotherm_aceq_d3q19.html'>bgk_advRel_isotherm_acEq_d3q19</a></td>
                 <td><a href='../module/mus_isotherm_aceq_module.html'>mus_isotherm_acEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with BGK for the
isothermal acoustic equation.</p><a href="../proc/bgk_advrel_isotherm_aceq_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_msgas_generic.html'>bgk_advRel_MSGas_generic</a></td>
                 <td><a href='../module/mus_msgas_module.html'>mus_MSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model
for testing</p><a href="../proc/bgk_advrel_msgas_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_msliquid_generic.html'>bgk_advRel_MSLiquid_generic</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model</p><a href="../proc/bgk_advrel_msliquid_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_advrel_msliquid_generic_wtdf.html'>bgk_advRel_MSLiquid_generic_WTDF</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model
with thermodynamic factors in Maxwell-Stefan formulation</p><a href="../proc/bgk_advrel_msliquid_generic_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_dualrelaxationtime_rr_d2q9.html'>bgk_DualRelaxationTime_RR_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_dualrelaxationtime_rr_d3q19.html'>bgk_DualRelaxationTime_RR_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive Regularized relaxation routine for the D3Q19
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
works for both d3q19 and d3q27</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_dualrelaxationtime_rr_d3q27.html'>bgk_DualRelaxationTime_RR_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive Regularized relaxation routine for the D3Q27
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_forcing_advrel_msliquid_generic.html'>bgk_forcing_advRel_MSLiquid_generic</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model
with external forcing term</p><a href="../proc/bgk_forcing_advrel_msliquid_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularized_d2q9.html'>bgk_HybridRecursiveRegularized_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Hybrid recursive regularization relaxation routine for the BGK model.
based on: Feng et al., JCP 2019,
"Hybrid recursive regularized thermal lattice Boltzmann model
for high subsonic compressible flows"</p><a href="../proc/bgk_hybridrecursiveregularized_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularized_d3q19.html'>bgk_HybridRecursiveRegularized_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q19
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
 works for both d3q19 and d3q27</p><a href="../proc/bgk_hybridrecursiveregularized_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularized_d3q27.html'>bgk_HybridRecursiveRegularized_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q19
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
 works for both d3q19 and d3q27</p><a href="../proc/bgk_hybridrecursiveregularized_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularizedcorr_d2q9.html'>bgk_HybridRecursiveRegularizedCorr_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Hybrid recursive regularization relaxation routine for the BGK model.
based on: Feng et al., JCP 2019,
"Hybrid recursive regularized thermal lattice Boltzmann model
for high subsonic compressible flows"</p><a href="../proc/bgk_hybridrecursiveregularizedcorr_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularizedcorr_d3q19.html'>bgk_HybridRecursiveRegularizedCorr_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q19
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
 works for both d3q19 and d3q27</p><a href="../proc/bgk_hybridrecursiveregularizedcorr_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_hybridrecursiveregularizedcorr_d3q27.html'>bgk_HybridRecursiveRegularizedCorr_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q19
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
 works for both d3q19 and d3q27</p><a href="../proc/bgk_hybridrecursiveregularizedcorr_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_projectedrecursiveregularized_d2q9.html'>bgk_ProjectedRecursiveRegularized_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_projectedrecursiveregularized_d3q19.html'>bgk_ProjectedRecursiveRegularized_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q19
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
 works for both d3q19 and d3q27</p><a href="../proc/bgk_projectedrecursiveregularized_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_projectedrecursiveregularized_d3q27.html'>bgk_ProjectedRecursiveRegularized_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Projected Recursive Regularized relaxation routine for the D3Q27
 This subroutine interface must match the abstract interface definition
 <a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
 via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.</p><a href="../proc/bgk_projectedrecursiveregularized_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_recursiveregularized_d2q9.html'>bgk_RecursiveRegularized_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_recursiveregularized_d3q19.html'>bgk_RecursiveRegularized_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive Regularized relaxation routine for the D3Q19
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
works for both d3q19 and d3q27</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_recursiveregularized_d3q27.html'>bgk_RecursiveRegularized_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursive Regularized relaxation routine for the D3Q27
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_regularized_d2q9.html'>bgk_Regularized_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_regularized_d3q19.html'>bgk_Regularized_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Regularized relaxation routine for the D3Q19 and 27 model with BGK.
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
works for both d3q19 and d3q27</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/bgk_regularized_d3q27.html'>bgk_Regularized_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Regularized relaxation routine for the D3Q19 and 27 model with BGK.
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.
works for both d3q19 and d3q27</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/build_bclevelpointer.html'>build_bcLevelPointer</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/build_bclists.html'>build_BClists</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assemble the level-wise list of elements which adhere to the boundary
conditions.</p><a href="../proc/build_bclists.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_mlups.html'>calc_MLUPS</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Function</td>
                 <td><p>Calculate the MLUPS or MFLUPS for the simulation</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/calc_ms_diff_matrix_from_moledens.html'>calc_ms_diff_matrix_from_moledens</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td><p>This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix
for given mole_frac of all species</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/calc_ms_diff_matrix_from_molefrac.html'>calc_ms_diff_matrix_from_molefrac</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td><p>This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix
for given mole_frac of all species</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calc_surface_vel.html'>calc_surface_vel</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/calc_therm_factor_loc.html'>calc_therm_factor_loc</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td><p>This routine calculates thermodynamic factor for given mole_frac
of all species</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcdensandvelsfrompdf.html'>calcDensAndVelsFromPDF</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns mass density of all species and mass averaged mixture
velocity from given pdf of all species for single element.
It is used in Nonequilbrium extrapolation based boundary conditions.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcperiodicdistancetosurface.html'>calcPeriodicDistanceToSurface</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>wrap_periodic checks whether a distance r from x_particle to </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcperiodicrsurface.html'>calcPeriodicRsurface</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calcPeriodicRsurface is used to calculate the vector from the 
particle origin to a point on the surface in presence of periodic 
boundaries.
Usage: first calculate the distance from the particle origin to a 
surface element using r = baryOfSurface - x_origin. If the particle is 
close to a periodic boundary this vector may not be correct.
In that case a call to calcPeriodicRsurface modifies the vector r to 
take into account the periodicity. This is done by checking if the 
magnitude of r is less than the particle radius R_particle (which can 
be modified with some tolerance if needed).
This routine is used for fully resolved (MEM) particles only.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcturbwallbndforceandmoment.html'>calcTurbWallBndForceAndMoment</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes bndForce on boundary elements using momentum
exchange method.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calculate_nelems.html'>calculate_nElems</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate global and sum of levels numbers of elements</p><a href="../proc/calculate_nelems.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvelocityandpressuregradient.html'>calcVelocityAndPressureGradient</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calcVelocityAndPressureGradient calculates the gradient of pressure and
curl of the velocity field (in lattice units) at coordinate coord
Coord must be a local element on this process!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvelocityandpressuregradient_onewaycoupled.html'>calcVelocityAndPressureGradient_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calcVelocityAndPressureGradient calculates the gradient of pressure and
curl of the velocity field (in lattice units) at coordinate coord
Coord must be a local element on this process!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvelocityandpressuregradient_onewaycoupled_old.html'>calcVelocityAndPressureGradient_onewaycoupled_old</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>calcVelocityAndPressureGradient calculates the gradient of pressure and
curl of the velocity field (in lattice units) at coordinate coord
Coord must be a local element on this process!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvelsw_unitsw_veltau_tvisc.html'>calcVelSW_unitSW_velTau_tVisc</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculation stream-wise velocity compononent from wall function and
friction velocity, stream-wise unit vector and turbulent viscosity with
mixing length formulation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_cs.html'>calcVisc_CS</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian Casson model.
$\mu = (k0 + k1 * sqrt(shearRate))^2/shearRate$</p><a href="../proc/calcvisc_cs.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_cy.html'>calcVisc_CY</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian Carreau-Yasuda model.
$\mu = \mu_\inf + (\mu_0-\mu_\inf)(1+(\lambda<em>shearRate)</em>a)^((n-1)/a)$</p><a href="../proc/calcvisc_cy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_incomp_cs.html'>calcVisc_incomp_CS</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian Casson model for
incompressible model.
$\mu = (k0 + k1 * sqrt(shearRate))^2/shearRate$</p><a href="../proc/calcvisc_incomp_cs.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_incomp_cy.html'>calcVisc_incomp_CY</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian Carreau-Yasuda model for
incompressible model.
$\mu = \mu_\inf + (\mu_0-\mu_\inf)(1+(\lambda<em>shearRate)</em>a)^((n-1)/a)$</p><a href="../proc/calcvisc_incomp_cy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_incomp_pl.html'>calcVisc_incomp_PL</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian power-law model for
incompressible model
$\mu = K shearRate^(n-1)$</p><a href="../proc/calcvisc_incomp_pl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/calcvisc_pl.html'>calcVisc_PL</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinematic viscosity from nonNewtonian power-law model.
$\mu = K shearRate^(n-1)$.
Shear rate is computed from strain rate which is computed from
nonEquilibrium PDF which in turn computed from pre-collision PDF</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cascaded_d3q27.html'>cascaded_d3q27</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/cascaded_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/central_moment.html'>central_moment</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment.
This follows equations 21 in cumulent paper ( Geier .et al 2015 )</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/central_moment_split.html'>central_moment_split</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment by spliting among directions.
This follows equations 43, 44, 45 in cumulent paper (Geier .et al 2015)
We first do x direction for better performance.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_and_create_new_particles_dps.html'>check_and_create_new_particles_DPS</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine that checks if new particles should be created and creates them if so.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_and_create_new_particles_mem.html'>check_and_create_new_particles_MEM</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine that checks if new particles should be created and creates them if so.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_bcs_prerequisite_ms.html'>check_BCs_preRequisite_MS</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check prerequisite for some boundary conditions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_density.html'>check_density</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check the total density for a selected scheme and write to unit</p><a href="../proc/check_density.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_flow_status.html'>check_flow_status</a></td>
                 <td><a href='../module/mus_aux_module.html'>mus_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine performs several tasks: geometry increment, time updating,
tracking, density checking, restart</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_mrt_matrix_d3q19.html'>check_mrt_matrix_d3q19</a></td>
                 <td><a href='../module/mus_mrtinit_module.html'>mus_mrtInit_module</a></td>
                 <td>Function</td>
                 <td><p>Unoptimized explicit implementation</p><a href="../proc/check_mrt_matrix_d3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_mrt_matrix_d3q27.html'>check_mrt_matrix_d3q27</a></td>
                 <td><a href='../module/mus_mrtinit_module.html'>mus_mrtInit_module</a></td>
                 <td>Function</td>
                 <td><p>Unoptimized explicit implementation</p><a href="../proc/check_mrt_matrix_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_particle_scheme_kind_compatibility.html'>check_particle_scheme_kind_compatibility</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_particles_dps.html'>check_particles_DPS</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_particles_mem.html'>check_particles_MEM</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_potential.html'>check_potential</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check the total potential for poisson scheme</p><a href="../proc/check_potential.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_solid_in_bc.html'>check_solid_in_bc</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>It count valid (non-solid) elements in BC elements list.
Input:
  minLevel, maxLevel
  LevelPointer
  LevelDesc
  nElems - number of BC elements
  elems - positions of BC elements in tree or levelPointer
Output:
  nValid - number of valid BC elements
  posInBCElem - positions of valid elements in BC elements list</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_streaming_layout.html'>check_streaming_layout</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check for the streaming layout.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_varsys_forpdfvar.html'>check_varSys_forPdfVar</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This function runs over all variable loaded from restart file check if
variables loaded are pdf variable or derive variable</p><a href="../proc/check_varsys_forpdfvar.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_velocityfluid.html'>check_velocityFluid</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check the maximum velocity whether it is above Ma&gt;0.1</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_velocityms.html'>check_velocityMS</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check the maximum velocity whether it is above Ma&gt;0.1</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/checkandcollidedem.html'>checkAndCollideDEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/checkandcollidedem_dps.html'>checkAndCollideDEM_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td><p>checkAndCollideDEM checks if two particles A and B collide
This is the case if the continuous representations overlap
If there is a collision, a collision force is applied to each particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/checkandcollidedem_mem.html'>checkAndCollideDEM_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td><p>checkAndCollideDEM checks if two particles A and B collide
This is the case if the continuous representations overlap
If there is a collision, a collision force is applied to each particle
checkAndCollideDEM checks if two particles A and B collide
This is the case if the continuous representations overlap
If there is a collision, a collision force is applied to each particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/checkforparticleoverlap.html'>checkForParticleOverlap</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>handleParticleOverlap checks for overlap with discrete representations
of other particles. Returns overlapsOtherParticle = TRUE if
there is overlap. This does not require communication with other
processes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/closeparticlelog.html'>closeParticleLog</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cm_to_pdf.html'>cm_to_pdf</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/communicate_property.html'>communicate_property</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the communication buffers for a single level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_bulkviscomega.html'>compute_bulkViscOmega</a></td>
                 <td><a href='../module/mus_species_module.html'>mus_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute bulk viscosity omega for species for all levels
omega_bulk = (2-molWeigRatio_k)/(3*bulk_visc)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_fluid_momentum.html'>compute_fluid_momentum</a></td>
                 <td><a href='../module/mus_particle_checks_module.html'>mus_particle_checks_module</a></td>
                 <td>Subroutine</td>
                 <td><p>compute_fluid_momentum calculates the total momentum of the fluid for all 
fluid elements in the global domain. The result "totalMomentum" is returned 
in physical units.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_fricvel.html'>compute_fricVel</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes friction velocity from wall model profile
using Newton iteration method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_molweightratio.html'>compute_molWeightRatio</a></td>
                 <td><a href='../module/mus_species_module.html'>mus_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes the molecular weight ratio for all species
based asinari model</p><a href="../proc/compute_molweightratio.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_particle_momentum.html'>compute_particle_momentum</a></td>
                 <td><a href='../module/mus_particle_checks_module.html'>mus_particle_checks_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/compute_weight.html'>compute_weight</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes weights for weighted_average interpolation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computedisplacement.html'>computeDisplacement</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>computeDistance computes the shortest distance between points x1 and x2
In doing so it takes possible periodic boundaries into account.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computehydroforces_dps.html'>computeHydroForces_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_computeExternalForces adds the non-DEM forces (including
hydrodynamic force from the LBM) to F_DEM which is used to
update velocity within the DEM subcycle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computelubforce_normal.html'>computeLubForce_normal</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computelubforce_tangential.html'>computeLubForce_tangential</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computestreamwisevel.html'>computeStreamWiseVel</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines computes streamWise velocity component from friction velocity
and distance to boundary using any wall function profile.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computewallforce_1d.html'>computeWallForce_1D</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td><p>computeWallForce_1D computes the 1D DEM force between a particle at position
xp with velocity un to a wall at position xwall.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computewallforce_dps.html'>computeWallForce_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Function</td>
                 <td><p>Routine for computing the collision force between particles and walls for the 
case of a simple prismatic domain with walls aligned with the Cartesian axes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/computewallpossum.html'>computeWallPosSum</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computewallpossum_dps.html'>computeWallPosSum_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td><p>computeWallPosSum computes the sum of the locations of wall boundaries in the
area surrounding the particle. It also sets rmflag to true if an open boundary
is detected, indicating that this particle should be removed from the global
domain (in a different routine)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/computewallpossum_mem.html'>computeWallPosSum_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td><p>computeWallPosSum computes the sum of the locations of wall boundaries in the
area surrounding the particle. It also sets rmflag to true if an open boundary
is detected, indicating that this particle should be removed from the global
domain (in a different routine)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/convprepost.html'>convPrePost</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Conversion factor betwen the pre- and post-collision quantity for the shear
 stress.</p><a href="../proc/convprepost.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/coordexistsonmyrank.html'>coordExistsOnMyRank</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Checks if integer coordinate is in the total list of this rank</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/coordlocalonmyrank.html'>coordLocalOnMyRank</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Routine which checks whether integer coordinate is local 
on the current rank</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/countnbnds.html'>countnBnds</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Identify the number of boundary condition elements of each BC type
and number of elements with multiple BC types.
This is 1st step in Build_BClists</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_particles_dps.html'>create_particles_DPS</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create new unresolved DPS particles</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/create_particles_mem.html'>create_particles_MEM</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create new fully resolved MEM particles</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/createnewparticle_dps.html'>createNewParticle_DPS</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create a new particle using the information in the
particleCreator object</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/createnewparticle_mem.html'>createNewParticle_MEM</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create a new particle using the information in the particleCreator object</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cross_product.html'>cross_product</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>computes cross-product a x b = res</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cumnor.html'>cumnor</a></td>
                 <td><a href='../module/mus_particle_prob_module.html'>mus_particle_prob_module</a></td>
                 <td>Subroutine</td>
                 <td><p><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>*</strong>*80</p><a href="../proc/cumnor.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cumulant_d3q27.html'>cumulant_d3q27</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/cumulant_d3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cumulant_d3q27_extended_fast.html'>cumulant_d3q27_extended_fast</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Cumulant kernel based on Geier2017 and optimized.
Just omega(2) is given in input. omega(2)=-1 means omega2=omegaBulk.
Limiters read from input. lim(N)=10^10 means unlimited.
lim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper.
omega(6:10) = 1._rk</p><a href="../proc/cumulant_d3q27_extended_fast.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cumulant_d3q27_extended_generic.html'>cumulant_d3q27_extended_generic</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Cumulant based on Geier2017 paper. With all modifications and limiters.
All omegas are given in input. When omega(N) = -1 means adjusted in
this routine. omega(2)=-1 means omega2=omegaBulk. Limiters read from
input. lim(N)=10^10 means unlimited.
lim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper.</p><a href="../proc/cumulant_d3q27_extended_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cumulant_omega_check.html'>cumulant_omega_check</a></td>
                 <td><a href='../module/mus_cumulantinit_module.html'>mus_cumulantInit_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Checking the stability regions of omegas for the parametrized Cumulant
Just omega(2) is given in input. omega(2)=-1 means omega2=omegaBulk.
Limiters read from input. lim(N)=10^10 means unlimited.
lim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper.
omega(6:10) = 1._rk</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_connectivity.html'>debug_connectivity</a></td>
                 <td><a href='../module/mus_debug_module.html'>mus_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Detailed Debug output to the PDF neighbor (connectivity) list</p><a href="../proc/debug_connectivity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_dependencies.html'>debug_dependencies</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Finer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_dependenciesfromcoarser.html'>debug_dependenciesFromCoarser</a></td>
                 <td><a href='../module/mus_debug_module.html'>mus_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolation routine that is based on a simple weighted average of source
nodes. This is the interpolation coarse-&gt; fine. Weights are needed here,
as the distances source &lt;-&gt; target are different for the source nodes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_dependenciesfromfiner.html'>debug_dependenciesFromFiner</a></td>
                 <td><a href='../module/mus_debug_module.html'>mus_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Debug the dependencies for the ghostFromFiner elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_glob_boundary_type.html'>debug_glob_boundary_type</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/debug_normals.html'>debug_normals</a></td>
                 <td><a href='../module/mus_debug_module.html'>mus_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump the neighbors found for the boundaries with neighbor elements</p><a href="../proc/debug_normals.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_collidewithplanarwall_dps.html'>DEM_collideWithPlanarWall_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dem_collidewithwall.html'>DEM_collideWithWall</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_collidewithwall_dps.html'>DEM_collideWithWall_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_collidewithwall_mem.html'>DEM_collideWithWall_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computeexternalforces.html'>DEM_computeExternalForces</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_computeExternalForces adds the non-DEM forces (including
hydrodynamic force from the LBM) to F_DEM which is used to
update velocity within the DEM subcycle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computeexternalforces_dps_oneway.html'>DEM_computeExternalForces_DPS_oneway</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_computeExternalForces adds the non-DEM forces (including
hydrodynamic force from the LBM) to F_DEM which is used to
update velocity within the DEM subcycle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computelocalcollisionforces.html'>DEM_computeLocalCollisionForces</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute collision forces using Discrete Element Method between particles 
local to this process i.e. both particles are owned by this process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computelocalcollisionforces_dps.html'>DEM_computeLocalCollisionForces_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute collision forces using Discrete Element Method between particles 
local to this process i.e. both particles are owned by this process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computeremotecollisionforces.html'>DEM_computeRemoteCollisionForces</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute collision forces using Discrete Element Method between particle
pairs where particles belong to different processes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computeremotecollisionforces_dps.html'>DEM_computeRemoteCollisionForces_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute collision forces using Discrete Element Method between particle
pairs where particles belong to different processes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computewallforces_dps.html'>DEM_computeWallForces_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_computeWallForces_DPS computes the forces on particles as a result of 
collisions with walls described in the boundaryData object. These forces 
are only computed for particles owned by this process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_computewallforces_mem.html'>DEM_computeWallForces_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_exchangeforces.html'>DEM_exchangeForces</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_exchangeForces sends DEM collision force contributions from collisions that
cannot be resolved by the receiving process. The send force buffers in this case must
already be filled in the DEM collision-handling routines!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_exchangeforces_dps.html'>DEM_exchangeForces_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_exchangeForces sends DEM collision force contributions from collisions that
cannot be resolved by the receiving process. The send force buffers in this case must
already be filled in the DEM collision-handling routines!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_exchangewallpositions.html'>DEM_exchangeWallPositions</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_exchangeWallPositions sends wall position sums close to a particle as detected on each process
to the particle owner, which averages the results to get one average wall position
Upon termination of this routine particle%rwall for all particles which I own should be set
correctly.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_exchangewallpositions_dps.html'>DEM_exchangeWallPositions_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEM_exchangeWallPositions sends wall position sums close to a particle as detected on each process
to the particle owner, which averages the results to get one average wall position
Upon termination of this routine particle%rwall for all particles which I own should be set
correctly.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_fillneighborlist.html'>DEM_fillNeighborList</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dem_isremotecollision.html'>DEM_isRemoteCollision</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_isremotecollision_dps.html'>DEM_isRemoteCollision_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_isremotecollision_mem.html'>DEM_isRemoteCollision_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_resetfnext_dps.html'>DEM_resetFnext_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reset the force at the next time step to 0</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_resetfnext_mem.html'>DEM_resetFnext_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reset the force at the next time step to 0</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_storewallpositions_mem.html'>DEM_storeWallPositions_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/dem_swapfnowfnext.html'>DEM_swapFnowFnext</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_swapfnowfnext_dps.html'>DEM_swapFnowFnext_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Swap the indices of Fnow and Fnext pointing to the 
force at the current and next time step respectively</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dem_swapfnowfnext_mem.html'>DEM_swapFnowFnext_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Swap the indices of Fnow and Fnext pointing to the 
force at the current and next time step respectively</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/demsubcycles_dps.html'>DEMSubcycles_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEMsubcycles runs Nsubcycles time integration steps per LBM time step 
In this routine velocity verlet integration of particle position and
velocity is used. </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/demsubcycles_dps_onewaycoupled.html'>DEMSubcycles_DPS_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEMsubcycles runs Nsubcycles time integration steps per LBM time step 
In this routine velocity verlet integration of particle position and
velocity is used. This routine is for one-way coupled DPS particles. </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/demsubcycles_mem.html'>DEMSubcycles_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>DEMsubcycles runs Nsubcycles time integration steps per LBM time step 
In this routine simple Forward Euler integration of particle position and
velocity is used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derdensityisothermaceq.html'>derDensityIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given set of elements (sum up all links).</p><a href="../proc/derdensityisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derequilisothermaceq.html'>derEquilIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the equlibrium of given elements with the given input state
array.</p><a href="../proc/derequilisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derequilisothermaceq_fromindex.html'>derEquilIsothermAcEq_fromIndex</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of equilibrium.
This routine sets the function Pointer for equilibrium calcualtion and calls
the generice get Value of Index routine</p><a href="../proc/derequilisothermaceq_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_absorblayer.html'>derive_absorbLayer</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive absorb layer variable defined as a source term.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_absorblayerincomp.html'>derive_absorbLayerIncomp</a></td>
                 <td><a href='../module/mus_derquanincomp_module.html'>mus_derQuanIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive absorb layer variable defined as a source term.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_equalinjectionps.html'>derive_equalInjectionPS</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive injection variable defined as a source term for lbm passive scalar.
It evaluates spacetime function defined in lua file for injection variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_force1stord.html'>derive_force1stOrd</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive external force variable defined as a source term.
It evaluates spacetime function defined in lua file for force variable
and convert it to state value which is to be added to the state</p><a href="../proc/derive_force1stord.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_force_mrt.html'>derive_force_MRT</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive external force variable defined as a source term.
It evaluates spacetime function defined in lua file for force variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_hrrcorrection_d2q9.html'>derive_HRRCorrection_d2q9</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive external force variable defined as a source term.
It evaluates spacetime function defined in lua file for force variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_hrrcorrection_d3q19.html'>derive_HRRCorrection_d3q19</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive external force variable defined as a source term.
It evaluates spacetime function defined in lua file for force variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_hrrcorrection_d3q27.html'>derive_HRRCorrection_d3q27</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive external force variable defined as a source term.
It evaluates spacetime function defined in lua file for force variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derive_injectionps.html'>derive_injectionPS</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive injection variable defined as a source term for lbm passive scalar.
It evaluates spacetime function defined in lua file for injection variable
and convert it to state value which is to be added to the state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveaux_fromstate.html'>deriveAux_fromState</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField from state array</p><a href="../proc/deriveaux_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxmsgas_fromstate.html'>deriveAuxMSGas_fromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField 'density and velocity' of given field
from state array.
velocity of original PDF is computed in this routine by solving LSE</p><a href="../proc/deriveauxmsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxmsliquid_fromstate.html'>deriveAuxMSLiquid_fromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField 'density and velocity' of given field
from state array.
velocity of original PDF is computed in this routine by solving LSE.</p><a href="../proc/deriveauxmsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxmsliquid_fromstate_wtdf.html'>deriveAuxMSLiquid_fromState_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField 'density and velocity' of given field
from state array with thermodynamic factot.
velocity of original PDF is computed in this routine by solving LSE.</p><a href="../proc/deriveauxmsliquid_fromstate_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxnp_fromstate.html'>deriveAuxNP_fromState</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for weakly compressible PB
(schemekind = 'nernstPlanck') to the varsys.
A Coupled Lattice Boltzmann Method to Solve Nernst-Planck Model
for Simulating Electro-Osmotic flows
author&gt; Xuguang yang
This routine computes auxField 'mole_density' from state array</p><a href="../proc/deriveauxnp_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxpoisson_fromstate.html'>deriveAuxPoisson_fromState</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField 'potential' from state array</p><a href="../proc/deriveauxpoisson_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveauxps_fromstate.html'>deriveAuxPS_fromState</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes auxField from state array</p><a href="../proc/deriveauxps_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivebndforce.html'>deriveBndForce</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the force on the boundary of a given set of elements</p><a href="../proc/derivebndforce.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivebndmoment.html'>deriveBndMoment</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the moment on the boundary of a given set of elements</p><a href="../proc/derivebndmoment.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensity.html'>deriveChargeDensity</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate charge density of a given element for mixture.
Charge density is mixture quantity to it returns same value for all
species
charge_density = Faraday * \sum_i z_i*density_i/molecularWeight_i</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensity_fromindex.html'>deriveChargeDensity_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate charge density from species concentration</p><a href="../proc/derivechargedensity_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensityboltzappr_forelement.html'>deriveChargeDensityBoltzAppr_forElement</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate charge density from potential field using Boltzmann approximation</p><a href="../proc/derivechargedensityboltzappr_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensityboltzappr_fromindex.html'>deriveChargeDensityBoltzAppr_fromIndex</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate charge density from potential field using Boltzmann approximation
from given index</p><a href="../proc/derivechargedensityboltzappr_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensityphy.html'>deriveChargeDensityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the charge density of a given set of elements</p><a href="../proc/derivechargedensityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivechargedensityphy_fromindex.html'>deriveChargeDensityPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the charge density of a given idx</p><a href="../proc/derivechargedensityphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivecurrentdensity.html'>deriveCurrentDensity</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Current density is computed from species momentum stored in auxField array.
Current density, J = charge_density*velocity = \rho_e * u
= \sum_k z_k F p_k / M_k
where p_k is the species momentum</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivecurrentdensity_fromindex.html'>deriveCurrentDensity_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate current density from species momentum</p><a href="../proc/derivecurrentdensity_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivecurrentdensityphy.html'>deriveCurrentDensityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the current density of a given set of elements</p><a href="../proc/derivecurrentdensityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivecurrentdensityphy_fromindex.html'>deriveCurrentDensityPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the current density of a given idx (sum up all links).</p><a href="../proc/derivecurrentdensityphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivedensity.html'>deriveDensity</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of density
This routine sets the function Pointer for density calcualtion and calls
the generice get Element from PDF routine</p><a href="../proc/derivedensity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivedensity_fromindex.html'>deriveDensity_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of density.
This routine sets the function Pointer for density calcualtion and calls
the generice get Value of Index routine</p><a href="../proc/derivedensity_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivedensityphy.html'>deriveDensityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given set of elements (sum up all links).</p><a href="../proc/derivedensityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivedensityphy_fromindex.html'>deriveDensityPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given idx (sum up all links).</p><a href="../proc/derivedensityphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveelectric_fieldphy.html'>deriveElectric_FieldPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the electric_field of a given set of elements</p><a href="../proc/deriveelectric_fieldphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveelectric_fieldphy_fromindex.html'>deriveElectric_FieldPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the electrical field of a given idx</p><a href="../proc/deriveelectric_fieldphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveelectricfield_forelement.html'>deriveElectricfield_forElement</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the electric field of a given set of elements (sum up all links).
This routine is used to compute electric field for all scheme kinds</p><a href="../proc/deriveelectricfield_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveelectricfield_fromindex.html'>deriveElectricfield_fromIndex</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the electric field of a given set of elements (sum up all links).
This routine is used to compute electric field for all scheme kinds</p><a href="../proc/deriveelectricfield_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveeq_fromstate.html'>deriveEq_FromState</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/deriveeq_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveeq_fromstate_isothermaceq.html'>deriveEq_FromState_IsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equil from state array</p><a href="../proc/deriveeq_fromstate_isothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveeqmsgas_fromstate.html'>deriveEqMSGas_FromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilibrium from state array</p><a href="../proc/deriveeqmsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveeqmsliquid_fromstate.html'>deriveEqMSLiquid_FromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilibrium from state array</p><a href="../proc/deriveeqmsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequil.html'>deriveEquil</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of equlibrium
This routine sets the function Pointer for equlibrium calcualtion and calls
the generice get Element from PDF routine</p><a href="../proc/deriveequil.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequil_fromaux.html'>deriveEquil_fromAux</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequil_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequil_fromindex.html'>deriveEquil_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of equilibrium.
This routine sets the function Pointer for equilibrium calcualtion and calls
the generice get Value of Index routine</p><a href="../proc/deriveequil_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequil_frommacro.html'>deriveEquil_FromMacro</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from density and velocity
This must comply with interface in mus_variable_module derive_FromMacro</p><a href="../proc/deriveequil_frommacro.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequil_frommacro_isothermaceq.html'>deriveEquil_FromMacro_IsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from density and velocity
This must comply with interface in mus_variable_module derive_FromMacro</p><a href="../proc/deriveequil_frommacro_isothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilisothermaceq_fromaux.html'>deriveEquilIsoThermAcEq_fromAux</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilisothermaceq_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsgas.html'>deriveEquilMSGas</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the equlibrium of a given element number with the given input
state vector.</p><a href="../proc/deriveequilmsgas.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsgas_fromaux.html'>deriveEquilMSGas_fromAux</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilmsgas_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsgas_frommacro.html'>deriveEquilMSGas_FromMacro</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from density and velocity
This must comply with mus_variable_module%derive_FromMacro</p><a href="../proc/deriveequilmsgas_frommacro.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsliquid.html'>deriveEquilMSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Equilibrium from density and momentum stored in auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsliquid_fromaux.html'>deriveEquilMSLiquid_fromAux</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilmsliquid_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilmsliquid_frommacro.html'>deriveEquilMSLiquid_FromMacro</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from density and velocity
This must comply with mus_variable_module%derive_FromMacro</p><a href="../proc/deriveequilmsliquid_frommacro.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilnp_fromaux.html'>deriveEquilNP_fromAux</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilnp_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilpoisson_fromaux.html'>deriveEquilPoisson_fromAux</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilpoisson_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilps2ndorder_frommacro.html'>deriveEquilPS2ndOrder_FromMacro</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes 2nd order equilbrium from density and velocity
This must comply with mus_variable_module%derive_FromMacro</p><a href="../proc/deriveequilps2ndorder_frommacro.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilps_fromaux.html'>deriveEquilPS_fromAux</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from auxField</p><a href="../proc/deriveequilps_fromaux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilps_frommacro.html'>deriveEquilPS_FromMacro</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes equilbrium from density and velocity
This must comply with mus_variable_module%derive_FromMacro</p><a href="../proc/deriveequilps_frommacro.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilvelmsgas.html'>deriveEquilVelMSGas</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Equilibrium velocity from state
Calculate the momentum of a given element for single species or mixture
from the cptr scheme state vector for gas mixture (Asinari model).
Need to solve the system of equations to compute this momentum since
first order moments gives only moments of transformed pdfs. Hence
to obtain the first order moments of actual pdfs we need to solve
system of equation of size = nSpecies for each velocity components</p><a href="../proc/deriveequilvelmsgas.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilvelmsliquid.html'>deriveEquilVelMSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Equilibrium velocity from density and momentum in auxField.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilvelwtdf_msliquid.html'>deriveEquilVelWTDF_MSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Equilibrium velocity from density and momentum in auxField
with thermodynamic factor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveequilwtdf_msliquid.html'>deriveEquilWTDF_MSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Equilibrium from density and momentum in auxField with thermodynamic factor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveforcephy.html'>deriveForcePhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute and convert following variable force into physical units</p><a href="../proc/deriveforcephy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveforcephy_fromindex.html'>deriveForcePhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the bnd_force of a given idx</p><a href="../proc/deriveforcephy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveke.html'>deriveKE</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate kinetic energy from density and velocity in auxField
This routine sets the function Pointer for kinetic energy calcualtion and
calls the generice get Element from PDF routine</p><a href="../proc/deriveke.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveke_forpoint.html'>deriveKE_forPoint</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculates Kinetic energy from density and velocity for given set of points.</p><a href="../proc/deriveke_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveke_fromindex.html'>deriveKe_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of kinetic_energy.
This routine sets the function Pointer for kinetic_energy calcualtion and
calls the generice get Value of Index routine</p><a href="../proc/deriveke_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivekineenerphy.html'>deriveKineEnerPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the kinetic energy in physical units
The interface has to comply to the abstract interface
<a href="https://apes-suite.github.io/treelm/interface/tem_varsys_proc_element.html">tem_varSys_proc_element</a>.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivekineenerphy_fromindex.html'>deriveKineEnerPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the kinetic energy of a given idx</p><a href="../proc/derivekineenerphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivekinepressmsliquid.html'>deriveKinePressMSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate mixture kinematic pressure.
 This routine requires initial total mole density which is defined in
 mixture table.
 Formula to compute kinematic pressure
 <script type="math/tex"> p = c^2_s (\sum_k \rho_k \phi_k - min_l (m_l) n_0)/\rho_0 </script>
 here, <script type="math/tex"> \rho_k </script> - species density, \
 <script type="math/tex"> \phi_k </script> - species molecular weight ratio, \
 <script type="math/tex"> n_0 </script> - reference mixture number density,\
 <script type="math/tex"> \rho_0 </script> - reference density.
 In tracking,</p><a href="../proc/derivekinepressmsliquid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivekinepressphy.html'>deriveKinePressPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the kinematic mixture pressure in physical
 of a given set of elements (sum up all links).</p><a href="../proc/derivekinepressphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivekinepressphy_fromindex.html'>deriveKinePressPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the kinematic pressure of a given idx</p><a href="../proc/derivekinepressphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemachnr.html'>deriveMachNr</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the mach number of a given set of elements (sum up all links).</p><a href="../proc/derivemachnr.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemachnr_forpoint.html'>deriveMachNr_forPoint</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculates Mach nr for given set of points.</p><a href="../proc/derivemachnr_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemachnr_fromindex.html'>deriveMachNr_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of mach number.
This routine sets the function Pointer for pressure calcualtion and calls
the generice get Value of Index routine</p><a href="../proc/derivemachnr_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemassfracms.html'>deriveMassFracMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>mass fraction from density stored in auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemixvelms.html'>deriveMixVelMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate mixture velocity of a given element
from the momentum and density stored in auxField array for liquid mixture.
auxField was updated with momentum of untransformed PDF which was computed
by solving LSE in compute kernel.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemixvelms_fromindex.html'>deriveMixVelMS_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate mixture velocity from density from species momentum</p><a href="../proc/derivemixvelms_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensity_forelement.html'>deriveMoleDensity_forElement</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the potential of a given set of elements (sum up all links).
This routine is used to compute potential for all scheme kinds</p><a href="../proc/derivemoledensity_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensity_fromindex.html'>deriveMoleDensity_fromIndex</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the potential of a given set of elements (sum up all links).
This routine is used to compute potential for all scheme kinds</p><a href="../proc/derivemoledensity_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensityms.html'>deriveMoleDensityMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the number density of a given element for single species
from the density stored in auxField array.
Mixture number density is computed by summing species number density
using tem_evalAdd_forElement
Number density = density/molecular weight
mixture number density = sum(number_density)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensityms_fromindex.html'>deriveMoleDensityMS_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate mole density from species concentration for getValOfIndex</p><a href="../proc/derivemoledensityms_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensityphy.html'>deriveMoleDensityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given set of elements (sum up all links).</p><a href="../proc/derivemoledensityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoledensityphy_fromindex.html'>deriveMoleDensityPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the mole density of a given idx</p><a href="../proc/derivemoledensityphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemolefluxms.html'>deriveMoleFluxMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute mole flux from momentum stored in auxField.
mole flux = numDens_i*velocity_i = momentum / molWeight</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemolefluxms_fromindex.html'>deriveMoleFluxMS_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate mole flux from species momentum for getValOfIndex</p><a href="../proc/derivemolefluxms_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemolefluxphy.html'>deriveMoleFluxPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given set of elements (sum up all links).</p><a href="../proc/derivemolefluxphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemolefluxphy_fromindex.html'>deriveMoleFluxPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the mole flux of a given idx</p><a href="../proc/derivemolefluxphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemolefracms.html'>deriveMoleFracMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>mole fraction from density stored in auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemoment.html'>deriveMoment</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of moment for 2D
This routine sets the function Pointer for moment for 2D calcualtion and
calls the generice get Element from PDF routine</p><a href="../proc/derivemoment.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentamsgas_fromstate.html'>deriveMomentaMSGas_FromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes momentum from state array</p><a href="../proc/derivemomentamsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentamsliquid_fromstate.html'>deriveMomentaMSLiquid_FromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes momentum of all species from state array</p><a href="../proc/derivemomentamsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentphy.html'>deriveMomentPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute and convert following variable moment into physical units</p><a href="../proc/derivemomentphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentphy_fromindex.html'>deriveMomentPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the bnd_moment of a given idx</p><a href="../proc/derivemomentphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentum.html'>deriveMomentum</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate momentum from density and velocity stored in auxField</p><a href="../proc/derivemomentum.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentum_forpoint.html'>deriveMomentum_forPoint</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculates momentum from density and velocity for given set of points.</p><a href="../proc/derivemomentum_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentum_fromindex.html'>deriveMomentum_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate Momentum from density and velocity in auxField.</p><a href="../proc/derivemomentum_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentumphy.html'>deriveMomentumPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the momentum of a given element number with the given input
       vector (sum up all values)</p><a href="../proc/derivemomentumphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemomentumphy_fromindex.html'>deriveMomentumPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the momentum of a given idx</p><a href="../proc/derivemomentumphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemommsgas_fromstate.html'>deriveMomMSGas_FromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes momentum from state array</p><a href="../proc/derivemommsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivemommsliquid_fromstate.html'>deriveMomMSLiquid_FromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes momentum from state array</p><a href="../proc/derivemommsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivenonequil.html'>deriveNonEquil</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of NonEquil
This routine sets the function Pointer for NonEquil calcualtion and calls
the generice get Element from PDF routine</p><a href="../proc/derivenonequil.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivenonequil_fromindex.html'>deriveNonEquil_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of non_equilibrium.
This routine sets the function Pointer for non_equilibrium calcualtion and
calls the generice get Value of Index routine</p><a href="../proc/derivenonequil_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepdfmomentsphy.html'>derivePDFMomentsPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the momentum of a given element number with the given input
       vector (sum up all values)</p><a href="../proc/derivepdfmomentsphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepdfmomentsphy_fromindex.html'>derivePDFMomentsPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the momentum of a given idx</p><a href="../proc/derivepdfmomentsphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepotentialphy.html'>derivePotentialPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the potential of a given set of elements</p><a href="../proc/derivepotentialphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepotentialphy_fromindex.html'>derivePotentialPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the potential of a given idx</p><a href="../proc/derivepotentialphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressure.html'>derivePressure</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the pressure of a given set of elements (sum up all links).</p><a href="../proc/derivepressure.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressure_forpoint.html'>derivePressure_forPoint</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculates pressure for given set of points.</p><a href="../proc/derivepressure_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressure_fromindex.html'>derivePressure_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of pressure.
This routine sets the function Pointer for pressure calcualtion and calls
the generice get Value of Index routine</p><a href="../proc/derivepressure_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressurems.html'>derivePressureMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate species  pressure both for gas and liquid model
In case of gas mixture, it is partial pressure where as in
liquid mixture this is not valid.
However, it is used to compute mixture pressure and then the
kinematic_pressure from the mixture pressure.
Formula to calculate pressure:
<script type="math/tex"> p_k = c^2_s ( \rho_k \phi_k ) </script>
here, <script type="math/tex"> \rho_k </script> - species density, \
<script type="math/tex"> \phi_k </script> - species molecular weight ratio, \</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressurephy.html'>derivePressurePhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute and convert following variable pressure/shear_stress/wss/shear_mag
into physical units</p><a href="../proc/derivepressurephy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivepressurephy_fromindex.html'>derivePressurePhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the pressure of a given idx</p><a href="../proc/derivepressurephy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveqcriterionphy.html'>deriveQCriterionPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert lattice q-criterion to physical unit i.e strainRate**2</p><a href="../proc/deriveqcriterionphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriverho_fromstate.html'>deriveRho_FromState</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes density from state array</p><a href="../proc/deriverho_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveshearmag.html'>deriveShearMag</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the shear stress magnitude of a given element number with the
given</p><a href="../proc/deriveshearmag.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveshearrate.html'>deriveShearRate</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the shear rate</p><a href="../proc/deriveshearrate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveshearstress.html'>deriveShearStress</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the deviatoric shear stress for Newtonian fluid
(exclude pressure) (no mixtures).\n
Shear Stress depends on variable: nonEquilibirium</p><a href="../proc/deriveshearstress.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivesrc_chargedensity.html'>deriveSrc_chargeDensity</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate charge density source variable referred in config file</p><a href="../proc/derivesrc_chargedensity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivestrainrate.html'>deriveStrainRate</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of StrainRate
This routine sets the function Pointer for StrainRate calcualtion and calls
the generice get Element from PDF routine</p><a href="../proc/derivestrainrate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivestrainrate_fromindex.html'>deriveStrainRate_fromIndex</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of kinetic_energy.
This routine sets the function Pointer for kinetic_energy calcualtion and
calls the generice get Value of Index routine</p><a href="../proc/derivestrainrate_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivestrainratephy.html'>deriveStrainRatePhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the strain rate (or called rate of strain)</p><a href="../proc/derivestrainratephy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivestrainratephy_fromindex.html'>deriveStrainRatePhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the strain rate of a given idx</p><a href="../proc/derivestrainratephy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivetemp.html'>deriveTemp</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the temperature of a given set of elements (sum up all links).</p><a href="../proc/derivetemp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivetempphy.html'>deriveTempPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the velocity magnitude of a given element number with the given
input vector (sum up all values)</p><a href="../proc/derivetempphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivetempphy_fromindex.html'>deriveTempPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the temperature of a given idx</p><a href="../proc/derivetempphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevel_fromprecolstate.html'>deriveVel_FromPreColState</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from pre collision state array using Fetch</p><a href="../proc/derivevel_fromprecolstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevel_fromstate.html'>deriveVel_FromState</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/derivevel_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelmsgas_fromstate.html'>deriveVelMSGas_FromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/derivevelmsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelmsliquid_fromstate.html'>deriveVelMSLiquid_FromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/derivevelmsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocitiesmsgas_fromstate.html'>deriveVelocitiesMSGas_FromState</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/derivevelocitiesmsgas_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocitiesmsliquid_fromstate.html'>deriveVelocitiesMSLiquid_FromState</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocities of all species from state array</p><a href="../proc/derivevelocitiesmsliquid_fromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocity_fromstate_isothermaceq.html'>deriveVelocity_FromState_IsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes velocity from state array</p><a href="../proc/derivevelocity_fromstate_isothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocityms.html'>deriveVelocityMS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the velocity of a given element for single species.
from the momentum and density stored in auxField array for liquid mixture.
auxField was updated with momentum of untransformed PDF which was computed
by solving LSE in compute kernel.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocityms_fromindex.html'>deriveVelocityMS_fromIndex</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate velocity from species density and momentum in auxField
for getValOfIndex</p><a href="../proc/derivevelocityms_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocityphy.html'>deriveVelocityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the velocity of a given element number with the given input
       vector (sum up all values)</p><a href="../proc/derivevelocityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivevelocityphy_fromindex.html'>deriveVelocityPhy_fromIndex</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the velocity of a given idx</p><a href="../proc/derivevelocityphy_fromindex.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/deriveviscosityphy.html'>deriveViscosityPhy</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert lattice viscosity to physical viscosity</p><a href="../proc/deriveviscosityphy.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivewss2d.html'>deriveWSS2D</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derivewss3d.html'>deriveWSS3D</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the wall shear stress (WSS) of a given element with the given
input</p><a href="../proc/derivewss3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/derpressureisothermaceq.html'>derPressureIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the pressure of a given set of elements (sum up all links).</p><a href="../proc/derpressureisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dervelocityisothermaceq.html'>derVelocityIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initiates the calculation of velocity
This routine sets the function Pointer for velocity calcualtion and calls
the generice get Element from PDF routine</p><a href="../proc/dervelocityisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/destroy_da_particle_dps.html'>destroy_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/destroy_da_particle_mem.html'>destroy_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/destroyparticle_mem.html'>destroyParticle_MEM</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>destroyParticle_MEM removes a particle from the lattice and the particleGroup
It will
* empty the exclusionList
* initialize all the former particle elements to new fluid elements
* restore connectivity for all these new fluid elements
This routine should be followed up by a call to remove_particle_from_da_particle_MEM!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/distributeparticlevolume.html'>distributeParticleVolume</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Distribute the volume of a particle to update the fluid volume fraction field</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_benchmark.html'>do_benchmark</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_fast_singlelevel.html'>do_fast_singleLevel</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Control routine for an optimized workflow with reduced functionality.</p><a href="../proc/do_fast_singlelevel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_intpcoarserandexchange.html'>do_intpCoarserAndExchange</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine utilizes fluid elements on my level (L) to fill finer
ghost elements on next level (L+1).
Then it exchanges the datas of finer ghost elements (L+1) between process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_intpfinerandexchange.html'>do_intpFinerAndExchange</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine does:
1. interpolate my coarse ghost element (iLevel) from finer level (iLevel+1)
2. exchange the data of my coarse ghost elements between process</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_nothing.html'>do_nothing</a></td>
                 <td><a href='../module/mus_bc_fluid_wall_module.html'>mus_bc_fluid_wall_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/do_nothing.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_nothing~2.html'>do_nothing</a></td>
                 <td><a href='../module/mus_interpolate_debug_module.html'>mus_interpolate_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill GhostFromFiner elements on my level with debug value</p><a href="../proc/do_nothing~2.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_nothing_arbi.html'>do_nothing_arbi</a></td>
                 <td><a href='../module/mus_interpolate_debug_module.html'>mus_interpolate_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill GhostFromFiner elements on my level with debug value</p><a href="../proc/do_nothing_arbi.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/do_recursive_multilevel.html'>do_recursive_multiLevel</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main control routine: Update the time step for all levels.
Main steps:
  * if iLevel &lt; maxLevel do recursive at iLevel+1
  * do BC at iLevel
  * do auxField calculation at iLevel
  * do compute kernel at iLevel
  * do apply source at iLevel
  * do do_IntpFinerAndExchange at iLevel if iLevel &lt; maxLevel
    * intp My Coarser ghost (iLevel) from Finer (iLevel+1)
    * do exchange bufferFromFiner at iLevel
  * exchange buffer at iLevel
  * exchange bufferFromCoarser at iLevel if iLevel &gt; minLevel
  * do do_intpCoarserAndExchange at iLevel if iLevel &lt; maxLevel
    * intp Finer Ghost (iLevel+1) from my coarser (iLevel)
    * exchange bufferFromCoarser at iLevel+1</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_bc_timing.html'>dump_bc_timing</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine dump compute and BC timing for all ranks
rank    nFluids     tCompute     nBCElems     tBC    tCPU    tMainLoop</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_debug_info.html'>dump_debug_info</a></td>
                 <td><a href='../module/mus_debug_module.html'>mus_debug_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump pdf values into debug files</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_elemdep.html'>dump_elemDep</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>dump dependencies for one element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_finerghostsfromme.html'>dump_FinerGhostsFromMe</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Coarser</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_finerghostsfrommebuffer.html'>dump_FinerGhostsFromMeBuffer</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Coarser</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_intplist.html'>dump_intpList</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Finer and write them out so we can compare</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_intplists.html'>dump_intpLists</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Finer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_level_timing.html'>dump_level_timing</a></td>
                 <td><a href='../module/mus_program_module.html'>mus_program_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_linear_partition.html'>dump_linear_partition</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_myghostsfromfiner.html'>dump_MyGhostsFromFiner</a></td>
                 <td><a href='../module/mus_interpolate_tools_module.html'>mus_interpolate_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>check the dependencies from Finer and write them out so we can compare</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_particle_timing.html'>dump_particle_timing</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to dump particle timing data</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dump_timing.html'>dump_timing</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Performance results (MLUPs) are written to a file for statistical review
The file-format is simple can be evaluated with gnuplot</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dumpdata.html'>dumpdata</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Debugging routine to dump debug tracking data</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dumppdfall.html'>dumpPdfAll</a></td>
                 <td><a href='../module/mus_debug_tools_module.html'>mus_debug_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write all pdf entries of a all elements of the pdf array for a given level
to the debug unit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/equilfrommacro.html'>equilFromMacro</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>derive equilibrium from macro</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/equilfrommacrowtdf.html'>equilFromMacroWTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>derive equilibrium from macro</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/equilvelfrommacro.html'>equilVelFromMacro</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>Equlibrium velocity from macro</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/equilvelfrommacrowtdf.html'>equilVelFromMacroWTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>Equlibrium velocity from macro with thermodynamic factor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchange_tree_bc.html'>exchange_tree_bc</a></td>
                 <td><a href='../module/mus_dynloadbal_module.html'>mus_dynLoadBal_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangeforces.html'>exchangeForces</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeForces send force contributions from each process on which a particle
exists to the particle owner. The total hydrodynamic force is then computed by
the particle owner as the sum of all the force contributions (which physically are
the surface forces from the part of the particle surface handled by each process).
The owner then updates particle velocity in a subsequent call to a different routine.
For momentum-exchange method only!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangehydroforces_dps.html'>exchangeHydroForces_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeHydroForces_DPS exchanges particles hydrodynamic forces after they
have been updated by the particle owner. Each process sends force updates
for particles they own and receives updates for particles which they do not
own, but that do exist in their particleGroup.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangemominc_dps.html'>exchangeMomInc_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeMomInc_DPS send the accumulated momentum transfer FROM particles TO fluid
from a particle's previous owner to its new owner.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangenewparticles_dps.html'>exchangeNewParticles_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeNewParticles sends all the data needed to initialize a particle on
a process. This is needed when a particle travels from one process to another.
The data is used to add the particle to the receiving process particleGroup.
This only creates a continuous representation of the particle on the receiving
process. A subsequent call to a different routine then maps this to the discrete
representation in the form of elements in the exclusionList.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangenewparticles_mem.html'>exchangeNewParticles_MEM</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeNewParticles sends all the data needed to initialize a particle on
a process. This is needed when a particle travels from one process to another.
The data is used to add the particle to the receiving process particleGroup.
This only creates a continuous representation of the particle on the receiving
process. A subsequent call to a different routine then maps this to the discrete
representation in the form of elements in the exclusionList.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangeparticlestates.html'>exchangeParticleStates</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeParticleStates is used to exchange particle (continuous) position
and velocity as well as the integer coordOfOrigin. This is necessary for
(for example) the collision handling routines</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangeparticlestoremove.html'>exchangeParticlesToRemove</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>If a particle is removed from the global domain (e.g. after colliding with an open boundary)
then exchangeParticlesToRemove will send messages informing all other processes
that this particle should be removed.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangeparticlestoremove_dps.html'>exchangeParticlesToRemove_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>If a particle is removed from the global domain (e.g. after colliding with an open boundary)
then exchangeParticlesToRemove will send messages informing all other processes
that this particle should be removed.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangepositions.html'>exchangePositions</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangePositions exchanges particles continuous positions after they
have been updated by the particle owner. Each process sends position updates
for particles they own and receives updates for particles which they do not
own, but that do exist in their particleGroup.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangepositions_dps.html'>exchangePositions_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangePositions exchanges particles continuous positions after they
have been updated by the particle owner. Each process sends position updates
for particles they own and receives updates for particles which they do not
own, but that do exist in their particleGroup.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangevelocities.html'>exchangeVelocities</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeVelocities exchanges particles continuous velocities after they
have been updated by the particle owner. Each process sends velocity updates
for particles they own and receives updates for particles which they do not
own, but that do exist in their particleGroup.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exchangevelocities_dps.html'>exchangeVelocities_DPS</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>exchangeVelocities exchanges particles continuous velocities after they
have been updated by the particle owner. Each process sends velocity updates
for particles they own and receives updates for particles which they do not
own, but that do exist in their particleGroup.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/expand_da_particle_dps.html'>expand_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/expand_da_particle_mem.html'>expand_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_2nd_ord_d2q9.html'>f_f_eq_regularized_2nd_ord_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_2nd_ord_d3q19.html'>f_f_eq_regularized_2nd_ord_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_2nd_ord_d3q27.html'>f_f_eq_regularized_2nd_ord_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_4th_ord_d2q9.html'>f_f_eq_regularized_4th_ord_d2q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_4th_ord_d3q19.html'>f_f_eq_regularized_4th_ord_d3q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_f_eq_regularized_4th_ord_d3q27.html'>f_f_eq_regularized_4th_ord_d3q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_bcbuffer.html'>fill_bcBuffer</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer pdf of boundary elements into bcBuffer which is used by all
boundary routines.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_bins.html'>fill_bins</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine which fills the bins in mus_particle_blob_prob_type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_blob_positions_gauss.html'>fill_blob_positions_gauss</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize particle creator object with random positions 
inside a cylinder described by blob_cylinder type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_blob_positions_gauss_prism.html'>fill_blob_positions_gauss_prism</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize particle creator object with random positions 
inside a prism described by blob_prism type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_cylinder.html'>fill_cylinder</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill_cylinder fills the dynamic array positions with coordinates
of particles spaced a distance d apart inside a cylinder with
faces z = 0 and z = L and radius R.
For cylinders of different position and orientation, these coordinates
can be transformed.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_neighbuffer.html'>fill_neighBuffer</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Transfer pre- and post-collision PDF of neighbors of boundary elements
into neighBufferPre and neighBufferPost.
Access to state array</p><a href="../proc/fill_neighbuffer.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/fill_prism.html'>fill_prism</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_prism_by_distance.html'>fill_prism_by_distance</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fill_prism_by_number.html'>fill_prism_by_number</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbifinerghostsfromme_linear.html'>fillArbiFinerGhostsFromMe_linear</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from coarse source to fine target</p><a href="../proc/fillarbifinerghostsfromme_linear.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbifinerghostsfromme_linear2d.html'>fillArbiFinerGhostsFromMe_linear2D</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from coarse source to fine target</p><a href="../proc/fillarbifinerghostsfromme_linear2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbifinerghostsfromme_quad.html'>fillArbiFinerGhostsFromMe_quad</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from coarse source to fine target</p><a href="../proc/fillarbifinerghostsfromme_quad.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbifinerghostsfromme_quad2d.html'>fillArbiFinerGhostsFromMe_quad2D</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from coarse source to fine target</p><a href="../proc/fillarbifinerghostsfromme_quad2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbifinerghostsfromme_weighavg.html'>fillArbiFinerGhostsFromMe_weighAvg</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from coarse source to fine target</p><a href="../proc/fillarbifinerghostsfromme_weighavg.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillarbimyghostsfromfiner_avg.html'>fillArbiMyGhostsFromFiner_avg</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate auxiliary field from fine source to coarse target</p><a href="../proc/fillarbimyghostsfromfiner_avg.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_linear2d_feq_fneq.html'>fillFinerGhostsFromMe_linear2D_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by linear interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic linear interpolation.</p><a href="../proc/fillfinerghostsfromme_linear2d_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_linear_feq_fneq.html'>fillFinerGhostsFromMe_linear_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by linear interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic linear interpolation.</p><a href="../proc/fillfinerghostsfromme_linear_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_linearles_feq_fneq.html'>fillFinerGhostsFromMe_linearLES_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by linear interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic linear interpolation.</p><a href="../proc/fillfinerghostsfromme_linearles_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_quad2d_feq_fneq.html'>fillFinerGhostsFromMe_quad2D_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by quadratic interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic quadratic interpolation.</p><a href="../proc/fillfinerghostsfromme_quad2d_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_quad_feq_fneq.html'>fillFinerGhostsFromMe_quad_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by quadratic interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic quadratic interpolation.</p><a href="../proc/fillfinerghostsfromme_quad_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_quadles_feq_fneq.html'>fillFinerGhostsFromMe_quadLES_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill fine ghost from coarse fluid by quadratic interpolation for D2Q9
stencil.
1. Compute moments for all source elements, save in momBuf
2. For each target, interpolate moments (den, vel, tau)
   (10 moments for 3D and 6 moments for 2D)
3. calculate fEq and use it to calculate high order moments
4. convert moments to PDF
This routine is used by acoustic quadratic interpolation.</p><a href="../proc/fillfinerghostsfromme_quadles_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_weighavg2d_feq_fneq.html'>fillFinerGhostsFromMe_weighAvg2D_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p><a href="../page/features/intp_methods.html">Linear interpolation</a> of ghostFromFiner
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillfinerghostsfromme_weighavg2d_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_weighavg_feq_fneq.html'>fillFinerGhostsFromMe_weighAvg_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p><a href="../page/features/intp_methods.html">Linear interpolation</a> of ghostFromFiner
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillfinerghostsfromme_weighavg_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillfinerghostsfromme_weighavgles_feq_fneq.html'>fillFinerGhostsFromMe_weighAvgLES_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p><a href="../page/features/intp_methods.html">Linear interpolation</a> of ghostFromFiner
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillfinerghostsfromme_weighavgles_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillhelperelementscoarsetofine.html'>fillHelperElementsCoarseToFine</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursively fill all the helper elements (i.e. ghost, halo) with valid
information from the fluid elements.</p><a href="../proc/fillhelperelementscoarsetofine.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillhelperelementsfinetocoarse.html'>fillHelperElementsFineToCoarse</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Recursively fill all the helper elements (i.e. ghost, halo) with valid
information from the fluid elements.</p><a href="../proc/fillhelperelementsfinetocoarse.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillmyghostsfromfiner_avg2d_feq_fneq.html'>fillMyGhostsFromFiner_avg2D_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Fill coarse target ghost from fine source fluid by average interpolation.
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillmyghostsfromfiner_avg2d_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillmyghostsfromfiner_avg_feq_fneq.html'>fillMyGhostsFromFiner_avg_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p><a href="../page/features/intp_methods.html">Average interpolation</a> of ghostFromFiner
The interpolation procedure used in this routine is:\n
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillmyghostsfromfiner_avg_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fillmyghostsfromfiner_avgles_feq_fneq.html'>fillMyGhostsFromFiner_avgLES_feq_fneq</a></td>
                 <td><a href='../module/mus_interpolate_average_module.html'>mus_interpolate_average_module</a></td>
                 <td>Subroutine</td>
                 <td><p><a href="../page/features/intp_methods.html">Average interpolation</a> of ghostFromFiner
The interpolation procedure used in this routine is:\n
1. Calculate Equilibrium and nonEquilibrium
2. Compute scaling factor
3. calculate target: Eq + Scale * nonEquilibrium</p><a href="../proc/fillmyghostsfromfiner_avgles_feq_fneq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/finalize_bclist.html'>finalize_BClist</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/finalize_particle_interpolator.html'>finalize_particle_interpolator</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/find_particle_comm_procs4.html'>find_particle_comm_procs4</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>find_particle_comm_procs generates a list of all processes we may need to communicate
particle data with over the duration of the simulation. We only need to communicate
this data for particles on our rank which also exist on other processes. This means
we will never communicate with processes whose domains are not within one particle
diameter of our domain. This is the key assumption used to generate the list of procs
Hence the padding distance dpad should be set to the largest particle diameter in the
simulation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/find_possintporderandupdatemysources.html'>find_possIntpOrderAndUpdateMySources</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Find maximum possible interpolation order which can be used for
fillFinerFromMe by comparing nFoundSources with nMaxSources of different
interpolation order starting from interpolation order defined by user</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/findparticlefromelem.html'>findParticleFromElem</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>find particle index and ID in particleGroup array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/findpartitionoftreeid.html'>findPartitionOfTreeID</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to find the process a certain treeID is on.
Looks in the ranks in the array of argument procs
Returns the INDEX of the found proc in this array
Example: procs = [4 8 7] and we find our treeID on rank 8
         will return procIndex = 2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/findpropindex.html'>findPropIndex</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fixedpoint_method.html'>fixedPoint_method</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Function</td>
                 <td><p>This routine computes friction velocity from wall model profile
using fixed-point iterative method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/followneighpath.html'>followNeighPath</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>followNeighPath can be used to determine the position of a neighboring
lattice site in the total list. For this we follow one or more entries of
the levelDesc%neigh array. Since this array is only defined for local fluid
elements, startPos must point to a local fluid element.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fricvel_schmitt.html'>fricVel_Schmitt</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes friction velocity from Schmitt wall model.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/generateelemlistline.html'>generateElemListLine</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Debugging routine to create a list of elements along a line so
that the properties of these elements can be printed</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_auxtime.html'>get_auxTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_auxtime_atlevel.html'>get_auxTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_auxtime_total.html'>get_auxTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_bcbufferratio.html'>get_bcBufferRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_bcbufferratio_atlevel.html'>get_bcBufferRatio_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_bcbufferratio_total.html'>get_bcBufferRatio_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_bcbuffertime.html'>get_bcBufferTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_bcbuffertime_atlevel.html'>get_bcBufferTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_bcbuffertime_total.html'>get_bcBufferTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_boundaryratio.html'>get_boundaryRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_boundarytime.html'>get_boundaryTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_boundarytime_byid.html'>get_boundaryTime_byID</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_boundarytime_total.html'>get_boundaryTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_communicateratio.html'>get_communicateRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_communicatetime.html'>get_communicateTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_computeratio.html'>get_computeRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_computeratio_atlevel.html'>get_computeRatio_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_computeratio_total.html'>get_computeRatio_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_computetime.html'>get_computeTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_computetime_atlevel.html'>get_computeTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_computetime_total.html'>get_computeTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_d_uplus_d_utau.html'>get_d_uPlus_d_uTau</a></td>
                 <td><a href='../module/mus_wall_function_musker_module.html'>mus_wall_function_musker_module</a></td>
                 <td>Function</td>
                 <td><p>function to get the derivative of uPlus with respect to uTau</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_d_uplus_d_utau~2.html'>get_d_uPlus_d_uTau</a></td>
                 <td><a href='../module/mus_wall_function_reichardt_module.html'>mus_wall_function_reichardt_module</a></td>
                 <td>Function</td>
                 <td><p>function to get the derivative of uPlus with respect to uTau</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_d_uplus_d_utau~3.html'>get_d_uPlus_d_uTau</a></td>
                 <td><a href='../module/mus_wall_function_schmitt_module.html'>mus_wall_function_schmitt_module</a></td>
                 <td>Function</td>
                 <td><p>function to get the derivative of uPlus with respect to uTau</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_d_uplus_d_utau_interface.html'>get_d_uPlus_d_uTau_interface</a></td>
                 <td><a href='../module/mus_wall_function_abstract_module.html'>mus_wall_function_abstract_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_intpfromcoarserratio.html'>get_intpFromCoarserRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromcoarserratio_atlevel.html'>get_intpFromCoarserRatio_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromcoarserratio_total.html'>get_intpFromCoarserRatio_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_intpfromcoarsertime.html'>get_intpFromCoarserTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromcoarsertime_atlevel.html'>get_intpFromCoarserTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromcoarsertime_total.html'>get_intpFromCoarserTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_intpfromfinerratio.html'>get_intpFromFinerRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromfinerratio_atlevel.html'>get_intpFromFinerRatio_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromfinerratio_total.html'>get_intpFromFinerRatio_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_intpfromfinertime.html'>get_intpFromFinerTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromfinertime_atlevel.html'>get_intpFromFinerTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpfromfinertime_total.html'>get_intpFromFinerTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intpratio.html'>get_intpRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_intptime.html'>get_intpTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_kineticenergy_from_vel_dens_compressible.html'>get_kineticEnergy_from_vel_dens_compressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get kineticEnergy from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_kineticenergy_from_vel_dens_incompressible.html'>get_kineticEnergy_from_vel_dens_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get kineticEnergy from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_mainlooptime.html'>get_mainLoopTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_moment.html'>get_moment</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Function</td>
                 <td><p>Calculate the moment of a centain order
The moment of a distribution <script type="math/tex"> f_i </script> is defined as:\n
<script type="math/tex; mode=display">
   m_{x^{p}y^{q}z^{r}} = \sum_{i}^{Q} c^{p}_{xi} c^{q}_{yi} c^{r}_{zi} f_i
</script>
The fucntion argument <code>expX</code> is array of size 3,
which contains the values of \f$p, q, r\f$</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_momentum_from_vel_dens_compressible.html'>get_momentum_from_vel_dens_compressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get momentum from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_momentum_from_vel_dens_incompressible.html'>get_momentum_from_vel_dens_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get momentum from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_momentvector.html'>get_momentVector</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Function</td>
                 <td><p>get the moment vector to calculate the moment from the pdf</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_compressible.html'>get_pdfEq_compressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density along a</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_compressible_idir.html'>get_pdfEq_compressible_iDir</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density along a</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_d2q9.html'>get_pdfEq_d2q9</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_d3q19.html'>get_pdfEq_d3q19</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_d3q27.html'>get_pdfEq_d3q27</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_incomp_d2q9.html'>get_pdfEq_incomp_d2q9</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the incompressible equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_incomp_d3q19.html'>get_pdfEq_incomp_d3q19</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the incompressible equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_incomp_d3q27.html'>get_pdfEq_incomp_d3q27</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the incompressible equilibrium pdf from velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_incompressible.html'>get_pdfEq_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density along a</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_pdfeq_incompressible_idir.html'>get_pdfEq_incompressible_iDir</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density along a</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_relaxtime.html'>get_relaxTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_relaxtime_atlevel.html'>get_relaxTime_atLevel</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_relaxtime_total.html'>get_relaxTime_total</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_rho0inv_compressible.html'>get_rho0Inv_compressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get kineticEnergy from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_rho0inv_incompressible.html'>get_rho0Inv_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get kineticEnergy from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sigma_d2q9.html'>get_sigma_d2q9</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the sigma vector necessary to get the</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sigma_d3q19.html'>get_sigma_d3q19</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the sigma vector necessary to get the</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_sigma_d3q27.html'>get_sigma_d3q27</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes the sigma vector necessary to get the</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_stageratio.html'>get_stageRatio</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_stagetime.html'>get_stageTime</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_uplus.html'>get_uPlus</a></td>
                 <td><a href='../module/mus_wall_function_musker_module.html'>mus_wall_function_musker_module</a></td>
                 <td>Function</td>
                 <td><p>function to get uPlus</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_uplus~2.html'>get_uPlus</a></td>
                 <td><a href='../module/mus_wall_function_reichardt_module.html'>mus_wall_function_reichardt_module</a></td>
                 <td>Function</td>
                 <td><p>function to get uPlus</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_uplus~3.html'>get_uPlus</a></td>
                 <td><a href='../module/mus_wall_function_schmitt_module.html'>mus_wall_function_schmitt_module</a></td>
                 <td>Function</td>
                 <td><p>function to get uPlus</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/get_uplus_interface.html'>get_uPlus_interface</a></td>
                 <td><a href='../module/mus_wall_function_abstract_module.html'>mus_wall_function_abstract_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_utau_loglayer.html'>get_uTau_logLayer</a></td>
                 <td><a href='../module/mus_wall_function_schmitt_module.html'>mus_wall_function_schmitt_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_utau_subvisouslayer.html'>get_uTau_subVisousLayer</a></td>
                 <td><a href='../module/mus_wall_function_schmitt_module.html'>mus_wall_function_schmitt_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_compressible.html'>get_vel_from_pdf_compressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_compressible_vectorized.html'>get_vel_from_pdf_compressible_vectorized</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d2q9.html'>get_vel_from_pdf_d2q9</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d2q9 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d2q9_incompressible.html'>get_vel_from_pdf_d2q9_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d2q9 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d2q9_vectorized.html'>get_vel_from_pdf_d2q9_vectorized</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d2q9_vectorized_incompressible.html'>get_vel_from_pdf_d2q9_vectorized_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q19.html'>get_vel_from_pdf_d3q19</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d3q19 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q19_incompressible.html'>get_vel_from_pdf_d3q19_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d3q19 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q19_vectorized.html'>get_vel_from_pdf_d3q19_vectorized</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q19_vectorized_incompressible.html'>get_vel_from_pdf_d3q19_vectorized_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q27.html'>get_vel_from_pdf_d3q27</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d3q27 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q27_incompressible.html'>get_vel_from_pdf_d3q27_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for d3q27 stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q27_vectorized.html'>get_vel_from_pdf_d3q27_vectorized</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_d3q27_vectorized_incompressible.html'>get_vel_from_pdf_d3q27_vectorized_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_incompressible.html'>get_vel_from_pdf_incompressible</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_vel_from_pdf_incompressible_vectorized.html'>get_vel_from_pdf_incompressible_vectorized</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>function pointer to get pdf equilibrium from vel and density for any stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/get_xd.html'>get_xd</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getbaryofcoord.html'>getBaryOfCoord</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Convenience function to get barycenter of integer coordinate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getcartesianstencilindices.html'>getCartesianStencilIndices</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getconversionfac.html'>getConversionFac</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the conversion factor variable from physics table from a given solver
specific character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getdensity.html'>getDensity</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getdensity_forelemfromstate.html'>getDensity_forElemFromState</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the density of a given element number with the given state
       vector (sum up all values)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getdensity_forpdfsubset.html'>getDensity_forPdfSubset</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the density of a given subset of pdfs
       vector (sum up all values)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/geteqbydensvel.html'>getEqByDensVel</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the equilibrium distribution function in all directions</p><a href="../proc/geteqbydensvel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getequilibrium.html'>getEquilibrium</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getequilibrium_forelemfromstate.html'>getEquilibrium_forElemfromState</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the equilibrium distribution function in all directions</p><a href="../proc/getequilibrium_forelemfromstate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getequilibrium_forpdfsubset.html'>getEquilibrium_forPdfSubset</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the equilibrium distribution function in all directions</p><a href="../proc/getequilibrium_forpdfsubset.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getequilibriumincomp.html'>getEquilibriumIncomp</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the equilibrium distribution function in all directions
This is the incompressible formulation with reference density rho0</p><a href="../proc/getequilibriumincomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getfieldprefixes.html'>getFieldPrefixes</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the right field prefixes from a given solver specific character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getfieldvariable.html'>getFieldVariable</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getfieldvariable_array.html'>getFieldVariable_array</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the field variable name for given field type from a given solver
specific character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getfieldvariable_scalar.html'>getFieldVariable_scalar</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the field variable name for given field type from a given solver
specific character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradrhou3_1d.html'>getGradRhoU3_1D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of rho * velocity^3 from gradient, density
and veleocity data. Just derivatives u_x, v_y and w_z.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradrhou3_2d.html'>getGradRhoU3_2D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of rho * velocity^3 from gradient, density
and veleocity data. Just derivatives u_x, v_y and w_z.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradrhou3_3d.html'>getGradRhoU3_3D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of rho * velocity^3 from gradient, density
and veleocity data. Just derivatives u_x, v_y and w_z.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradrhouvz_3d.html'>getGradRhoUVZ_3D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of rho * velocity^3 from gradient, density
and veleocity data. Just derivatives u_x, v_y and w_z.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradu_1d.html'>getGradU_1D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradu_2d.html'>getGradU_2D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradu_3d.html'>getGradU_3D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradxxu_1d.html'>getGradXXU_1D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradxxu_2d.html'>getGradXXU_2D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getgradxxu_3d.html'>getGradXXU_3D</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function computes gradient of velocity from gradient and veleocity
data.
Gradient is computed using central difference.
if an element has an boundary then neighbor refers to current element
then forward difference is used</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/gethermitepolynomials.html'>getHermitepolynomials</a></td>
                 <td><a href='../module/mus_hrrinit_module.html'>mus_hrrInit_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This function computes Hermite polinomial. It gives in output minimum</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/gethermitepolynomials_d3q19.html'>getHermitepolynomials_D3Q19</a></td>
                 <td><a href='../module/mus_hrrinit_module.html'>mus_hrrInit_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This function computes Hermite polinomial. It gives in output minimum</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getidentifychar.html'>getIdentifyChar</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get a character from the identify table using a given solver specific
character handle and a given key word.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getindexofcoordintotal.html'>getIndexOfCoordInTotal</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the index in the total list of a specified integer coordinate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getinterpolationbnds.html'>getInterpolationBnds</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>getInterpolationBnds is used to determine which cells to interpolate
fluid quantities from for a particle positioned at its coordOfOrigin + r_lat.
The 8 cells obtained are the cells whose barycenter forms the tightest
bounding cube around the particle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getneighborcoord.html'>getNeighborCoord</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Function</td>
                 <td><p>getNeighborCoord gets the coordinate of the element
offset from input coord by (nx,ny,nz) while taking into
account periodicity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getneq_acoustic.html'>getNEq_acoustic</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Setting the non-equilibrium part based on the acoustic scaling</p><a href="../proc/getneq_acoustic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getneq_diffusive.html'>getNEq_diffusive</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the non-equilibrium part of pdf from strain rate tensor
based on the diffusive scaling</p><a href="../proc/getneq_diffusive.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnewparticleid.html'>getNewParticleID</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to generate a unique particleID for a particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnfields.html'>getNFields</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the number of fields from a given solver specific character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnoneqfac_intp.html'>getNonEqFac_intp</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the conversion factor to convert nonEq moments
between fine and coarser.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnoneqfac_intp_coarse_to_fine.html'>getNonEqFac_intp_coarse_to_fine</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the conversion factor to convert nonEq pdfs
from coarse to fine.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getnoneqfac_intp_fine_to_coarse.html'>getNonEqFac_intp_fine_to_coarse</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the conversion factor to convert nonEq pdfs
from fine to coarse.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getparticlelogunit.html'>getParticleLogUnit</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to create a particle logunit based on particle ID</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getpathtovec.html'>getPathToVec</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>getPathToVec builds a series of 3 indices which can be followed using the 
levelDesc(lev)%neigh array to get the position of a neighboring element 
in the total list.
Usage: given an element at coordinate [0,0,0] with position startPos in the
total list, to reach the element at [1,1,1] we do:
call getPathToVec([1,1,1], cxDir, path)
pos = startPos 
do k = 1,3
  pos = levelDesc(lev)%neigh%nghElems(path(k),pos)
end do
At the end of the loop pos will point to the requested element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getposofcoord.html'>getPosOfCoord</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Get the position in the levelDesc%total list of an element with 
integer coordinate coord. This routine returns ldPos &lt;= 0 if 
the element could not be found on this process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getprocessboundingbox.html'>getProcessBoundingBox</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to find the bounding box of the part of the spatial 
domain on this process</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getsearchboxlimits.html'>getSearchBoxLimits</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>getSearchBoxLimits is used in find_particle_comm_procs to determine
where the non-local elements we have to check the owner proc of are.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getshearrate.html'>getShearRate</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the Shear Rate</p><a href="../proc/getshearrate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getvariable_fromtable.html'>getVariable_FromTable</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the value of variable inside the table name 'key' in scheme
 @note Todo
      extent it for vectors</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getvelocity.html'>getVelocity</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getvelocity_forelemfromstate_noforce.html'>getVelocity_forElemFromState_noForce</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the velocity in all 3 directions
from the element indicated (elem),
reading the pdf (state information) from the state array.
state array includes all the pdfs of all elements.
The access to the state array has to be done via the generic
access macro IDX, as we want to access post-collision values.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getvelocity_forpdfsubset.html'>getVelocity_forPdfSubset</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the velocity in all 3 directions
       from a subset given, ordered according to the stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getvelocity_forpdfsubset_incomp.html'>getVelocity_forPdfSubset_incomp</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate the velocity in all 3 directions
       from a subset given, ordered according to the stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/getvelocity_incomp.html'>getVelocity_incomp</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getweights.html'>getWeights</a></td>
                 <td><a href='../module/mus_solspechelpers_module.html'>mus_solSpecHelpers_module</a></td>
                 <td>Function</td>
                 <td><p>Get the the weights of a used stencil from a given solver specific
character handle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getwght1d_linear.html'>getwght1d_linear</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td><p>Weight function for 1d linear interpolation or distribution.
Given the distance from particle to fluid cell barycenter,
it returns weight, where weight is a linear function
of the distance between the position of the particle and the
barycenter of the lattice site we are distributing to.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/getwss.html'>getWSS</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Function</td>
                 <td><p>Calculate wss from shear stress (tau)
tau: x, y, z, xy, yz, xz</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/grabvalueatcoord.html'>grabValueAtCoord</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for routine to get the value of the velocity and
pressure field at a specified integer coordinate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/grabvalueatcoord_onewaycoupled.html'>grabValueAtCoord_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the value of the density and velocity at a certain integer coordinate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/grabvalueatcoord_twowaycoupled.html'>grabValueAtCoord_twowaycoupled</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the value of the density and velocity at a certain integer coordinate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/has_remote_neighbors.html'>has_remote_neighbors</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Function which checks if element has remote neighbors</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/hrr_correction_d2q9.html'>HRR_Correction_d2q9</a></td>
                 <td><a href='../module/mus_hrrinit_module.html'>mus_hrrInit_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/hrr_correction_d3q19.html'>HRR_Correction_d3q19</a></td>
                 <td><a href='../module/mus_hrrinit_module.html'>mus_hrrInit_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/hrr_correction_d3q27.html'>HRR_Correction_d3q27</a></td>
                 <td><a href='../module/mus_hrrinit_module.html'>mus_hrrInit_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/incrementauxfield_dps.html'>incrementAuxField_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Add momentum increments due to particles within DEM subcycles to the
auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_advrel.html'>init_advRel</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Choose the relaxation model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_boundary_single.html'>init_boundary_single</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the right boundary conditions for the different
boundaries.</p><a href="../proc/init_boundary_single.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_cxdirweightedavg.html'>init_cxDirWeightedAvg</a></td>
                 <td><a href='../module/mus_interpolate_header_module.html'>mus_interpolate_header_module</a></td>
                 <td>Function</td>
                 <td><p>Initialize stencil for weighted average interpolation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_da_particle_dps.html'>init_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_da_particle_mem.html'>init_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/init_enrtl_loc.html'>init_enrtl_loc</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td><p>This function initialize eNRTL model by loading liquid mixture
property from filename</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_intparraysperlevel.html'>init_intpArraysPerLevel</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_levelbuffers.html'>init_levelBuffers</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the communication buffers for a single level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_momentsbc.html'>init_momentsBC</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the values required for the moments BC</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_mus_particles_comm_type.html'>init_mus_particles_comm_type</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Allocate mus_particles_communication_type and its variables</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_nrbc.html'>init_nrbc</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the values required for the characteristic boundary conditions</p><a href="../proc/init_nrbc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../interface/init_particle_blob_prob.html'>init_particle_blob_prob</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_blob_prob_circle.html'>init_particle_blob_prob_circle</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_blob_prob_square.html'>init_particle_blob_prob_square</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_creator.html'>init_particle_creator</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_creator_from_blob.html'>init_particle_creator_from_blob</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the particle creator object from a particle 
blob cylinder object
Check if particles should be initialized to the local fluid velocity.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_creator_from_blob_prism.html'>init_particle_creator_from_blob_prism</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the particle creator object from a particle 
blob prism object
Check if particles should be initialized to the local fluid velocity.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_interpolator.html'>init_particle_interpolator</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_particle_logger.html'>init_particle_logger</a></td>
                 <td><a href='../module/mus_particle_logging_type_module.html'>mus_particle_logging_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_qvals.html'>init_qVals</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>assign qVal to corresponding BC and level-wise if qVal not provided by
seeder. qVal from seeder are assigned in assignBCList in
mus_construction_module, So set qVal from config only when it is not
provided by seeder.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_recvbuffers.html'>init_recvBuffers</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create the communication buffers</p><a href="../proc/init_recvbuffers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_sendbuffers.html'>init_sendBuffers</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create the communication buffers</p><a href="../proc/init_sendbuffers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_transformation_matrix_fluid.html'>init_transformation_matrix_fluid</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize Moments transformation matrix for LBM compressible and
incompressible fluid model. This matrix must be consistent with the
relaxation matrix used in compute kernel and interpolation routines</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/init_transformation_matrix_ms.html'>init_transformation_matrix_MS</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Intialize the moment transformation matrix for multispecies.
This matrix must be consistent with relaxation matrix used for
multispecies MRT collision routines</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/initparticle_dps.html'>initParticle_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>initParticle_DPS performs the initialization of a DPS particle once
it has been created. This consists of determining the coordinates of
particle origin and determining which processes this particle exists
on.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/initparticle_mem.html'>initParticle_MEM</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize a newly created MEM particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/initparticlelog_dps.html'>initParticleLog_DPS</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize DPS particle log file (e.g. print header)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/initparticlelog_mem.html'>initParticleLog_MEM</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize MEM particle log file (e.g. print header)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inlet_nrbc.html'>inlet_nrbc</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Characteristic-based non-reflective inlet boundary conditions</p><a href="../proc/inlet_nrbc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inlet_nrbc_incomp.html'>inlet_nrbc_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Characteristic-based non-reflective inlet boundary conditions for
incompressible flows</p><a href="../proc/inlet_nrbc_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/inlet_passcal.html'>inlet_pasScal</a></td>
                 <td><a href='../module/mus_bc_passivescalar_module.html'>mus_bc_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet boundary conditions for passive scalar transport (Flekkoy).</p><a href="../proc/inlet_passcal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/interpolate_dump.html'>interpolate_dump</a></td>
                 <td><a href='../module/mus_interpolate_header_module.html'>mus_interpolate_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump interpolation method to logUnit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/interpolatefluidproperties_dps.html'>interpolateFluidProperties_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main control routine which interpolates and stores the fluid properties at
the particle locations</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/interpolatefluidprops.html'>interpolateFluidProps</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate the fluid properties to a point xp</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/interpolatefluidprops_onewaycoupled.html'>interpolateFluidProps_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolate the fluid properties to a point xp</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/interpolatefluidprops_onewaycoupled_old.html'>interpolateFluidProps_onewaycoupled_old</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/intp1d_linear.html'>intp1d_linear</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/intp_1d_delta.html'>intp_1D_delta</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td><p>1D discrete delta interpolation function. Used to interpolate the
fluid property of a lattice cell with barycenter xf to the position
of a particle xp.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/intp_1d_peskin.html'>intp_1D_peskin</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td><p>1D discrete delta interpolation function according to Peskin.
Used to interpolate the
fluid property of a lattice cell with barycenter xf to the position
of a particle xp.
Note that this function has a support of 2*dx so requires both neighbor
and next-neighbor for interpolation</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/islocalcollision.html'>isLocalCollision</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/islocalcollision_dps.html'>isLocalCollision_DPS</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td><p>isLocalCollision checks if collision between two particles is local
This is the case when they are both owned by this process</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/islocalcollision_mem.html'>isLocalCollision_MEM</a></td>
                 <td><a href='../module/mus_particle_interactions_module.html'>mus_particle_interactions_module</a></td>
                 <td>Function</td>
                 <td><p>isLocalCollision checks if collision between two particles is local
This is the case when they are both owned by this process</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kpc_i_bg.html'>kpc_i_bg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Back to central moment
This follows equations 57-59 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kpc_ij_g.html'>kpc_ij_g</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Back to central moment
This follows equations 60-62 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kpc_ijk.html'>kpc_ijk</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Back to central moment
This follows equations 63-65 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kum_abg.html'>kum_abg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment
This follows equations 12-14 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kum_i_bg.html'>kum_i_bg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment
This follows equations 9-11 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/kum_ij_g.html'>kum_ij_g</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment
This follows equations 6-8 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_iterativemethod.html'>load_iterativeMethod</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the iterativeMethod to use in the turbulent wall model from the user
configuration.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_particle_dps_creator_data.html'>load_particle_dps_creator_data</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_particle_dps_data.html'>load_particle_dps_data</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_particle_mem_creator_data.html'>load_particle_mem_creator_data</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_particle_mem_data.html'>load_particle_mem_data</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_relaxation_header.html'>load_relaxation_header</a></td>
                 <td><a href='../module/mus_scheme_header_module.html'>mus_scheme_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load relaxation options from a table</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_turbchanforce.html'>load_turbChanForce</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load shape, bulk velocity and height for turbulent channel force</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/load_wall_function.html'>load_wall_function</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the iterativeMethod to use in the turbulent wall model from the user
configuration.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/logparticledata.html'>logParticleData</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/logparticledata_dps.html'>logParticleData_DPS</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to log DPS particle data</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/logparticledata_mem.html'>logParticleData_MEM</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to log MEM particle data</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/make_pdf_tiny.html'>make_pdf_tiny</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>make_pdf_tiny sets the state vector (particle distribution function) values
to some tiny value. This is done for visualization purposes. It has no effect
on the flow as the particle elements do not participate in the
stream-and-collide process.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/map_to_bin.html'>map_to_bin</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mapparticlestolattice_dps.html'>mapParticlesToLattice_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main control routine which maps each DPS particle to the lattice</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maptolattice.html'>mapToLattice</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>mapToLattice is the high-level routine performs a full re-mapping each time step</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/maptolattice_dps.html'>mapToLattice_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to map particles to the lattice (update coordinate of the origin etc.)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mfr_bounceback.html'>mfr_bounceback</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity Bounce Back boundary condition with mass flow rate as input</p><a href="../proc/mfr_bounceback.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mfr_eq.html'>mfr_eq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity Equilibrium type boundary conditions with mass flow rate
 as input</p><a href="../proc/mfr_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/modify_auxfield_of_elem.html'>modify_AuxField_of_Elem</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Modify the auxField of an element with posInTotal in the total list</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moledens_neumann.html'>moleDens_neumann</a></td>
                 <td><a href='../module/mus_bc_nernstplanck_module.html'>mus_bc_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/moledens_neumann.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moledens_neumann_curved.html'>moleDens_neumann_curved</a></td>
                 <td><a href='../module/mus_bc_nernstplanck_module.html'>mus_bc_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/moledens_neumann_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moledens_noneqexpol.html'>moleDens_nonEqExpol</a></td>
                 <td><a href='../module/mus_bc_nernstplanck_module.html'>mus_bc_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/moledens_noneqexpol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moledens_noneqexpol_curved.html'>moleDens_nonEqExpol_curved</a></td>
                 <td><a href='../module/mus_bc_nernstplanck_module.html'>mus_bc_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/moledens_noneqexpol_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moments_inflow.html'>moments_inflow</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based velocity boundary condition from Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"</p><a href="../proc/moments_inflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moments_outflow.html'>moments_outflow</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based velocity boundary condition from Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"</p><a href="../proc/moments_outflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/moments_wall.html'>moments_wall</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based wall boundary condition from Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"
 Usage</p><a href="../proc/moments_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/momentumfrommacrolse.html'>momentumFromMacroLSE</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>derive untransformed pdf velocity of species by solving system of
equations of nSpecies</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/momentumfrommacrolse_wtdf.html'>momentumFromMacroLSE_WTDF</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Function</td>
                 <td><p>derive untransformed pdf velocity of species by solving system of
equations of nSpecies</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_advrel_d3q19f3_msliquid.html'>mrt_advRel_d3q19f3_MSLiquid</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Optimized Advection relaxation routine for the multispecies mrt model
for d3q19 with 3 species</p><a href="../proc/mrt_advrel_d3q19f3_msliquid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_advrel_d3q19f3_msliquid_wtdf.html'>mrt_advRel_d3q19f3_MSLiquid_WTDF</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Optimized Advection relaxation routine for the multispecies mrt model
for d3q19 with 3 species with thermodynamic factor</p><a href="../proc/mrt_advrel_d3q19f3_msliquid_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_advrel_msliquid_generic.html'>mrt_advRel_MSLiquid_generic</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model</p><a href="../proc/mrt_advrel_msliquid_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_advrel_msliquid_generic_wtdf.html'>mrt_advRel_MSLiquid_generic_WTDF</a></td>
                 <td><a href='../module/mus_msliquid_module.html'>mus_MSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized Advection relaxation routine for the multispecies BGK model
with thermodynamic factors in Maxwell-Stefan formulation</p><a href="../proc/mrt_advrel_msliquid_generic_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_bgk.html'>mrt_bgk</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>set all relaxation parameter to same omega, results in bgk collision</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_d2q9.html'>mrt_d2q9</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns mrt relaxation diagonal matrix for d2q9 layout
Parameters are taken from:
Lallemand, P., &amp; Luo, L. (2000).
Theory of the lattice boltzmann method: dispersion, dissipation,
isotropy, galilean invariance, and stability. Physical Review. E,
Statistical Physics, Plasmas, Fluids, and Related Interdisciplinary
Topics, 61(6 Pt A), 6546–62.</p><a href="../proc/mrt_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_d2q9_incomp.html'>mrt_d2q9_incomp</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns mrt relaxation diagonal matrix for d2q9 layout
Parameters are taken from:
Lallemand, P., &amp; Luo, L. (2000).
Theory of the lattice boltzmann method: dispersion, dissipation,
isotropy, galilean invariance, and stability. Physical Review. E,
Statistical Physics, Plasmas, Fluids, and Related Interdisciplinary
Topics, 61(6 Pt A), 6546–62.</p><a href="../proc/mrt_d2q9_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_d3q15.html'>mrt_d3q15</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns mrt relaxation diagonal matrix for d3q15 layout
Parameters are taken from:
D’Humières, D., Ginzburg, I., Krafczyk, M., Lallemand, P., &amp; Luo, L.-S.
(2002). Multiple-relaxation-time lattice Boltzmann models in three
dimensions. Philosophical Transactions. Series A, Mathematical,
Physical, and Engineering Sciences, 360(1792), 437–51.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_d3q19.html'>mrt_d3q19</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns mrt relaxation diagonal matrix for d3q19 layout
Parameters are taken from:
D’Humières, D., Ginzburg, I., Krafczyk, M., Lallemand, P., &amp; Luo, L.-S.
(2002). Multiple-relaxation-time lattice Boltzmann models in three
dimensions. Philosophical Transactions. Series A, Mathematical,
Physical, and Engineering Sciences, 360(1792), 437–51.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mrt_d3q27.html'>mrt_d3q27</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns mrt relaxation diagonal matrix for d3q27 layout</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_abortcriteria_load.html'>mus_abortCriteria_load</a></td>
                 <td><a href='../module/mus_abortcriteria_module.html'>mus_abortCriteria_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Loading Musubi specific abort criteria from the <code>abort_criteria</code> table.</p><a href="../proc/mus_abortcriteria_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_access_auxfieldvar_forelement.html'>mus_access_auxFieldVar_forElement</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Return the solver aux variable for a given set of elements</p><a href="../proc/mus_access_auxfieldvar_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_access_state_forelement.html'>mus_access_state_forElement</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Return the solver state variable for a given set of elements</p><a href="../proc/mus_access_state_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_access_statefetch_forelement.html'>mus_access_stateFetch_forElement</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Return the solver state variable for a given set of elements by using
FETCH macro for nNext</p><a href="../proc/mus_access_statefetch_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_access_statefetch_now_forelement.html'>mus_access_stateFetch_now_forElement</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Return the solver state variable for a given set of elements by using
FETCH macro for nNow</p><a href="../proc/mus_access_statefetch_now_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_accessvar_setupindices.html'>mus_accessVar_setupIndices</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine takes points coordinates, stores them in the method_data and
return indices where points are located in the growing array of points or
values ( sometimes we do not need to store the points )
It is need to setup points for every variable. Points will be provided by
boundaries or sources depends on what uses the variable. This points do not
change with time . This indices will be stored in corresponding boundary
or source to evaluate a value on that point later using
tem_varSys_proc_getValOfIndex.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_adapt_refine.html'>mus_adapt_refine</a></td>
                 <td><a href='../module/mus_mesh_adaptation_module.html'>mus_mesh_adaptation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Wrap up the routines required for dynamic load balancing</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_add_bcghostelem.html'>mus_add_BcghostElem</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_add_internal_source_var.html'>mus_add_internal_source_var</a></td>
                 <td><a href='../module/mus_source_var_module.html'>mus_source_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine load musubi source terms for given key.
key is glob_source or source</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_adddynsponfldtoauxfield_fluid.html'>mus_addDynSponFldToAuxField_fluid</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add sponge density and velocity field to density and velocity
in auxField. Density and velocity in far field are computed by time
average.</p><a href="../proc/mus_adddynsponfldtoauxfield_fluid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addelectrictoauxfield_msl.html'>mus_addElectricToAuxField_MSL</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add electric force to momentum in auxField for multispecies
liquid model
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addelectrictoauxfield_msl_wtdf.html'>mus_addElectricToAuxField_MSL_WTDF</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add electric force to momentum in auxField for multispecies
liquid model with thermodynamic factor
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addforcetoauxfield_fluid.html'>mus_addForceToAuxField_fluid</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add body force to velocity in auxField for weakly-compressible
model.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addforcetoauxfield_fluid_gns.html'>mus_addForceToAuxField_fluid_GNS</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add body force to velocity in auxField for weakly-compressible
model for the Generalized Navier Stokes equations (GNS) for coupled
LBM-DEM simulations.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addforcetoauxfield_fluidincomp.html'>mus_addForceToAuxField_fluidIncomp</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add force to velocity in auxField for incompressible model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addforcetoauxfield_msl.html'>mus_addForceToAuxField_MSL</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add body force to momentum in auxField for multispecies
liquid model
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addforcetoauxfield_msl_wtdf.html'>mus_addForceToAuxField_MSL_WTDF</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add body force to momentum in auxField for multispecies
liquid model with thermodynamic factor
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addhrrcorrtoauxfield_fluid_2d.html'>mus_addHRRCorrToAuxField_fluid_2D</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add sponge density and velocity field to density and velocity
in auxField. Density and velocity in far field are computed by time
average.</p><a href="../proc/mus_addhrrcorrtoauxfield_fluid_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addhrrcorrtoauxfield_fluid_3d.html'>mus_addHRRCorrToAuxField_fluid_3D</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add sponge density and velocity field to density and velocity
in auxField. Density and velocity in far field are computed by time
average.</p><a href="../proc/mus_addhrrcorrtoauxfield_fluid_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addsponfldtoauxfield_fluid.html'>mus_addSponFldToAuxField_fluid</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add sponge density and velocity field to density and velocity
in auxField for weakly-compressible model.
Reference:
Jacob, J.; Sagaut, P. (2019): Solid wall and open boundary conditions in
hybrid recursive regularized lattice Boltzmann method for compressible
flows. In Physics of Fluids 31 (12), p. 126103.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addsrctoauxfield_dummy.html'>mus_addSrcToAuxField_dummy</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine for add source to auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addsrctoauxfield_poisson.html'>mus_addSrcToAuxField_poisson</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add source term with charge density in the Poisson equation
to the potential.
Refer to Appendix in PhD Thesis of K. Masilamani
"Coupled Simulation Framework to Simulate Electrodialysis Process for
Seawater Desalination"</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_addturbchanforcetoauxfield_fluid.html'>mus_addTurbChanForceToAuxField_fluid</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine add dynamic force to velocity in auxField for
weakly-compressible model for turbulent channel test case.
Force definition:
Force = rho<em>u_tau^2/H + rho</em>(u_bulk_ref-uX_bulk_avg)*u_bulk_ref/H
Reference:
1) https://www.wias-berlin.de/people/john/ELECTRONIC_PAPERS/JR07.IJNMF.pdf
2) Haussmann, Marc; BARRETO, Alejandro CLARO; KOUYI, Gislain LIPEME;
Rivière, Nicolas; Nirschl, Hermann; Krause, Mathias J. (2019):
Large-eddy simulation coupled with wall models for turbulent channel flows
at high Reynolds numbers with a lattice Boltzmann method — Application to
Coriolis mass flowmeter. In Computers &amp; Mathematics with Applications 78
(10), pp. 3285–3302. DOI: 10.1016/j.camwa.2019.04.033.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kcfd_rbgk_vstd_ld3q27.html'>mus_advRel_kCFD_rBGK_vStd_lD3Q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q27 model with BGK with
standard equilibrium function</p><a href="../proc/mus_advrel_kcfd_rbgk_vstd_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kcfd_rbgk_vstdnoopt_l.html'>mus_advRel_kCFD_rBGK_vStdNoOpt_l</a></td>
                 <td><a href='../module/mus_bgk_module.html'>mus_bgk_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the
BGK model with an explicit calculation of all equilibrium
quantities. Slow and simple. This routine should only be
used for testing purposes</p><a href="../proc/mus_advrel_kcfd_rbgk_vstdnoopt_l.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kcfd_rmrt_vstdnoopt_l.html'>mus_advRel_kCFD_rMRT_vStdNoOpt_l</a></td>
                 <td><a href='../module/mus_mrt_d3q19_module.html'>mus_mrt_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized explicit implementation</p><a href="../proc/mus_advrel_kcfd_rmrt_vstdnoopt_l.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kcfd_rmrt_vstdnoopt_ld3q27.html'>mus_advRel_kCFD_rMRT_vStdNoOpt_lD3Q27</a></td>
                 <td><a href='../module/mus_mrt_d3q27_module.html'>mus_mrt_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Unoptimized explicit implementation</p><a href="../proc/mus_advrel_kcfd_rmrt_vstdnoopt_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rbgk_vblock_ld3q19.html'>mus_advRel_kFluid_rBGK_vBlock_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluid_rbgk_vblock_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rbgk_vimproved_ld2q9.html'>mus_advRel_kFluid_rBGK_vImproved_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Improved BGK model (with Galilean correction term)
taken from Martin Geier cumulent paper 2015
Geier, M., Schönherr, M., Pasquali, A., &amp; Krafczyk, M. (2015).
The cumulant lattice Boltzmann equation in three dimensions : Theory and
validation. Computers and Mathematics with Applications.</p><a href="../proc/mus_advrel_kfluid_rbgk_vimproved_ld2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rbgk_vimproved_ld3q27.html'>mus_advRel_kFluid_rBGK_vImproved_lD3Q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Improved BGK model (with Galilean correction term)
taken from Martin Geier cumulent paper 2015
Geier, M., Schönherr, M., Pasquali, A., &amp; Krafczyk, M. (2015).
The cumulant lattice Boltzmann equation in three dimensions : Theory and
validation. Computers and Mathematics with Applications.</p><a href="../proc/mus_advrel_kfluid_rbgk_vimproved_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rbgk_vstd_ld2q9.html'>mus_advRel_kFluid_rBGK_vStd_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluid_rbgk_vstd_ld2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rbgk_vstd_ld3q19.html'>mus_advRel_kFluid_rBGK_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with BGK.</p><a href="../proc/mus_advrel_kfluid_rbgk_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rmrt_vstd_ld2q9.html'>mus_advRel_kFluid_rMRT_vStd_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D2Q9 MRT model
f( x+c, t+1 ) = f(x,t) - M^(-1)S( m - meq )</p><a href="../proc/mus_advrel_kfluid_rmrt_vstd_ld2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rmrt_vstd_ld3q19.html'>mus_advRel_kFluid_rMRT_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_mrt_d3q19_module.html'>mus_mrt_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the MRT model.
This routine has roughly 260 FLOPS per elements.</p><a href="../proc/mus_advrel_kfluid_rmrt_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rmrt_vstd_ld3q27.html'>mus_advRel_kFluid_rMRT_vStd_lD3Q27</a></td>
                 <td><a href='../module/mus_mrt_d3q27_module.html'>mus_mrt_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Semi-optimized explicit implementation</p><a href="../proc/mus_advrel_kfluid_rmrt_vstd_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rmrt_vstdnoopt_ld3q19.html'>mus_advRel_kFluid_rMRT_vStdNoOpt_lD3Q19</a></td>
                 <td><a href='../module/mus_mrt_d3q19_module.html'>mus_mrt_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluid_rmrt_vstdnoopt_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rtrt_vstd_ld3q19.html'>mus_advRel_kFluid_rTRT_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with TRT collision
operator
In TRT, there are two relaxation parameters one can choose.
They have a relationship, which is so-called magic number:
Lambda = ( 1/omegaP - 1/2 ) * ( 1/omegaN - 1/2 )
Different value of Lambda results different error:
Lambda = 1/4 is the best stability for the LBE. As well, this number gives
the solution for the steady-state case dependant only on the equilibirium
funciton.
Lambda = 1/12 removes the third-order advection error
Lambda = 1/6 removes fourth-order diffusion errors
Lambda = 3/16 gives exact location of bounce-back walls for the Poiseuille
flow.
omegaP is usually fixed by viscosity, another one is fixed through the
above magic number combination.</p><a href="../proc/mus_advrel_kfluid_rtrt_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluid_rtrt_vstd_ld3q27.html'>mus_advRel_kFluid_rTRT_vStd_lD3Q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluid_rtrt_vstd_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidgns_rbgk_vstd_ld2q9.html'>mus_advRel_kFluidGNS_rBGK_vStd_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BGK relaxation routine using equilibrium distribution for simulating the
Generalized Navier Stokes (GNS) aka Volume-Averaged Navier-Stokes (VANS)
equations for coupled LBM-DEM simulations
This subroutine interface must match the abstract interface definition
<a href="../interface/kernel.html">kernel</a> in scheme/<a href="../module/mus_scheme_type_module.html">mus_scheme_type_module</a>.f90 in order to be callable
via <a href="../type/mus_scheme_type.html#variable-compute">compute</a> function pointer.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rbgk_vstd_ld2q9.html'>mus_advRel_kFluidIncomp_rBGK_vStd_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluidincomp_rbgk_vstd_ld2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rbgk_vstd_ld3q19.html'>mus_advRel_kFluidIncomp_rBGK_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with BGK for
incompressible lbm model</p><a href="../proc/mus_advrel_kfluidincomp_rbgk_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld2q9.html'>mus_advRel_kFluidIncomp_rMRT_vStd_lD2Q9</a></td>
                 <td><a href='../module/mus_d2q9_module.html'>mus_d2q9_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D2Q9 MRT model
f( x+c, t+1 ) = f(x,t) - M^(-1)S( m - meq )</p><a href="../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld3q19.html'>mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_mrt_d3q19_module.html'>mus_mrt_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the MRT model.
This routine has roughly 205 FLOPS per element.</p><a href="../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld3q27.html'>mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q27</a></td>
                 <td><a href='../module/mus_mrt_d3q27_module.html'>mus_mrt_d3q27_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Semi-optimized explicit implementation</p><a href="../proc/mus_advrel_kfluidincomp_rmrt_vstd_ld3q27.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rmrt_vstdnoopt_ld3q19.html'>mus_advRel_kFluidIncomp_rMRT_vStdNoOpt_lD3Q19</a></td>
                 <td><a href='../module/mus_mrt_d3q19_module.html'>mus_mrt_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/mus_advrel_kfluidincomp_rmrt_vstdnoopt_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincomp_rtrt_vstd_ld3q19.html'>mus_advRel_kFluidIncomp_rTRT_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with TRT collision
operator.</p><a href="../proc/mus_advrel_kfluidincomp_rtrt_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kfluidincompgns_rbgk_vstd_ld3q19.html'>mus_advRel_kFluidIncompGNS_rBGK_vStd_lD3Q19</a></td>
                 <td><a href='../module/mus_d3q19_module.html'>mus_d3q19_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the D3Q19 model with BGK based on the !!
equilibrium distribution function for the generalized Navier Stokes equations
(GNS) aka Volume Averaged Navier-Stokes !! equations (VANS).
feq definition from: Z. Guo and T. S. Zhao, “Lattice Boltzmann model for
incompressible flows through porous media,” Phys. Rev. E, vol. 66, no. 3, p.
036304, Sep. 2002, doi: 10.1103/PhysRevE.66.036304.
Incompressible version</p><a href="../proc/mus_advrel_kfluidincompgns_rbgk_vstd_ld3q19.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kps_rbgk_v1st_l.html'>mus_advRel_kPS_rBGK_v1st_l</a></td>
                 <td><a href='../module/mus_compute_passivescalar_module.html'>mus_compute_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the flekkoy diffusion model.</p><a href="../proc/mus_advrel_kps_rbgk_v1st_l.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kps_rbgk_v2nd_l.html'>mus_advRel_kPS_rBGK_v2nd_l</a></td>
                 <td><a href='../module/mus_compute_passivescalar_module.html'>mus_compute_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the 2nd order diffusion model.
A comparison to the previous flekkoy model can be found in
Chopard, B., Falcone, J. &amp; Latt, J. "The lattice Boltzmann advection
-diffusion model revisited." Eur. Phys. J. Spec. Top. 171, 245–249 (2009).
https://doi.org/10.1140/epjst/e2009-01035-5</p><a href="../proc/mus_advrel_kps_rbgk_v2nd_l.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_advrel_kps_rtrt_vstdnoopt_l.html'>mus_advRel_kPS_rTRT_vStdNoOpt_l</a></td>
                 <td><a href='../module/mus_compute_passivescalar_module.html'>mus_compute_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the TRT diffusion model.</p><a href="../proc/mus_advrel_kps_rtrt_vstdnoopt_l.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_alloc_bouzidi.html'>mus_alloc_bouzidi</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_alloc_fieldbc.html'>mus_alloc_fieldBC</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_auxfield.html'>mus_append_auxField</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append auxiliary variables which are computed from state and stored
in auxField array using calcAuxField function</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_bcvar.html'>mus_append_bcVar</a></td>
                 <td><a href='../module/mus_bc_var_module.html'>mus_bc_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine adds boundary variables for tracking</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_derliquidmixvar.html'>mus_append_derLiquidMixVar</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append mixture variables for multicomponent liquid models</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dermixvar_ms.html'>mus_append_derMixVar_MS</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append mixture variables for multicomponent models</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_fluid.html'>mus_append_derVar_fluid</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for weakly compressible LBM
(schemekind = 'fluid') to the varsys.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_fluidincomp.html'>mus_append_derVar_fluidIncomp</a></td>
                 <td><a href='../module/mus_derquanincomp_module.html'>mus_derQuanIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for incompressible LBM
(schemekind = 'fluid_incompressible') to the varsys.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_isotherm_aceq.html'>mus_append_derVar_isotherm_acEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for isothermal acoustic
equations
(schemekind = 'isotherm_acEq') to the varsys.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_lbmps.html'>mus_append_derVar_lbmPS</a></td>
                 <td><a href='../module/mus_derquanps_module.html'>mus_derQuanPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for weakly compressible LBM
(schemekind = 'passive_scalar') to the varsys.
for passive scalar contains only one derive variable:
density</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_msgas.html'>mus_append_derVar_MSGas</a></td>
                 <td><a href='../module/mus_derquanmsgas_module.html'>mus_derQuanMSGas_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for multispecies-liquid
(schemekind = 'multispecies_gas') to the varsys.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_msliquid.html'>mus_append_derVar_MSLiquid</a></td>
                 <td><a href='../module/mus_derquanmsliquid_module.html'>mus_derQuanMSLiquid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for multispecies-liquid
(schemekind = 'multispecies_liquid') to the varsys.</p><a href="../proc/mus_append_dervar_msliquid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_physics.html'>mus_append_derVar_physics</a></td>
                 <td><a href='../module/mus_derquanphysics_module.html'>mus_derQuanPhysics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for weakly compressible LBM
(schemekind = 'lbm') to the varsys.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_dervar_poisson.html'>mus_append_derVar_poisson</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add derive variables for weakly compressible PB
(schemekind = 'poisson') to the varsys.
A Coupled Lattice Boltzmann Method to Solve Nernst-Planck Model
for Simulating Electro-Osmotic flows
author&gt; Xuguang yang</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_materialvar.html'>mus_append_materialVar</a></td>
                 <td><a href='../module/mus_material_var_module.html'>mus_material_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add material variable</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_readvarasstatevar.html'>mus_append_readVarAsStateVar</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append variable read from restart file as state variables</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_sourcevar.html'>mus_append_sourceVar</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Build a variable system of all possible source terms for the given
schemeKind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_statevar.html'>mus_append_stateVar</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Append state variable depends on the scheme kind</p><a href="../proc/mus_append_statevar.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_append_turbvar.html'>mus_append_turbVar</a></td>
                 <td><a href='../module/mus_turbulence_var_module.html'>mus_turbulence_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to add variables for turbulence model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_apply_sourceterms.html'>mus_apply_sourceTerms</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply all source terms i.e field specific source and global source on
all fields.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_applyforce_x.html'>mus_applyForce_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine applies the force calculated to the eulerian elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_applysrc_dummy.html'>mus_applySrc_dummy</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine for apply source</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_calcauxfield_ptr.html'>mus_assign_calcAuxField_ptr</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assign function pointer to compute auxField var</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_derived_functions_ptr.html'>mus_assign_derived_functions_ptr</a></td>
                 <td><a href='../module/mus_scheme_derived_quantities_module.html'>mus_scheme_derived_quantities_module</a></td>
                 <td>Function</td>
                 <td><p>This function assigns the pointers for the respective derived function in</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_gradcalculation_ptr.html'>mus_assign_GradCalculation_ptr</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns function pointer of nonEquilibrium scaling
for interpolation according to scheme definition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_mrt_ptr.html'>mus_assign_mrt_ptr</a></td>
                 <td><a href='../module/mus_mrtrelaxation_module.html'>mus_mrtRelaxation_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This function returns mrt function pointer according to scheme definition.
In Jonas Toelke paper (2006) about MRT, the following notions are used:\n
 s(a) = s(2)
 s(b) = s(3)
 s(c) = s(5) = s(7) = s(9)
 s(d) = s(11) = s(13
 s(e) = s(17) = s(18) = s(19)
 s(w) = s(10) = s(12) = s(14) = s(15) = s(16)
It is suggested that, for D3Q19,
 s(a) = s(b) = s(c) = s(d) = s(e) = max( s(w), -1.0 )
Notice that the collision matrix S used in this papar corresponds to
-omega in BGK model, because it express the LB equation is slightly
different way.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_nnwtnvisc_ptr.html'>mus_assign_nNwtnVisc_ptr</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns function pointer to compute non-Newtonian viscosity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_assign_turbvisc_ptr.html'>mus_assign_turbVisc_ptr</a></td>
                 <td><a href='../module/mus_turb_viscosity_module.html'>mus_turb_viscosity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns function pointer to compute turbulence viscosity
based on turbulence model and scheme header definition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_auxfieldvar_forpoint.html'>mus_auxFieldVar_forPoint</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Auxilary field variable for a given set of points using linear
interpolation. Unlike mus_deriveVar_forPoint which does not consider
ghost and halo elements, this routine considers them because
auxField vars on ghost elements are interpolated and halo elements are
exchanged.
The interface has to comply to the abstract interface
<a href="https://apes-suite.github.io/treelm/interface/tem_varsys_proc_point.html">tem_varSys_proc_point</a>.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_auxfieldvar_fromindex.html'>mus_auxFieldVar_fromIndex</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to get the actual value for a given array of indices.
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_balance.html'>mus_balance</a></td>
                 <td><a href='../module/mus_dynloadbal_module.html'>mus_dynLoadBal_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine performs the load balancing for multilevel simulations. The
weights are calculated on the basis of levelwise run time, which are then
fed to sparta for calculation of splitting positions. Restart files are
saved and the simulation is restarted with the newly distributed mesh</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_banner.html'>mus_banner</a></td>
                 <td><a href='../module/mus_aux_module.html'>mus_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize musubi solverHead and print musubi banner to screen</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_bc_timing.html'>mus_BC_timing</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Output the min and max time across all ranks,
which are spent on each boundary condition.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_build_bcstencils.html'>mus_build_BCStencils</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>subroutine to find neighbours of element with individual (for each element)
stencil definitions.
Unique stencil label for boundary stencils are created with boundary label
and stencil%cxDir therefore each stencil is limited to one boundary type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_build_ibmstencils.html'>mus_build_IBMStencils</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine build and append IBM stencils to scheme stencil array</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_build_minbcid.html'>mus_build_minBcID</a></td>
                 <td><a href='../module/mus_geom_module.html'>mus_geom_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine build minBcID for boundary elements, it is required if a
element has more than one boundary in its directions.
if a element has more than one boundary then use minBcID which depends
on boundary order in seeder configuration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_build_posinprop.html'>mus_build_posInProp</a></td>
                 <td><a href='../module/mus_geom_module.html'>mus_geom_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine builds mapping between elements in tree to to propery list</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_build_varsys.html'>mus_build_varSys</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Build global variable system for Musubi</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_buildbuffibm.html'>mus_buildBuffIBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_commamount.html'>mus_calc_commAmount</a></td>
                 <td><a href='../module/mus_statistics_module.html'>mus_statistics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the number of links to be communicated</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mus_calc_ms_diffmatrix.html'>mus_calc_MS_DiffMatrix</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mus_calc_ms_diffmatrix~2.html'>mus_calc_MS_DiffMatrix</a></td>
                 <td><a href='../module/mus_enrtl_module~2.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_ms_diffmatrix_single.html'>mus_calc_MS_DiffMatrix_single</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine calculates Diffusivity coefficients matrix for given mole_frac
of all species for single element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_ms_diffmatrix_single~2.html'>mus_calc_MS_DiffMatrix_single</a></td>
                 <td><a href='../module/mus_enrtl_module~2.html'>mus_eNRTL_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine which sets diffusivity coeff matrix to diagonal matrix</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_nelems.html'>mus_calc_nElems</a></td>
                 <td><a href='../module/mus_pdf_module.html'>mus_pdf_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute nElems for different types</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mus_calc_thermfactor.html'>mus_calc_thermFactor</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mus_calc_thermfactor~2.html'>mus_calc_thermFactor</a></td>
                 <td><a href='../module/mus_enrtl_module~2.html'>mus_eNRTL_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_thermfactor_single.html'>mus_calc_thermFactor_single</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine calculates thermodynamic factor for given mole_frac
of all species for single element</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calc_thermfactor_single~2.html'>mus_calc_thermFactor_single</a></td>
                 <td><a href='../module/mus_enrtl_module~2.html'>mus_eNRTL_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine which sets thermodynamic factor matrix to diagonal matrix</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_dummy.html'>mus_calcAuxField_dummy</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine for calcAuxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_fluid.html'>mus_calcAuxField_fluid</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxFields density and velocity for compressible model
for fluid and nGhostFromCoarser elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_fluid_d2q9.html'>mus_calcAuxField_fluid_d2q9</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxFields density and velocity for compressible
d2q9 model for fluid and nGhostFromCoarser elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_fluid_d3q19.html'>mus_calcAuxField_fluid_d3q19</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxFields density and velocity for compressible
d3q19 model for fluid and nGhostFromCoarser elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_fluid_d3q27.html'>mus_calcAuxField_fluid_d3q27</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxFields density and velocity for compressible
d3q27 model for fluid and nGhostFromCoarser elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_ms.html'>mus_calcAuxField_MS</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxField density and momentum for each species
for multicomponent models. The momentum computed here is only momentum
of transformed PDF. The momentum of original PDF is computed by solving
linear equation system in compute kernel and the momentum in auxField is
updated there.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_nernst_planck.html'>mus_calcAuxField_nernst_planck</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute zeroth moment (mole density) from state for each
species and store in auxField.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfield_zerothmoment.html'>mus_calcAuxField_zerothMoment</a></td>
                 <td><a href='../module/mus_auxfieldvar_module.html'>mus_auxFieldVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute zeroth moment from state and store in auxField.
use this routine only for models which requires only zeroth-order
moment as auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcauxfieldandexchange.html'>mus_calcAuxFieldAndExchange</a></td>
                 <td><a href='../module/mus_auxfield_module.html'>mus_auxField_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute auxField variable from pre-collision pdf and exchange
halos</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcbndforce.html'>mus_calcBndForce</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes force on boundary elements which are used to
compute lift and drag coefficient on boundary</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcbndforce_dummy.html'>mus_calcBndForce_dummy</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine for calcBndForce</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcbndforce_turbwall.html'>mus_calcBndForce_turbWall</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine access bndForce from turbulent wall function boundary elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcbndforce_wall.html'>mus_calcBndForce_wall</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes bndForce on wall boundary elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcbndforce_wall_libb.html'>mus_calcBndForce_wall_libb</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes bndForce on wall_libb boundary elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcforce_x.html'>mus_calcForce_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine fills the force array for the X (neighbors).
(Inamuro paper: step 1, fill g_l(X))</p><a href="../proc/mus_calcforce_x.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calcomegafromvisc.html'>mus_calcOmegaFromVisc</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Function</td>
                 <td><p>This function compute relaxation paramter omega from viscosity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_calculate_speed_of_sound.html'>mus_calculate_speed_of_sound</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Function</td>
                 <td><p>Calculate lattice speed of sound for given stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_check_allwall.html'>mus_check_allWall</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Function</td>
                 <td><p>Check if a BC is wall or symmetry for all fields</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_check_omegakine.html'>mus_check_omegaKine</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine checks whether omega is within the stability limit.
If not it will terminate the simulation with error message.
Using limits given in
Tölke, J., Freudiger, S., &amp; Krafczyk, M. (2006). An adaptive scheme using
hierarchical grids for lattice Boltzmann multi-phase flow simulations.
Computers &amp; Fluids, 35(8–9), 820–830.
For BGK: 2/3 &lt; omega &lt; 1.976
For MRT: 2/3 &lt; omega &lt; 1.999</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_construct.html'>mus_construct</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize Musubi data strucutres based on data provided by Treelm</p><a href="../proc/mus_construct.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_construct_connectivity.html'>mus_construct_connectivity</a></td>
                 <td><a href='../module/mus_connectivity_module.html'>mus_connectivity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Construct the propagation list for each element of 1st field.</p><a href="../proc/mus_construct_connectivity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_corrforce_xk.html'>mus_corrForce_Xk</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_corrvel_x.html'>mus_corrVel_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine corrects the velocity values according to the force on X
(neighbors).
(Inamuro paper: step 2, correct u_l(X))</p><a href="../proc/mus_corrvel_x.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_create_funcstr.html'>mus_create_funcStr</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine creates musubi specific lua function to compute dx and dt.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_create_poss_srcvar.html'>mus_create_poss_srcVar</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine initialize possible source variable depends on scheme kind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_create_poss_transvar.html'>mus_create_poss_transVar</a></td>
                 <td><a href='../module/mus_transport_var_module.html'>mus_transport_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine initialize possible transport variable depends on scheme kind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_createsrcelemintreeforgetpoint.html'>mus_createSrcElemInTreeForGetPoint</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine creates srcElemInTree in pointData. It is called all in
getPoint routine when first time the get point routine in called.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d1q3.html'>mus_define_d1q3</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d2q9 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d2q5.html'>mus_define_d2q5</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d2q5 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d2q9.html'>mus_define_d2q9</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d2q9 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d3q13.html'>mus_define_d3q13</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d3q13 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d3q19.html'>mus_define_d3q19</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d3q19 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d3q27.html'>mus_define_d3q27</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d3q27 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d3q6.html'>mus_define_d3q6</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d3q6
layout%fStencil, used by the Flekkoy model of passive scalar transport.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_d3q7.html'>mus_define_d3q7</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the parameters for the predefined d3q7 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_define_layout.html'>mus_define_layout</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine defines layout for predefined stencils</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derequilisothermaceq.html'>mus_derEquilIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the equlibrium of given elements with the given input state
array.</p><a href="../proc/mus_derequilisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derive_frommacro_dummy.html'>mus_derive_FromMacro_dummy</a></td>
                 <td><a href='../module/mus_dervarpos_module.html'>mus_derVarPos_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derive_fromprecolstate_dummy.html'>mus_derive_FromPreColState_dummy</a></td>
                 <td><a href='../module/mus_dervarpos_module.html'>mus_derVarPos_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derive_fromstate_dummy.html'>mus_derive_FromState_dummy</a></td>
                 <td><a href='../module/mus_dervarpos_module.html'>mus_derVarPos_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivedensity.html'>mus_derivedensity</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the density of a given set of elements (sum up all links).
This routine is used to compute density for all scheme kinds
For multispecies, it can compute both species density and mixture density</p><a href="../proc/mus_derivedensity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_deriveelectricfield.html'>mus_deriveElectricField</a></td>
                 <td><a href='../module/mus_derquanpoisson_module.html'>mus_derQuanPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the electric_field of a given pre-collision pdfs
i.e fetch_pdf_now</p><a href="../proc/mus_deriveelectricfield.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_deriveequil.html'>mus_deriveEquil</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the equlibrium of given elements with the given input state
array.</p><a href="../proc/mus_deriveequil.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivemoledensity.html'>mus_deriveMoleDensity</a></td>
                 <td><a href='../module/mus_derquannernstplanck_module.html'>mus_derQuanNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the potential of a given set of pdfs of elements</p><a href="../proc/mus_derivemoledensity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivemoment.html'>mus_deriveMoment</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>For 2D only!</p><a href="../proc/mus_derivemoment.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivenonequil.html'>mus_deriveNonEquil</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the Non-Equlibrium</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivestrainrate.html'>mus_deriveStrainRate</a></td>
                 <td><a href='../module/mus_derquan_module.html'>mus_derQuan_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the strain rate ( or rate of strain, or rate of deformation)</p><a href="../proc/mus_derivestrainrate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_derivevar_forpoint.html'>mus_deriveVar_forPoint</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Derive variable for a given set of points using linear interpolation.
This is a generic routine for any variable.
Limitation: If neighbor is halo element then its not considered for
interpolation, only the fluid (non-ghost) elements in the local process
are used for interpolation.</p><a href="../proc/mus_derivevar_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dervar_intponpoint.html'>mus_derVar_intpOnPoint</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dervelocityisothermaceq.html'>mus_derVelocityIsothermAcEq</a></td>
                 <td><a href='../module/mus_derquanisothermaceq_module.html'>mus_derQuanIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate the velocity of a given element number with the given input
vector (sum up all values)</p><a href="../proc/mus_dervelocityisothermaceq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_destroy_stencil.html'>mus_destroy_stencil</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Destroy the stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dump_leveldescintp_nelems.html'>mus_dump_levelDescIntp_nElems</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine dumps global nElems in intpFromCoarser, intpFromFiner,
sourcesFromCoarser ans sourcesFromFiner</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dump_moments.html'>mus_dump_moments</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump moments matrix: toPDF and toMoment</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dumpdata.html'>mus_dumpData</a></td>
                 <td><a href='../module/mus_aux_module.html'>mus_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine dumps tracking and restart when timeControl is active</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_dumpweights.html'>mus_dumpWeights</a></td>
                 <td><a href='../module/mus_weights_module.html'>mus_weights_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump weights to a file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_field_cleanup.html'>mus_field_cleanup</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines act as a destructor for field type.
Only allocatable arrays which are allocated in mus_construct routine
are deallocated.
KM: DO NOT DESTROY FIELD ARRAY AS IT CONTAINS ALL CONFIG INFO</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_field_getsymmetricbcs.html'>mus_field_getSymmetricBCs</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine checks for the existence of symmetric boundaries and
returns the boundary IDs which are defined as symmetry</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_field_out_scal.html'>mus_field_out_scal</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write single field into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_field_prop_out.html'>mus_field_prop_out</a></td>
                 <td><a href='../module/mus_field_prop_module.html'>mus_field_prop_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write field prop into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fieldbc_cleanup.html'>mus_fieldBC_cleanup</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines deallocates allocatables in field%bc boundary_type for
dynamic load balancing</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/mus_fields_out.html'>mus_fields_out</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Interface</td>
                 <td><p>Interface for dumping a single field or a set of fields in a file in lua
format.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fields_out_vec.html'>mus_fields_out_vec</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write array of fields into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fillneigh_surfdata.html'>mus_fillNeigh_surfData</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine builds the neighbor lists for Xk -&gt; x (neigh_Xk) and
x-&gt;Xk (neigh_x) as well as the send and receive buffers for the eulerian
elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_finalize.html'>mus_finalize</a></td>
                 <td><a href='../module/mus_program_module.html'>mus_program_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Do final check on check on total density,
Close auxiliary stuff such as restart and the tracker,
finalize treelm, dump timing and finialize mpi with fin_env</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_finalize_layout.html'>mus_finalize_layout</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine finialize grwStencil by truncating stencil elem arrays and
set stencil%nElems</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_finalize_particlegroup.html'>mus_finalize_particleGroup</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_finishibm.html'>mus_finishIBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine dumps the timings%timedat to disc</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fluid_cleanup.html'>mus_fluid_cleanup</a></td>
                 <td><a href='../module/mus_fluid_module.html'>mus_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines act as a destructor for fluid type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fluid_dump.html'>mus_fluid_dump</a></td>
                 <td><a href='../module/mus_fluid_module.html'>mus_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_fluid_save2lua.html'>mus_fluid_save2lua</a></td>
                 <td><a href='../module/mus_fluid_module.html'>mus_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write fluid prop into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_free_ibmdata.html'>mus_free_IBMData</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine frees all temporary variables and destroys growing arrays
as well as the communicators.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_generic_frompdf_forelement.html'>mus_generic_fromPDF_forElement</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine prepares the data for variable derivation or operators. It
gathers all input variables from the variable system, calls the function
with the actual calculation.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_generic_varfrompdf_fromindex.html'>mus_generic_varFromPDF_fromIndex</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to get the actual value for a given array of indices for
musubi derive variables
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_geomincr.html'>mus_geomIncr</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine checks for various conditions defined in the geomIncr table
within the lua file, calculates the requested macroscpoic variables and
then compares them against the specified threshold.
Accordingly then solidification or fluidification of elements is performed.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_geomincrhead_load.html'>mus_geomIncrHead_load</a></td>
                 <td><a href='../module/mus_geomincrhead_module.html'>mus_geomIncrHead_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read all the necessary information for the geometry increase from the lua
 config file. This routine basically provides as a wrapper to the routine
 which reads single values</p><a href="../proc/mus_geomincrhead_load.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_geomincrhead_load_single.html'>mus_geomIncrHead_load_single</a></td>
                 <td><a href='../module/mus_geomincrhead_module.html'>mus_geomIncrHead_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Reads various parameters from the lua file defined for geometry increase
This routine reads single values and is wrapped around in another function
where it is called multiple times as required</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_get_new_solver_ptr.html'>mus_get_new_solver_ptr</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Function</td>
                 <td><p>Routine to get a pointer to a new instance of mus_varSys_solverData_type
 to be used as method data for a variable in the variable system.</p><a href="../proc/mus_get_new_solver_ptr.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_get_points_frombc.html'>mus_get_points_fromBC</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get Surface points on boundary elements.
For boundary state variable which are evaluated linkwise, extract surface
points for each link and for non-link based variables project barycenter
on the boundary surface.
Return real coordinates on boundary surface and offset bit which encodes
direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_get_timerhandles.html'>mus_get_timerHandles</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns musubi modular variable mus_timerHandles to apesmate
and deallocate mus_timerHandles level timers.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_getweights.html'>mus_getWeights</a></td>
                 <td><a href='../module/mus_weights_module.html'>mus_weights_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate weights using timing from compute kernel, interpolation and
 boundary routines</p><a href="../proc/mus_getweights.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_hvs_config_load.html'>mus_hvs_config_load</a></td>
                 <td><a href='../module/mus_hvs_config_module.html'>mus_hvs_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in LUA parameter file
See http://www.lua.org for a reference on how to use
Lua is a scripting language in itself which allows
more complex parameter files including comments
And load / create the mesh depending on the configuration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_hvs_construct.html'>mus_hvs_construct</a></td>
                 <td><a href='../module/mus_hvs_construction_module.html'>mus_hvs_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize Musubi data strucutres based on data provided by Treelm</p><a href="../proc/mus_hvs_construct.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_hvs_init_aux.html'>mus_hvs_init_aux</a></td>
                 <td><a href='../module/mus_hvs_aux_module.html'>mus_hvs_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init auxiliary features such as interpolation boundaries, restart and
the tracker</p><a href="../proc/mus_hvs_init_aux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_hvs_load_solverdata.html'>mus_hvs_load_solverData</a></td>
                 <td><a href='../module/mus_hvs_config_module.html'>mus_hvs_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines load solver data from config file except tracking</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_buildsendrecv_xk.html'>mus_IBM_buildSendRecv_Xk</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine builds the communication types for the lagrangian elements
Xk.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_commnewpos.html'>mus_IBM_commNewPos</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine communicates all elements which just moved from the fluids
to the halo elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_fillrecvpos_x.html'>mus_IBM_fillRecvPos_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_fillsendpos_x.html'>mus_IBM_fillSendPos_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_getsurfvel.html'>mus_IBM_getSurfVel</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine calculates the surface velocity for all local xk.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_preparesendrecv_x.html'>mus_IBM_prepareSendRecv_X</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine prepares the send and receive buffers for the eulerian
elements by copying information from the send and receive buffers for the
lagrangian elements.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibm_setparentids.html'>mus_IBM_setParentIDs</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine sets the positions of the parent IDs in the level
descriptor.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_ibmfinishbuff.html'>mus_IBMFinishBuff</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine finishes the buffers for Xk and X_pdf. This is moved to
a seperate routine since both buffers depend on a local communication
which should be done nearby the global synchronization point (mus_exchange)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_imomvector.html'>mus_iMomVector</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Function</td>
                 <td><p>The integer moment vector for a given cxDir and order.</p><a href="../proc/mus_imomvector.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_inamuro_ibm.html'>mus_inamuro_IBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine modifies the state vector according to the method described
in the paper \a Lift generation by a two-dimensional symmetric flapping
wing: immersed boundary-lattice Boltzmann simulations \a by Inamuro et al.
@cite Ota:2012bx .</p><a href="../proc/mus_inamuro_ibm.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_inamuroini.html'>mus_inamuroIni</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine fills the initial force, initial velocity, predef. velocity
array for the surface points Xk as well as the velocity array for the
neighbors.</p><a href="../proc/mus_inamuroini.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_absorblayer.html'>mus_init_absorbLayer</a></td>
                 <td><a href='../module/mus_absorblayer_module.html'>mus_absorbLayer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize arrays to store time average density and velocity for
dynamic absorbing layer.
\todo KM: 20210301 Allocate only pressure or velocity depending on
absorb_layer_inlet or absorb_layer_outlet</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluid.html'>mus_init_advRel_fluid</a></td>
                 <td><a href='../module/mus_initfluid_module.html'>mus_initFluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assigning compute kernel routine by scheme relaxation type for fluid kind.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluid_bgk.html'>mus_init_advRel_fluid_bgk</a></td>
                 <td><a href='../module/mus_initfluid_module.html'>mus_initFluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns compute routine for bgk relaxation.</p><a href="../proc/mus_init_advrel_fluid_bgk.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluid_gns.html'>mus_init_advRel_fluid_GNS</a></td>
                 <td><a href='../module/mus_initfluid_module.html'>mus_initFluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assigning compute kernel routine by scheme relaxation type for fluid GNS kind.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluid_mrt.html'>mus_init_advRel_fluid_mrt</a></td>
                 <td><a href='../module/mus_initfluid_module.html'>mus_initFluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns compute routine for mrt relaxation</p><a href="../proc/mus_init_advrel_fluid_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluid_trt.html'>mus_init_advRel_fluid_trt</a></td>
                 <td><a href='../module/mus_initfluid_module.html'>mus_initFluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns compute routine for trt relaxation</p><a href="../proc/mus_init_advrel_fluid_trt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluidincomp.html'>mus_init_advRel_fluidIncomp</a></td>
                 <td><a href='../module/mus_initfluidincomp_module.html'>mus_initFluidIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm incompressible model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluidincomp_bgk.html'>mus_init_advRel_fluidIncomp_bgk</a></td>
                 <td><a href='../module/mus_initfluidincomp_module.html'>mus_initFluidIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns compute routine for bgk relaxation</p><a href="../proc/mus_init_advrel_fluidincomp_bgk.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluidincomp_gns.html'>mus_init_advRel_fluidIncomp_GNS</a></td>
                 <td><a href='../module/mus_initfluidincomp_module.html'>mus_initFluidIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assigning compute kernel routine by scheme relaxation type for fluid GNS 
kind for unresolved LBM-DEM particulate flow simulations</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_fluidincomp_mrt.html'>mus_init_advRel_fluidIncomp_mrt</a></td>
                 <td><a href='../module/mus_initfluidincomp_module.html'>mus_initFluidIncomp_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine assigns compute routine for mrt relaxation</p><a href="../proc/mus_init_advrel_fluidincomp_mrt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_isotherm_aceq.html'>mus_init_advRel_isotherm_acEq</a></td>
                 <td><a href='../module/mus_initisothermaceq_module.html'>mus_initIsothermAcEq_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Assigning compute kernel routine by scheme relaxation type for
isotherm_acEq kind.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_lbm_ps.html'>mus_init_advRel_lbm_ps</a></td>
                 <td><a href='../module/mus_initlbmps_module.html'>mus_initLBMPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm passive scalar scheme kind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_multispecies_gas.html'>mus_init_advRel_multispecies_gas</a></td>
                 <td><a href='../module/mus_initmultispecies_module.html'>mus_initMultispecies_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for multispecies gas model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_multispecies_liquid.html'>mus_init_advRel_multispecies_liquid</a></td>
                 <td><a href='../module/mus_initmultispecies_module.html'>mus_initMultispecies_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for multispecies liquid model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_nernstplanck.html'>mus_init_advRel_nernstPlanck</a></td>
                 <td><a href='../module/mus_initnernstplanck_module.html'>mus_initNernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm poisson equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_pblinear.html'>mus_init_advRel_PBLinear</a></td>
                 <td><a href='../module/mus_initpoisson_module.html'>mus_initPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm poisson equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_pbnonlinear.html'>mus_init_advRel_PBnonLinear</a></td>
                 <td><a href='../module/mus_initpoisson_module.html'>mus_initPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm poisson equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_advrel_poisson.html'>mus_init_advRel_Poisson</a></td>
                 <td><a href='../module/mus_initpoisson_module.html'>mus_initPoisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the relaxation model for lbm poisson equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_aux.html'>mus_init_aux</a></td>
                 <td><a href='../module/mus_aux_module.html'>mus_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Init auxiliary features such as interpolation boundaries, restart and
the tracker</p><a href="../proc/mus_init_aux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_auxfieldarrays.html'>mus_init_auxFieldArrays</a></td>
                 <td><a href='../module/mus_auxfield_module.html'>mus_auxField_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize auxField var val array and communication buffers</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_bc_elems.html'>mus_init_bc_elems</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_bctimer.html'>mus_init_bcTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_bndforce.html'>mus_init_bndForce</a></td>
                 <td><a href='../module/mus_bndforce_module.html'>mus_bndForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize bndForce array assign function pointer to
calculate bndForce</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_boundary.html'>mus_init_boundary</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Check prerequisite for multi-species boundary conditions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_byic.html'>mus_init_byIC</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize flow field by calling corresponding routine according to scheme
kind.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_control.html'>mus_init_control</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines sets the function pointer to main control routine</p><a href="../proc/mus_init_control.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_enrtl.html'>mus_init_eNRTL</a></td>
                 <td><a href='../module/mus_enrtl_module.html'>mus_eNRTL_module</a></td>
                 <td>Function</td>
                 <td><p>This function loads property file using external c-function</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_enrtl~2.html'>mus_init_eNRTL</a></td>
                 <td><a href='../module/mus_enrtl_module~2.html'>mus_eNRTL_module</a></td>
                 <td>Function</td>
                 <td><p>Dummy function to init_enrtl</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_flow.html'>mus_init_flow</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize flow field depends on read restart or initial condition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_fluid.html'>mus_init_fluid</a></td>
                 <td><a href='../module/mus_fluid_module.html'>mus_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initilizes fluid visocity and relaxation paramters for each
level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_geomincr.html'>mus_init_geomIncr</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine initializes the geometry increment.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_graddata.html'>mus_init_gradData</a></td>
                 <td><a href='../module/mus_graddata_module.html'>mus_gradData_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize gradData with direct neighbors in state and
finite difference coefficients.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_hrrcorrection.html'>mus_init_hrrCorrection</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize arrays to store time average density and velocity for
dynamic hrrCorrection.
\todo KM: 20210301 Allocate also for ghost cells!</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_ibm.html'>mus_init_IBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine initializes the IBM data incl. reading the stl, unifying
the coordinates, storing the connectivity, allocating the parentIDs array
and initializing the stencil used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_ibmdata.html'>mus_init_IBMData</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine initializes all arrays in the mus_IBM_tmpData_type.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_internalsource.html'>mus_init_internalSource</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines does setup indices for given source within a field or
global. Index are stored for points which source term is active</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_interpolate.html'>mus_init_interpolate</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine initialzes the interpolation</p><a href="../proc/mus_init_interpolate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_isotherm_aceq.html'>mus_init_isotherm_acEq</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the isothermal acEq flow from density and velocity\n
equilibrium pdf (fEq) is calculated from density and velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_latticeunit.html'>mus_init_latticeUnit</a></td>
                 <td><a href='../module/mus_param_module.html'>mus_param_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize lattice dx and dt</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_layout.html'>mus_init_layout</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize growing array of stencils</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_leveldescintparrays.html'>mus_init_levelDescIntpArrays</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize levelwise ghost and source list for interpolation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_leveltimer.html'>mus_init_levelTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_longbuffers.html'>mus_init_longBuffers</a></td>
                 <td><a href='../module/mus_comm_module.html'>mus_comm_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Wrapper around the actual communication, to avoid copy-in, copy-out by the
Intel compiler. (At least the intel compiler on pigeon (v12.0) seems to do
copying here, if a sub-array is passed to an assumed size dummy argument.
Therefore we use this wrapping with an assumed shape dummy argument, so we
can pass a complete field to the actual exchange which has an assumed size
argument, without copying complete state field around, just for
communication. Ugly, but it doesn't seem to have an impact on performance,
and right it seems to be the most suitable solution.</p><a href="../proc/mus_init_longbuffers.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_maintimer.html'>mus_init_mainTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Timers initialization routine for whatever</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_moments.html'>mus_init_moments</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the moment space</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_msgas.html'>mus_init_MSGas</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flow from calculated quantitites like density, velocity etc.
 for multispecies lbm</p><a href="../proc/mus_init_msgas.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_msliquid.html'>mus_init_MSLiquid</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flow from calculated quantitites like density, velocity etc.
for multispecies lbm</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_nernst_planck.html'>mus_init_nernst_planck</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize nernst planck from           and           .\n
Equilibirium pdf (fEq) is calculated from          and         .</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_particletimer.html'>mus_init_particleTimer</a></td>
                 <td><a href='../module/mus_particle_timer_module.html'>mus_particle_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_passivescalar.html'>mus_init_passiveScalar</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize passive scalar from pressure and velocity.\n
Equilibirium pdf (fEq) is calculated from pressure and velocity.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_pdf.html'>mus_init_pdf</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize the flow from pressure, velocity and strain rate.\n
First equilibirium pdf (fEq) is calculated from pressure and velocity.
Then non-equilibirium (fnEq) is calculated from strain rate.
At last set the pdf of each element by sum up these two parts (fEq+fnEq).</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_poisson.html'>mus_init_poisson</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize poisson lbm from potential
Equilibirium pdf (fEq) is calculated from potential.</p><a href="../proc/mus_init_poisson.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_relaxparam.html'>mus_init_relaxParam</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize relaxation parameter</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_scheme.html'>mus_init_scheme</a></td>
                 <td><a href='../module/mus_scheme_module.html'>mus_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize single scheme stencil and variable system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_sourceterms.html'>mus_init_sourceTerms</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine does set_params and setupIndices for all sources terms
by gathering points to apply souce term before.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_tracker.html'>mus_init_tracker</a></td>
                 <td><a href='../module/mus_tracking_module.html'>mus_tracking_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize tracking subTree to remove empty tracking objects.
On active tracking objects: Homogenize time control, write solver speific
info for harvester output format and initialize output using
tem_init_tracker</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_transport_var.html'>mus_init_transport_var</a></td>
                 <td><a href='../module/mus_transport_var_module.html'>mus_transport_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialize transport variable by calling setupIndices for every variable
and store pntIndex</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_turb_wallfunc.html'>mus_init_turb_wallFunc</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine allocates turbulent viscosity and friction velocity on
boundary elements. It also initialize friction velocity from stream-wise
velocity component on first neighbor in normal direction.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_turbchanforce.html'>mus_init_turbChanForce</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Create subTree and store nElemsGlobal in all proc for turbulent
channel force</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_turbulencedata.html'>mus_init_turbulenceData</a></td>
                 <td><a href='../module/mus_turbulence_module.html'>mus_turbulence_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This initialize turbulence data type which includes velocity array
and communication buffer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_init_varsys_solverdata.html'>mus_init_varSys_solverData</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_initauxfield.html'>mus_initAuxField</a></td>
                 <td><a href='../module/mus_flow_module.html'>mus_flow_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initialize auxField variable from PDF values initialized by
initial condition. AuxField is computed from state using SAVE access for
fluid elements and interpolated for ghost elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_initauxfieldfluidandexchange.html'>mus_initAuxFieldFluidAndExchange</a></td>
                 <td><a href='../module/mus_auxfield_module.html'>mus_auxField_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine initializes auxField for fluid elements using SAVE access on
PDF initialized by IC</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_initialize.html'>mus_initialize</a></td>
                 <td><a href='../module/mus_program_module.html'>mus_program_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine load musubi configuration file and initialize construction
flow, auxilary and main control routines</p><a href="../proc/mus_initialize.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_interpolate_linear2d_leastsq.html'>mus_interpolate_linear2D_leastSq</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Function</td>
                 <td><p>Bilinear interpolation for a vector quantity phi</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_interpolate_linear3d_leastsq.html'>mus_interpolate_linear3D_leastSq</a></td>
                 <td><a href='../module/mus_interpolate_linear_module.html'>mus_interpolate_linear_module</a></td>
                 <td>Function</td>
                 <td><p>Trilinear interpolation for a vector quantity phi
Each phi corresponds to each moment</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_interpolate_out.html'>mus_interpolate_out</a></td>
                 <td><a href='../module/mus_interpolate_header_module.html'>mus_interpolate_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump interpolation method to lua</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_interpolate_quad2d_leastsq.html'>mus_interpolate_quad2D_leastSq</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Function</td>
                 <td><p>Biquadratic interpolation for a vector quantity phi</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_interpolate_quad3d_leastsq.html'>mus_interpolate_quad3D_leastSq</a></td>
                 <td><a href='../module/mus_interpolate_quadratic_module.html'>mus_interpolate_quadratic_module</a></td>
                 <td>Function</td>
                 <td><p>Triquadratic interpolation for a vector quantity phi
Each phi corresponds to each moment</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_error.html'>mus_intp_error</a></td>
                 <td><a href='../module/mus_interpolate_verify_module.html'>mus_interpolate_verify_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Determine the numerical error of the interpolated quantities to the given
initial conditions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_getpdfs_d3q27.html'>mus_intp_getPdfs_D3Q27</a></td>
                 <td><a href='../module/mus_d3q27_module.html'>mus_d3q27_module</a></td>
                 <td>Function</td>
                 <td><p>This function returns pdfs from state</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_getsrcelemposinleveldesc.html'>mus_intp_getSrcElemPosInLevelDesc</a></td>
                 <td><a href='../module/mus_connectivity_module.html'>mus_connectivity_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_getsrcelemposintree.html'>mus_intp_getSrcElemPosinTree</a></td>
                 <td><a href='../module/mus_connectivity_module.html'>mus_connectivity_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_update_depfromcoarser.html'>mus_intp_update_depFromCoarser</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>The required source elements for ghost from coarser elements are
 identified in this routine. Moreover, the weights for each sources based
 on distance are calculated. \n</p><a href="../proc/mus_intp_update_depfromcoarser.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intp_update_depfromfiner.html'>mus_intp_update_depFromFiner</a></td>
                 <td><a href='../module/mus_interpolate_module.html'>mus_interpolate_module</a></td>
                 <td>Subroutine</td>
                 <td><p>All sources (children) have been found in treelm,
updated number of sources needed, based on nDims
collect all source elements into sourceFromFiner
assign ghost intp list. Currently only average interpolation is implemented
for fillMineFromFiner</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intpauxfieldcoarserandexchange.html'>mus_intpAuxFieldCoarserAndExchange</a></td>
                 <td><a href='../module/mus_auxfield_module.html'>mus_auxField_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine interpolate auxField variable for ghostFromFiner and exchange
halos</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intpauxfieldfinerandexchange.html'>mus_intpAuxFieldFinerAndExchange</a></td>
                 <td><a href='../module/mus_auxfield_module.html'>mus_auxField_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine interpolate auxField variable for ghostFromCoarser and exchange
halos</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_intpvel_xk.html'>mus_intpVel_Xk</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine interpolates the velocity values using the velocity on Xk.
(neighbors).
(Inamuro paper: step 3, correct u_l(X_k))</p><a href="../proc/mus_intpvel_xk.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_absorblayer.html'>mus_load_absorbLayer</a></td>
                 <td><a href='../module/mus_absorblayer_module.html'>mus_absorbLayer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine load additional information for absorblayer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_bc.html'>mus_load_bc</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the boundary conditions from the LUA parameter file.\n</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_bc_data.html'>mus_load_bc_data</a></td>
                 <td><a href='../module/mus_geom_module.html'>mus_geom_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine invokes the treelm routines to load the boundary conditions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_config.html'>mus_load_config</a></td>
                 <td><a href='../module/mus_config_module.html'>mus_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in LUA parameter file
See http://www.lua.org for a reference on how to use
Lua is a scripting language in itself which allows
more complex parameter files including comments
And load / create the mesh depending on the configuration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_debugtracker.html'>mus_load_debugtracker</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_field_prop.html'>mus_load_field_prop</a></td>
                 <td><a href='../module/mus_field_prop_module.html'>mus_field_prop_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load fluid properties like fluid and species table from
lua file based on the scheme kind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_field_single.html'>mus_load_field_single</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load a single field table
In includes:
  load field property
  load source variables
  load boundary defination
  load immersed boundary method
  load initial condition defination and its property</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_fieldbaseinfos.html'>mus_load_fieldBaseInfos</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns nFields and field labels from config file.
It is required to initialize variable system.
labels are loaded only if field table is present else default
is set to empty string.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_fields.html'>mus_load_fields</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Subroutine to load the field table from the lua configuration file.</p><a href="../proc/mus_load_fields.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_fluid.html'>mus_load_fluid</a></td>
                 <td><a href='../module/mus_fluid_module.html'>mus_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the fluid property from the LUA parameter file</p><a href="../proc/mus_load_fluid.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_geom.html'>mus_load_geom</a></td>
                 <td><a href='../module/mus_geom_module.html'>mus_geom_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine load all geometry related datas like mesh, boundary
and immersed_boundary. Restart is also loaded here because mesh is loaded
in tem_load_restart if restart read is defined.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_ibm.html'>mus_load_IBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load the IBM information from the lua config file.</p><a href="../proc/mus_load_ibm.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_ibm_single.html'>mus_load_IBM_single</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load a single IBM table from the config file.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_interpolate.html'>mus_load_interpolate</a></td>
                 <td><a href='../module/mus_interpolate_header_module.html'>mus_interpolate_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the type of interpolation scheme</p><a href="../proc/mus_load_interpolate.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_mixture.html'>mus_load_mixture</a></td>
                 <td><a href='../module/mus_mixture_module.html'>mus_mixture_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine load mixture table from scheme table.
Define either mass density or number density.
If mass density is specified, number density can be computed at runtime
or vice versa.
 @note Todo
      Currently, the simulation is initialized by density, extend
    it to initialize from mixture number density/volume fraction
    and mole fraction
    \verbatim
    mixture = { rho0 = 1.0, omega }
    \endverbatim</p><a href="../proc/mus_load_mixture.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_nernstplanck.html'>mus_load_nernstPlanck</a></td>
                 <td><a href='../module/mus_nernstplanck_module.html'>mus_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load input to solve nernst_planck equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_newlayout.html'>mus_load_newLayout</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load a new stencil definition from the lua file</p><a href="../proc/mus_load_newlayout.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_param.html'>mus_load_param</a></td>
                 <td><a href='../module/mus_param_module.html'>mus_param_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load global parameter from conf</p><a href="../proc/mus_load_param.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_boundaries.html'>mus_load_particle_boundaries</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_collisions.html'>mus_load_particle_collisions</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_creator_timing.html'>mus_load_particle_creator_timing</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_distribution.html'>mus_load_particle_distribution</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_dps_data_chunk.html'>mus_load_particle_dps_data_chunk</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_interpolation.html'>mus_load_particle_interpolation</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particle_mem_data_chunk.html'>mus_load_particle_mem_data_chunk</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particleblob_cylinder.html'>mus_load_particleblob_cylinder</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particleblob_prism.html'>mus_load_particleblob_prism</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particlekind.html'>mus_load_particlekind</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Get the particle kind from the configuration</p><a href="../proc/mus_load_particlekind.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_particles.html'>mus_load_particles</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to load the particle data from the musubi.lua file
meant to be called from within mus_load_config after the lua
file has already been opened</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_physics.html'>mus_load_physics</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads the physics table from musubi config file</p><a href="../proc/mus_load_physics.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_poisson.html'>mus_load_poisson</a></td>
                 <td><a href='../module/mus_poisson_module.html'>mus_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load input to solve poisson equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_poissonboltzmann.html'>mus_load_poissonBoltzmann</a></td>
                 <td><a href='../module/mus_poisson_module.html'>mus_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Load input to solve poisson boltzmann equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_predefined_particleblob.html'>mus_load_predefined_particleblob</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_scheme.html'>mus_load_scheme</a></td>
                 <td><a href='../module/mus_scheme_module.html'>mus_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load single scheme defined in lua file with or without scheme handle</p><a href="../proc/mus_load_scheme.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_scheme_header.html'>mus_load_scheme_header</a></td>
                 <td><a href='../module/mus_scheme_header_module.html'>mus_scheme_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load scheme header info from lua file identify table or from scheme table
 or from config</p><a href="../proc/mus_load_scheme_header.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_source_var.html'>mus_load_source_var</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine load musubi source terms for given key.
key is glob_source or source</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_species.html'>mus_load_species</a></td>
                 <td><a href='../module/mus_species_module.html'>mus_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>this routines load species table from config file</p><a href="../proc/mus_load_species.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_transport_var.html'>mus_load_transport_var</a></td>
                 <td><a href='../module/mus_transport_var_module.html'>mus_transport_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine load musubi transport variables</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_turb_wallfunc.html'>mus_load_turb_wallFunc</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads wall model and nonlinear solver type for nonlinear
equation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_load_turbulence.html'>mus_load_turbulence</a></td>
                 <td><a href='../module/mus_turbulence_module.html'>mus_turbulence_module</a></td>
                 <td>Subroutine</td>
                 <td><p>load turbulence table</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_log_fluid_momentum.html'>mus_log_fluid_momentum</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>perform_particle_checks computes the total momentum of the fluid and particle
phases and logs this to a file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_mixture_out.html'>mus_mixture_out</a></td>
                 <td><a href='../module/mus_mixture_module.html'>mus_mixture_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine write mixture properties into lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nernstplanck_advrel_generic.html'>mus_nernstPlanck_advRel_generic</a></td>
                 <td><a href='../module/mus_compute_nernstplanck_module.html'>mus_compute_nernstPlanck_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the
nernst planvk model with an explicit calculation of all equilibrium
quantities. Slow and simple. This routine should only be
used for testing purposes</p><a href="../proc/mus_nernstplanck_advrel_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cs_dump.html'>mus_nNwtn_CS_dump</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump nonNewtonian (CY) parameters to outUnit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cs_load.html'>mus_nNwtn_CS_load</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the nonNewtonian Casson model parameters from Lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cs_save.html'>mus_nNwtn_CS_save</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write nonNewtonian Casson parameters into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cy_dump.html'>mus_nNwtn_CY_dump</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump nonNewtonian (CY) parameters to outUnit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cy_load.html'>mus_nNwtn_CY_load</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the nonNewtonian Carreau-Yasuda (CY) model parameters from Lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_cy_save.html'>mus_nNwtn_CY_save</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write nonNewtonian (CY) parameters into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_dump2outunit.html'>mus_nNwtn_dump2outUnit</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump nonNewtonian fluid parameters to outUnit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_load.html'>mus_nNwtn_load</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the nonNewtonian table from Lua file and dump parameters to logUnit
Specificly, this routine calls each model parameter loader.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_pl_dump.html'>mus_nNwtn_PL_dump</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump nonNewtonian Power Law (PL) parameters to outUnit</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_pl_load.html'>mus_nNwtn_PL_load</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read in the nonNewtonian Power Law (PL) model parameters from Lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_pl_save.html'>mus_nNwtn_PL_save</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write nonNewtonian Power Law (PL) parameters into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_nnwtn_save2lua.html'>mus_nNwtn_save2lua</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Subroutine</td>
                 <td><p>write nonNewtonian fluid parameters into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_open_config.html'>mus_open_config</a></td>
                 <td><a href='../module/mus_config_module.html'>mus_config_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine loads musubi specific lua function from string and musubi
input configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_opvar_gradu_forelement.html'>mus_opVar_gradU_forElement</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine returns the velocity gradient from velocity in auxField</p><a href="../proc/mus_opvar_gradu_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_opvar_qcriterion_forelement.html'>mus_opVar_QCriterion_forElement</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes Q-criterion from velocity in auxField.
<script type="math/tex; mode=display">Q = 1/2 ( (tr(\nabla u))^2 - tr(\nabla u \cdot \nabla u) )
= 1/2 |\Omega|^2 - |S|^2 </script>,
where <script type="math/tex; mode=display">\Omega</script> and S are asymmetric (vorticity tensor) and
symmetric (rate of strain) part of velocity gradient.
i.e <script type="math/tex; mode=display">\Omega = 1/2(du_i/dx_j - du_j/dx_i)</script> and
<script type="math/tex; mode=display">S=1/2(du_i/dx_j + du_j/dx_i)</script>.</p><a href="../proc/mus_opvar_qcriterion_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_opvar_setupindices.html'>mus_opVar_setupIndices</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_opvar_vorticity_forelement.html'>mus_opVar_vorticity_forElement</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes vorticity from curl of velocity in auxField.
<script type="math/tex; mode=display">vorticity = \nabla \times u</script>
</p><a href="../proc/mus_opvar_vorticity_forelement.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_param_out.html'>mus_param_out</a></td>
                 <td><a href='../module/mus_param_module.html'>mus_param_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine writes global parameter into solver specific string in lua
format</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_addsourcetermstoauxfield_dps.html'>mus_particles_addSourceTermsToAuxField_DPS</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_applyhydrodynamicforces_dps.html'>mus_particles_applyHydrodynamicForces_DPS</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_applyhydrodynamicforces_dps_onewaycoupled.html'>mus_particles_applyHydrodynamicForces_DPS_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_applyhydrodynamicforces_mem.html'>mus_particles_applyHydrodynamicForces_MEM</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_buffers.html'>mus_particles_comm_init_buffers</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_idbuffer.html'>mus_particles_comm_init_IDbuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_particlebuffer.html'>mus_particles_comm_init_particlebuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_posbuffer.html'>mus_particles_comm_init_posbuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_statebuffer.html'>mus_particles_comm_init_statebuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_vectorbuffer.html'>mus_particles_comm_init_vectorbuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_comm_init_wallbuffer.html'>mus_particles_comm_init_wallbuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_dps_interpolatefluidproperties.html'>mus_particles_DPS_interpolateFluidProperties</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolates fluid properties from neighboring lattice sites to determine the
fluid density and velocity at the location of the particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_dps_interpolatefluidproperties_onewaycoupled.html'>mus_particles_DPS_interpolateFluidProperties_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Interpolates fluid properties from neighboring lattice sites to determine the
fluid density and velocity at the location of the particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_global_errorcheck.html'>mus_particles_global_errorcheck</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to aggregate local error flags and use MPI allreduce 
to set a global flag if any of the local flags is true</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initfluidvolumefraction.html'>mus_particles_initFluidVolumeFraction</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to initialize the fluid volume fraction field</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initforcecontributionmpitype.html'>mus_particles_initForceContributionMPItype</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initialize.html'>mus_particles_initialize</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Initialization for particleGroup and all the particles in it
Includes:
* Assigning the required procedure pointers for particleGroup and particles
* Initializing loggers
* Initializing communication routines
* Building the representation of the particles on the grid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initialize_communication.html'>mus_particles_initialize_communication</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initparticleinfompitype.html'>mus_particles_initParticleInfoMPItype</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create and commit the MPI type used to communicate
all continuous particle data</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initparticlestatempitype.html'>mus_particles_initParticleStateMPItype</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create and commit the MPI type used to communicate
position, velocity and coordOfOrigin</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initpositionupdatempitype.html'>mus_particles_initPositionUpdateMPItype</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to create and commit the MPI type used to communicate
position and coordOfOrigin</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_initwallposmpitype.html'>mus_particles_initWallPosMPItype</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_log_total_momentum.html'>mus_particles_log_total_momentum</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>perform_particle_checks computes the total momentum of the fluid and particle
phases and logs this to a file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_logdata_dps.html'>mus_particles_logdata_DPS</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main routine to log particle data for DPS particles</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_logdata_mem.html'>mus_particles_logdata_MEM</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main routine to log particle data for MEM particles</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_mapping_dps.html'>mus_particles_mapping_DPS</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_mapping_mem.html'>mus_particles_mapping_MEM</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>mus_particles_mapping maps the current particle positions to the lattice
This means the exclusionLists are updated, connectivity of solid and
fluid neighbor particles is modified, new fluid particles are initialized
and have their connectivity restored. Also particles that have no more elements
on this process (either local or halo) get removed from this process.
Should be called once per LBM time step.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_move.html'>mus_particles_move</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine moves all particles in particleArray.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_move_dps.html'>mus_particles_move_DPS</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine moves all particles in particleArray.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_move_dps_onewaycoupled.html'>mus_particles_move_DPS_onewaycoupled</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine moves all particles in particleArray.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_print_config.html'>mus_particles_print_config</a></td>
                 <td><a href='../module/mus_particle_config_module.html'>mus_particle_config_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_runtests.html'>mus_particles_runtests</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_transfermomentumtofluid_dps.html'>mus_particles_transferMomentumToFluid_DPS</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_transfermomentumtofluid_mem.html'>mus_particles_transferMomentumToFluid_MEM</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_particles_updatefluidvolumefraction.html'>mus_particles_updateFluidVolumeFraction</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Main routine to update the fluid volume fraction in the auxField</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_pblinear_advrel_generic.html'>mus_PBLinear_advRel_generic</a></td>
                 <td><a href='../module/mus_compute_poisson_module.html'>mus_compute_Poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the linear
 poisson boltzmann equation with an explicit calculation of all equilibrium
 quantities. Slow and simple.
 <script type="math/tex; mode=display"> \nabla^2 \phi = k^2 \phi </script>
 Where k^2 is inverse of debye length and in this kernel refered as
 RHS_coeff
 <script type="math/tex; mode=display"> k^2 = \sum_i \frac{ c_{\infty}z_i^2 e^2}{\epsilon_r \epsilon_0 k_b T} </script>
</p><a href="../proc/mus_pblinear_advrel_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_pbnonlinear_advrel_generic.html'>mus_PBnonLinear_advRel_generic</a></td>
                 <td><a href='../module/mus_compute_poisson_module.html'>mus_compute_Poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the nonlinear
 poisson boltzmann equation for electrolyte solution
 <script type="math/tex; mode=display"> \nabla^2 \phi = - \frac{1}{\epsilon_r \epsilon_0}
    \sum_i { e z_i c_{\infty} N_A exp(-\frac{z e }{k_b T}\phi) } </script>
</p><a href="../proc/mus_pbnonlinear_advrel_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_pdf_allocate.html'>mus_pdf_allocate</a></td>
                 <td><a href='../module/mus_pdf_module.html'>mus_pdf_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_pdf_serialize.html'>mus_pdf_serialize</a></td>
                 <td><a href='../module/mus_buffer_module.html'>mus_buffer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Preparation of the serialize PDF data</p><a href="../proc/mus_pdf_serialize.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_pdf_unserialize.html'>mus_pdf_unserialize</a></td>
                 <td><a href='../module/mus_buffer_module.html'>mus_buffer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine unserializes the read data and stores it in the state-
vector to perform a restart.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_perf_measure.html'>mus_perf_measure</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine measures performance imbalance, MLUPS and dumps timings
to disk</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_perform_dynloadbal.html'>mus_perform_dynLoadBal</a></td>
                 <td><a href='../module/mus_dynloadbal_module.html'>mus_dynLoadBal_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Wrap up the routines required for dynamic load balancing</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_physics_dump2outunit.html'>mus_physics_dump2outUnit</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_physics_out.html'>mus_physics_out</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine write reference physics parameters into solver specific
string in lua format.</p><a href="../proc/mus_physics_out.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_physics_out_conv.html'>mus_physics_out_conv</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine write physics convert factor into solver specific string in
lua format.
use reference density to parmeterize kg and reference mole density
to parmeterize mol.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_poisson_advrel_d2q9.html'>mus_Poisson_advRel_d2q9</a></td>
                 <td><a href='../module/mus_compute_poisson_module.html'>mus_compute_Poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the
 poisson equation with an explicit calculation of all equilibrium
 quantities. Slow and simple.
 <script type="math/tex; mode=display"> \nabla^2 \phi = - \frac{\rho_e}{\epsilon_r \epsilon_0} </script>
 The right hand side of equation is added as a source term in
 mus_apply_sourceTerms routine</p><a href="../proc/mus_poisson_advrel_d2q9.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_poisson_advrel_generic.html'>mus_Poisson_advRel_generic</a></td>
                 <td><a href='../module/mus_compute_poisson_module.html'>mus_compute_Poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Advection relaxation routine for the
 poisson equation with an explicit calculation of all equilibrium
 quantities. Slow and simple.
 <script type="math/tex; mode=display"> \nabla^2 \phi = - \frac{\rho_e}{\epsilon_r \epsilon_0} </script>
 The right hand side of equation is added as a source term in
 mus_apply_sourceTerms routine</p><a href="../proc/mus_poisson_advrel_generic.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_print_ppinfo.html'>mus_print_ppInfo</a></td>
                 <td><a href='../module/mus_ppinfo_module.html'>mus_ppInfo_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Print information on the pre-processor options of the executable.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_readrestart.html'>mus_readRestart</a></td>
                 <td><a href='../module/mus_restart_module.html'>mus_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the serialized restart file into the state vectors</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reductiontransient_forpoint.html'>mus_reductionTransient_forPoint</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Same as reductionTransient_forElement except it evaluate it multiply values
from points</p><a href="../proc/mus_reductiontransient_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reload_ibm.html'>mus_reload_IBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reset_aux.html'>mus_reset_aux</a></td>
                 <td><a href='../module/mus_dynloadbal_module.html'>mus_dynLoadBal_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine initializes musubi after a dynamic load balancing is
performed.</p><a href="../proc/mus_reset_aux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reset_bctimer.html'>mus_reset_bcTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reset_leveltimer.html'>mus_reset_levelTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_reset_maintimer.html'>mus_reset_mainTimer</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_scheme_cleanup.html'>mus_scheme_cleanup</a></td>
                 <td><a href='../module/mus_scheme_module.html'>mus_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This subroutine acts as a destructor for the construct routine</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_scheme_header_out.html'>mus_scheme_header_out</a></td>
                 <td><a href='../module/mus_scheme_header_module.html'>mus_scheme_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dumps scheme header</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_scheme_out.html'>mus_scheme_out</a></td>
                 <td><a href='../module/mus_scheme_module.html'>mus_scheme_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump single scheme info into restart solver specific conf to dump
solver specific information in restart header file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_bclinks.html'>mus_set_bcLinks</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_bouzidi.html'>mus_set_bouzidi</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set necessary data for Wall Bouzidi BC
bouzidi should be allocated beforehand</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_convfac.html'>mus_set_convFac</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computed conversion factors for lattice to physical units.
inverse of this factors can be used to convert from physical to lattice
units.\n
use reference density to parmeterize kg and reference mole density
to parmeterize mol.\n
Multiply these factors with the LB quantity to get the physical quantity
Divide the physical quantity by these factors to get the LB units.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_ic_states.html'>mus_set_ic_states</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set ic states labels by scheme kind</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_inletbfl.html'>mus_set_inletBfl</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Bitmask is true for incoming direction</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_inletubb.html'>mus_set_inletUbb</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set necessary data for BC velocity_bounceback_qval</p><a href="../proc/mus_set_inletubb.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_noneqexpol.html'>mus_set_nonEqExpol</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Linkwise non-equilibrium extrapolation (can handle curved walls)</p><a href="../proc/mus_set_noneqexpol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_nsources.html'>mus_set_nSources</a></td>
                 <td><a href='../module/mus_interpolate_header_module.html'>mus_interpolate_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_opvar_getelement.html'>mus_set_opVar_getElement</a></td>
                 <td><a href='../module/mus_operation_var_module.html'>mus_operation_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to store musubi varSys Data in operation variable solver_bundle.
Unline Ateles, Musubi operations does not require any special treatment so
it uses to generic routines in treelm</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_outletexpol.html'>mus_set_outletExpol</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_posinnghelems.html'>mus_set_posInNghElems</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set BC elements positions in LevelDesc%neigh%nghElems</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_scalefac.html'>mus_set_scaleFac</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_stfun_getelement.html'>mus_set_stFun_getElement</a></td>
                 <td><a href='../module/mus_varsys_module.html'>mus_varSys_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to store musubi varSys Data in stFun variable</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_timerhandles.html'>mus_set_timerHandles</a></td>
                 <td><a href='../module/mus_timer_module.html'>mus_timer_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine sets mus_timerHandles passed by apesmate</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d1q3.html'>mus_set_weights_d1q3</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d2q5.html'>mus_set_weights_d2q5</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d2q9.html'>mus_set_weights_d2q9</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d3q13.html'>mus_set_weights_d3q13</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d3q19.html'>mus_set_weights_d3q19</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d3q27.html'>mus_set_weights_d3q27</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d3q6.html'>mus_set_weights_d3q6</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_set_weights_d3q7.html'>mus_set_weights_d3q7</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_setprop.html'>mus_setProp</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine updates the propertybits of an element
If solidify == true, set prp_fluidify and set prp_solid
If fluidify == treu, clean prp_fluidify and set prp_fluid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_setupindices_forbc.html'>mus_setupIndices_forBC</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine setup indices for boundary variables in bc_State_type
pntIndex for the points on which boundaries are treated.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_setupindices_forsrc.html'>mus_setupIndices_forSrc</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routines does setup indices for given source within a field or
global. Index are stored for points which source term is active</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_solve.html'>mus_solve</a></td>
                 <td><a href='../module/mus_program_module.html'>mus_program_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine does the main musubi computation loop</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_source_cleanup.html'>mus_source_cleanup</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine act as a destructor for source type.
The arrays allocated in mus_init_sourceTerms are destroyed here</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_species_out.html'>mus_species_out</a></td>
                 <td><a href='../module/mus_species_module.html'>mus_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>writes species propertries into a lua file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_statevar_fetch_fromindex.html'>mus_stateVar_Fetch_fromIndex</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to get the actual value for a given array of indices.
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_statevar_fetch_now_fromindex.html'>mus_stateVar_Fetch_now_fromIndex</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to get the actual value for a given array of indices.
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_statevar_forpoint.html'>mus_stateVar_forPoint</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>State variable for a given set of points using linear interpolation.</p><a href="../proc/mus_statevar_forpoint.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_statevar_fromindex.html'>mus_stateVar_fromIndex</a></td>
                 <td><a href='../module/mus_statevar_module.html'>mus_stateVar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine to get the actual value for a given array of indices.
The indices belong to the grwarray of points storing levelwise in
Pointdata%pntLvl(iLevel).
Hence this routines takes the indeices as input, can refer to the pointData
and evaluate the variable and returns the values</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_store_bcvarpos.html'>mus_store_bcVarPos</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Store the position of each boundary variable in the global varSys
in the field%bc%varPos%<variable>.
This routine also checks if boundary variable defined in config file
has same number of components as expected.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_store_dervarpos.html'>mus_store_derVarPos</a></td>
                 <td><a href='../module/mus_variable_module.html'>mus_variable_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Store the position of each variable in the global system in the derVarPos
This function is also called in Harvester.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_swap_now_next.html'>mus_swap_Now_Next</a></td>
                 <td><a href='../module/mus_pdf_module.html'>mus_pdf_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_testinterpolation.html'>mus_testInterpolation</a></td>
                 <td><a href='../module/mus_interpolate_verify_module.html'>mus_interpolate_verify_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Call tests to determine the actual error from the interpolation routines on
the ghost elements. Compare against the analytical solution, which is
given in terms of the initial conditions.
Call this routine after the initial values are set and the ghost elements
have been filled once, but no computation was started
-&gt; after fillHelperElements in the mus_aux_module</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_time_homogenize.html'>mus_time_homogenize</a></td>
                 <td><a href='../module/mus_time_module.html'>mus_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Convert itime from restart to real time</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_time_modulo.html'>mus_time_modulo</a></td>
                 <td><a href='../module/mus_time_module.html'>mus_time_module</a></td>
                 <td>Function</td>
                 <td><p>Check for multilevel cycle complete by modulo of nIters by scaleFactor
depends on acoustic or diffusive scaling.
Acoustic scaling: scale factor = 2
Diffusive scaling: scale factor = 4</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_timecontrol_homogenize.html'>mus_timeControl_homogenize</a></td>
                 <td><a href='../module/mus_time_module.html'>mus_time_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Converts sim time to iter and vice versa depends on which one is defined
in the configuration file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turb_calcvisc.html'>mus_turb_calcVisc</a></td>
                 <td><a href='../module/mus_turbulence_module.html'>mus_turbulence_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compute turbulence viscosity and stores in turbulence data type</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turb_updateviscofturbwall.html'>mus_turb_updateViscOfTurbWall</a></td>
                 <td><a href='../module/mus_turbulence_module.html'>mus_turbulence_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine update turbulent viscosity of boundary elements from RANS
viscosity computed in turbulent_wall boundary.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_fromgradu_dummy.html'>mus_turbVisc_fromGradU_dummy</a></td>
                 <td><a href='../module/mus_turb_viscosity_module.html'>mus_turb_viscosity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy function for turbulent viscosity from Gradu procedure</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_fromprecolpdf_dummy.html'>mus_turbVisc_fromPreColPDF_dummy</a></td>
                 <td><a href='../module/mus_turb_viscosity_module.html'>mus_turb_viscosity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy function to compute turbulent viscosity from PDF</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromgradu2d.html'>mus_turbVisc_Smagorinsky_fromGradU2D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for compressible model
using gradient of velocity for 2D layout</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromgradu2d_incomp.html'>mus_turbVisc_Smagorinsky_fromGradU2D_incomp</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for incompressible model
using gradient of velocity for 2D layout</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromgradu3d.html'>mus_turbVisc_Smagorinsky_fromGradU3D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for compressible model
using gradient of velocity
Reference paper:
https://link.springer.com/content/pdf/10.1007/s10494-012-9405-0.pdf?pdf=button
The formula is taken from https://caefn.com/openfoam/smagorinsky-sgs-model
nu_t = C_k delta sqrt(k_sgs)
k_sgs = ((-b+sqrt(b^2+4ac))/2a)^2
a = C_e/delta, b=2/3 tr(dev(Strain)), c = 2 C_k delta (dev(Strain):Strain)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromgradu3d_incomp.html'>mus_turbVisc_Smagorinsky_fromGradU3D_incomp</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for incompressible model
using gradient of velocity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromprecolpdf_2d.html'>mus_turbVisc_Smagorinsky_fromPreColPDF_2D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for compressible model
using pre-collision PDF.
Schneider, A. (2015). A Consistent Large Eddy Approach for Lattice
Boltzmann Methods and its Application to Complex Flows.
Technical University Kaiserslautern.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromprecolpdf_3d.html'>mus_turbVisc_Smagorinsky_fromPreColPDF_3D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for compressible model
using pre-collision PDF.
Schneider, A. (2015). A Consistent Large Eddy Approach for Lattice
Boltzmann Methods and its Application to Complex Flows.
Technical University Kaiserslautern.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromprecolpdf_incomp_2d.html'>mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_2D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for incompressible model
using pre-collision PDF</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_smagorinsky_fromprecolpdf_incomp_3d.html'>mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_3D</a></td>
                 <td><a href='../module/mus_smagorinsky_module.html'>mus_Smagorinsky_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with smagorinsky model for incompressible model
using pre-collision PDF</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_vreman_2d.html'>mus_turbVisc_Vreman_2D</a></td>
                 <td><a href='../module/mus_vreman_module.html'>mus_Vreman_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with Vreman model for 2D stencil
model
\todo add reference and formula</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_vreman_3d.html'>mus_turbVisc_Vreman_3D</a></td>
                 <td><a href='../module/mus_vreman_module.html'>mus_Vreman_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with Vreman model for 3D stencil
Fortran implementation of this model:
http://www.vremanresearch.nl/Vreman_Subgridmodel_Fortran.txt</p><a href="../proc/mus_turbvisc_vreman_3d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_wale_2d.html'>mus_turbVisc_WALE_2D</a></td>
                 <td><a href='../module/mus_wale_module.html'>mus_WALE_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)
model
\todo add reference and formula</p><a href="../proc/mus_turbvisc_wale_2d.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_turbvisc_wale_3d.html'>mus_turbVisc_WALE_3D</a></td>
                 <td><a href='../module/mus_wale_module.html'>mus_WALE_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)
model
\todo add reference and formula</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_unload_ibm.html'>mus_unload_IBM</a></td>
                 <td><a href='../module/mus_ibm_module.html'>mus_IBM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_bcghostelem.html'>mus_update_BcghostElem</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_relaxparamfromviscstfun.html'>mus_update_relaxParamFromViscSTfun</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine is used to initialize relaxation paramter and update
bulk viscosity at every time step
Bulk visocisty is defined as space-time function to apply
ramping and spatial sponge in bulk viscosity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_relaxparamkine.html'>mus_update_relaxParamKine</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update kinematic relaxation parameter from viscosity and check omega</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_relaxparams.html'>mus_update_relaxParams</a></td>
                 <td><a href='../module/mus_aux_module.html'>mus_aux_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set relaxation parameters for MRT</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_sourcevars.html'>mus_update_sourceVars</a></td>
                 <td><a href='../module/mus_source_module.html'>mus_source_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Updated all source variables i.e field specific source and global source on
all fields.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_update_visckine.html'>mus_update_viscKine</a></td>
                 <td><a href='../module/mus_relaxationparam_module.html'>mus_relaxationParam_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update kinematic viscosity from STfun and calculate turbulent viscosity
from velocity gradient or nonEqPDF
Viscosity obtained from this routine are normalized to the level</p><a href="../proc/mus_update_visckine.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_updateconnectivity_forsymmetricbc.html'>mus_updateConnectivity_forSymmetricBC</a></td>
                 <td><a href='../module/mus_connectivity_module.html'>mus_connectivity_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update the connectivity for elements with symmetric boundary condition
such that during the propagation they are applied implicitly.</p><a href="../proc/mus_updateconnectivity_forsymmetricbc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_updatesrcvar_dummy.html'>mus_updateSrcVar_dummy</a></td>
                 <td><a href='../module/mus_source_type_module.html'>mus_source_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dummy routine for update source variable</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_updatesrcvar_dynsponfld.html'>mus_updateSrcVar_dynSponFld</a></td>
                 <td><a href='../module/mus_source_var_module.html'>mus_source_var_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute density and velocity in sponge layer for dynamic sponge</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_updatesrcvar_turbchanforce.html'>mus_updateSrcVar_turbChanForce</a></td>
                 <td><a href='../module/mus_source_var_turbchanforce_module.html'>mus_source_var_turbChanForce_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Compute dynamic force term using auxField for turbulent channel
force.</p><a href="../proc/mus_updatesrcvar_turbchanforce.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_weights_out.html'>mus_weights_out</a></td>
                 <td><a href='../module/mus_scheme_layout_module.html'>mus_scheme_layout_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dump the weights in lua format.</p><a href="../proc/mus_weights_out.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_writerestart.html'>mus_writeRestart</a></td>
                 <td><a href='../module/mus_restart_module.html'>mus_restart_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write the serialized buffer assembled in mus_serializeData to disk</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mus_writesolverspecinfo.html'>mus_writeSolverSpecInfo</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Write solver specific info to scratch file</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/must_create_new_particles.html'>must_create_new_particles</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Function</td>
                 <td><p>Function to check whether particles should be created using the particleCreator 
object at the current iteration iter.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/newton_method.html'>newton_method</a></td>
                 <td><a href='../module/mus_turb_wallfunc_module.html'>mus_turb_wallFunc_module</a></td>
                 <td>Function</td>
                 <td><p>This routine computes friction velocity from wall model profile
using Newton iteration method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/normalize_probabilities.html'>normalize_probabilities</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/normalizebc.html'>normalizeBC</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine normalizes the normal vectors of boundary elements including
the corner elements as well as assigns the corresponding prevailing
direction from the stencil</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/normcdf.html'>normcdf</a></td>
                 <td><a href='../module/mus_particle_prob_module.html'>mus_particle_prob_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This function evaluates the normal distribution function:</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/one.html'>one</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Function</td>
                 <td><p>Function to return interpolation weight 1.0 regardless of input.
We need this as the weight for the z-direction interpolation in
case of d2q9 stencil.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/openlogfile.html'>openLogFile</a></td>
                 <td><a href='../module/mus_particle_logging_module.html'>mus_particle_logging_module</a></td>
                 <td>Subroutine</td>
                 <td><p>openLogFile opens a file with name fileName and returns the unit
attached to it. It checks whether the file exists and if not</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_dnt.html'>outlet_dnt</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet Pressure do-nothing boundary is the open boundary condition for
incompressible model.
This BC sets reference density at boundary so pressure is not loaded
config file.
Here, the normal velocity is extrapolated from 1st fluid node and
tangential velocity is extrapolated from 2nd fluid node in normal
direction.
Algorithm used in this boundary condition:
fEq(1,u) and fEq(rho,u) are computed using macroscopic values from current
element.
In fNeq, post-collision of current time step is used for normal direction.</p><a href="../proc/outlet_dnt.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_nrbc.html'>outlet_nrbc</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Characteristic-based non-reflective open boundary conditions</p><a href="../proc/outlet_nrbc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_nrbc_eq.html'>outlet_nrbc_eq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Characteristic-based non-reflective open boundary conditions</p><a href="../proc/outlet_nrbc_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_nrbc_incomp.html'>outlet_nrbc_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Characteristic-based non-reflective open boundary conditions</p><a href="../proc/outlet_nrbc_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_passcal.html'>outlet_pasScal</a></td>
                 <td><a href='../module/mus_bc_passivescalar_module.html'>mus_bc_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet boundary conditions for passive scalar transport (Flekkoy).</p><a href="../proc/outlet_passcal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/outlet_zero_prsgrd.html'>outlet_zero_prsgrd</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet boundary conditions with zero pressure gradient.</p><a href="../proc/outlet_zero_prsgrd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/perform_checks.html'>perform_checks</a></td>
                 <td><a href='../module/mus_tools_module.html'>mus_tools_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Perform run-time checks if interval is active</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pick_random_position.html'>pick_random_position</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/positionlocalonmyrank.html'>positionLocalOnMyRank</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td><p>Routine which checks whether a spatial position is local 
on the current rank</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/potential_neumann.html'>potential_neumann</a></td>
                 <td><a href='../module/mus_bc_poisson_module.html'>mus_bc_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Linkwise neumann potential non-equilibrium boundary condition for curved
 and straight walls (zero gradient).
 For straight wall, values are extrapolated along
 boundary normal instead of along the link. The accuracy of straight wall
 depends on the qVal defined in config file and default is set to 0.5</p><a href="../proc/potential_neumann.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/potential_neumann_curved.html'>potential_neumann_curved</a></td>
                 <td><a href='../module/mus_bc_poisson_module.html'>mus_bc_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/potential_neumann_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/potential_noneqexpol.html'>potential_nonEqExpol</a></td>
                 <td><a href='../module/mus_bc_poisson_module.html'>mus_bc_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Linkwise Dirichlet potential non-equilibrium boundary condition for curved
 and straight walls. For straight wall, physical boundary overlaps with
 boundary node i.e. qVal=0.0.</p><a href="../proc/potential_noneqexpol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/potential_noneqexpol_curved.html'>potential_nonEqExpol_curved</a></td>
                 <td><a href='../module/mus_bc_poisson_module.html'>mus_bc_poisson_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Linkwise Dirichlet potential non-equilibrium boundary condition for curved
 wall</p><a href="../proc/potential_noneqexpol_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/prepare_target_elem_list.html'>prepare_target_elem_list</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine compares the macroscopic quantity obtained for an element
against specified threshold and populates the list of target elements
which participate in geometry change. In addition it sets the property
bit(s) of target elements to fluidify in case of solidification and clears
this bit in case of fluidification</p><a href="../proc/prepare_target_elem_list.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/press_neq.html'>press_neq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Pressure Non-Equilibrium type boundary conditions from
 Guo, Z., &amp; Shi, B. (2002). "Non-equilibrium extrapolation method for
 velocity and pressure boundary conditions in the lattice Boltzmann method."
 Chinese Physics, (November 2016).</p><a href="../proc/press_neq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_antibounceback.html'>pressure_antiBounceBack</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet Pressure Bounce Back boundary condition</p><a href="../proc/pressure_antibounceback.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_antibounceback_passcal.html'>pressure_antiBounceBack_pasScal</a></td>
                 <td><a href='../module/mus_bc_passivescalar_module.html'>mus_bc_passiveScalar_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Dirichlet stationary boundary conditions for passive scalar transport in</p><a href="../proc/pressure_antibounceback_passcal.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_eq.html'>pressure_eq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet Pressure Equilibrium type boundary conditions</p><a href="../proc/pressure_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_expol.html'>pressure_expol</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet Pressure extrapolation boundary.
 qVal for this boundary must be 0.0</p><a href="../proc/pressure_expol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_expol_slow.html'>pressure_expol_slow</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/pressure_expol_slow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_momentsbased.html'>pressure_momentsbased</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based open boundary condition from Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"
 for weakly compressible LBM model</p><a href="../proc/pressure_momentsbased.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_momentsbased_incomp.html'>pressure_momentsbased_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based open boundary condition from Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"
 for incompressible LBM model</p><a href="../proc/pressure_momentsbased_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pressure_noneqexpol.html'>pressure_nonEqExpol</a></td>
                 <td><a href='../module/mus_bc_fluid_noneqexpol_module.html'>mus_bc_fluid_nonEqExpol_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Element-wise Dirichlet pressure non-equilibrium boundary condition for
 straight boundary and updates all directions.
 For straight wall, values are extrapolated along
 boundary normal instead of along the link and qVal=0.</p><a href="../proc/pressure_noneqexpol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particle_creator.html'>print_particle_creator</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Print the data in particle creator object, used for debugging</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particle_creator_positions.html'>print_particle_creator_positions</a></td>
                 <td><a href='../module/mus_particle_creator_module.html'>mus_particle_creator_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Print the positions in particle creator object, used for debugging</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particleblob.html'>print_particleblob</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particleblob_prism.html'>print_particleblob_prism</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particleblob_prob.html'>print_particleblob_prob</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particles_comm.html'>print_particles_comm</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particles_pidvectorbuffer.html'>print_particles_pIDvectorbuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_particles_statebuffer.html'>print_particles_statebuffer</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/print_positions.html'>print_positions</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printdebugtrackerdata.html'>printDebugTrackerData</a></td>
                 <td><a href='../module/mus_particle_logging_type_module.html'>mus_particle_logging_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printneighlist.html'>printNeighList</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printparticlegroup.html'>printParticleGroup</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printparticlegroup2_dps.html'>printParticleGroup2_DPS</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printparticlegroup2_mem.html'>printParticleGroup2_MEM</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printparticlegroupdata.html'>printParticleGroupData</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printparticleinterpolator.html'>printParticleInterpolator</a></td>
                 <td><a href='../module/mus_particle_interpolation_module.html'>mus_particle_interpolation_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printpidlist.html'>printpIDlist</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/printtotalelemlist.html'>printTotalElemList</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/proximity.html'>proximity</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>A subroutine which checks the proximity condition and generates a new
treeID list of potential target elements which can then be checked against
various thresholds as defined in the lua configuration file.</p><a href="../proc/proximity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pruneparticlecommprocs.html'>pruneParticleCommProcs</a></td>
                 <td><a href='../module/mus_particle_comm_type_module.html'>mus_particle_comm_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>pruneParticleCommProcs takes the initial list of processes we think
we need to communicate particle data with (determined using only
local data) and checks whether those processes also think they
need to communicate with us. The prunedProcs array contains the
final list of processes for which we know we will send and also
receive messages.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/r8_swap.html'>r8_swap</a></td>
                 <td><a href='../module/mus_particle_prob_module.html'>mus_particle_prob_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Swap two reals of kind rk</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rearrange_bc_elems.html'>rearrange_bc_elems</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>It removes non-valid elements while still maintaining the origianl order.
The given bc elements (elems) contains both valid and non-valid elements.
Position of valid elements are given by posInBCElem.
Valid elements are moved towards the start of the elems so that they become
continuous in the elems.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/recalculate_auxfield_dps.html'>recalculate_auxField_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Remove the momentum increments added during subcycles to prevent double-adding
the momentum of particles to the fluid.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/remove_elem_grw_real2darray.html'>remove_elem_grw_real2darray</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/remove_elem_grw_realarray.html'>remove_elem_grw_realarray</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/remove_particle_from_da_particle_dps.html'>remove_particle_from_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/remove_particle_from_da_particle_mem.html'>remove_particle_from_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/remove_solid_in_bc.html'>remove_solid_in_bc</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>First check count number of valid elements (non-solid) in each BC.
Then rearrange BC elements list so it contains only valid elements.
Update fields%bc%elemLvl%stencilPos fields%bc%elemLvl%posInNghElems
accordingly.</p><a href="../proc/remove_solid_in_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/resetforcebuffers.html'>resetForceBuffers</a></td>
                 <td><a href='../module/mus_particle_comm_module.html'>mus_particle_comm_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rodriguez_rotation.html'>rodriguez_rotation</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rotate_positions.html'>rotate_positions</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/secondmom_2d.html'>secondMom_2D</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate second moments of some quantity <script type="math/tex"> f </script>
<script type="math/tex; mode=display">
   M_{\alpha\beta} = \sum_{i=1}^{Q} c_{i\alpha} c_{i\beta} f_i
</script>
where Q is number of discrete velocity.\n
The output is 1 dimentional array which has 6 componenents.\n
Specifically,
<script type="math/tex; mode=display"> m_1 = \sum_{i=1}^{Q} c_{i1} c_{i1} f_i </script>
<script type="math/tex; mode=display"> m_2 = \sum_{i=1}^{Q} c_{i2} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_3 = \sum_{i=1}^{Q} c_{i1} c_{i2} f_i </script>
This function is used by shear stress and strain rate.
1=xx, 2=yy, 3=xy</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/secondmom_3d.html'>secondMom_3D</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate second moments of some quantity <script type="math/tex"> f </script>
<script type="math/tex; mode=display">
   M_{\alpha\beta} = \sum_{i=1}^{Q} c_{i\alpha} c_{i\beta} f_i
</script>
where Q is number of discrete velocity.\n
The output is 1 dimentional array which has 6 componenents.\n
Specifically,
<script type="math/tex; mode=display"> m_1 = \sum_{i=1}^{Q} c_{i1} c_{i1} f_i </script>
<script type="math/tex; mode=display"> m_2 = \sum_{i=1}^{Q} c_{i2} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_3 = \sum_{i=1}^{Q} c_{i3} c_{i3} f_i </script>
<script type="math/tex; mode=display"> m_4 = \sum_{i=1}^{Q} c_{i1} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_5 = \sum_{i=1}^{Q} c_{i2} c_{i3} f_i </script>
<script type="math/tex; mode=display"> m_6 = \sum_{i=1}^{Q} c_{i3} c_{i1} f_i </script>
This function is used by shear stress and strain rate.
1=xx, 2=yy, 3=zz, 4=xy, 5=yz, 6=xz
in 2D:
1=xx, 2=yy, 3=xy</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/secondmom_minus_cs2_2d.html'>secondMom_minus_cs2_2D</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate second moments of some quantity <script type="math/tex"> f </script>
<script type="math/tex; mode=display">
   M_{\alpha\beta} = \sum_{i=1}^{Q} c_{i\alpha} c_{i\beta} f_i
</script>
where Q is number of discrete velocity.\n
The output is 1 dimentional array which has 6 componenents.\n
Specifically,
<script type="math/tex; mode=display"> m_1 = \sum_{i=1}^{Q} c_{i1} c_{i1} f_i </script>
<script type="math/tex; mode=display"> m_2 = \sum_{i=1}^{Q} c_{i2} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_3 = \sum_{i=1}^{Q} c_{i1} c_{i2} f_i </script>
This function is used by shear stress and strain rate.
1=xx, 2=yy, 3=xy</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/secondmom_minus_cs2_3d.html'>secondMom_minus_cs2_3D</a></td>
                 <td><a href='../module/mus_derivedquantities_module2.html'>mus_derivedQuantities_module2</a></td>
                 <td>Function</td>
                 <td><p>Calculate second moments of some quantity <script type="math/tex"> f </script>
<script type="math/tex; mode=display">
   M_{\alpha\beta} = \sum_{i=1}^{Q} c_{i\alpha} c_{i\beta} f_i
</script>
where Q is number of discrete velocity.\n
The output is 1 dimentional array which has 6 componenents.\n
Specifically,
<script type="math/tex; mode=display"> m_1 = \sum_{i=1}^{Q} c_{i1} c_{i1} f_i </script>
<script type="math/tex; mode=display"> m_2 = \sum_{i=1}^{Q} c_{i2} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_3 = \sum_{i=1}^{Q} c_{i3} c_{i3} f_i </script>
<script type="math/tex; mode=display"> m_4 = \sum_{i=1}^{Q} c_{i1} c_{i2} f_i </script>
<script type="math/tex; mode=display"> m_5 = \sum_{i=1}^{Q} c_{i2} c_{i3} f_i </script>
<script type="math/tex; mode=display"> m_6 = \sum_{i=1}^{Q} c_{i3} c_{i1} f_i </script>
This function is used by shear stress and strain rate.
1=xx, 2=yy, 3=zz, 4=xy, 5=yz, 6=xz</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_boundary.html'>set_boundary</a></td>
                 <td><a href='../module/mus_bc_general_module.html'>mus_bc_general_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Call the functions associated with each boundary condition</p><a href="../proc/set_boundary.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_bouzidi_coeff.html'>set_bouzidi_coeff</a></td>
                 <td><a href='../module/mus_bc_header_module.html'>mus_bc_header_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set the coefficients of bouzidi linear interpolation boundary condition.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_halo_commlinks.html'>set_halo_commLinks</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Select the halo elements which require all links</p><a href="../proc/set_halo_commlinks.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_momentindices.html'>set_momentIndices</a></td>
                 <td><a href='../module/mus_moments_module.html'>mus_moments_module</a></td>
                 <td>Subroutine</td>
                 <td><p>set indices for accessing the pressure, velocity and the shear from a 1d
vector</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_omegaslvl.html'>set_omegasLvl</a></td>
                 <td><a href='../module/mus_mixture_module.html'>mus_mixture_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set the omegas according to the time step setting</p><a href="../proc/set_omegaslvl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_random_seed.html'>set_random_seed</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_sendhalobits.html'>set_sendHaloBits</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>set the sendHalo bit for all fluid elements which are send
to remote procs</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/set_values_by_levels.html'>set_values_by_levels</a></td>
                 <td><a href='../module/mus_physics_module.html'>mus_physics_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/setfieldbcneigh.html'>setFieldBCNeigh</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine sets field BC neigh array with position of
neighbor element in the inward normal direction of boundary
in the levelwise list.
if valid 1st neighbor does not exist return current element position.
if valid higher order neighbor does not exist return last valid
neighbor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/setparameters_multispecies.html'>setParameters_multispecies</a></td>
                 <td><a href='../module/mus_field_module.html'>mus_field_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Set parameters for multispecies</p><a href="../proc/setparameters_multispecies.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/settoequilibrium.html'>setToEquilibrium</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>setToEquilibrium sets elements to equilibrium distribution</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/slip_wall.html'>slip_wall</a></td>
                 <td><a href='../module/mus_bc_fluid_wall_module.html'>mus_bc_fluid_wall_module</a></td>
                 <td>Subroutine</td>
                 <td><p>slip-wall boundary condition. Slip defined by a slip factor</p><a href="../proc/slip_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sortposofval_particle_dps.html'>sortposofval_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Function</td>
                 <td><p>return the sorted position of a value in the given dynamic array</p><a href="../proc/sortposofval_particle_dps.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/sortposofval_particle_mem.html'>sortposofval_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Function</td>
                 <td><p>return the sorted position of a value in the given dynamic array</p><a href="../proc/sortposofval_particle_mem.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_bb_vel_test.html'>spc_bb_vel_test</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>species bounce back velocity boundary
 Usage</p><a href="../proc/spc_bb_vel_test.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_bb_wall.html'>spc_bb_wall</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>species bounce back wall boundary
 Usage</p><a href="../proc/spc_bb_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_blackbox_mem_ion.html'>spc_blackbox_mem_ion</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes mole diffusion flux of the ionic species at the
membrance using black box model and then mass density at the membrane
boundary from mole diffusion flux. Then equilibrium is set at the boundary
which is computed from mass density and velocity</p><a href="../proc/spc_blackbox_mem_ion.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_blackbox_mem_solvent.html'>spc_blackbox_mem_solvent</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine computes mole diffusion flux of the solvent at the membrance
using black box model and then mass density at the membrane boundary
from mole diffusion flux. Then equilibrium is set at the boundary which is
computed from mass density and velocity</p><a href="../proc/spc_blackbox_mem_solvent.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_inflow.html'>spc_inflow</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inflow boundary condition based on non-Equilbrium extrapolation method.
 Usage</p><a href="../proc/spc_inflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_inlet.html'>spc_inlet</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet boundary condition for defined species velocity and mole fraction
 Usage</p><a href="../proc/spc_inlet.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_inlet_eq.html'>spc_inlet_eq</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet species velocity equilibrium boundary with specified
 mixture averaged mass velocity and its molefraction
 mixture kinematic pressure is extrapolated here.
 Density and velocity of all fields are used to compute equilibrium
 Usage</p><a href="../proc/spc_inlet_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_mole_fraction_noneq_expol.html'>spc_mole_fraction_noneq_expol</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole fraction boundary condition for nonequilibrium extrapolation based.
 Default qVal=0.0.
 Usage</p><a href="../proc/spc_mole_fraction_noneq_expol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moledens_eq.html'>spc_moleDens_eq</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole density boundary condition
 Usage</p><a href="../proc/spc_moledens_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_molediff_flux.html'>spc_moleDiff_Flux</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>molar diffusion flux boundary condition
 Usage</p><a href="../proc/spc_molediff_flux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moleflux.html'>spc_moleFlux</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>molar flux boundary condition like velocity bounce back bc type
 Usage</p><a href="../proc/spc_moleflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moleflux_eq.html'>spc_moleFlux_eq</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>molar flux equilibrium boundary condition
 Usage</p><a href="../proc/spc_moleflux_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_molefrac.html'>spc_moleFrac</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole fraction boundary condition
 Usage</p><a href="../proc/spc_molefrac.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_molefrac_eq.html'>spc_moleFrac_eq</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole fraction boundary condition
 Usage</p><a href="../proc/spc_molefrac_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_molefrac_wtdf.html'>spc_moleFrac_wtdf</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole fraction boundary condition with thermodynamic factor
 Usage</p><a href="../proc/spc_molefrac_wtdf.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moments_moleflux.html'>spc_moments_moleFlux</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>molar flux boundary condition like moments velocity bc type
 Usage</p><a href="../proc/spc_moments_moleflux.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moments_molefrac.html'>spc_moments_moleFrac</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Mole fraction boundary condition
 Usage</p><a href="../proc/spc_moments_molefrac.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moments_outflow.html'>spc_moments_outflow</a></td>
                 <td><a href='../module/mus_bc_fluid_experimental_module.html'>mus_bc_fluid_experimental_module</a></td>
                 <td>Subroutine</td>
                 <td><p>molar flux boundary condition like moments velocity bc type
 Usage</p><a href="../proc/spc_moments_outflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moments_vel.html'>spc_moments_vel</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>velocity boundary condition like moments velocity bc type
 Usage</p><a href="../proc/spc_moments_vel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_moments_wall.html'>spc_moments_wall</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based wall boundary condition from Sam Bennent PhD thesis
"A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"</p><a href="../proc/spc_moments_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_outflow.html'>spc_outflow</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Open outflow boundary condition based on nonequilibrium extrapolation
 method. Default qVal = 0.0
 Usage</p><a href="../proc/spc_outflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_outlet_eq.html'>spc_outlet_eq</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet mixture pressure species equilibrium boundary
 kinematic pressure is computed from pressure
 species density and velocity are extrapolated
 Usage</p><a href="../proc/spc_outlet_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_outlet_expol.html'>spc_outlet_expol</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>species Outlet Pressure extrapolation boundary. NOT VERIFIED</p><a href="../proc/spc_outlet_expol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_outlet_vel.html'>spc_outlet_vel</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet species velocity equilibrium boundary with specified
 mixture averaged mass velocity.
 molefraction is extrapolated here.
 Usage</p><a href="../proc/spc_outlet_vel.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_outlet_zero_prsgrd.html'>spc_outlet_zero_prsgrd</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Outlet boundary conditions with zero pressure gradient.</p><a href="../proc/spc_outlet_zero_prsgrd.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_slip_wall.html'>spc_slip_wall</a></td>
                 <td><a href='../module/mus_bc_fluid_wall_module.html'>mus_bc_fluid_wall_module</a></td>
                 <td>Subroutine</td>
                 <td><p>slip-wall boundary condition. Slip defined by a slip factor</p><a href="../proc/spc_slip_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_solvent_inflow.html'>spc_solvent_inflow</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inflow boundary condition for solvent based on non-Equilbrium
 extrapolation method. Similar to spc_velocity_noneq_expol except
 the mass density for solvent is enforced such that total moleDens0 is
 maintained.
 Default qVal=1.0.
 Usage</p><a href="../proc/spc_solvent_inflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_solvent_outflow.html'>spc_solvent_outflow</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Open outflow boundary condition for solvent based on nonequilibrium
 extrapolation. total moledens at boundary is enforced.
 method. Default qVal = 0.0
 Usage</p><a href="../proc/spc_solvent_outflow.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_vel_bb.html'>spc_vel_bb</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet species velocity bounce back boundary with specified
 mixture averaged mass velocity and its molefraction
 mixture kinematic pressure is extrapolated here.
 Usage</p><a href="../proc/spc_vel_bb.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/spc_velocity_noneq_expol.html'>spc_velocity_noneq_expol</a></td>
                 <td><a href='../module/mus_bc_species_module.html'>mus_bc_species_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Velocity boundary condition based on non-Equilbrium extrapolation method.
 Default qVal=1.0.
 Usage</p><a href="../proc/spc_velocity_noneq_expol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/start_stagetimer.html'>start_stageTimer</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/stop_stagetimer.html'>stop_stageTimer</a></td>
                 <td><a href='../module/mus_control_module.html'>mus_control_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swap_da_particle_dps.html'>swap_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>swaps the position of two particles in particle dynamic array
new position of ielem1 = old position of ielem2 and vice-versa
also updates the pidlist and pidsort arrays</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swap_da_particle_mem.html'>swap_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>swaps the position of two particles in particle dynamic array
new position of ielem1 = old position of ielem2 and vice-versa
also updates the pidlist and pidsort arrays</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swap_grw_real2darray.html'>swap_grw_real2darray</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swap_grw_realarray.html'>swap_grw_realarray</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swapfbuff.html'>swapFBuff</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Swap index of the particle force buffer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/swapmomnowmomlast.html'>swapMomNowMomLast</a></td>
                 <td><a href='../module/mus_particle_checks_module.html'>mus_particle_checks_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_append_da_particle.html'>test_append_da_particle</a></td>
                 <td><a href='../module/mus_particle_type_module.html'>mus_particle_type_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_calcvelocityandpressuregradient_dps.html'>test_calcVelocityAndPressureGradient_DPS</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_compute_fluid_momentum.html'>test_compute_fluid_momentum</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_compute_particle_momentum.html'>test_compute_particle_momentum</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_computedisplacement.html'>test_computeDisplacement</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_computewallforces.html'>test_computeWallForces</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_dem_fillneighborlist.html'>test_DEM_fillNeighborList</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_generateelemlistline.html'>test_generateElemListLine</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_global_errorcheck.html'>test_global_errorcheck</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_interpolation_delta_dps_d2q9.html'>test_interpolation_delta_DPS_d2q9</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_interpolation_delta_dps_d3q19.html'>test_interpolation_delta_DPS_d3q19</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_intp1d_peskin.html'>test_intp1D_peskin</a></td>
                 <td><a href='../module/mus_particle_tests_module.html'>mus_particle_tests_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/test_loopoverlocallinks.html'>test_loopOverLocalLinks</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/testparticleconnectivity.html'>testParticleConnectivity</a></td>
                 <td><a href='../module/mus_particle_module.html'>mus_particle_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine for manually checking connectivity of particle elements,
to be removed later</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/tgv_2d.html'>TGV_2D</a></td>
                 <td><a href='../module/mus_interpolate_debug_module.html'>mus_interpolate_debug_module</a></td>
                 <td>Function</td>
                 <td><p>This routine returns the analytical solution of TGV 2D testcase for a given
position and time (coord, t)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/transfermomentumtofluid_dps.html'>transferMomentumToFluid_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine that applies forces from particles to the fluid for unresolved
DPS particles based on the VANS equations</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/transfermomentumtofluid_dps_twoway.html'>transferMomentumToFluid_DPS_twoway</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Routine that applies forces from particles to the fluid for unresolved
DPS two-way coupled particles</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/translate_positions.html'>translate_positions</a></td>
                 <td><a href='../module/mus_particle_blob_module.html'>mus_particle_blob_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/treeidlocalonmyrank.html'>treeIDlocalOnMyRank</a></td>
                 <td><a href='../module/mus_particle_aux_module.html'>mus_particle_aux_module</a></td>
                 <td>Function</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/truncate_da_particle_dps.html'>truncate_da_particle_dps</a></td>
                 <td><a href='../module/mus_particle_dps_type_module.html'>mus_particle_DPS_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>truncate the dynamic particle array to only fit the actual entries</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/truncate_da_particle_mem.html'>truncate_da_particle_mem</a></td>
                 <td><a href='../module/mus_particle_mem_type_module.html'>mus_particle_MEM_type_module</a></td>
                 <td>Subroutine</td>
                 <td><p>truncate the dynamic particle array to only fit the actual entries</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall.html'>turbulent_wall</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall.
 It uses wall model to compute velocity on the boundary node.
 The implementation is based on the following paper:
 Haussmann, Marc; Ries, Florian; Jeppener-Haltenhoff, Jonathan B.; Li,
 Yongxiang; Schmidt, Marius; Welch, Cooper et al. (2020): Evaluation of a
 Near-Wall-Modeled Large Eddy Lattice Boltzmann Method for the Analysis of
 Complex Flows Relevant to IC Engines. In Computation 8 (2), p. 43.
 DOI: 10.3390/computation8020043.</p><a href="../proc/turbulent_wall.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall_eq.html'>turbulent_wall_eq</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall based on equilibrium BC.
 The implementation is based on the following paper:
 Haussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models
 for turbulent channel flows at high Reynolds numbers with a lattice
 Boltzmann method — Application to Coriolis mass flowmeter’, Computers &amp;
 Mathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302.</p><a href="../proc/turbulent_wall_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall_eq_curved.html'>turbulent_wall_eq_curved</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall based on equilibrium BC.
 The implementation is based on the following paper:
 Haussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models
 for turbulent channel flows at high Reynolds numbers with a lattice
 Boltzmann method — Application to Coriolis mass flowmeter’, Computers &amp;
 Mathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302.</p><a href="../proc/turbulent_wall_eq_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall_libb.html'>turbulent_wall_libb</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall.
 It uses wall model to compute velocity on the boundary node.
 The implementation is based on the following paper:
 Haussmann, Marc; Ries, Florian; Jeppener-Haltenhoff, Jonathan B.; Li,
 Yongxiang; Schmidt, Marius; Welch, Cooper et al. (2020): Evaluation of a
 Near-Wall-Modeled Large Eddy Lattice Boltzmann Method for the Analysis of
 Complex Flows Relevant to IC Engines. In Computation 8 (2), p. 43.
 DOI: 10.3390/computation8020043.</p><a href="../proc/turbulent_wall_libb.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall_noneq_expol.html'>turbulent_wall_noneq_expol</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall based on Guo's nonequilibrium extrapolation.
 The implementation is based on the following paper:
 Haussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models
 for turbulent channel flows at high Reynolds numbers with a lattice
 Boltzmann method — Application to Coriolis mass flowmeter’, Computers &amp;
 Mathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302.</p><a href="../proc/turbulent_wall_noneq_expol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/turbulent_wall_noneq_expol_curved.html'>turbulent_wall_noneq_expol_curved</a></td>
                 <td><a href='../module/mus_bc_fluid_turbulent_module.html'>mus_bc_fluid_turbulent_module</a></td>
                 <td>Subroutine</td>
                 <td><p>BC routine for turbulent wall based on Guo's nonequilibrium extrapolation.
 The implementation is based on the following paper:
 Haussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models
 for turbulent channel flows at high Reynolds numbers with a lattice
 Boltzmann method — Application to Coriolis mass flowmeter’, Computers &amp;
 Mathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302.</p><a href="../proc/turbulent_wall_noneq_expol_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_bclists.html'>update_BClists</a></td>
                 <td><a href='../module/mus_construction_module.html'>mus_construction_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update the neighbor stencil positions for the Boundaries</p><a href="../proc/update_bclists.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/update_connectivity.html'>update_connectivity</a></td>
                 <td><a href='../module/mus_geomincr_module.html'>mus_geomIncr_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Construct the propagation stencil for each element</p><a href="../proc/update_connectivity.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatecoordoforigin.html'>updateCoordOfOrigin</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateCoordOfOrigin updates the integer coordinate of
the origin of a particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatecoordoforigin_dps.html'>updateCoordOfOrigin_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateCoordOfOrigin updates the integer coordinate of
the origin of a particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateexclusionlist.html'>updateExclusionList</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>UpdateExclusionList uses the continuous particle position and particle
radius to determine which lattice elements belong to the particle.
These are stored in the 'ExclusionList' of elements which do not participate
in stream-and-collide. It also checks if particles exist or should exist
on some other process and stores this information in the logical masks of
the particle.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateexistsonproc.html'>updateExistsOnProc</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateExistsOnProc updates the mask that tells us whether a particle exists
on our neighboring procs. It does this by checking which processes are intersected
by the bounding box of the particle + a "bumper" of one lattice cell to account
for the fact that a particle can also exist on a proc as purely halos</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateexistsonproc_dps.html'>updateExistsOnProc_DPS</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateExistsOnProc updates the boolean values of the array of neighbor procs
that tell us whether the particle exists on that process or not.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatefluidneighbors.html'>updateFluidNeighbors</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateFluidNeighbors Runs over all particle elements
(those in exclusionList) and then over each stencil direction.
 When it finds a fluid neighbor in a direction it sets
 the bounceback condition for that neighbor</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatenewfluidnodes.html'>updateNewFluidNodes</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateNewFluidNodes restores the correct connectivity for
new fluid elements which were particle elements in the previous time step.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateparticleforces.html'>updateParticleForces</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateparticleowner.html'>updateParticleOwner</a></td>
                 <td><a href='../module/mus_particle_dps_module.html'>mus_particle_DPS_module</a></td>
                 <td>Subroutine</td>
                 <td><p>UpdateParticleOwner updates the "owner process" of each particle,
which is the process responsible for performing operations
(e.g. modifying velocity and position) on the particle and sending
updates to other processes.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updateparticleowner~2.html'>updateParticleOwner</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/updatepositioneuler.html'>updatePositionEuler</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatepositioneuler_dps.html'>updatePositionEuler_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle continuous position using Euler integration </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatepositioneuler_mem.html'>updatePositionEuler_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle continuous position using Euler integration </p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/updatepositionverlet.html'>updatePositionVerlet</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatepositionverlet_dps.html'>updatePositionVerlet_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle position using Verlet integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatepositionverlet_mem.html'>updatePositionVerlet_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle position using Verlet integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatesolidnodes.html'>updateSolidNodes</a></td>
                 <td><a href='../module/mus_particle_mem_module.html'>mus_particle_MEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>updateSolidNodes  modifies connectivity of scheme%pdf%neigh such
that the particle cells do not participate in the streaming process.
Specifically it:
 * runs over the elements in this%exclusionList
 * sets kernel neighbor list values to the particle elements themselves.
 * This way they are effectively excluded from the streaming process.
 * Sets the property bit prp_solid to 1 to indicate elements
   belonging to a particle</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/updatevelocityeuler.html'>updateVelocityEuler</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatevelocityeuler_dps.html'>updateVelocityEuler_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle velocity according to current forces on particle
using Euler integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatevelocityeuler_mem.html'>updateVelocityEuler_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle velocity according to current forces on particle
using Euler integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/updatevelocityverlet.html'>updateVelocityVerlet</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatevelocityverlet_dps.html'>updateVelocityVerlet_DPS</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle velocity using Verlet integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/updatevelocityverlet_mem.html'>updateVelocityVerlet_MEM</a></td>
                 <td><a href='../module/mus_particle_dem_module.html'>mus_particle_DEM_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Update particle velocity using Verlet integration</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/vec_fma.html'>vec_fma</a></td>
                 <td><a href='../module/mus_test_module.html'>mus_test_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Testing routine which performs fused multiplication and addtion on the state
variable. The calculation is simple, so that the cost is mostly due to
the data transfer through the memory interface.</p><a href="../proc/vec_fma.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/vel_neq.html'>vel_neq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Velocity Non-Equilibrium type boundary conditions from
 Guo, Z., &amp; Shi, B. (2002). "Non-equilibrium extrapolation method for
 velocity and pressure boundary conditions in the lattice Boltzmann method."
 Chinese Physics, (November 2016).</p><a href="../proc/vel_neq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_bfl.html'>velocity_bfl</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity BFL rule  boundary condition</p><a href="../proc/velocity_bfl.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_bfl_incomp.html'>velocity_bfl_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/velocity_bfl_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_bounceback.html'>velocity_bounceback</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity Bounce Back boundary condition with qvalues for compressible
flows. It is similar to velocity_bounceback except the density is extrapolated
from fluid element.</p><a href="../proc/velocity_bounceback.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_bounceback_incomp.html'>velocity_bounceback_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity Bounce Back boundary condition with qvalues</p><a href="../proc/velocity_bounceback_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_eq.html'>velocity_eq</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Inlet Velocity Equilibrium type boundary conditions for weakly
 compressible lbm scheme</p><a href="../proc/velocity_eq.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_momentsbased.html'>velocity_momentsbased</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based velocity boundary condition for weakly compressible LBM model
 Based on Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"
  Usage</p><a href="../proc/velocity_momentsbased.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_momentsbased_incomp.html'>velocity_momentsbased_incomp</a></td>
                 <td><a href='../module/mus_bc_fluid_module.html'>mus_bc_fluid_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Moment based velocity boundary condition for incompressible LBM model
 Based on Sam Bennent PhD thesis
 "A Lattice Boltzmann Model for Diffusion of Binary Gas Mixtures"
  Usage</p><a href="../proc/velocity_momentsbased_incomp.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_noneqexpol.html'>velocity_nonEqExpol</a></td>
                 <td><a href='../module/mus_bc_fluid_noneqexpol_module.html'>mus_bc_fluid_nonEqExpol_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Element-wise Dirichlet velocity non-equilibrium boundary condition for
 straight boundary to update all directions.
 For straight wall, values are extrapolated along
 boundary normal instead of along the link and qVal =0.0 for straight wall.</p><a href="../proc/velocity_noneqexpol.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/velocity_noneqexpol_curved.html'>velocity_nonEqExpol_curved</a></td>
                 <td><a href='../module/mus_bc_fluid_noneqexpol_module.html'>mus_bc_fluid_nonEqExpol_module</a></td>
                 <td>Subroutine</td>
                 <td><p>Linkwise Dirichlet velocity non-equilibrium boundary condition for
 curved using the subroutine "mus_set_nonEqExpol".
 For curved wall, values are extrapolated along
 element normal</p><a href="../proc/velocity_noneqexpol_curved.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/viscphy_cs.html'>viscPhy_CS</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Function</td>
                 <td><p>nonNewtonian Casson model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/viscphy_cy.html'>viscPhy_CY</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Function</td>
                 <td><p>nonNewtonian Carreau-Yasuda model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/viscphy_pl.html'>viscPhy_PL</a></td>
                 <td><a href='../module/mus_nonnewtonian_module.html'>mus_nonNewtonian_module</a></td>
                 <td>Function</td>
                 <td><p>nonNewtonian power-law model</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wall_libb.html'>wall_libb</a></td>
                 <td><a href='../module/mus_bc_fluid_wall_module.html'>mus_bc_fluid_wall_module</a></td>
                 <td>Subroutine</td>
                 <td><p>No comment yet!</p><a href="../proc/wall_libb.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/weights_abg.html'>weights_abg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment weights
This follows equation 5 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/weights_from_layout.html'>weights_from_layout</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>allocate weights from D3Q27 ordered disposition to cumulant disposition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/weights_ibg.html'>weights_ibg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment weights
This follows equation 3 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/weights_ijg.html'>weights_ijg</a></td>
                 <td><a href='../module/mus_compute_cumulant_module.html'>mus_compute_cumulant_module</a></td>
                 <td>Function</td>
                 <td><p>Calculating central moment weights
This follows equation 3 in cumulent paper (Geier .et al 2017)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wrapperiodiccoord.html'>wrapPeriodicCoord</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td><p>wrapPeriodicCoord modifies the input coord to take into
account periodicity</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wrapperiodicpos.html'>wrapPeriodicPos</a></td>
                 <td><a href='../module/mus_particle_boundary_module.html'>mus_particle_boundary_module</a></td>
                 <td>Subroutine</td>
                 <td></td>
               </tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              Musubi
 was developed by University of Siegen<br>              &copy; 2025 
<br /><small>64b1e032793c</small></p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
 on 2025-05-18T06:51:20.632862+0000             </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>
  </body>
</html>