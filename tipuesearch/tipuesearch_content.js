var tipuesearch = {"pages":[{"title":" Musubi ","text":"Musubi Introduction to Musubi Musubi is the multi-level parallel lattice Boltzmann solver within the APES\nsuite.\nIt is working on a linearized octree and uses efficient data structures\nallowing adaptive parallel simulations.\nMusubi offers several collision kernels and is designed in a way to deal with\nhuge meshes efficiently. See the documentation for details, tutorials and examples. Developer Info University of Siegen","tags":"home","loc":"index.html"},{"title":"mus_species_type – Musubi ","text":"type, public :: mus_species_type this type contains species parameters Todo KM: extent level dependent parameter for multilevel Inherits type~~mus_species_type~~InheritsGraph type~mus_species_type mus_species_type type~mrt_species_type mrt_species_type type~mus_species_type->type~mrt_species_type mrt Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_species_type~~InheritedByGraph type~mus_species_type mus_species_type type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_species_type species type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: molWeight molecular weight of the species real(kind=rk), public :: molWeightInv Inverse of molecular weight of the species.\nThis parameter is required to convert mass density to mole density real(kind=rk), public :: molWeigRatio ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma i \\f$ real(kind=rk), public, allocatable :: diff_coeff (:) coefficient of diffusivity  of the species (size of nspecies) real(kind=rk), public, allocatable :: resi_coeff (:) coefficient of resisivity of species which is\nreciprocal of diffusivity of the species Todo set diffusivity and resistivity for multilevel type( mrt_species_type ), public :: mrt (globalMaxLevels) molar fraction of this species in the mixture\nVolume fraction of is species in the mixture\nmrt relaxation for each level real(kind=rk), public :: omBulk bulk relaxation parameter\nomBulk_k = (2-phi_k)/3*bulkViscosity real(kind=rk), public :: ombulkLvl (globalMaxLevels) bulk relaxation parameter for each level real(kind=rk), public :: omega relaxation parameter for Nernst-Planck equation real(kind=rk), public :: lambda relaxation parameter for trt scheme real(kind=rk), public :: chargeNr charge number of the species","tags":"","loc":"type/mus_species_type.html"},{"title":"mrt_species_type – Musubi ","text":"type, private :: mrt_species_type MRT species type Inherited by type~~mrt_species_type~~InheritedByGraph type~mrt_species_type mrt_species_type type~mus_species_type mus_species_type type~mus_species_type->type~mrt_species_type mrt type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_species_type species type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: s_mrt (:,:) relaxation matrix for mrt\nsize of this matrix is (layout%QQ, layout%QQ) real(kind=rk), public, allocatable :: omegaMoments (:,:) transformed relaxation matrix-moments factor\nomegaMoments = (Moments&#94;-1.s_mrt.Moments)\n              .(I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1 real(kind=rk), public, allocatable :: omegaMomForce (:,:) Omega factor for 2nd order force term\nomegaMomForce = (I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1","tags":"","loc":"type/mrt_species_type.html"},{"title":"mus_hvs_config_type – Musubi ","text":"type, public :: mus_hvs_config_type This datatype describes the various settings to load from the configuration\nfile. Inherits type~~mus_hvs_config_type~~InheritsGraph type~mus_hvs_config_type mus_hvs_config_type hvs_output_config_type hvs_output_config_type type~mus_hvs_config_type->hvs_output_config_type output Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=pathLen), public :: prefix Location on disk to load the mesh data from. This prefix will be put before the various filenames of the individual\nmesh data files. type( hvs_output_config_type ), public :: output Description of how the visualization output should be done.","tags":"","loc":"type/mus_hvs_config_type.html"},{"title":"mus_moment_type – Musubi ","text":"type, public :: mus_moment_type moment space definition Inherits type~~mus_moment_type~~InheritsGraph type~mus_moment_type mus_moment_type tem_matrix_type tem_matrix_type type~mus_moment_type->tem_matrix_type toMoments, toPDF Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_moment_type~~InheritedByGraph type~mus_moment_type mus_moment_type type~mus_scheme_layout_type mus_scheme_layout_type type~mus_scheme_layout_type->type~mus_moment_type moment type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_scheme_layout_type layout Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: mom_ready = .false. is true if this type is already filled and no need\nto fill again after load balancing type( tem_matrix_type ), public :: toMoments transformation matrix from pdf space to moments type( tem_matrix_type ), public :: toPDF transformation matrix from moment space to pdf character(len=labelLen), public, allocatable :: momLabel (:) Labels of the moments integer, public, allocatable :: first_moments (:) position of first order moments in moments vector integer, public, allocatable :: second_moments (:) position of second order moments in moments vector integer, public, allocatable :: third_moments (:) position of third order moments in moments vector integer, public, allocatable :: fourth_moments (:) position of fourth order moments in moments vector","tags":"","loc":"type/mus_moment_type.html"},{"title":"mus_statistics_type – Musubi ","text":"type, public :: mus_statistics_type runtime statistics\nthis includes memory consumption, amount of data to communciate,\nruntimes etc. Components Type Visibility Attributes Name Initial integer, public :: nLinks_comm = 0 number of links to communicate\nSubset of nLinks_total integer, public :: nLinks_total = 0 number of total links available which theoretically can be communciated integer, public :: nProcs_send = 0 Mean number of neighbor processes to which one process needs to send","tags":"","loc":"type/mus_statistics_type.html"},{"title":"mus_nernstPlanck_type – Musubi ","text":"type, public :: mus_nernstPlanck_type Contains configuration to calculate nernst_planck equation.\nMore information can be found in\nA Coupled Lattice Boltzmann Method to Solve Nernst_Planck Model for\nsimulating Electro-Osmatic Flows by Yang x., Shi B., Chai Z., Guo Z. Inherited by type~~mus_nernstplanck_type~~InheritedByGraph type~mus_nernstplanck_type mus_nernstPlanck_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_nernstplanck_type nernstPlanck Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: temp abosulte temperature in Kelvin real(kind=rk), public :: moleDens Molar density of ions","tags":"","loc":"type/mus_nernstplanck_type.html"},{"title":"mus_fluid_type – Musubi ","text":"type, public :: mus_fluid_type collection of properties of the fluid Inherits type~~mus_fluid_type~~InheritsGraph type~mus_fluid_type mus_fluid_type mus_nNwtn_type mus_nNwtn_type type~mus_fluid_type->mus_nNwtn_type nNwtn type~mus_turbulence_type mus_turbulence_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_viscosity_type mus_viscosity_type type~mus_fluid_type->type~mus_viscosity_type viscKine type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_turbulence_data_type mus_turbulence_data_type type~mus_turbulence_type->type~mus_turbulence_data_type dataOnLvl type~mus_turbulence_visc_proc_type mus_turbulence_visc_proc_type type~mus_turbulence_type->type~mus_turbulence_visc_proc_type calcVisc grw_realarray_type grw_realarray_type type~mus_viscosity_type->grw_realarray_type dataOnLvl tem_spacetime_fun_type tem_spacetime_fun_type type~mus_viscosity_type->tem_spacetime_fun_type STfun type~mus_relaxationparam_type mus_relaxationParam_type type~mus_viscosity_type->type~mus_relaxationparam_type omLvl type~les_coeff_type les_coeff_type type~mus_turbulence_config_type->type~les_coeff_type coeff tem_communication_type tem_communication_type type~mus_turbulence_data_type->tem_communication_type sendBuffer, recvBuffer, sendBufferFromCoarser, sendBufferFromFiner, recvBufferFromCoarser, recvBufferFromFiner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_fluid_type~~InheritedByGraph type~mus_fluid_type mus_fluid_type type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active = .false. real(kind=rk), public :: lambda = 0.25_rk Magic value for TRT collision model\nLambda = ( 1/omega_+ - 0.5 ) * ( 1/omega_- - 0.5 ) real(kind=rk), public, allocatable :: omegaBulkLvl (:) level-wise bulk omegas, used as relaxation in mrt model\nallocated in mus_init_fluid real(kind=rk), public, allocatable :: viscBulkLvl (:) Level wise bulk viscosity in lattice type( mus_turbulence_type ), public :: turbulence Contains information for turbulence model type(mus_nNwtn_type), public :: nNwtn nonNewtonian fluid parameter procedure(mus_proc_mrt), public, nopass, pointer :: mrtPtr => null() function pointer to get MRT diagonal relaxation matrix type( mus_viscosity_type ), public :: viscKine kinematic viscosity\n\\todo KM: implement interpolation routine for constant viscosity real(kind=rk), public :: viscBulk_phy real(kind=rk), public :: force (3) real(kind=rk), public :: HRR_sigma = 0.98_rk real(kind=rk), public :: DRT_tauN = 0.70_rk real(kind=rk), public :: omega_Cum (10) real(kind=rk), public :: omega_Lim (3)","tags":"","loc":"type/mus_fluid_type.html"},{"title":"mus_mixture_type – Musubi ","text":"type, public :: mus_mixture_type This type contains mixture information Todo KM: implement parameters which depend on dx and dt for all levels Inherits type~~mus_mixture_type~~InheritsGraph type~mus_mixture_type mus_mixture_type tem_ini_condition_type tem_ini_condition_type type~mus_mixture_type->tem_ini_condition_type ic tem_spatial_type tem_spatial_type type~mus_mixture_type->tem_spatial_type viscSpatial tem_temporal_type tem_temporal_type type~mus_mixture_type->tem_temporal_type omega_ramping type~mixrelaxation_type mixRelaxation_type type~mus_mixture_type->type~mixrelaxation_type relaxLvl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_mixture_type~~InheritedByGraph type~mus_mixture_type mus_mixture_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_mixture_type mixture Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_ini_condition_type ), public :: ic initialization case, initial condition of the mixture real(kind=rk), public :: rho0 mass density of the mixture\nSI unit: kg/m&#94;3.\nPhysics to lattice conversion: rho0/physics%rho0 real(kind=rk), public :: rho0LB lattice mass density of the mixture real(kind=rk), public :: moleDens0 number density of the mixture or total mixture molar density\nSI unit: mol/m&#94;3.\nphysics to lattice conversion:\nnT0/physics%mol*physics%fac(minlevel)%length&#94;3.\nmixture molar density is required if initial condition\nare defined by molar fraction.\nset only if initial molefraction is space independent real(kind=rk), public :: moleDens0LB lattice number density of the mixture or total mixture molar density\nphysics to lattice conversion:\nmoleDens0/physics%mol*physics%fac(minlevel)%length&#94;3. real(kind=rk), public :: kine_viscosityLB lattice kinematic shear viscosity of the mixture real(kind=rk), public :: kine_viscosity physical kinematic shear viscosity of the mixture real(kind=rk), public :: bulk_viscosityLB lattice bulk viscosity real(kind=rk), public :: bulk_viscosity physical bulk viscosity real(kind=rk), public :: bulk_modulusLB lattice bulk modulus of the liquid mixture , - speed of sound (in lattice unit: \\f$ 1/\\sqrt{3} \\f$ real(kind=rk), public :: omega_diff relaxation parameter, , B - free parameter unit same as resistivity real(kind=rk), public :: omega_kine real(kind=rk), public :: omega_hom omega for higher order moments type( mixRelaxation_type ), public :: relaxLvl (globalMaxLevels) relaxation parameters for each level type( tem_temporal_type ), public :: omega_ramping temporal omega for ramping etc. real(kind=rk), public :: paramB free parameter\n\\f$ B = \\omega*\\rho/K \\f$ real(kind=rk), public :: temp0 temperature real(kind=rk), public :: temp0LB temperature real(kind=rk), public :: theta_eq equilibrium theta to choose between mixture velocity\nand equilibrium species velocity in the quadratic term\nequilibrium function.\ntheta = 0 -> mixture velocity\ntheta = 1 -> equilibrium species velocity\n\\todo KM: remove theta_eq and use\nmixture velocity in quadratic term of equilibrium function type( tem_spatial_type ), public :: viscSpatial spatial omega definition, e.g. for sponge layers real(kind=rk), public :: electricField (3) external electrical force real(kind=rk), public :: gravityField (3) gravitational force real(kind=rk), public :: faraday faraday constant(C/mol) real(kind=rk), public :: faradayLB faraday constant in lattice real(kind=rk), public :: gasConst_R gas constant R (Nm/(mol *K)) real(kind=rk), public :: gasConst_R_LB gas constant R in lattice character(kind=c_char, len=labelLen), public :: prop_file eNRTL file with species properties real(kind=rk), public :: atm_press atmospheric pressure real(kind=rk), public :: atm_pressLB atmospheric pressure","tags":"","loc":"type/mus_mixture_type.html"},{"title":"mixRelaxation_type – Musubi ","text":"type, private :: mixRelaxation_type relaxation paraemters multispecies required for each level Inherited by type~~mixrelaxation_type~~InheritedByGraph type~mixrelaxation_type mixRelaxation_type type~mus_mixture_type mus_mixture_type type~mus_mixture_type->type~mixrelaxation_type relaxLvl type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_mixture_type mixture Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: visc lattice shear viscosity of the mixture for different level real(kind=rk), public :: paramB lattice free parameter B for different level real(kind=rk), public :: bulkVisc lattice bulk viscosity for different level real(kind=rk), public :: omega_diff relaxation parameter, , B - free parameter unit same as resistivity real(kind=rk), public :: omega_kine","tags":"","loc":"type/mixrelaxation_type.html"},{"title":"pdf_data_type – Musubi ","text":"type, public :: pdf_data_type This level-wise data type contains the PDF arrays which are fed into the\nkernel.\nThe solver updates the state vector and finds the position of the neighbor\nvectors by looking it up in the neigh array Inherited by type~~pdf_data_type~~InheritedByGraph type~pdf_data_type pdf_data_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~pdf_data_type pdf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: nElems_fluid number of local fluid elements integer, public :: nElems_halo number of halo elements (from remote processes) integer, public :: nElems_ghostFromCoarser number of ghost elements (from other levels) integer, public :: nElems_ghostFromFiner number of ghost elements (from other levels) integer, public :: nElems_ghost number of ghost elements (from other levels) integer, public :: nElems_local number of local elements (fluid+halos+ghost) integer, public :: nElems_solve fluid elements + ghostFromCoarser elements (elements for solver).\nPDF and auxFied are interpolated for ghostFromFiner and there is no\nneed to do collision on these elements. integer, public :: nElems_computed fluid elements + ghostFromCoarse + ghostFromFiner integer, public :: nSize number of elements padded to 4 integer, public :: nNow = 1 which buffer to use for current time step integer, public :: nNext = 2 which buffer to use for next time step integer, public, allocatable, dimension(:) :: neigh Connectivity array\nPoints to where to send respective pdfs\nAccess in a neigh way\nSize: QQ * nSize\nallocated in routine: mus_pdf_allocate real(kind=rk), public, allocatable, dimension(:) :: bcBuffer containing state vector values of elements which have a boundary\nIt always uses AOS data layout\nallocated in routine: mus_pdf_allocate\nfilled for each iteration in routine: fill_bcBuffer real(kind=rk), public, allocatable :: momBuf (:,:) Buffer storing the moments of all source from Coarser","tags":"","loc":"type/pdf_data_type.html"},{"title":"mus_turb_wallFunc_type – Musubi ","text":"type, public :: mus_turb_wallFunc_type Contains function pointers to compute friction velocity and stream-wise\nvelocity component Inherits type~~mus_turb_wallfunc_type~~InheritsGraph type~mus_turb_wallfunc_type mus_turb_wallFunc_type type~mus_turb_wallfunc_data_type mus_turb_wallFunc_data_type type~mus_turb_wallfunc_type->type~mus_turb_wallfunc_data_type dataOnLvl type~mus_wall_function_type mus_wall_function_type type~mus_turb_wallfunc_type->type~mus_wall_function_type wall_function Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. is true if wall function is active character(len=labelLen), public :: wall_func Wall model function character(len=labelLen), public :: nonlinear_solver Nonlinear solver type real(kind=rk), public :: vonKarman = 0.4_rk Von-Karman constant. Default = 0.4_rk logical, public :: useVanDriest = .true. Use vanDriest damping function to damp turbulent viscosity type( mus_turb_wallFunc_data_type ), public, allocatable :: dataOnLvl (:) Contains data computed in turbulent wall bc routine on each level procedure( mus_proc_calcFricVel ), public, pointer, pass(this) :: calcFricVel => null() Function pointer to compute friction velocity procedure( mus_proc_calcStreamWiseVel ), public, pointer, nopass :: calcStreamWiseVel => null() Function pointer to compute strean-wise velocity component class( mus_wall_function_type ), public, allocatable :: wall_function Allocate wall function object procedure( mus_iterative_method_interface ), public, pointer, nopass :: iterativeMethod => null() Function pointer to the iterative method","tags":"","loc":"type/mus_turb_wallfunc_type.html"},{"title":"mus_turb_wallFunc_data_type – Musubi ","text":"type, private :: mus_turb_wallFunc_data_type Contains friction velocity and turbulent viscosity on boundary elements on\neach level Inherited by type~~mus_turb_wallfunc_data_type~~InheritedByGraph type~mus_turb_wallfunc_data_type mus_turb_wallFunc_data_type type~mus_turb_wallfunc_type mus_turb_wallFunc_type type~mus_turb_wallfunc_type->type~mus_turb_wallfunc_data_type dataOnLvl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: tVisc (:) Turbulent viscosity on boundary element computed using mixing length\nformulation in lattice unit\nnu_t = (vonKarman distToBnd) *2 * |du/dy| real(kind=rk), public, allocatable :: velTau (:) Friction velocity on first neighbor in normal direction in lattice unit\ncomputed from wall model real(kind=rk), public, allocatable :: distToBnd (:) Distance to boundary from first fluid in normal direction\nin lattice unit. real(kind=rk), public, allocatable :: neighDistToBnd (:) Distance to boundary from first fluid neighbor in normal direction\nin lattice unit. real(kind=rk), public, allocatable :: unitNormal (:,:) Unit normal for each boundary element.\nSize: (3, nElems) real(kind=rk), public, allocatable :: bndForce (:,:) Force on each boundary element.\nSize: (3, nElems) real(kind=rk), public, allocatable :: bndMoment (:,:) Moment on each boundary element.\nSize: (3, nElems)","tags":"","loc":"type/mus_turb_wallfunc_data_type.html"},{"title":"mus_relaxation_header_type – Musubi ","text":"type, public :: mus_relaxation_header_type Datatype containing additional options for the relaxation like variant and\nother variant specific parameters Inherited by type~~mus_relaxation_header_type~~InheritedByGraph type~mus_relaxation_header_type mus_relaxation_header_type type~mus_scheme_header_type mus_scheme_header_type type~mus_scheme_header_type->type~mus_relaxation_header_type relaxHeader type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_scheme_header_type header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: variant Varaint name of the relaxation. Set to \"default\" to select default\nrelaxation real(kind=rk), public :: regularization_omega Addtional information to load for regularited bgk like\n\"regularized\", \"recursive_regularited\" and \"hybrid_recursive_regularized\"\nvariant.","tags":"","loc":"type/mus_relaxation_header_type.html"},{"title":"mus_scheme_header_type – Musubi ","text":"type, public :: mus_scheme_header_type Datatype containing information to identify the scheme Combination of scheme kind, relaxation and layout%stencilKind\n are used to choose the correct compute kernel for the\n scheme type options kind fluid (default) fluid_incompressible isotherm_acEq multispecies_gas multispecies_liquid nernst_planck passive_scalar poisson poisson_boltzmann_linear poisson_boltzmann_nonlinear ------ --------------------------------- layout d2q9 d3q19 (default) d3q27 d1q3 d2q5 d3q6 d3q7 d3q13 d3q15 flekkoy -------- -------------------- relaxation bgk (default) mrt trt bgk_withthermodynfac mrt_withthermodynfac cumulant cascaded vec_fma test bgk_noFluid ------------ -------------------------- variant for bgk relaxation standard (default) improved block mrt ------------------------------------------------------------ Inherits type~~mus_scheme_header_type~~InheritsGraph type~mus_scheme_header_type mus_scheme_header_type type~mus_relaxation_header_type mus_relaxation_header_type type~mus_scheme_header_type->type~mus_relaxation_header_type relaxHeader Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_scheme_header_type~~InheritedByGraph type~mus_scheme_header_type mus_scheme_header_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_scheme_header_type header Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: kind scheme kind, Ex: fluid, fluid_incompressible, multispecies_gas,\nmultispecies_liquid, poisson, poisson_boltzmann_linear,\npoisson_boltzmann_nonlinear, nernst_planck, isotherm_acEq character(len=labelLen), public :: layout scheme layout, Ex: d3q19 character(len=labelLen), public :: relaxation scheme relaxation type Ex: BGK, MRT, bgk_pl, bgk_cy, bgk_cs... type( mus_relaxation_header_type ), public :: relaxHeader Variant and additional options for a relaxation","tags":"","loc":"type/mus_scheme_header_type.html"},{"title":"mus_wall_function_schmitt_type – Musubi ","text":"type, public, extends( mus_wall_function_type ) :: mus_wall_function_schmitt_type extend the abstract subclass mus_wall_function_type Inherits type~~mus_wall_function_schmitt_type~~InheritsGraph type~mus_wall_function_schmitt_type mus_wall_function_schmitt_type type~mus_wall_function_type mus_wall_function_type type~mus_wall_function_schmitt_type->type~mus_wall_function_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, nopass :: get_uPlus function to get uPlus private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) procedure, public, nopass :: get_d_uPlus_d_uTau function to apply the newton method private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"type/mus_wall_function_schmitt_type.html"},{"title":"mus_HRRCorrectionTerm_type – Musubi ","text":"type, public :: mus_HRRCorrectionTerm_type Stores correction term for HRR_bgk Inherited by type~~mus_hrrcorrectionterm_type~~InheritedByGraph type~mus_hrrcorrectionterm_type mus_HRRCorrectionTerm_type type~mus_source_elems_type mus_source_elems_type type~mus_source_elems_type->type~mus_hrrcorrectionterm_type HRR_Corr type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dens (:) density real(kind=rk), public, allocatable :: vel (:,:) velocity","tags":"","loc":"type/mus_hrrcorrectionterm_type.html"},{"title":"mus_turbChannelForce_type – Musubi ","text":"type, public :: mus_turbChannelForce_type Contains information to compute average bulk velocity for dynamic_force.\nIn turb_channel_force, the force term is adapted according to difference\nbetween reference bulk velocity and simulated plane average bulk velocity\nto avoid linear increase in simulated bulk velocits.\nFor more information:\nhttps://www.wias-berlin.de/people/john/ELECTRONIC_PAPERS/JR07.IJNMF.pdf Inherits type~~mus_turbchannelforce_type~~InheritsGraph type~mus_turbchannelforce_type mus_turbChannelForce_type tem_shape_type tem_shape_type type~mus_turbchannelforce_type->tem_shape_type geom_utau, geom_umean tem_subTree_type tem_subTree_type type~mus_turbchannelforce_type->tem_subTree_type subTree_utau, subTree_umean Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_turbchannelforce_type~~InheritedByGraph type~mus_turbchannelforce_type mus_turbChannelForce_type type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_turbchannelforce_type turbChanForce type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_shape_type ), public :: geom_utau (1) tracking shapes type( tem_shape_type ), public :: geom_umean (1) type( tem_subTree_type ), public :: subTree_utau sub-tree resulting from the elements within the tracking shape\nThe sub-tree also holds the sub-communicator\nThis data needs to be UPDATED after balance type( tem_subTree_type ), public :: subTree_umean real(kind=rk), public :: refVelBulk Reference bulk velocity in physical unit real(kind=rk), public :: refHeight Characteristic height in physical unit integer, public :: flow_direction Stream-wise direction to compute average velocity\nx=1, y=2, z=3 real(kind=rk), public :: forceDyn (3) Dynamic Force term for turbulent channel in physical unit [m/s&#94;2]\nF_dyn = (refVelBulk-avgVelXBulk) * refVelBulk / refHeight integer, public :: nElemsGlobal_utau Global number of elements in defined shape integer, public :: nElemsGlobal_umean","tags":"","loc":"type/mus_turbchannelforce_type.html"},{"title":"mus_source_op_type – Musubi ","text":"type, public :: mus_source_op_type Description contains list of elements on which source is active and\nfunction pointer to update source Inherits type~~mus_source_op_type~~InheritsGraph type~mus_source_op_type mus_source_op_type type~mus_absorblayer_type mus_absorbLayer_type type~mus_source_op_type->type~mus_absorblayer_type absLayer type~mus_source_elems_type mus_source_elems_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_turbchannelforce_type mus_turbChannelForce_type type~mus_source_op_type->type~mus_turbchannelforce_type turbChanForce type~absorblayer_config_type absorbLayer_config_type type~mus_absorblayer_type->type~absorblayer_config_type config type~mus_absorblayer_dynavg_type mus_absorbLayer_dynAvg_type type~mus_source_elems_type->type~mus_absorblayer_dynavg_type dynAvg type~mus_hrrcorrectionterm_type mus_HRRCorrectionTerm_type type~mus_source_elems_type->type~mus_hrrcorrectionterm_type HRR_Corr tem_shape_type tem_shape_type type~mus_turbchannelforce_type->tem_shape_type geom_utau, geom_umean tem_subTree_type tem_subTree_type type~mus_turbchannelforce_type->tem_subTree_type subTree_utau, subTree_umean Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_source_op_type~~InheritedByGraph type~mus_source_op_type mus_source_op_type type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: srcTerm_varPos Position of this source term variable in the varSys integer, public :: data_varPos Position of data variable provided in config file in the varSys type( mus_source_elems_type ), public, allocatable :: elemLvl (:) Contains source elements position in state array/total list for\neach level procedure( proc_apply_source ), public, pointer :: applySrc => null() Function to update state with source term character(len=labelLen), public :: varname to use source field array\nname of the source variable procedure( proc_addSrcToAuxField ), public, pointer :: addSrcToAuxField => null() Function pointer to append source field to auxilary variable procedure( proc_updateSourceVar ), public, pointer :: updateSourceVar => null() Function pointer to update source variable which are dependent on\nauxField. integer, public :: order Order of approximation for source like force, electric_field,\ncharge_density.\nOrder = 1, uses force term in BE approximated by forward Euler method\nOrder = 2, uses force term in BE approximated by Trapezoidal method.\nFor order 2, macroscopic source is also added to auxField.\nFor fluid, fluid_incompressible, multispecies_liquid: source is added\nto momentum and for poisson: source is added to potential.\nDefault: order = 2. type( mus_absorbLayer_type ), public :: absLayer Additional config information for absorbLayer type( mus_turbChannelForce_type ), public :: turbChanForce Contains information to compute average bulk velocity for dynamic_force","tags":"","loc":"type/mus_source_op_type.html"},{"title":"mus_source_type – Musubi ","text":"type, public :: mus_source_type Description of musubi source type Inherits type~~mus_source_type~~InheritsGraph type~mus_source_type mus_source_type grw_stringkeyvaluepairarray_type grw_stringkeyvaluepairarray_type type~mus_source_type->grw_stringkeyvaluepairarray_type varDict type~mus_source_op_type mus_source_op_type type~mus_source_type->type~mus_source_op_type method type~mus_absorblayer_type mus_absorbLayer_type type~mus_source_op_type->type~mus_absorblayer_type absLayer type~mus_source_elems_type mus_source_elems_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_turbchannelforce_type mus_turbChannelForce_type type~mus_source_op_type->type~mus_turbchannelforce_type turbChanForce type~absorblayer_config_type absorbLayer_config_type type~mus_absorblayer_type->type~absorblayer_config_type config type~mus_absorblayer_dynavg_type mus_absorbLayer_dynAvg_type type~mus_source_elems_type->type~mus_absorblayer_dynavg_type dynAvg type~mus_hrrcorrectionterm_type mus_HRRCorrectionTerm_type type~mus_source_elems_type->type~mus_hrrcorrectionterm_type HRR_Corr tem_shape_type tem_shape_type type~mus_turbchannelforce_type->tem_shape_type geom_utau, geom_umean tem_subTree_type tem_subTree_type type~mus_turbchannelforce_type->tem_subTree_type subTree_utau, subTree_umean Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_source_type~~InheritedByGraph type~mus_source_type mus_source_type type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( mus_source_op_type ), public, allocatable :: method (:) Contains source elements position in tree%treeID and\nfunction pointer to update source\nSize: varDict%nVals type( grw_stringkeyvaluepairarray_type ), public :: varDict Dictionary of source variable with\nvarDict%val()%key is the name of source variable and\nvarDict%val()%value is the name of variable provided for the key","tags":"","loc":"type/mus_source_type.html"},{"title":"mus_source_elems_type – Musubi ","text":"type, private :: mus_source_elems_type Contains source elements position in state array and idx to access\ndata variable refered in config file.\nThis type is defined for each level Inherits type~~mus_source_elems_type~~InheritsGraph type~mus_source_elems_type mus_source_elems_type type~mus_absorblayer_dynavg_type mus_absorbLayer_dynAvg_type type~mus_source_elems_type->type~mus_absorblayer_dynavg_type dynAvg type~mus_hrrcorrectionterm_type mus_HRRCorrectionTerm_type type~mus_source_elems_type->type~mus_hrrcorrectionterm_type HRR_Corr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_source_elems_type~~InheritedByGraph type~mus_source_elems_type mus_source_elems_type type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: nElems Number of source elements on this level.\nnFluids + nGhosts integer, public, allocatable :: posInTotal (:) Position of elements in state array to apply source terms.\nPosition in state array is same as position in total list\nSize: nElems integer, public, allocatable :: idx (:) Index to access point data type to retrieve values from variable\nrefered for source variable type( mus_absorbLayer_dynAvg_type ), public :: dynAvg source field value obtained from ST_fun data variable.\nFilled only for elements where source is active i.e. elements in\nposInTotal.\nsize: nElems*nComponents\n\\todo KM: might be not neccessary\nContains time average values of density and velocity for dynamic\nabsorblayer.\n\\todo KM: 02042021 Introduce method_data c_ptr and point to\ndynAvg for absorbLayer and change intent(inout) to intent(in) in\nproc_addSrcToAuxField. type( mus_HRRCorrectionTerm_type ), public :: HRR_Corr","tags":"","loc":"type/mus_source_elems_type.html"},{"title":"mus_auxFieldVar_type – Musubi ","text":"type, public :: mus_auxFieldVar_type Contains auxiliary field variable values per level and communication\nbuffers Inherits type~~mus_auxfieldvar_type~~InheritsGraph type~mus_auxfieldvar_type mus_auxFieldVar_type tem_communication_type tem_communication_type type~mus_auxfieldvar_type->tem_communication_type sendBuffer, sendBufferFromCoarser, sendBufferFromFiner, recvBuffer, recvBufferFromCoarser, recvBufferFromFiner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_auxfieldvar_type~~InheritedByGraph type~mus_auxfieldvar_type mus_auxFieldVar_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_auxfieldvar_type auxField Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: val (:) auxiliary field variable values computed from pre-collision PDF\nafter PDF exchange\nSize: nSize nScalars\nElement order is same as state array\nAccess: (iElem-1) nScalars + varSys%method%val(iVar)%auxField_varPos\nSee mus_append_auxField for the name of the variable stored in this\narray as it depends on the scheme kind. type( tem_communication_type ), public :: sendBuffer Local Fluids required by remote processes type( tem_communication_type ), public :: sendBufferFromCoarser Local ghostFromCoarser required by remote processes type( tem_communication_type ), public :: sendBufferFromFiner Local ghostFromFiner required by remote processes type( tem_communication_type ), public :: recvBuffer My halos which are fluids on remote processes type( tem_communication_type ), public :: recvBufferFromCoarser My halos which are ghostFromCoarser on remote processes type( tem_communication_type ), public :: recvBufferFromFiner My halos which are ghostFromFiner on remote processes","tags":"","loc":"type/mus_auxfieldvar_type.html"},{"title":"mus_derVarPos_type – Musubi ","text":"type, public :: mus_derVarPos_type This type stores the position of each variable in the global sys Inherited by type~~mus_dervarpos_type~~InheritedByGraph type~mus_dervarpos_type mus_derVarPos_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_dervarpos_type derVarPos Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: pdf = -1 integer, public :: fetch_pdf = -1 integer, public :: omega = -1 integer, public :: density = -1 integer, public :: moleDensity = -1 integer, public :: pressure = -1 integer, public :: kinePress = -1 integer, public :: velocity = -1 integer, public :: spc_velocities = -1 integer, public :: velMag = -1 integer, public :: momentum = -1 integer, public :: spc_momenta = -1 integer, public :: shearStress = -1 integer, public :: wss = -1 integer, public :: shearMag = -1 integer, public :: strainRate = -1 integer, public :: shearRate = -1 integer, public :: kineticEnergy = -1 integer, public :: temperature = -1 integer, public :: moleFrac = -1 integer, public :: massFrac = -1 integer, public :: moleflux = -1 integer, public :: equilibrium = -1 integer, public :: nonEquilibrium = -1 integer, public :: equilibriumVel = -1 integer, public :: potential = -1 procedure( derive_FromMacro ), public, pointer, nopass :: equilFromMacro => null() procedure( derive_FromState ), public, pointer, nopass :: velFromState => null() procedure( derive_FromState ), public, pointer, nopass :: equilFromState => null() procedure( derive_FromState ), public, pointer, nopass :: momFromState => null() procedure( derive_FromState ), public, pointer, nopass :: velocitiesFromState => null() procedure( derive_FromState ), public, pointer, nopass :: momentaFromState => null() procedure( derive_FromPreColState ), public, pointer, nopass :: velFromPreColState => null() procedure( derive_auxFromState ), public, pointer :: auxFieldFromState => null() return auxField from local pdf state procedure( derive_equilFromAux ), public, pointer, nopass :: equilFromAux => null() return equilibrium from auxilary variable for given nElems","tags":"","loc":"type/mus_dervarpos_type.html"},{"title":"mus_poisson_type – Musubi ","text":"type, public :: mus_poisson_type Contains information to solve the poission equation Inherits type~~mus_poisson_type~~InheritsGraph type~mus_poisson_type mus_poisson_type type~mus_poisson_boltzmann_type mus_poisson_boltzmann_type type~mus_poisson_type->type~mus_poisson_boltzmann_type PB Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_poisson_type~~InheritedByGraph type~mus_poisson_type mus_poisson_type type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_poisson_type poisson type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: pot_diff Potential diffusivty to tune omega and stability real(kind=rk), public :: omega relaxation parameter real(kind=rk), public :: permittivity the dielectric constant C&#94;2 J&#94;-1 m&#94;-1 type( mus_poisson_boltzmann_type ), public :: PB information of poisson boltmann equation","tags":"","loc":"type/mus_poisson_type.html"},{"title":"mus_poisson_boltzmann_type – Musubi ","text":"type, private :: mus_poisson_boltzmann_type Contains information to calculate rhs for poisson boltzmann equation.\nDefinition of linear and non-linear poisson boltzmann equation\ncan be found in\nMasilamani, K. (2010). WaLBerla : Investigation of Electrostatic Effects\nin Particulate and Electro-Osmotic Flows. Master Thesis.\nFRIEDRICH-ALEXANDER-UNIVERSITÄT ERLANGEN-NÜRNBERG. Inherited by type~~mus_poisson_boltzmann_type~~InheritedByGraph type~mus_poisson_boltzmann_type mus_poisson_boltzmann_type type~mus_poisson_type mus_poisson_type type~mus_poisson_type->type~mus_poisson_boltzmann_type PB type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_poisson_type poisson type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active Neccesary if source term is poisson_boltzmann real(kind=rk), public :: temp abosulte temperature in Kelvin integer, public :: nIons Number of ions integer, public, allocatable :: valence (:) valence of the ion\nsize: nions real(kind=rk), public :: moleDens0 Mole density of ions in the bulk real(kind=rk), public :: RHS_coeff RHS coeff for linear poisson boltzmann equation real(kind=rk), public :: gasConst_R_LB Gas constant in lattice unit real(kind=rk), public :: faradayLB Faraday constant in lattice unit Boltzmann constant in lattice unit Fundamental charge in lattice unit","tags":"","loc":"type/mus_poisson_boltzmann_type.html"},{"title":"mus_turbulence_config_type – Musubi ","text":"type, public :: mus_turbulence_config_type Contains turbulence information loaded from config file Inherits type~~mus_turbulence_config_type~~InheritsGraph type~mus_turbulence_config_type mus_turbulence_config_type type~les_coeff_type les_coeff_type type~mus_turbulence_config_type->type~les_coeff_type coeff Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_turbulence_config_type~~InheritedByGraph type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_type mus_turbulence_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: model turbulence model type type( les_coeff_type ), public :: coeff les model coefficients logical, public :: compSR_fromPDF = .false. To compute strain-rate from non-equilibrium PDF for Smagorinsky les model.\nIf true then velocity and grad data are not required logical, public :: useKolmogorovScale = .true. Use Kolmogorov scale for interpolation turbulent viscosity for multilevel","tags":"","loc":"type/mus_turbulence_config_type.html"},{"title":"mus_turbulence_data_type – Musubi ","text":"type, public :: mus_turbulence_data_type Contains velocity and gradient data to compute eddy viscosity Inherits type~~mus_turbulence_data_type~~InheritsGraph type~mus_turbulence_data_type mus_turbulence_data_type tem_communication_type tem_communication_type type~mus_turbulence_data_type->tem_communication_type sendBuffer, recvBuffer, sendBufferFromCoarser, sendBufferFromFiner, recvBufferFromCoarser, recvBufferFromFiner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_turbulence_data_type~~InheritedByGraph type~mus_turbulence_data_type mus_turbulence_data_type type~mus_turbulence_type mus_turbulence_type type~mus_turbulence_type->type~mus_turbulence_data_type dataOnLvl type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_communication_type ), public :: sendBuffer Communication buffers to communicate visoscity field\nLocal Fluids required by remote processes type( tem_communication_type ), public :: recvBuffer My halos which are fluids on remote processes type( tem_communication_type ), public :: sendBufferFromCoarser Local ghostFromCoarser required by remote processes type( tem_communication_type ), public :: sendBufferFromFiner Local ghostFromFiner required by remote processes type( tem_communication_type ), public :: recvBufferFromCoarser My halos which are ghostFromCoarser on remote processes type( tem_communication_type ), public :: recvBufferFromFiner My halos which are ghostFromFiner on remote processes real(kind=rk), public, allocatable :: visc (:) Normalized turbulence viscosity\ni.e. viscosity scaled to current level i.e. visc/dtL\nSize: nSize (nFluids+nGhosts+nHalos)\nUsed gradData to compute viscosity for nFluids and nGhosts.\nThis viscosity is interpolated and scaled for setting nonEq term\ninterpolation routines. The source element of interpolation might be\nhalo so they are communicated. Simple scaling assumping norm of strainrate tensor |S| in different\nlevel is small:\nSchneider, A. (2015). A Consistent Large Eddy Approach for\nLattice Boltzmann Methods and its Application to Complex Flows.\nTechnical University Kaiserslautern.\nv_c = 4 v_f. Scaled visc: v&#94;s = v/dt.\n=> v&#94;s_c dtL_c = 4 v&#94;s_f dtL_f => v&#94;s_c = 2 v&#94;s_f Kolmogorov scaling:\nTouil, H., Ricot, D., & Lévêque, E. (2014). Direct and large-eddy\nsimulation of turbulent flows on composite multi-resolution grids by\nthe lattice Boltzmann method. Journal of Computational Physics, 256,\n220–233.\nv&#94;s_c = 2&#94;(1/3) v&#94;s_f","tags":"","loc":"type/mus_turbulence_data_type.html"},{"title":"mus_turbulence_type – Musubi ","text":"type, public :: mus_turbulence_type Contains information required to compute eddy viscosity Inherits type~~mus_turbulence_type~~InheritsGraph type~mus_turbulence_type mus_turbulence_type type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_turbulence_data_type mus_turbulence_data_type type~mus_turbulence_type->type~mus_turbulence_data_type dataOnLvl type~mus_turbulence_visc_proc_type mus_turbulence_visc_proc_type type~mus_turbulence_type->type~mus_turbulence_visc_proc_type calcVisc type~les_coeff_type les_coeff_type type~mus_turbulence_config_type->type~les_coeff_type coeff tem_communication_type tem_communication_type type~mus_turbulence_data_type->tem_communication_type sendBuffer, recvBuffer, sendBufferFromCoarser, sendBufferFromFiner, recvBufferFromCoarser, recvBufferFromFiner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_turbulence_type~~InheritedByGraph type~mus_turbulence_type mus_turbulence_type type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active is true if turbulence table is defined type( mus_turbulence_config_type ), public :: config information loaded from config file type( mus_turbulence_data_type ), public, allocatable :: dataOnLvl (:) contains level-wise turbulence data to compute eddy viscosity\nsize: minlevel:maxLevel type( mus_turbulence_visc_proc_type ), public :: calcVisc contains turbulence viscosity function pointers real(kind=rk), public :: fac_c2f Factor to scale normalized turbulent viscosity from coarse to fine\ndepending on whether useKolmogorovScale true or false\nif useKolmogorovScale fac_c2f = 1/2&#94;(1/3) else fac_c2f = 1/2\nHow to use: v&#94;s_f = fac_c2f v&#94;s_c real(kind=rk), public :: fac_f2c Factor to scale normalized turbulent viscosity from fine to coarse\ndepending on whether useKolmogorovScale true or false\nif useKolmogorovScale fac_f2c = 2&#94;(1/3) else fac_f2c = 2\nHow to use: v&#94;s_c = fac_f2c v&#94;s_f","tags":"","loc":"type/mus_turbulence_type.html"},{"title":"les_coeff_type – Musubi ","text":"type, private :: les_coeff_type Contains large Eddy Turbulence (LES) model coefficients Inherited by type~~les_coeff_type~~InheritedByGraph type~les_coeff_type les_coeff_type type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_config_type->type~les_coeff_type coeff type~mus_turbulence_type mus_turbulence_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: C_s Smagorinsky constant.\nC_s = sqrt(C_k sqrt(C_k/C_e) ) = 0.16778594 = 0.17 real(kind=rk), public :: C_w Model constant for WALE (Wall-Adapting Local Eddy-Viscosity)\ndefault: 0.5 real(kind=rk), public :: C_v Model constant for Vreman model\nIn literature: C_v = sqrt(2.5) C_s = 0.27 real(kind=rk), public :: C_e Modal constant for turbulent kinetic energy dissipation rate\ndefault: 1.048 real(kind=rk), public :: C_k Model constant for eddy-viscosity coefficient\ndefault: 0.094_rk\nhttps://caefn.com/openfoam/smagorinsky-sgs-model","tags":"","loc":"type/les_coeff_type.html"},{"title":"mus_turbulence_visc_proc_type – Musubi ","text":"type, private :: mus_turbulence_visc_proc_type Contains function pointers to obtain normalized turbulence viscosity.\nViscosity is normalized to current level i.e. v_s = v/dt Inherited by type~~mus_turbulence_visc_proc_type~~InheritedByGraph type~mus_turbulence_visc_proc_type mus_turbulence_visc_proc_type type~mus_turbulence_type mus_turbulence_type type~mus_turbulence_type->type~mus_turbulence_visc_proc_type calcVisc type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial procedure( proc_calc_turb_visc_fromGradU ), public, pointer, nopass :: fromGradU => null() this procedure compute eddy viscosity from velocity field depending\nturbulence and lbm (compressible/incompressible) models procedure( proc_calc_turb_visc_fromPreColPDF ), public, pointer, nopass :: fromPreColPDF => null() this procedure compute eddy viscosity from preCollision PDF.\nIt is used for Smagorinsky model which depends only on strain rate\nthat can be calculated using local nonEquilibrium.\nIs assigned when compSR_fromPDF is .true.","tags":"","loc":"type/mus_turbulence_visc_proc_type.html"},{"title":"mus_scheme_layout_type – Musubi ","text":"type, public :: mus_scheme_layout_type data structure containing all information related to the\ncompute stencil. Several stencils can be defined. mus_moments_module Moments are directly related to the\nstencil layout and are therefore defined here Inherits type~~mus_scheme_layout_type~~InheritsGraph type~mus_scheme_layout_type mus_scheme_layout_type dyn_labelarray_type dyn_labelarray_type type~mus_scheme_layout_type->dyn_labelarray_type stencil_labels grw_stencilheaderarray_type grw_stencilheaderarray_type type~mus_scheme_layout_type->grw_stencilheaderarray_type grwStencil tem_stencilHeader_type tem_stencilHeader_type type~mus_scheme_layout_type->tem_stencilHeader_type fStencil, stencil type~mus_moment_type mus_moment_type type~mus_scheme_layout_type->type~mus_moment_type moment type~mus_scheme_derived_quantities_type mus_scheme_derived_quantities_type type~mus_scheme_layout_type->type~mus_scheme_derived_quantities_type quantities tem_matrix_type tem_matrix_type type~mus_moment_type->tem_matrix_type toMoments, toPDF Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_scheme_layout_type~~InheritedByGraph type~mus_scheme_layout_type mus_scheme_layout_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_scheme_layout_type layout Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_stencilHeader_type ), public :: fStencil fluid stencil same as stencil(1) integer, public :: nStencils number of stencils used in this scheme type( grw_stencilheaderarray_type ), public :: grwStencil Temporary growing array of stencil\nIt is copied to stencil(:) and destroyed, where this is destroyed? type( tem_stencilHeader_type ), public, allocatable :: stencil (:) The list of stencil types, the stencils for the individual schemes\nis ordered as follows: | flSt | bcSt1_field1 ... bcStN_field1 ... bcSt1_fieldM ... bcStN_fieldM | addSt ... | Unique stencil label for boundary stencils are created with boundary label\nand stencil%cxDir therefore each stencil is limited to one boundary type type( dyn_labelarray_type ), public :: stencil_labels dynamic array of labels created from stencil directions to create unique\ngrowing array of grwStencil integer, public :: fStencil_pos position of fluid stencil in grwStencil real(kind=rk), public, allocatable :: weight (:) The weights for the different discrete velocities real(kind=rk), public :: cs Lattice speed of sound for fStencil\n$\\sum_i (weight_i cx_i cx_i) = c_s&#94;2 I real(kind=rk), public, allocatable :: prevailDir (:,:) Prevailing directions type( mus_moment_type ), public :: moment Moment space definition logical, public :: new_stencil = .false. New stencil definition loaded from config type( mus_scheme_derived_quantities_type ), public :: quantities derive quantities that depends on the layout such as velocity, pdf_eq, etc..","tags":"","loc":"type/mus_scheme_layout_type.html"},{"title":"mus_transport_var_type – Musubi ","text":"type, public :: mus_transport_var_type Description of musubi transport variable type Inherits type~~mus_transport_var_type~~InheritsGraph type~mus_transport_var_type mus_transport_var_type grw_stringkeyvaluepairarray_type grw_stringkeyvaluepairarray_type type~mus_transport_var_type->grw_stringkeyvaluepairarray_type varDict type~mus_transport_op_type mus_transport_op_type type~mus_transport_var_type->type~mus_transport_op_type method tem_indexLvl_type tem_indexLvl_type type~mus_transport_op_type->tem_indexLvl_type pntIndex Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_transport_var_type~~InheritedByGraph type~mus_transport_var_type mus_transport_var_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_transport_var_type transVar Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( mus_transport_op_type ), public, allocatable :: method (:) Contains variable pntIndex to setup_index and getValOfIndex\nSize: varDict%nVals type( grw_stringkeyvaluepairarray_type ), public :: varDict Dictionary of transport variable with\nvarDict%val()%key is the name of transport variable and\nvarDict%val()%value is the name of variable provided for the key","tags":"","loc":"type/mus_transport_var_type.html"},{"title":"mus_transport_op_type – Musubi ","text":"type, private :: mus_transport_op_type Description contains index to access value using variable function\npointer Inherits type~~mus_transport_op_type~~InheritsGraph type~mus_transport_op_type mus_transport_op_type tem_indexLvl_type tem_indexLvl_type type~mus_transport_op_type->tem_indexLvl_type pntIndex Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_transport_op_type~~InheritedByGraph type~mus_transport_op_type mus_transport_op_type type~mus_transport_var_type mus_transport_var_type type~mus_transport_var_type->type~mus_transport_op_type method type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_transport_var_type transVar Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: data_varpos Position of data variable provided in config file in the varSys type( tem_indexLvl_type ), public :: pntIndex Indices for points for nElems_solve (nFluids + nGhostsFromCoarser).\nOrder of index matches levelDesc%total list, required for setup_index,\ngetvalof_Index","tags":"","loc":"type/mus_transport_op_type.html"},{"title":"mus_geom_type – Musubi ","text":"type, public :: mus_geom_type Geometric information and definitions Inherits type~~mus_geom_type~~InheritsGraph type~mus_geom_type mus_geom_type mus_IBM_globType mus_IBM_globType type~mus_geom_type->mus_IBM_globType globIBM tem_BC_prop_type tem_BC_prop_type type~mus_geom_type->tem_BC_prop_type boundary treelmesh_type treelmesh_type type~mus_geom_type->treelmesh_type tree type~mus_geomincrhead_type mus_geomIncrHead_type type~mus_geom_type->type~mus_geomincrhead_type geomIncr tem_timeControl_type tem_timeControl_type type~mus_geomincrhead_type->tem_timeControl_type timeControl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( treelmesh_type ), public :: tree tree data type type( tem_BC_prop_type ), public :: boundary boundary information as stored on disk type( mus_geomIncrHead_type ), public, allocatable :: geomIncr (:) The header type containing all the geometry increase information logical, public :: dynamicGeom = .false. Logical to define whether geometry increase is active or not integer, public, allocatable :: posInBndID (:) Tree element position in the boundary_ID( nDir, nElems) in bc_prop_type\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  posInBndID = posInBndID( iElem )\n  ! current element has boundary only if posInBndID>0\n  ! else posInBndID = -1\n  if (posInBnd > 0 )\n    bnd_ID(1:nDir) = bc_prop%boundary_ID( 1:nDir, posInBndID )\n  end if\nend do integer, public, allocatable :: posInQVal (:) Tree element position in the qVal( nDir, nElems) in bc_prop_type\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  posInQVal = posInQVal( iElem )\n  ! current element has qVal if posInQVal>0 else posInQVal = -1\n  if (posInQVal > 0 )\n    qVal(1:nDir) = bc_prop%qVal( 1:nDir, posInQVal )\n  end if\nend do integer, public, allocatable :: levelPointer (:) tree element position in level descriptor total list\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  treeID = tree%treeID( iElem )\n  level = tem_levelOf( treeID )\n  posInTotal = levelPointer( iElem )\n  treeID = LevelDesc( iLevel )%total( posInTotal )\nend do integer, public, allocatable :: bcLevelPointer (:) Boundary element poisition in the levelwise globBC%elemLvl(:)%elem%val\nIt has a size of geometry%boundary%property%nElems.\nIt is used in tracking to extract value stored in boundary types.\nHot to use this access normal direction of boundary element:\ndo iElem = 1, tree%nElems\n  level = tem_levelOf( treeID )\n  posInBndID = posInBndID(iElem)\n  if (posInBndID > 0) then\n    BCIDs = bc_prop%boundary_ID(:, posInBndID)\n    minBCID = minval(BCIDs, BCIDs > 0)\n    posInBcElem = bcLevelPointer(posInBndID)\n    normal = globBC%elemLvl(iLevel)%normal(posInBcElem)\n  end if\nend do integer, public, allocatable :: minBcID (:) Minimum bcID for each boundary element.\nif a element has more than one boundary then use minBcID which depends\non boundary order in seeder configuration. type(mus_IBM_globType), public :: globIBM immersed boundary data real(kind=rk), public, allocatable :: bndForce (:,:) Contains Forces on boundary elements computed using momentum exchange\nmethod. This will be used to derive_bndForce routine to compute force\nof certain boundaries.\nForces are stored in level-independent fashion as geometry%boundaryID\nloaded from mesh files.\nDim1: geometry%boundaryi%property%nElems\nDim2: 3 real(kind=rk), public, allocatable :: bndMoment (:,:) Contains Moments on boundary elements computed using momentum exchange\nmethod. This will be used to derive_bndMoment routine to compute moment\nof certain boundaries.\nForces are stored in level-independent fashion as geometry%boundaryID\nloaded from mesh files.\nDim1: geometry%boundaryi%property%nElems\nDim2: 3","tags":"","loc":"type/mus_geom_type.html"},{"title":"mus_timer_handle_type – Musubi ","text":"type, public :: mus_timer_handle_type Musubi timer type -------------------------------------------------- Components Type Visibility Attributes Name Initial integer, public :: mainloop handle for the complete mainloop integer, public :: loadMesh handle for loading / creating the mesh and config integer, public :: initLvlD handle for initialising the levelDescriptor integer, public :: wRestart handle for writing restart integer, public :: balance handle for the dyn_loadBal routine integer, public :: source handle for source terms integer, public :: first = 0 First main handle position in treelm timer object integer, public :: last = -1 Last main handle position in treelm timer object integer, public, allocatable :: compute (:) handle for advection relaxation integer, public, allocatable :: aux (:) handle for auxfield calculation integer, public, allocatable :: relax (:) handle for relax parameter update integer, public, allocatable :: comm (:) handle for communicate integer, public, allocatable :: intpFromCoarser (:) handle for interpolation and communicate integer, public, allocatable :: intpFromFiner (:) integer, public, allocatable :: commFromCoarser (:) integer, public, allocatable :: commFromFiner (:) integer, public, allocatable :: setBnd (:) handle for setboundary integer, public, allocatable :: bcBuffer (:) integer, public, allocatable :: doIBM (:) handle for immersed boundary method integer, public :: stage (nStages) Stage timers for multi level recursive algorithm integer, public :: minLevel min. level in mesh integer, public :: maxLevel max. level in mesh integer, public :: nBCs number of BCs","tags":"","loc":"type/mus_timer_handle_type.html"},{"title":"mus_interpolation_method_type – Musubi ","text":"type, public :: mus_interpolation_method_type This data types contains intpRoutine function pointer for FillFiner\nand FillCoarser.\nFor fillFiner, it build least square fit matrix for linear\nquadratic interpolations\nFor fillCoarser: currently we do simple average Why do we need different intpRoutine for fillFinerFromMe?\nThe order of interpolation to finer depends on available number\nof coarser source elements so for every order we use different\ninterpolation routines.\nWe start with user defined interpolation order and\nIf nMinSources for that order is not found then we fall back to lower order\nWeighted average will be the lowest level for which nMinSources = 1 Inherits type~~mus_interpolation_method_type~~InheritsGraph type~mus_interpolation_method_type mus_interpolation_method_type tem_intpMatrixLSF_type tem_intpMatrixLSF_type type~mus_interpolation_method_type->tem_intpMatrixLSF_type intpMat_forLSF Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_interpolation_method_type~~InheritedByGraph type~mus_interpolation_method_type mus_interpolation_method_type type~mus_interpolation_type mus_interpolation_type type~mus_interpolation_type->type~mus_interpolation_method_type fillFinerFromME, fillMineFromFiner type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_interpolation_type intp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial procedure( intpRoutine ), public, pointer :: do_intp => null() Routine to interpolate coarse to fine for ghostFromCoarser elements\nand interpolate fine to coarse for ghostFromFiner elements.\nSets pdf for ghost elements by f_eq + f_neq\nThe moments required to compute equilibrium function are obtained\nfrom auxField array and the auxField of ghost elements are interpolate\nseperately using do_intpArbitraryField procedure( intpRoutine_arbitraryVal ), public, pointer :: do_intpArbiVal => null() Routine to interpolate coarse to fine and fine to coarse for\narbitrary variables type( tem_intpMatrixLSF_type ), public :: intpMat_forLSF Matrix entries for linear/Quadratic interpolation least square fit\n((A&#94;T)A)&#94;-1*(A&#94;T)\nSize: (6,9) for D2Q9 stencil\nSize: (10,QQ)  for D3Q19 and D3Q27 integer, public :: nMinSources how many source elements are required by this interpolation order integer, public :: nMaxSources Max number of sources amoung target ghosts\nComputed in mus_contruction::mus_intp_complete_coarseDep","tags":"","loc":"type/mus_interpolation_method_type.html"},{"title":"mus_interpolation_stencil_type – Musubi ","text":"type, public :: mus_interpolation_stencil_type Contains stencil for interpolation Inherited by type~~mus_interpolation_stencil_type~~InheritedByGraph type~mus_interpolation_stencil_type mus_interpolation_stencil_type type~mus_interpolation_type mus_interpolation_type type~mus_interpolation_type->type~mus_interpolation_stencil_type weightedAvgStencil type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_interpolation_type intp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is active only for specific layouts like d2q9, d3q19, d3q27 integer, public, allocatable :: neighDir (:,:) cxDir for interpolation stencil for depFromCoarser","tags":"","loc":"type/mus_interpolation_stencil_type.html"},{"title":"mus_interpolation_config_type – Musubi ","text":"type, public :: mus_interpolation_config_type Contains information loaded from config file Inherited by type~~mus_interpolation_config_type~~InheritedByGraph type~mus_interpolation_config_type mus_interpolation_config_type type~mus_interpolation_type mus_interpolation_type type~mus_interpolation_type->type~mus_interpolation_config_type config type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_interpolation_type intp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: method name of the order of the interpolation method for fillFinerFromMe integer, public :: order Order of the interpolation for fillFinerFromMe character(len=labelLen), public :: weights_method = 'linear_distance' name of used weighting method integer, public :: IDW_powerfac = 6 Power factor for inverse distance weighting logical, public :: useComputeStencil = .false. Stencil for linear interpolation.\nBy default use stencil from weighted average logical, public :: testInterpolation = .false. Interpolation test by comparing against the initial condition logical, public :: testEachElement = .false. logical, public :: testFluids = .false. logical, public :: noIntpFromFiner = .false. logical, public :: noIntpFromCoarser = .false.","tags":"","loc":"type/mus_interpolation_config_type.html"},{"title":"mus_interpolation_type – Musubi ","text":"type, public :: mus_interpolation_type definition of the used interpolation method Inherits type~~mus_interpolation_type~~InheritsGraph type~mus_interpolation_type mus_interpolation_type type~mus_interpolation_config_type mus_interpolation_config_type type~mus_interpolation_type->type~mus_interpolation_config_type config type~mus_interpolation_method_type mus_interpolation_method_type type~mus_interpolation_type->type~mus_interpolation_method_type fillFinerFromME, fillMineFromFiner type~mus_interpolation_stencil_type mus_interpolation_stencil_type type~mus_interpolation_type->type~mus_interpolation_stencil_type weightedAvgStencil tem_intpMatrixLSF_type tem_intpMatrixLSF_type type~mus_interpolation_method_type->tem_intpMatrixLSF_type intpMat_forLSF Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_interpolation_type~~InheritedByGraph type~mus_interpolation_type mus_interpolation_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_interpolation_type intp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( mus_interpolation_config_type ), public :: config Information loaded from config file type( mus_interpolation_method_type ), public, allocatable :: fillFinerFromME (:) Interpolation routines to fillFiner\nSize: interpolation order type( mus_interpolation_method_type ), public :: fillMineFromFiner Interpolation routines to fillCoarser type( mus_interpolation_stencil_type ), public :: weightedAvgStencil stencil for weighted average interpolation","tags":"","loc":"type/mus_interpolation_type.html"},{"title":"mus_convertFac_type – Musubi ","text":"type, public :: mus_convertFac_type This type contains the converstion factor for derived variables\nfrom lattice to physical. Their inverses can be used to convert physical to lattice units\nuse reference density to parmeterize kg and reference mole density\nto parmeterize mol Inherited by type~~mus_convertfac_type~~InheritedByGraph type~mus_convertfac_type mus_convertFac_type type~mus_physics_type mus_physics_type type~mus_physics_type->type~mus_convertfac_type fac type~mus_param_type mus_param_type type~mus_param_type->type~mus_physics_type physics Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: length length (m) = dx real(kind=rk), public :: time time (s) = dt real(kind=rk), public :: vel velocity(m/s) = dx/dt real(kind=rk), public :: visc kinematic viscosity(m&#94;2/s) = dx&#94;2/dt real(kind=rk), public :: viscDyna Dynamic viscosity (Pa s) = kg/m/s real(kind=rk), public :: accel acceleration(m/s&#94;2) = dx/dt&#94;2 real(kind=rk), public :: force Force(N)(kg m/s&#94;2) = rho0*dx&#94;4/dt&#94;2 real(kind=rk), public :: body_force Force per unit volume (N/m&#94;3)(kg/s&#94;2/m&#94;2) = rho0*dx/dt&#94;2 real(kind=rk), public :: press Pressure(N/m&#94;2)(kg/m/s&#94;2) = rho0*dx&#94;2/dt&#94;2 real(kind=rk), public :: strainRate Strain Rate (1/s) = 1/dt real(kind=rk), public :: energy Energy (N-m) (kg m&#94;2/s&#94;2) = rho0 dx&#94;5/dt&#94;2 real(kind=rk), public :: chargeDens mole density(mol/m&#94;3) = mole0/dx&#94;3\nCharge density (C/m&#94;3) = Coulomb0/dx&#94;3 real(kind=rk), public :: currentDens Current density (C/s/m&#94;2) = Coulomb0/dt/dx&#94;2 real(kind=rk), public :: moleFlux mole flux(mol/m&#94;2/s) = moleDen0*dx/dt real(kind=rk), public :: flux mass flux(kg/m&#94;2/s) = rho0*dx/dt real(kind=rk), public :: diffusivity diffusivity(m&#94;2/s) = dx&#94;2/dt real(kind=rk), public :: faraday faraday (C/mol) = coulomb0/moleDens0/dx&#94;3 real(kind=rk), public :: gasConst gas constant (J/mol/K) (N m/mol/K) (kg m&#94;2/s&#94;2/mol/K)\n= rho0*dx&#94;5/dt&#94;2/mole0/temp0 real(kind=rk), public :: potential Potential (V) (kg m&#94;2/(C*S&#94;2))","tags":"","loc":"type/mus_convertfac_type.html"},{"title":"mus_physics_type – Musubi ","text":"type, public :: mus_physics_type This type contains the reference values as defined in the physics\ntable by the user They are used to convert lattice to physical unit and vice versa.\nkeep reference mass density, mole density and molecular weight\nsame for all levels.\nUse [mus_load_physics] to fill the datatype properly. Inherits type~~mus_physics_type~~InheritsGraph type~mus_physics_type mus_physics_type type~mus_convertfac_type mus_convertFac_type type~mus_physics_type->type~mus_convertfac_type fac Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_physics_type~~InheritedByGraph type~mus_physics_type mus_physics_type type~mus_param_type mus_param_type type~mus_param_type->type~mus_physics_type physics Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active = .false. needed to check if physics table is defined real(kind=rk), public :: dx = -1.0_rk reference length - discretization size of the coarsest level\nSI unit - meter real(kind=rk), public, allocatable :: dxLvl (:) real(kind=rk), public :: dt = -1.0_rk reference time - time discretization for discretization size\nof the coarsest level\nSI unit - seconds real(kind=rk), public, allocatable :: dtLvl (:) real(kind=rk), public :: rho0 = -1.0_rk reference physical mass density\nSI unit - kg/m&#94;3 real(kind=rk), public :: moleDens0 = -1.0_rk reference physical mole density\nSI unit - mol/m&#94;3 real(kind=rk), public :: molWeight0 = -1.0_rk reference molecular weight\nSI unit - kg/mol real(kind=rk), public :: temp0 = -1.0_rk reference temperature\nSI unit - Kelvin real(kind=rk), public :: coulomb0 = -1.0_rk reference fundamental electrical charge\nSI unit - Coulomb real(kind=rk), public :: mole0 = -1.0_rk mole is defined by inverse of Avogadro Constant\nAvogadro Constant = 6.02214129e23 [1/mol] real(kind=rk), public :: mass0 = -1.0_rk reference mass in kg derived from density or moleweight\nSI unit :: kg type( mus_convertFac_type ), public, allocatable :: fac (:) Level-wise conversion factor for derived variables\nsize: minLevel:maxLevel\nallocated in mus_load_physics\n\\todo KM: conversion factor should not be level-dependent.\nit should be same for all levels, the lattice dx and dt for each level\nmust be considered to scale variables in multilevel.\nImplemented force, visc, etc using dtL according to formula\nIntroduced lattice speed variable: dx/dt for each level\nit should be same for all level for acoustic scaling and different\nfor diffusive scaling real(kind=rk), public, allocatable :: pFac (:,:) Pressure (strain rate) over level scale factor.\nThis factor is meant to convert pressure in LB unit on source level to\nthe required pressure on target level.\nIt is mainly used in interpolation routine.\nIt is allocated as: allocate(pFac( minLevel:maxLevel, minLevel:maxLevel))\nIt is allocated and initialized in routine: mus_set_scaleFac\nHow to use it in the code:\npTargetLevel = pSourceLevel * pFac( sourceLevel, targetLevel ) real(kind=rk), public, allocatable :: vFac (:,:) Velocity over level scale factor\nIts usage is the same as pressure scale factor real(kind=rk), public, allocatable :: sFac (:,:) Strain rate over level scale factor\nIts usage is the same as pressure scale factor","tags":"","loc":"type/mus_physics_type.html"},{"title":"mus_geomIncrHead_type – Musubi ","text":"type, public :: mus_geomIncrHead_type Inherits type~~mus_geomincrhead_type~~InheritsGraph type~mus_geomincrhead_type mus_geomIncrHead_type tem_timeControl_type tem_timeControl_type type~mus_geomincrhead_type->tem_timeControl_type timeControl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_geomincrhead_type~~InheritedByGraph type~mus_geomincrhead_type mus_geomIncrHead_type type~mus_geom_type mus_geom_type type~mus_geom_type->type~mus_geomincrhead_type geomIncr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: active = .false. logical, public :: solidify = .false. logical, public :: fluidify = .false. logical, public :: proximity = .false. type( tem_timeControl_type ), public :: timeControl character(len=labelLen), public :: cond_varName Name of the variable defined for condition varname in config file.\nVariable refered should return 0 for if condition is false and\nIf there are more than one condition variable required then they must\nbe combined via variable definitions in config file. integer, public :: cond_varPos Position of variable defined for the condition varname in the varSys","tags":"","loc":"type/mus_geomincrhead_type.html"},{"title":"mus_wall_function_type – Musubi ","text":"type, public, abstract :: mus_wall_function_type collection of properties of the wall function type Inherited by type~~mus_wall_function_type~~InheritedByGraph type~mus_wall_function_type mus_wall_function_type type~mus_turb_wallfunc_type mus_turb_wallFunc_type type~mus_turb_wallfunc_type->type~mus_wall_function_type wall_function type~mus_wall_function_musker_type mus_wall_function_musker_type type~mus_wall_function_musker_type->type~mus_wall_function_type type~mus_wall_function_reichardt_type mus_wall_function_reichardt_type type~mus_wall_function_reichardt_type->type~mus_wall_function_type type~mus_wall_function_schmitt_type mus_wall_function_schmitt_type type~mus_wall_function_schmitt_type->type~mus_wall_function_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure( get_uPlus_interface ), public, deferred, nopass :: get_uPlus function to get uPlus pure function get_uPlus_interface(yPlus) result(uPlus) Prototype function interface to get u_Plus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) procedure( get_d_uPlus_d_uTau_interface ), public, deferred, nopass :: get_d_uPlus_d_uTau function to apply the newon method pure function get_d_uPlus_d_uTau_interface(y, uTau, nu) result(d_uPlus_d_uTau) Prototype function interface to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"type/mus_wall_function_type.html"},{"title":"mus_viscosity_type – Musubi ","text":"type, public :: mus_viscosity_type Contains STfun of viscosity variable and relaxation parameter for each\nlevel Inherits type~~mus_viscosity_type~~InheritsGraph type~mus_viscosity_type mus_viscosity_type grw_realarray_type grw_realarray_type type~mus_viscosity_type->grw_realarray_type dataOnLvl tem_spacetime_fun_type tem_spacetime_fun_type type~mus_viscosity_type->tem_spacetime_fun_type STfun type~mus_relaxationparam_type mus_relaxationParam_type type~mus_viscosity_type->type~mus_relaxationparam_type omLvl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_viscosity_type~~InheritedByGraph type~mus_viscosity_type mus_viscosity_type type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_viscosity_type viscKine type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_spacetime_fun_type ), public :: STfun space-time function type( grw_realarray_type ), public, allocatable :: dataOnLvl (:) viscosity value evaluated from STfun type( mus_relaxationParam_type ), public, allocatable :: omLvl (:) relaxation paramter omega for each level","tags":"","loc":"type/mus_viscosity_type.html"},{"title":"mus_relaxationParam_type – Musubi ","text":"type, private :: mus_relaxationParam_type Contains relaxation parameter for a level Inherited by type~~mus_relaxationparam_type~~InheritedByGraph type~mus_relaxationparam_type mus_relaxationParam_type type~mus_viscosity_type mus_viscosity_type type~mus_viscosity_type->type~mus_relaxationparam_type omLvl type~mus_fluid_type mus_fluid_type type~mus_fluid_type->type~mus_viscosity_type viscKine type~mus_field_prop_type mus_field_prop_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: val (:) Relaxation parameter computed from viscosity\nFor kinematic viscosity, if turbulence is active, this omega refers to\neffective omega which is omega_bg + omega_turb\nsize: nElems_solve","tags":"","loc":"type/mus_relaxationparam_type.html"},{"title":"mus_control_type – Musubi ","text":"type, public :: mus_control_type Datatype containing mapping of control routines to function pointers Components Type Visibility Attributes Name Initial procedure( computation ), public, pointer :: do_computation => null()","tags":"","loc":"type/mus_control_type.html"},{"title":"array2D_type – Musubi ","text":"type, public :: array2D_type To allow Intel AVX SIMD streaming store instructions,\nthe array must be aligned at 32 bytes Inherited by type~~array2d_type~~InheritedByGraph type~array2d_type array2D_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~array2d_type state Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable, dimension(:,:) :: val","tags":"","loc":"type/array2d_type.html"},{"title":"mus_scheme_type – Musubi ","text":"type, public :: mus_scheme_type Datatype containing all information on the scheme. The mus_scheme_type contains of all information that are needed\nto run a simulation (including informations on the: fluid, boundary\nconditions, levelDescriptor, state vector, layout, diffusion info,\ntracking). Inherits type~~mus_scheme_type~~InheritsGraph type~mus_scheme_type mus_scheme_type glob_boundary_type glob_boundary_type type~mus_scheme_type->glob_boundary_type globBC mus_Grad_type mus_Grad_type type~mus_scheme_type->mus_Grad_type Grad mus_gradData_type mus_gradData_type type~mus_scheme_type->mus_gradData_type gradData tem_levelDesc_type tem_levelDesc_type type~mus_scheme_type->tem_levelDesc_type levelDesc tem_possible_variable_type tem_possible_variable_type type~mus_scheme_type->tem_possible_variable_type poss_srcVar, poss_transVar tem_st_fun_linkedList_type tem_st_fun_linkedList_type type~mus_scheme_type->tem_st_fun_linkedList_type st_funList tem_tracking_type tem_tracking_type type~mus_scheme_type->tem_tracking_type track tem_varMap_type tem_varMap_type type~mus_scheme_type->tem_varMap_type redTransVarMap, stateVarMap tem_varSys_type tem_varSys_type type~mus_scheme_type->tem_varSys_type varSys tem_variable_type tem_variable_type type~mus_scheme_type->tem_variable_type luaVar type~array2d_type array2D_type type~mus_scheme_type->type~array2d_type state type~mus_auxfieldvar_type mus_auxFieldVar_type type~mus_scheme_type->type~mus_auxfieldvar_type auxField type~mus_dervarpos_type mus_derVarPos_type type~mus_scheme_type->type~mus_dervarpos_type derVarPos type~mus_field_type mus_field_type type~mus_scheme_type->type~mus_field_type field type~mus_interpolation_type mus_interpolation_type type~mus_scheme_type->type~mus_interpolation_type intp type~mus_mixture_type mus_mixture_type type~mus_scheme_type->type~mus_mixture_type mixture type~mus_nernstplanck_type mus_nernstPlanck_type type~mus_scheme_type->type~mus_nernstplanck_type nernstPlanck type~mus_scheme_header_type mus_scheme_header_type type~mus_scheme_type->type~mus_scheme_header_type header type~mus_scheme_layout_type mus_scheme_layout_type type~mus_scheme_type->type~mus_scheme_layout_type layout type~mus_source_type mus_source_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_transport_var_type mus_transport_var_type type~mus_scheme_type->type~mus_transport_var_type transVar type~pdf_data_type pdf_data_type type~mus_scheme_type->type~pdf_data_type pdf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( mus_interpolation_type ), public :: intp Interpolation description for each scheme to do its own interpolation type( mus_mixture_type ), public :: mixture contains mixture information for multispecies type( mus_nernstPlanck_type ), public :: nernstPlanck integer, public :: nFields = 0 number of fields in the current scheme type( mus_field_type ), public, allocatable :: field (:) array of field type for each field type(glob_boundary_type), public, allocatable :: globBC (:) array of boundary types contains elems of each boundary type( mus_source_type ), public :: globSrc global source applied to all fields type( tem_possible_variable_type ), public :: poss_srcVar possible source variables depends on scheme kind type( mus_transport_var_type ), public :: transVar transport variables type( tem_possible_variable_type ), public :: poss_transVar possible transport variables depends on scheme kind\nThis variables might be used in compute kernel type( mus_scheme_header_type ), public :: header identifier of the scheme type( tem_levelDesc_type ), public, allocatable :: levelDesc (:) type( pdf_data_type ), public, allocatable :: pdf (:) pdf_data_types for every level\nsize: minLevel:maxLevel type( array2D_type ), public, allocatable :: state (:) Data vector containing the pdf state\nallocated in routine: mus_construct\nsize: minLevel:maxLevel type( mus_scheme_layout_type ), public :: layout the scheme representation used in this scheme procedure( kernel ), public, pointer, nopass :: compute => null() function pointer to compute kernel type( tem_tracking_type ), public :: track Contains trackingControl, config and instances type( tem_varMap_type ), public :: redTransVarMap Position of reduction transient variable in varSys type( mus_derVarPos_type ), public, allocatable :: derVarPos (:) store position of derived variable each field and total field\nin the global system type( tem_varSys_type ), public :: varSys global variable system definition type( tem_variable_type ), public, allocatable :: luaVar (:) Variables defined in the lua file type( tem_varMap_type ), public :: stateVarMap state variable position in the global varSys type( tem_st_fun_linkedList_type ), public :: st_funList contains spacetime functions defined for lua variables logical, public :: readVarIsPdf Used in mus_harvesting to check whether variables loaded from\nrestart file has pdf variable type( mus_auxFieldVar_type ), public, allocatable :: auxField (:) stores auxField variable values and function pointer to compute\nauxiliary field\nSize: minlevel:maxLevel type(mus_gradData_type), public, allocatable :: gradData (:) Contains direct neighbor position in the state and\nfinite difference coefficients to compute gradient procedure( mus_proc_calcAuxField ), public, pointer, nopass :: calcAuxField => null() Function pointer to evaluate auxilary variable type(mus_Grad_type), public :: Grad Contains the different pointers to calculate the gradients","tags":"","loc":"type/mus_scheme_type.html"},{"title":"mus_latticeUnit_type – Musubi ","text":"type, public :: mus_latticeUnit_type lattice dx and dt on each level Inherited by type~~mus_latticeunit_type~~InheritedByGraph type~mus_latticeunit_type mus_latticeUnit_type type~mus_param_type mus_param_type type~mus_param_type->type~mus_latticeunit_type lattice Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dtLvl (:) dt in LB unit, dtLvl(minLevel) = 1.0 real(kind=rk), public, allocatable :: dxLvl (:) dx in LB unit, dxLvl(minLevel) = 1.0","tags":"","loc":"type/mus_latticeunit_type.html"},{"title":"mus_param_type – Musubi ","text":"type, public :: mus_param_type Global parameter type definition, filled with Inherits type~~mus_param_type~~InheritsGraph type~mus_param_type mus_param_type tem_general_type tem_general_type type~mus_param_type->tem_general_type general type~mus_abortcriteria_type mus_abortCriteria_type type~mus_param_type->type~mus_abortcriteria_type mus_Aborts type~mus_latticeunit_type mus_latticeUnit_type type~mus_param_type->type~mus_latticeunit_type lattice type~mus_physics_type mus_physics_type type~mus_param_type->type~mus_physics_type physics tem_solverAborts_type tem_solverAborts_type type~mus_abortcriteria_type->tem_solverAborts_type type~mus_convertfac_type mus_convertFac_type type~mus_physics_type->type~mus_convertfac_type fac Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( tem_general_type ), public :: general Treelm param parameter type type( mus_abortCriteria_type ), public :: mus_Aborts Musubi specific abort criteria type( mus_latticeUnit_type ), public :: lattice Lattice dx and dt on each level type( mus_physics_type ), public :: physics contains basic SI units to convert from lattice to physical and\nvice versa character(len=labelLen), public :: controlRoutine type of the control routine logical, public :: init_allElems = .false. initialize all elements with valid entries?\nThis should only be activated for debugging,\nas it needs to be ensured that all helper elements\nare filled by communication and interpolation instead\nof filling initial values (consider restart!) character(len=labelLen), public :: scaling type of the scaling:\n* acoustic\n* diffusive integer, public :: scaleFactor Temporal scaling factor for the scaling. Acoustic = 2, Diffusive = 4 integer, public :: nNesting = 2 To calculate turbulent viscosity, velocity on buffer ghost elements\nshould be valid to nesting is set to same as scaling Factor integer, public :: reqInterval Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached. logical, public :: comm_reduced = .true. character(len=labelLen), public :: version = 'v2.0' need to set solver version in  general%solver%version logical, public :: restart_triggered = .false. active when restart is triggered by restart timeControl\ndump restart when simulation reached end only when\nrestart is not triggered by its timeControl before logical, public :: remove_solid = .true. remove solid from BC list integer, public :: block = block_size Block size for compute kernel logical, public :: initial_balance = .false. Initial balance logical, public :: dump_level_timing = .false. scratch file unit contains solver specific info in dump in restart header\nThis file should contain the information in form of a Lua script.\nKM: Not required anymore. Load config file name from restart header\ninteger :: solSpec_unit = -1\nDump level timing logical, public :: dump_linear_partition = .false. Dump linear partition logical, public :: dump_bc_timing = .false. Dump computation and bc timing information for all ranks","tags":"","loc":"type/mus_param_type.html"},{"title":"mus_field_type – Musubi ","text":"type, public :: mus_field_type This type contains all information on fields with ic and bc\nExample fields: fluid, species etc.\nEach field contains one initial condition and array of\nboundary conditions Inherits type~~mus_field_type~~InheritsGraph type~mus_field_type mus_field_type boundary_type boundary_type type~mus_field_type->boundary_type bc tem_ini_condition_type tem_ini_condition_type type~mus_field_type->tem_ini_condition_type ic tem_restart_type tem_restart_type type~mus_field_type->tem_restart_type restart type~mus_field_prop_type mus_field_prop_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_source_type mus_source_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_fluid_type mus_fluid_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_poisson_type mus_poisson_type type~mus_field_prop_type->type~mus_poisson_type poisson type~mus_species_type mus_species_type type~mus_field_prop_type->type~mus_species_type species grw_stringkeyvaluepairarray_type grw_stringkeyvaluepairarray_type type~mus_source_type->grw_stringkeyvaluepairarray_type varDict type~mus_source_op_type mus_source_op_type type~mus_source_type->type~mus_source_op_type method mus_nNwtn_type mus_nNwtn_type type~mus_fluid_type->mus_nNwtn_type nNwtn type~mus_turbulence_type mus_turbulence_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_viscosity_type mus_viscosity_type type~mus_fluid_type->type~mus_viscosity_type viscKine type~mus_poisson_boltzmann_type mus_poisson_boltzmann_type type~mus_poisson_type->type~mus_poisson_boltzmann_type PB type~mus_absorblayer_type mus_absorbLayer_type type~mus_source_op_type->type~mus_absorblayer_type absLayer type~mus_source_elems_type mus_source_elems_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_turbchannelforce_type mus_turbChannelForce_type type~mus_source_op_type->type~mus_turbchannelforce_type turbChanForce type~mrt_species_type mrt_species_type type~mus_species_type->type~mrt_species_type mrt type~absorblayer_config_type absorbLayer_config_type type~mus_absorblayer_type->type~absorblayer_config_type config type~mus_absorblayer_dynavg_type mus_absorbLayer_dynAvg_type type~mus_source_elems_type->type~mus_absorblayer_dynavg_type dynAvg type~mus_hrrcorrectionterm_type mus_HRRCorrectionTerm_type type~mus_source_elems_type->type~mus_hrrcorrectionterm_type HRR_Corr tem_shape_type tem_shape_type type~mus_turbchannelforce_type->tem_shape_type geom_utau, geom_umean tem_subTree_type tem_subTree_type type~mus_turbchannelforce_type->tem_subTree_type subTree_utau, subTree_umean type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_turbulence_data_type mus_turbulence_data_type type~mus_turbulence_type->type~mus_turbulence_data_type dataOnLvl type~mus_turbulence_visc_proc_type mus_turbulence_visc_proc_type type~mus_turbulence_type->type~mus_turbulence_visc_proc_type calcVisc grw_realarray_type grw_realarray_type type~mus_viscosity_type->grw_realarray_type dataOnLvl tem_spacetime_fun_type tem_spacetime_fun_type type~mus_viscosity_type->tem_spacetime_fun_type STfun type~mus_relaxationparam_type mus_relaxationParam_type type~mus_viscosity_type->type~mus_relaxationparam_type omLvl Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_field_type~~InheritedByGraph type~mus_field_type mus_field_type type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=labelLen), public :: label field label. Should be unique for each field type( mus_field_prop_type ), public :: fieldProp physics parameters (fluid and species) for field type(boundary_type), public, allocatable :: bc (:) array of field boundary types for each field\nsize: #BCs in the boundary_condition table\nallocated in mus_load_bc type( tem_ini_condition_type ), public :: ic initialization case, one initial condition for each field type( mus_source_type ), public :: source field source applied only to current field type( mus_source_type ), public :: internalSource field internal source applied only to current field\nnot needed input from musubi.lua\nused only for HRR correction at the moment type( tem_restart_type ), public :: restart An instance of restart type","tags":"","loc":"type/mus_field_type.html"},{"title":"mus_scheme_derived_quantities_type – Musubi ","text":"type, public :: mus_scheme_derived_quantities_type collection of properties of the scheme derived quantities type Inherited by type~~mus_scheme_derived_quantities_type~~InheritedByGraph type~mus_scheme_derived_quantities_type mus_scheme_derived_quantities_type type~mus_scheme_layout_type mus_scheme_layout_type type~mus_scheme_layout_type->type~mus_scheme_derived_quantities_type quantities type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_scheme_layout_type layout Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial procedure( get_pdfEq ), public, nopass, pointer :: pdfEq_ptr => null() function pointer to get pdf equilibrium from vel and density procedure( get_pdfEq_iDir ), public, nopass, pointer :: pdfEq_iDir_ptr => null() function pointer to get pdf equilibrium in a specific direction procedure( get_vel_from_pdf ), public, nopass, pointer :: vel_from_pdf_ptr => null() function pointer to get velocities from pdf procedure( get_vel_from_pdf_vectorized ), public, nopass, pointer :: vel_from_pdf_vectorized_ptr => null() function pointer to get velocities from pdf VECTORIZED procedure( get_vector_from_vel_dens ), public, nopass, pointer :: momentum_from_vel_dens_ptr => null() function pointer to get momentum procedure( get_scalar_from_vel_dens ), public, nopass, pointer :: kineticEnergy_from_vel_dens_ptr => null() function pointer to get kinetic energy procedure( get_rho0Inv ), public, nopass, pointer :: rho0Inv_ptr => null() function pointer to get 1/rho as a mask regardless incompressibility","tags":"","loc":"type/mus_scheme_derived_quantities_type.html"},{"title":"mus_abortCriteria_type – Musubi ","text":"type, public, extends( tem_solverAborts_type ) :: mus_abortCriteria_type Musubi specific abort criteria. Inherits type~~mus_abortcriteria_type~~InheritsGraph type~mus_abortcriteria_type mus_abortCriteria_type tem_solverAborts_type tem_solverAborts_type type~mus_abortcriteria_type->tem_solverAborts_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_abortcriteria_type~~InheritedByGraph type~mus_abortcriteria_type mus_abortCriteria_type type~mus_param_type mus_param_type type~mus_param_type->type~mus_abortcriteria_type mus_Aborts Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: velLat_max = 0.15_rk Maximal lattice velocity that will be tolerated in the simulation.\nThe lattice velocity should usually be smaller than 0.1. Type-Bound Procedures procedure, public :: load => mus_abortCriteria_load private  subroutine mus_abortCriteria_load (me, conf, abort_table) Loading Musubi specific abort criteria from the abort_criteria table. Read more… Arguments Type Intent Optional Attributes Name class( mus_abortCriteria_type ), intent(inout) :: me Object to hold the solver specific configuration parameters. type( flu_State ), intent(in) :: conf Handle to the Lua script with the configuration. integer, intent(in) :: abort_table Handle to the opened abort_criteria table that holds the\nabort parameters to load.","tags":"","loc":"type/mus_abortcriteria_type.html"},{"title":"mus_absorbLayer_dynAvg_type – Musubi ","text":"type, public :: mus_absorbLayer_dynAvg_type Stores time average values of density and velocity for dynamic absorbLayer Inherited by type~~mus_absorblayer_dynavg_type~~InheritedByGraph type~mus_absorblayer_dynavg_type mus_absorbLayer_dynAvg_type type~mus_source_elems_type mus_source_elems_type type~mus_source_elems_type->type~mus_absorblayer_dynavg_type dynAvg type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_source_elems_type elemLvl type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dens (:) density time average in lattice unit real(kind=rk), public, allocatable :: velX (:) velocity time average in lattice unit real(kind=rk), public, allocatable :: velY (:) real(kind=rk), public, allocatable :: velZ (:) logical, public :: isInitDens = .true. It is used to initialiye dynamic average density with initial condition logical, public :: isInitVel = .true. It is used to initialiye dynamic average velocity with initial condition","tags":"","loc":"type/mus_absorblayer_dynavg_type.html"},{"title":"mus_absorbLayer_type – Musubi ","text":"type, public :: mus_absorbLayer_type Contains information for absorblayer Inherits type~~mus_absorblayer_type~~InheritsGraph type~mus_absorblayer_type mus_absorbLayer_type type~absorblayer_config_type absorbLayer_config_type type~mus_absorblayer_type->type~absorblayer_config_type config Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_absorblayer_type~~InheritedByGraph type~mus_absorblayer_type mus_absorbLayer_type type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_absorblayer_type absLayer type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( absorbLayer_config_type ), public :: config Information loaded from configuration file real(kind=rk), public :: smoothFac Smoothing factor for expoential moving average\n= 2 / (nRecord+1)","tags":"","loc":"type/mus_absorblayer_type.html"},{"title":"absorbLayer_config_type – Musubi ","text":"type, private :: absorbLayer_config_type Contains additional information for absorblayer source Inherited by type~~absorblayer_config_type~~InheritedByGraph type~absorblayer_config_type absorbLayer_config_type type~mus_absorblayer_type mus_absorbLayer_type type~mus_absorblayer_type->type~absorblayer_config_type config type~mus_source_op_type mus_source_op_type type~mus_source_op_type->type~mus_absorblayer_type absLayer type~mus_source_type mus_source_type type~mus_source_type->type~mus_source_op_type method type~mus_field_type mus_field_type type~mus_field_type->type~mus_source_type source, internalSource type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_source_type globSrc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=rk), public :: target_pressure target pressure real(kind=rk), public :: target_velocity (3) target velocityX, velocityY and velocityZ logical, public :: isPressDyn = .false. Use time average for pressure. Default: false. logical, public :: isVelDyn = .false. Use time average for Velocity. Default: false. integer, public :: nRecord = 100 Number of iterations to record for time-averaging","tags":"","loc":"type/absorblayer_config_type.html"},{"title":"mus_field_prop_type – Musubi ","text":"type, public :: mus_field_prop_type This type contains parameter needed for field Inherits type~~mus_field_prop_type~~InheritsGraph type~mus_field_prop_type mus_field_prop_type type~mus_fluid_type mus_fluid_type type~mus_field_prop_type->type~mus_fluid_type fluid type~mus_poisson_type mus_poisson_type type~mus_field_prop_type->type~mus_poisson_type poisson type~mus_species_type mus_species_type type~mus_field_prop_type->type~mus_species_type species mus_nNwtn_type mus_nNwtn_type type~mus_fluid_type->mus_nNwtn_type nNwtn type~mus_turbulence_type mus_turbulence_type type~mus_fluid_type->type~mus_turbulence_type turbulence type~mus_viscosity_type mus_viscosity_type type~mus_fluid_type->type~mus_viscosity_type viscKine type~mus_poisson_boltzmann_type mus_poisson_boltzmann_type type~mus_poisson_type->type~mus_poisson_boltzmann_type PB type~mrt_species_type mrt_species_type type~mus_species_type->type~mrt_species_type mrt type~mus_turbulence_config_type mus_turbulence_config_type type~mus_turbulence_type->type~mus_turbulence_config_type config type~mus_turbulence_data_type mus_turbulence_data_type type~mus_turbulence_type->type~mus_turbulence_data_type dataOnLvl type~mus_turbulence_visc_proc_type mus_turbulence_visc_proc_type type~mus_turbulence_type->type~mus_turbulence_visc_proc_type calcVisc grw_realarray_type grw_realarray_type type~mus_viscosity_type->grw_realarray_type dataOnLvl tem_spacetime_fun_type tem_spacetime_fun_type type~mus_viscosity_type->tem_spacetime_fun_type STfun type~mus_relaxationparam_type mus_relaxationParam_type type~mus_viscosity_type->type~mus_relaxationparam_type omLvl type~les_coeff_type les_coeff_type type~mus_turbulence_config_type->type~les_coeff_type coeff tem_communication_type tem_communication_type type~mus_turbulence_data_type->tem_communication_type sendBuffer, recvBuffer, sendBufferFromCoarser, sendBufferFromFiner, recvBufferFromCoarser, recvBufferFromFiner Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~mus_field_prop_type~~InheritedByGraph type~mus_field_prop_type mus_field_prop_type type~mus_field_type mus_field_type type~mus_field_type->type~mus_field_prop_type fieldProp type~mus_scheme_type mus_scheme_type type~mus_scheme_type->type~mus_field_type field Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( mus_fluid_type ), public :: fluid contains fluid information type( mus_species_type ), public :: species contains species information type( mus_poisson_type ), public :: poisson Contains information for poisson equation","tags":"","loc":"type/mus_field_prop_type.html"},{"title":"mus_wall_function_musker_type – Musubi ","text":"type, public, extends( mus_wall_function_type ) :: mus_wall_function_musker_type extend the abstract subclass mus_wall_function_type Inherits type~~mus_wall_function_musker_type~~InheritsGraph type~mus_wall_function_musker_type mus_wall_function_musker_type type~mus_wall_function_type mus_wall_function_type type~mus_wall_function_musker_type->type~mus_wall_function_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, nopass :: get_uPlus function to get uPlus private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) procedure, public, nopass :: get_d_uPlus_d_uTau function to apply the newon method private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"type/mus_wall_function_musker_type.html"},{"title":"mus_wall_function_reichardt_type – Musubi ","text":"type, public, extends( mus_wall_function_type ) :: mus_wall_function_reichardt_type extend the abstract subclass mus_wall_function_type Inherits type~~mus_wall_function_reichardt_type~~InheritsGraph type~mus_wall_function_reichardt_type mus_wall_function_reichardt_type type~mus_wall_function_type mus_wall_function_type type~mus_wall_function_reichardt_type->type~mus_wall_function_type Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, nopass :: get_uPlus function to get uPlus private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) procedure, public, nopass :: get_d_uPlus_d_uTau function to apply the newon method private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"type/mus_wall_function_reichardt_type.html"},{"title":"mus_iterative_method_interface – Musubi","text":"interface Interface definition for the turbulent wall bc routines private pure function mus_iterative_method_interface(velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine Description This routine computes friction velocity from wall model profile\nusing Newton iteration method","tags":"","loc":"interface/mus_iterative_method_interface.html"},{"title":"mus_proc_calcFricVel – Musubi","text":"interface Interface definition for the turbulent wall bc routines private pure subroutine mus_proc_calcFricVel(this, velTau, velSW, distToBnd, viscKine, nElems) Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Turbulent wall model to use for the computation real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normal direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays Description This abstract interface defines the interface to calculate turbulent wall\nfriction velocity from given velocity and distance to boundary.\nAll inputs and output are in lattice units.","tags":"","loc":"interface/mus_proc_calcfricvel.html"},{"title":"mus_proc_calcStreamWiseVel – Musubi","text":"interface Interface definition for the turbulent wall bc routines private pure subroutine mus_proc_calcStreamWiseVel(velSW, velTau, distToBnd, viscKine, nElems, wall_function) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: velSW (:) Stream-wise velocity component from wall model real(kind=rk), intent(in) :: velTau (:) Friction velocity computd from wall model real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays class( mus_wall_function_type ), intent(in) :: wall_function Allocate wall function object Description This abstract interface defines the interface to calculate stream-wise\nvelocity component from friction velocity and distance to boundary.\nAll inputs and output are in lattice units.","tags":"","loc":"interface/mus_proc_calcstreamwisevel.html"},{"title":"proc_apply_source – Musubi","text":"interface private  subroutine proc_apply_source(fun, inState, outState, neigh, auxField, nPdfSize, iLevel, varSys, time, phyConvFac, derVarPos) Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(in) :: fun Description of method to update source real(kind=rk), intent(in) :: inState (:) input  pdf vector\n\\todo KM: instate is passed to compute auxField.\nSince auxField is precomputed from instate and passed to this routine.\ninstate can be removed real(kind=rk), intent(inout) :: outState (:) output pdf vector integer, intent(in) :: neigh (:) connectivity Array corresponding to state vector real(kind=rk), intent(in) :: auxField (:) auxField array integer, intent(in) :: nPdfSize number of elements in state Array integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Description Abstract interface to update state with source terms","tags":"","loc":"interface/proc_apply_source.html"},{"title":"proc_addSrcToAuxField – Musubi","text":"interface private  subroutine proc_addSrcToAuxField(fun, auxField, iLevel, time, varSys, phyConvFac, derVarPos) Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(inout) :: auxField (:) output auxField array integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Description Interface to add source to auxField vars in source_op_type for\nall nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner).\nHalo elements are exchanged","tags":"","loc":"interface/proc_addsrctoauxfield.html"},{"title":"proc_updateSourceVar – Musubi","text":"interface private  subroutine proc_updateSourceVar(fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Description Interface to update source variable which has dependency on auxField.\nApplied on all nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner).\nHalo elements are exchanged\nThis should be called after adding sorce term to state so that both\nauxField and apply_source uses same source value in one multilevel cycle.","tags":"","loc":"interface/proc_updatesourcevar.html"},{"title":"mus_proc_calcAuxField – Musubi","text":"interface public  subroutine mus_proc_calcAuxField(auxField, state, neigh, nSize, nSolve, iLevel, stencil, varSys, derVarPos, quantities) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: auxField (:) output auxField array real(kind=rk), intent(in) :: state (:) input state array integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: nSize number of elements in the state array integer, intent(in) :: nSolve number of fluid elements + ghostFromCoarser integer, intent(in) :: iLevel current level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Description Interface to compute auxField vars i.e. conserved macroscopic moments\nfrom pre-collision PDF for fluid and ghostFromCoarser.\nauxField on GhostFromFiner elements are interpolated and\nhalo elements are exchanged\nFor Multicomponent models: in calcAuxField function, the velocity\nis computed on transformed PDF such that force term can be added to it\nin addSrcToAuxField routine. The auxField is updated with correct\nvelocity field in compute kernel\ni.e. velocity of original PDF is obtained by solving\nlinear equation system  in compute kernel","tags":"","loc":"interface/mus_proc_calcauxfield.html"},{"title":"derive_equilFromAuxFunc – Musubi","text":"interface private pure function derive_equilFromAuxFunc(derVarPos, auxField, iField, varSys, layout) result(res) Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: auxField (:) Array of auxField of single element.\nSingle species: dens_1, vel_1\nmultispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2,\nAccess: (iElem-1)*nFields + iField integer, intent(in) :: iField Current field type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights Return Value real(kind=rk)(layout%fStencil%QQ) Output of this routine\nDimension: QQ of res Description Derive equilibrium from auxField for single element","tags":"","loc":"interface/derive_equilfromauxfunc.html"},{"title":"derive_auxFromStateFunc – Musubi","text":"interface private pure function derive_auxFromStateFunc(derVarPos, state, iField, stencil, varSys) result(res) Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of derive variable in variable system real(kind=rk), intent(in) :: state (:) Array of state\nlayout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field type( tem_stencilHeader_type ), intent(in) :: stencil stencil header contains discrete velocity vectors type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr Return Value real(kind=rk)(varSys%nAuxScalars) Output of this routine\nSize: nAuxScalars Description Derive auxField from state for single element","tags":"","loc":"interface/derive_auxfromstatefunc.html"},{"title":"derive_FromMacro – Musubi","text":"interface private  subroutine derive_FromMacro(density, velocity, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: density (:) Array of density.\nSingle species: dens_1, dens_2 .. dens_n\nmultispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ...\n               dens_n_sp1, dens_n_sp2\nAccess: (iElem-1)*nFields + iField real(kind=rk), intent(in) :: velocity (:,:) Array of velocity.\nSize: (3, n nFields)\nAccess: ( iComp, (iElem-1) nFields + iField ) integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*nComponents of res Description interface to derive equilibrium from macro.\nMainly used in initial condition and boundary condition routines\nto avoid dublication of routines between different scheme kinds.\nIn this interface, solver definition can be access via\nvarSys%method%val(1)%method_data c_ptr","tags":"","loc":"interface/derive_frommacro.html"},{"title":"derive_FromState – Musubi","text":"interface private  subroutine derive_FromState(state, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp Description Interface that takes state array as input\ncalculate density, velocity or eq as output\nState should be AOS layout","tags":"","loc":"interface/derive_fromstate.html"},{"title":"derive_FromPreColState – Musubi","text":"interface private  subroutine derive_FromPreColState(state, neigh, iField, nSize, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: iField Current field integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp Description Interface that takes state array as input\ncalculate density, velocity or eq as output from FETCH state i.e.\nprecollision state\nState should be AOS layout","tags":"","loc":"interface/derive_fromprecolstate.html"},{"title":"derive_equilFromAux – Musubi","text":"interface private  subroutine derive_equilFromAux(derVarPos, auxField, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: auxField (:) Array of auxField.\nSingle species: dens_1, vel_1, dens_2, vel_2, .. dens_n, vel_n\nmultispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2,\n               dens_2_sp1, vel_2_spc2, dens_2_sp2, vel_2_spc2 ...\n               dens_n_sp1, vel_n_sp1, dens_n_sp2, vel_n_spc2\nAccess: (iElem-1)*nFields + iField integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*QQ of res Description Derive equilibrium from auxField for given nelems","tags":"","loc":"interface/derive_equilfromaux.html"},{"title":"derive_auxFromState – Musubi","text":"interface private  subroutine derive_auxFromState(derVarPos, state, neigh, iField, nElems, nSize, iLevel, stencil, varSys, auxField, quantities) Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: state (:) Array of state\nnSize * layout%stencil(1)%QQ * nFields\nuse IDX macro to access this state integer, intent(in) :: neigh (:) connectivity vector integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements to compute integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: iLevel current level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header contains discrete velocity vectors type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr real(kind=rk), intent(inout) :: auxField (:) Output of this routine\nauxField is inout to allow storing auxField for each species\nseperately\nSize: nElems*nAuxScalars type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Description Derive auxField from local state.\n\\todo KM: pass external force to add to auxField","tags":"","loc":"interface/derive_auxfromstate.html"},{"title":"proc_calc_turb_visc_fromGradU – Musubi","text":"interface interface to calculate subgrid scale turbulent eddy viscosity private  subroutine proc_calc_turb_visc_fromGradU(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence config contains oefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL turbulence coefficients\ncurrent level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Description This function computes turbulent viscosity from gradient U","tags":"","loc":"interface/proc_calc_turb_visc_fromgradu.html"},{"title":"proc_calc_turb_visc_fromPreColPDF – Musubi","text":"interface interface to calculate subgrid scale turbulent eddy viscosity private  subroutine proc_calc_turb_visc_fromPreColPDF(turbVisc, turbConfig, state, neigh, auxField, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence type is implicitly passed to access turbulence coefficients real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL Description This function compute turbulent viscosity from pre-collision PDF","tags":"","loc":"interface/proc_calc_turb_visc_fromprecolpdf.html"},{"title":"intpRoutine – Musubi","text":"interface private  subroutine intpRoutine(method, fieldProp, tLevelDesc, level, sState, sNeigh, snSize, sAuxField, tState, tNeigh, tnSize, layout, nTargets, targetList, physics, time, varSys, derVarPos) Arguments Type Intent Optional Attributes Name class( mus_interpolation_method_type ), intent(inout) :: method type( mus_field_prop_type ), intent(in), target :: fieldProp (:) Array of field properties (fluid or species) type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level integer, intent(in) :: level my refinement level real(kind=rk), intent(in) :: sState (:) State vector of SOURCE elements integer, intent(in) :: sNeigh (:) integer, intent(in) :: snSize real(kind=rk), intent(inout) :: sAuxField (:) AuxField variable to read rho and vel from source elements real(kind=rk), intent(inout) :: tState (:) State vector of TARGET GHOST elements integer, intent(in) :: tNeigh (:) integer, intent(in) :: tnSize type( mus_scheme_layout_type ), intent(in) :: layout the layout used integer, intent(in) :: nTargets List of target elements ( their position in depSource list ) integer, intent(in) :: targetList (nTargets) type( mus_physics_type ), intent(in) :: physics physics type to convert lattice to physics SI unit and vice versa type( tem_time_type ), intent(in) :: time time required to compute analytical solution for TGV case type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of all derive variable in varSys Description This is the interface for all interpolation methods that","tags":"","loc":"interface/intproutine.html"},{"title":"intpRoutine_arbitraryVal – Musubi","text":"interface private  subroutine intpRoutine_arbitraryVal(method, tLevelDesc, level, stencil, sVal, tVal, nTargets, targetList, nScalars) Arguments Type Intent Optional Attributes Name class( mus_interpolation_method_type ), intent(inout) :: method type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level integer, intent(in) :: level my refinement level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header real(kind=rk), intent(in) :: sVal (:) array of SOURCE elements real(kind=rk), intent(inout) :: tVal (:) array of TARGET GHOST elements integer, intent(in) :: nTargets List of target elements ( their position in depSource list ) integer, intent(in) :: targetList (nTargets) position in total list - offset integer, intent(in) :: nScalars Number of scalars to interpolate Description This is the interface for all interpolation methods that","tags":"","loc":"interface/intproutine_arbitraryval.html"},{"title":"computation – Musubi","text":"interface private  subroutine computation(me, scheme, geometry, params, iLevel) Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable Description Interface describes the main control routine which does computation\nset boundary and check flow status","tags":"","loc":"interface/computation.html"},{"title":"kernel – Musubi","text":"interface What does the kernel interface look like?\nEvery kernel's argument list must correspond to this one. Adhere to the below naming convection for the kernel names mus_advRel_k _r _v _l Examples:\n  mus_advRel_kFluid_rBGK_vStd_lD3Q19\n  mus_advRel_kFluidIncomp_rBGK_vStd_lD3Q19\n  mus_advRel_kFluid_rBGK_vHRR_lD3Q19 For non-specific implementation leave names out.\nSo we do not use generic keyword in the kernel names anymore.\nExamples:\n  mus_advRel_kFluid_rBGK_vStd_l\n  mus_advRel_kMsLiquid_rBGK_vStd_l public  subroutine kernel(fieldProp, inState, outState, auxField, neigh, nElems, nSolve, level, layout, params, varSys, derVarPos) Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(in) :: fieldProp (:) Array of field properties (fluid or species) real(kind=rk), intent(in) :: inState (nElems*varSys%nScalars) input  pdf vector real(kind=rk), intent(out) :: outState (nElems*varSys%nScalars) output pdf vector real(kind=rk), intent(inout) :: auxField (nElems*varSys%nAuxScalars) Auxiliary field computed from pre-collision state\nIs updated with correct velocity field for multicomponent models integer, intent(in) :: neigh (nElems*layout%fStencil%QQ) connectivity vector integer, intent(in) :: nElems number of elements in state Array integer, intent(in) :: nSolve number of elements solved in kernel integer, intent(in) :: level current level type( mus_scheme_layout_type ), intent(in) :: layout current layout type( mus_param_type ), intent(in) :: params global parameters type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys for all fields Description The common subroutine interface for compute kernels. All kernels have to\nimplement this interface in order to be callable via\nmus_scheme_type%compute function pointer.","tags":"","loc":"interface/kernel.html"},{"title":"get_pdfEq – Musubi","text":"interface private pure function get_pdfEq(rho, vel, QQ, cxDirRK, weight) result(fEq) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the stencil real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk)(QQ) Description function pointer to get pdf equilibrium from vel and density","tags":"","loc":"interface/get_pdfeq.html"},{"title":"get_pdfEq_iDir – Musubi","text":"interface private pure function get_pdfEq_iDir(rho, vel, iDir, cxDirRK, weight) result(fEq) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk) Description function pointer to get pdf equilibrium from vel and density along a","tags":"","loc":"interface/get_pdfeq_idir.html"},{"title":"get_vel_from_pdf – Musubi","text":"interface private pure function get_vel_from_pdf(pdf, dens, cxDirRK) result(vel) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk)(3) velocity Description function pointer to get pdf equilibrium from vel and density","tags":"","loc":"interface/get_vel_from_pdf.html"},{"title":"get_vel_from_pdf_vectorized – Musubi","text":"interface private pure function get_vel_from_pdf_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk)(3,vlen) velocity Description function pointer to get pdf equilibrium from vel and density VECTORIZED","tags":"","loc":"interface/get_vel_from_pdf_vectorized.html"},{"title":"get_vector_from_vel_dens – Musubi","text":"interface private pure function get_vector_from_vel_dens(vel, dens) result(vector) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk)(3) momentum Description function pointer to get pdf equilibrium from vel and density","tags":"","loc":"interface/get_vector_from_vel_dens.html"},{"title":"get_scalar_from_vel_dens – Musubi","text":"interface private pure function get_scalar_from_vel_dens(vel, dens) result(scalar) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) momentum Description function pointer to get pdf equilibrium from vel and density","tags":"","loc":"interface/get_scalar_from_vel_dens.html"},{"title":"get_rho0Inv – Musubi","text":"interface private pure function get_rho0Inv(dens) result(inv_rho0) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) inverse of density regardless compressibility Description function pointer to get 1/rho as a mask regardless incompressibility","tags":"","loc":"interface/get_rho0inv.html"},{"title":"mus_writeRestart – Musubi","text":"public  subroutine mus_writeRestart(levelPointer, restart, scheme, tree, timing, timerHandle, suffix) Write the serialized buffer assembled in mus_serializeData to disk Arguments Type Intent Optional Attributes Name integer, intent(in) :: levelPointer (:) global pdf info type( tem_restart_type ), intent(inout) :: restart restart information type( mus_scheme_type ), intent(inout) :: scheme array of schemes including the data to be serialized and dumped type( treelmesh_type ), intent(in) :: tree mesh, provided in treelm format type( tem_time_type ), intent(inout) :: timing current simulation time information integer, intent(in) :: timerHandle Timer handle character(len=*), intent(in), optional :: suffix optional suffix (if present NO timestamp will be added!!!!) Calls proc~~mus_writerestart~~CallsGraph proc~mus_writerestart mus_writeRestart mus_pdf_serialize mus_pdf_serialize proc~mus_writerestart->mus_pdf_serialize tem_restart_closeWrite tem_restart_closeWrite proc~mus_writerestart->tem_restart_closeWrite tem_restart_openWrite tem_restart_openWrite proc~mus_writerestart->tem_restart_openWrite tem_restart_writeData tem_restart_writeData proc~mus_writerestart->tem_restart_writeData tem_startTimer tem_startTimer proc~mus_writerestart->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_writerestart->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_writerestart~~CalledByGraph proc~mus_writerestart mus_writeRestart proc~mus_dumpdata mus_dumpData proc~mus_dumpdata->proc~mus_writerestart proc~check_flow_status check_flow_status proc~check_flow_status->proc~mus_dumpdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_writerestart.html"},{"title":"mus_readRestart – Musubi","text":"public  subroutine mus_readRestart(levelPointer, restart, scheme, tree) Read the serialized restart file into the state vectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: levelPointer (tree%nElems) Level pointer, from tree mesh to level descriptor type( tem_restart_type ), intent(inout) :: restart restart information type( mus_scheme_type ), intent(inout) :: scheme array of schemes including the data to be serialized and dumped type( treelmesh_type ), intent(in) :: tree mesh, provided in treelm format Calls proc~~mus_readrestart~~CallsGraph proc~mus_readrestart mus_readRestart mus_pdf_unserialize mus_pdf_unserialize proc~mus_readrestart->mus_pdf_unserialize tem_restart_closeRead tem_restart_closeRead proc~mus_readrestart->tem_restart_closeRead tem_restart_openRead tem_restart_openRead proc~mus_readrestart->tem_restart_openRead tem_restart_readData tem_restart_readData proc~mus_readrestart->tem_restart_readData Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_readrestart~~CalledByGraph proc~mus_readrestart mus_readRestart program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_readrestart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_readrestart.html"},{"title":"mus_load_species – Musubi","text":"public  subroutine mus_load_species(me, conf, parent, minLevel, nFields, physics, cs_lattice) this routines load species table from config file species = { molweight = 1.0, diff_coeff = { 0.5,0.3,0.1 } } if species handle is not defined\n convert physics to lattice unit\n \\todo KM: Compute omega for each level Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in), optional :: parent integer, intent(in) :: minLevel integer, intent(in) :: nFields type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout\nrequired to compute omega from potential diffusivity Calls proc~~mus_load_species~~CallsGraph proc~mus_load_species mus_load_species aot_get_val aot_get_val proc~mus_load_species->aot_get_val aot_table_close aot_table_close proc~mus_load_species->aot_table_close aot_table_length aot_table_length proc~mus_load_species->aot_table_length aot_table_open aot_table_open proc~mus_load_species->aot_table_open tem_abort tem_abort proc~mus_load_species->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_species->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_species~~CalledByGraph proc~mus_load_species mus_load_species proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_prop->proc~mus_load_species proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_species.html"},{"title":"compute_molWeightRatio – Musubi","text":"public  subroutine compute_molWeightRatio(molWeights, molWeigRatios) This routine computes the molecular weight ratio for all species\nbased asinari model \"Lattice Boltzmann scheme for mixture modeling: Analysis of the continuum\ndiffusion regimes recovering Maxwell-Stefan model and incompressible\nNavier-Stokes equations. Pietro Asinari(2009)\"\n\\f$ m_\\sigma = \\frac{min_\\varsigma(m_\\varsigma)}{m_\\sigma} \\le 1 \\f$ Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: molWeights (:) molecular weight of the species real(kind=rk), intent(out) :: molWeigRatios (:) ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma \\f$ Calls proc~~compute_molweightratio~~CallsGraph proc~compute_molweightratio compute_molWeightRatio tem_horizontalSpacer tem_horizontalSpacer proc~compute_molweightratio->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_molweightratio~~CalledByGraph proc~compute_molweightratio compute_molWeightRatio proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~compute_molweightratio proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/compute_molweightratio.html"},{"title":"compute_bulkViscOmega – Musubi","text":"public  subroutine compute_bulkViscOmega(species, bulkvisc, bulkviscLvl, minLevel, maxLevel) This routine compute bulk viscosity omega for species for all levels\nomega_bulk = (2-molWeigRatio_k)/(3*bulk_visc) Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(inout) :: species contains species information real(kind=rk), intent(in) :: bulkvisc bulk viscosity of the mixture real(kind=rk), intent(in) :: bulkviscLvl (globalMaxLevels) integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Called by proc~~compute_bulkviscomega~~CalledByGraph proc~compute_bulkviscomega compute_bulkViscOmega proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~compute_bulkviscomega proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/compute_bulkviscomega.html"},{"title":"mus_species_out – Musubi","text":"public  subroutine mus_species_out(me, conf) writes species propertries into a lua file Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(in) :: me type( aot_out_type ) :: conf Calls proc~~mus_species_out~~CallsGraph proc~mus_species_out mus_species_out aot_out_close_table aot_out_close_table proc~mus_species_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_species_out->aot_out_open_table aot_out_val aot_out_val proc~mus_species_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_species_out~~CalledByGraph proc~mus_species_out mus_species_out proc~mus_field_prop_out mus_field_prop_out proc~mus_field_prop_out->proc~mus_species_out proc~mus_field_out_scal mus_field_out_scal proc~mus_field_out_scal->proc~mus_field_prop_out interface~mus_fields_out mus_fields_out interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_species_out.html"},{"title":"mus_hvs_config_load – Musubi","text":"public  subroutine mus_hvs_config_load(me, scheme, solverData, geometry, params) Read in LUA parameter file\nSee http://www.lua.org for a reference on how to use\nLua is a scripting language in itself which allows\nmore complex parameter files including comments\nAnd load / create the mesh depending on the configuration Arguments Type Intent Optional Attributes Name type( mus_hvs_config_type ), intent(out) :: me Musubi harvesting configuration to load when no tracking table is defined type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(inout), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters Calls proc~~mus_hvs_config_load~~CallsGraph proc~mus_hvs_config_load mus_hvs_config_load aot_get_val aot_get_val proc~mus_hvs_config_load->aot_get_val conf conf proc~mus_hvs_config_load->conf hvs_output_load hvs_output_load proc~mus_hvs_config_load->hvs_output_load proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata proc~mus_load_bc_data mus_load_bc_data proc~mus_hvs_config_load->proc~mus_load_bc_data proc~mus_open_config mus_open_config proc~mus_hvs_config_load->proc~mus_open_config tem_abort tem_abort proc~mus_hvs_config_load->tem_abort tem_debug_load_main tem_debug_load_main proc~mus_hvs_config_load->tem_debug_load_main tem_horizontalSpacer tem_horizontalSpacer proc~mus_hvs_config_load->tem_horizontalSpacer tem_load_general tem_load_general proc~mus_hvs_config_load->tem_load_general tem_load_restart tem_load_restart proc~mus_hvs_config_load->tem_load_restart tem_logging_load_primary tem_logging_load_primary proc~mus_hvs_config_load->tem_logging_load_primary tem_startTimer tem_startTimer proc~mus_hvs_config_load->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_hvs_config_load->tem_stopTimer tem_timeControl_start_at_sim tem_timeControl_start_at_sim proc~mus_hvs_config_load->tem_timeControl_start_at_sim proc~mus_hvs_load_solverdata->conf proc~mus_hvs_load_solverdata->tem_horizontalSpacer proc~mus_load_param mus_load_param proc~mus_hvs_load_solverdata->proc~mus_load_param proc~mus_load_physics mus_load_physics proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_scheme mus_load_scheme proc~mus_hvs_load_solverdata->proc~mus_load_scheme init_tem_bc_prop init_tem_bc_prop proc~mus_load_bc_data->init_tem_bc_prop load_tem_BC_qVal load_tem_BC_qVal proc~mus_load_bc_data->load_tem_BC_qVal proc~mus_build_posinprop mus_build_posInProp proc~mus_load_bc_data->proc~mus_build_posinprop property property proc~mus_load_bc_data->property qval qval proc~mus_load_bc_data->qval open_config_chunk open_config_chunk proc~mus_open_config->open_config_chunk proc~mus_create_funcstr mus_create_funcStr proc~mus_open_config->proc~mus_create_funcstr tem_open_distconf_array tem_open_distconf_array proc~mus_open_config->tem_open_distconf_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_hvs_config_load~~CalledByGraph proc~mus_hvs_config_load mus_hvs_config_load program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_hvs_config_load.html"},{"title":"mus_hvs_load_solverData – Musubi","text":"private  subroutine mus_hvs_load_solverData(scheme, solverData, geometry, params) This routines load solver data from config file except tracking Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(inout), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters Calls proc~~mus_hvs_load_solverdata~~CallsGraph proc~mus_hvs_load_solverdata mus_hvs_load_solverData conf conf proc~mus_hvs_load_solverdata->conf proc~mus_load_param mus_load_param proc~mus_hvs_load_solverdata->proc~mus_load_param proc~mus_load_physics mus_load_physics proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_scheme mus_load_scheme proc~mus_hvs_load_solverdata->proc~mus_load_scheme tem_horizontalSpacer tem_horizontalSpacer proc~mus_hvs_load_solverdata->tem_horizontalSpacer proc~mus_load_param->tem_horizontalSpacer aot_get_val aot_get_val proc~mus_load_param->aot_get_val proc~mus_load_physics->tem_horizontalSpacer proc~mus_load_physics->aot_get_val aot_table_close aot_table_close proc~mus_load_physics->aot_table_close aot_table_open aot_table_open proc~mus_load_physics->aot_table_open proc~mus_physics_dump2outunit mus_physics_dump2outUnit proc~mus_load_physics->proc~mus_physics_dump2outunit proc~mus_set_convfac mus_set_convFac proc~mus_load_physics->proc~mus_set_convfac proc~mus_set_scalefac mus_set_scaleFac proc~mus_load_physics->proc~mus_set_scalefac proc~set_values_by_levels set_values_by_levels proc~mus_load_physics->proc~set_values_by_levels tem_ElemSizeLevel tem_ElemSizeLevel proc~mus_load_physics->tem_ElemSizeLevel tem_abort tem_abort proc~mus_load_physics->tem_abort proc~mus_load_scheme->tem_horizontalSpacer mus_init_varsys_solverdata mus_init_varsys_solverdata proc~mus_load_scheme->mus_init_varsys_solverdata proc~mus_append_readvarasstatevar mus_append_readVarAsStateVar proc~mus_load_scheme->proc~mus_append_readvarasstatevar proc~mus_append_statevar mus_append_stateVar proc~mus_load_scheme->proc~mus_append_statevar proc~mus_create_poss_srcvar mus_create_poss_srcVar proc~mus_load_scheme->proc~mus_create_poss_srcvar proc~mus_create_poss_transvar mus_create_poss_transVar proc~mus_load_scheme->proc~mus_create_poss_transvar proc~mus_define_layout mus_define_layout proc~mus_load_scheme->proc~mus_define_layout proc~mus_load_fieldbaseinfos mus_load_fieldBaseInfos proc~mus_load_scheme->proc~mus_load_fieldbaseinfos proc~mus_load_fields mus_load_fields proc~mus_load_scheme->proc~mus_load_fields proc~mus_load_interpolate mus_load_interpolate proc~mus_load_scheme->proc~mus_load_interpolate proc~mus_load_newlayout mus_load_newLayout proc~mus_load_scheme->proc~mus_load_newlayout proc~mus_load_scheme_header mus_load_scheme_header proc~mus_load_scheme->proc~mus_load_scheme_header proc~mus_load_source_var mus_load_source_var proc~mus_load_scheme->proc~mus_load_source_var proc~mus_load_transport_var mus_load_transport_var proc~mus_load_scheme->proc~mus_load_transport_var tem_load_tracking tem_load_tracking proc~mus_load_scheme->tem_load_tracking tem_varSys_init tem_varSys_init proc~mus_load_scheme->tem_varSys_init tem_variable_load tem_variable_load proc~mus_load_scheme->tem_variable_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_hvs_load_solverdata~~CalledByGraph proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_hvs_load_solverdata.html"},{"title":"mus_init_longBuffers – Musubi","text":"public  subroutine mus_init_longBuffers(comm, pattern) Wrapper around the actual communication, to avoid copy-in, copy-out by the\nIntel compiler. (At least the intel compiler on pigeon (v12.0) seems to do\ncopying here, if a sub-array is passed to an assumed size dummy argument.\nTherefore we use this wrapping with an assumed shape dummy argument, so we\ncan pass a complete field to the actual exchange which has an assumed size\nargument, without copying complete state field around, just for\ncommunication. Ugly, but it doesn't seem to have an impact on performance,\nand right it seems to be the most suitable solution. Copy the element position in send and recv buffer to pos array\nin long type buffer Arguments Type Intent Optional Attributes Name type( tem_communication_type ), intent(inout) :: comm type( tem_commPattern_type ), intent(in) :: pattern","tags":"","loc":"proc/mus_init_longbuffers.html"},{"title":"cumulant_omega_check – Musubi","text":"public  subroutine cumulant_omega_check(omegaVisc, omegaBulk, omegaIn, nSolve, level) Checking the stability regions of omegas for the parametrized Cumulant\nJust omega(2) is given in input. omega(2)=-1 means omega2=omegaBulk.\nLimiters read from input. lim(N)=10&#94;10 means unlimited.\nlim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper.\nomega(6:10) = 1._rk Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omegaVisc (:) vector of omegas in the level real(kind=rk), intent(in) :: omegaBulk omega bulk value in the level real(kind=rk), intent(in) :: omegaIn (:) vector of omegas as given in musubi.lua integer, intent(in) :: nSolve number of elements solved in kernel integer, intent(in) :: level current level Calls proc~~cumulant_omega_check~~CallsGraph proc~cumulant_omega_check cumulant_omega_check tem_abort tem_abort proc~cumulant_omega_check->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cumulant_omega_check~~CalledByGraph proc~cumulant_omega_check cumulant_omega_check proc~mus_fluid_dump mus_fluid_dump proc~mus_fluid_dump->proc~cumulant_omega_check proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_fluid_dump proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cumulant_omega_check.html"},{"title":"mus_calc_commAmount – Musubi","text":"public  subroutine mus_calc_commAmount(stat, comm, nProcs) Calculate the number of links to be communicated Arguments Type Intent Optional Attributes Name type( mus_statistics_type ), intent(inout) :: stat runtime statistic integer, intent(in) :: comm integer, intent(in) :: nProcs Calls proc~~mus_calc_commamount~~CallsGraph proc~mus_calc_commamount mus_calc_commAmount mpi_reduce mpi_reduce proc~mus_calc_commamount->mpi_reduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_commamount.html"},{"title":"mus_load_nernstPlanck – Musubi","text":"public  subroutine mus_load_nernstPlanck(me, conf, parent, physics) load input to solve nernst_planck equation Arguments Type Intent Optional Attributes Name type( mus_nernstPlanck_type ), intent(out) :: me nernst_planck type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa Calls proc~~mus_load_nernstplanck~~CallsGraph proc~mus_load_nernstplanck mus_load_nernstPlanck aot_get_val aot_get_val proc~mus_load_nernstplanck->aot_get_val aot_table_close aot_table_close proc~mus_load_nernstplanck->aot_table_close aot_table_open aot_table_open proc~mus_load_nernstplanck->aot_table_open tem_abort tem_abort proc~mus_load_nernstplanck->tem_abort tem_toStr tem_toStr proc~mus_load_nernstplanck->tem_toStr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_nernstplanck~~CalledByGraph proc~mus_load_nernstplanck mus_load_nernstPlanck proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_nernstplanck proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_nernstplanck.html"},{"title":"getIdentifyChar – Musubi","text":"public  function getIdentifyChar(conf, key) result(resChar) Get a character from the identify table using a given solver specific\ncharacter handle and a given key word. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: key key to search for Return Value character(len=labelLen) scheme kind to be returned Calls proc~~getidentifychar~~CallsGraph proc~getidentifychar getIdentifyChar aot_get_val aot_get_val proc~getidentifychar->aot_get_val aot_table_close aot_table_close proc~getidentifychar->aot_table_close aot_table_open aot_table_open proc~getidentifychar->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getidentifychar.html"},{"title":"getVariable_FromTable – Musubi","text":"public  function getVariable_FromTable(conf, varLabel, table) result(val) Get the value of variable inside the table name 'key' in scheme\n @note Todo\n      extent it for vectors Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label character(len=*), intent(in) :: table table name Return Value real(kind=rk) val to be returned Calls proc~~getvariable_fromtable~~CallsGraph proc~getvariable_fromtable getVariable_FromTable aot_get_val aot_get_val proc~getvariable_fromtable->aot_get_val aot_table_close aot_table_close proc~getvariable_fromtable->aot_table_close aot_table_open aot_table_open proc~getvariable_fromtable->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getvariable_fromtable.html"},{"title":"getNFields – Musubi","text":"public  function getNFields(conf) result(nFields) Get the number of fields from a given solver specific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character Return Value integer number of fields to be returned Calls proc~~getnfields~~CallsGraph proc~getnfields getNFields aot_get_val aot_get_val proc~getnfields->aot_get_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getnfields.html"},{"title":"getFieldPrefixes – Musubi","text":"public  function getFieldPrefixes(conf, nFields) result(prefix) Get the right field prefixes from a given solver specific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character integer, intent(in) :: nFields Return Value character(len=labelLen), (nFields) field prefixes to be returned Calls proc~~getfieldprefixes~~CallsGraph proc~getfieldprefixes getFieldPrefixes aot_get_val aot_get_val proc~getfieldprefixes->aot_get_val aot_table_close aot_table_close proc~getfieldprefixes->aot_table_close aot_table_open aot_table_open proc~getfieldprefixes->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getfieldprefixes.html"},{"title":"getWeights – Musubi","text":"public  function getWeights(conf, stencil) result(weights) Get the the weights of a used stencil from a given solver specific\ncharacter handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character type( tem_stencilHeader_type ), intent(in) :: stencil stencil information Return Value real(kind=rk), (stencil%QQ) weights to be returned Calls proc~~getweights~~CallsGraph proc~getweights getWeights aot_get_val aot_get_val proc~getweights->aot_get_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getweights.html"},{"title":"getConversionFac – Musubi","text":"public  function getConversionFac(conf, facName, nLevels) result(val) Get the conversion factor variable from physics table from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: facName conversion factor variable label integer, intent(in) :: nLevels Return Value real(kind=rk), (nLevels) val to be returned Calls proc~~getconversionfac~~CallsGraph proc~getconversionfac getConversionFac aot_get_val aot_get_val proc~getconversionfac->aot_get_val aot_table_close aot_table_close proc~getconversionfac->aot_table_close aot_table_open aot_table_open proc~getconversionfac->aot_table_open tem_abort tem_abort proc~getconversionfac->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getconversionfac.html"},{"title":"getFieldVariable_scalar – Musubi","text":"private  function getFieldVariable_scalar(conf, varLabel, varName, fieldVar, fieldProp) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' Return Value real(kind=rk) val to be returned Calls proc~~getfieldvariable_scalar~~CallsGraph proc~getfieldvariable_scalar getFieldVariable_scalar aot_get_val aot_get_val proc~getfieldvariable_scalar->aot_get_val aot_table_close aot_table_close proc~getfieldvariable_scalar->aot_table_close aot_table_open aot_table_open proc~getfieldvariable_scalar->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getfieldvariable_scalar~~CalledByGraph proc~getfieldvariable_scalar getFieldVariable_scalar interface~getfieldvariable getFieldVariable interface~getfieldvariable->proc~getfieldvariable_scalar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getfieldvariable_scalar.html"},{"title":"getFieldVariable_array – Musubi","text":"private  function getFieldVariable_array(conf, varLabel, varName, fieldVar, fieldProp, nVals) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' integer, intent(in) :: nVals number of entries in the array to read out Return Value real(kind=rk), (nVals) val to be returned Calls proc~~getfieldvariable_array~~CallsGraph proc~getfieldvariable_array getFieldVariable_array aot_get_val aot_get_val proc~getfieldvariable_array->aot_get_val aot_table_close aot_table_close proc~getfieldvariable_array->aot_table_close aot_table_open aot_table_open proc~getfieldvariable_array->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getfieldvariable_array~~CalledByGraph proc~getfieldvariable_array getFieldVariable_array interface~getfieldvariable getFieldVariable interface~getfieldvariable->proc~getfieldvariable_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getfieldvariable_array.html"},{"title":"getFieldVariable – Musubi","text":"public interface getFieldVariable Calls interface~~getfieldvariable~~CallsGraph interface~getfieldvariable getFieldVariable proc~getfieldvariable_array getFieldVariable_array interface~getfieldvariable->proc~getfieldvariable_array proc~getfieldvariable_scalar getFieldVariable_scalar interface~getfieldvariable->proc~getfieldvariable_scalar aot_get_val aot_get_val proc~getfieldvariable_array->aot_get_val aot_table_close aot_table_close proc~getfieldvariable_array->aot_table_close aot_table_open aot_table_open proc~getfieldvariable_array->aot_table_open proc~getfieldvariable_scalar->aot_get_val proc~getfieldvariable_scalar->aot_table_close proc~getfieldvariable_scalar->aot_table_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function getFieldVariable_scalar (conf, varLabel, varName, fieldVar, fieldProp) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' Return Value real(kind=rk) val to be returned private  function getFieldVariable_array (conf, varLabel, varName, fieldVar, fieldProp, nVals) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' integer, intent(in) :: nVals number of entries in the array to read out Return Value real(kind=rk), (nVals) val to be returned","tags":"","loc":"interface/getfieldvariable.html"},{"title":"get_moment – Musubi","text":"public pure function get_moment(QQ, cxDir, expX, pdf) result(mom) Calculate the moment of a centain order\nThe moment of a distribution is defined as:\\n The fucntion argument expX is array of size 3,\nwhich contains the values of \\f$p, q, r\\f$ Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) integer, intent(in) :: expX (3) real(kind=rk), intent(in) :: pdf (QQ) distribution value Return Value real(kind=rk) Calls proc~~get_moment~~CallsGraph proc~get_moment get_moment proc~get_momentvector get_momentVector proc~get_moment->proc~get_momentvector proc~mus_imomvector mus_iMomVector proc~get_momentvector->proc~mus_imomvector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_moment.html"},{"title":"get_momentVector – Musubi","text":"public pure function get_momentVector(QQ, cxDir, expX) result(mom) get the moment vector to calculate the moment from the pdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) integer, intent(in) :: expX (3) exponents of the moments Return Value real(kind=rk), (QQ) moment vector Calls proc~~get_momentvector~~CallsGraph proc~get_momentvector get_momentVector proc~mus_imomvector mus_iMomVector proc~get_momentvector->proc~mus_imomvector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_momentvector~~CalledByGraph proc~get_momentvector get_momentVector proc~get_moment get_moment proc~get_moment->proc~get_momentvector proc~init_transformation_matrix_fluid init_transformation_matrix_fluid proc~init_transformation_matrix_fluid->proc~get_momentvector proc~init_transformation_matrix_ms init_transformation_matrix_MS proc~init_transformation_matrix_ms->proc~get_momentvector proc~mus_init_moments mus_init_moments proc~mus_init_moments->proc~init_transformation_matrix_fluid proc~mus_init_moments->proc~init_transformation_matrix_ms proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_momentvector.html"},{"title":"mus_iMomVector – Musubi","text":"private pure function mus_iMomVector(cxDir, expX, QQ) result(iMom) The integer moment vector for a given cxDir and order. Assuming 0**0 = 1 here. Arguments Type Intent Optional Attributes Name integer, intent(in) :: cxDir (:,:) discrete velocity integer, intent(in) :: expX (3) order in each direction integer, intent(in) :: QQ number of velocity channels (include rest) Return Value integer, (QQ) Called by proc~~mus_imomvector~~CalledByGraph proc~mus_imomvector mus_iMomVector proc~get_momentvector get_momentVector proc~get_momentvector->proc~mus_imomvector proc~get_moment get_moment proc~get_moment->proc~get_momentvector proc~init_transformation_matrix_fluid init_transformation_matrix_fluid proc~init_transformation_matrix_fluid->proc~get_momentvector proc~init_transformation_matrix_ms init_transformation_matrix_MS proc~init_transformation_matrix_ms->proc~get_momentvector proc~mus_init_moments mus_init_moments proc~mus_init_moments->proc~init_transformation_matrix_fluid proc~mus_init_moments->proc~init_transformation_matrix_ms proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_imomvector.html"},{"title":"mus_init_moments – Musubi","text":"public  subroutine mus_init_moments(me, QQ, cxDir, label, schemeHeader) Initialize the moment space Arguments Type Intent Optional Attributes Name type( mus_moment_type ), intent(inout) :: me integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme Calls proc~~mus_init_moments~~CallsGraph proc~mus_init_moments mus_init_moments a a proc~mus_init_moments->a nentries nentries proc~mus_init_moments->nentries proc~init_transformation_matrix_fluid init_transformation_matrix_fluid proc~mus_init_moments->proc~init_transformation_matrix_fluid proc~init_transformation_matrix_ms init_transformation_matrix_MS proc~mus_init_moments->proc~init_transformation_matrix_ms proc~mus_dump_moments mus_dump_moments proc~mus_init_moments->proc~mus_dump_moments invert_matrix invert_matrix proc~init_transformation_matrix_fluid->invert_matrix proc~get_momentvector get_momentVector proc~init_transformation_matrix_fluid->proc~get_momentvector proc~init_transformation_matrix_ms->invert_matrix proc~init_transformation_matrix_ms->proc~get_momentvector tem_matrix_dump tem_matrix_dump proc~mus_dump_moments->tem_matrix_dump proc~mus_imomvector mus_iMomVector proc~get_momentvector->proc~mus_imomvector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_moments~~CalledByGraph proc~mus_init_moments mus_init_moments proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_moments.html"},{"title":"set_momentIndices – Musubi","text":"public  subroutine set_momentIndices(nDims, iPress, iVelMin, iVelMax, iSMin, iSMax) set indices for accessing the pressure, velocity and the shear from a 1d\nvector Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims number of dimensions integer, intent(out) :: iPress index for the pressure / density integer, intent(out) :: iVelMin starting index for velocity integer, intent(out) :: iVelMax ending index for velocity integer, intent(out) :: iSMin starting index for shear integer, intent(out) :: iSMax ending index for shear","tags":"","loc":"proc/set_momentindices.html"},{"title":"mus_dump_moments – Musubi","text":"public  subroutine mus_dump_moments(me, outUnit) Dump moments matrix: toPDF and toMoment Arguments Type Intent Optional Attributes Name type( mus_moment_type ), intent(in) :: me integer, intent(in) :: outUnit Calls proc~~mus_dump_moments~~CallsGraph proc~mus_dump_moments mus_dump_moments tem_matrix_dump tem_matrix_dump proc~mus_dump_moments->tem_matrix_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_dump_moments~~CalledByGraph proc~mus_dump_moments mus_dump_moments proc~mus_init_moments mus_init_moments proc~mus_init_moments->proc~mus_dump_moments proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_dump_moments.html"},{"title":"init_transformation_matrix_fluid – Musubi","text":"private  subroutine init_transformation_matrix_fluid(QQ, cxDir, label, me, toMoment, toPdf) Initialize Moments transformation matrix for LBM compressible and\nincompressible fluid model. This matrix must be consistent with the\nrelaxation matrix used in compute kernel and interpolation routines Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_moment_type ), intent(inout) :: me real(kind=rk), intent(inout) :: toMoment (me%toMoments%nEntries(1),me%toMoments%nEntries(2)) real(kind=rk), intent(inout) :: toPdf (me%toPDF%nEntries(1),me%toPDF%nEntries(2)) Calls proc~~init_transformation_matrix_fluid~~CallsGraph proc~init_transformation_matrix_fluid init_transformation_matrix_fluid invert_matrix invert_matrix proc~init_transformation_matrix_fluid->invert_matrix proc~get_momentvector get_momentVector proc~init_transformation_matrix_fluid->proc~get_momentvector proc~mus_imomvector mus_iMomVector proc~get_momentvector->proc~mus_imomvector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~init_transformation_matrix_fluid~~CalledByGraph proc~init_transformation_matrix_fluid init_transformation_matrix_fluid proc~mus_init_moments mus_init_moments proc~mus_init_moments->proc~init_transformation_matrix_fluid proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_transformation_matrix_fluid.html"},{"title":"init_transformation_matrix_MS – Musubi","text":"private  subroutine init_transformation_matrix_MS(QQ, cxDir, label, me, toMoment, toPdf) Intialize the moment transformation matrix for multispecies.\nThis matrix must be consistent with relaxation matrix used for\nmultispecies MRT collision routines Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_moment_type ), intent(inout) :: me real(kind=rk), intent(inout) :: toMoment (me%toMoments%nEntries(1),me%toMoments%nEntries(2)) real(kind=rk), intent(inout) :: toPdf (me%toPDF%nEntries(1),me%toPDF%nEntries(2)) Calls proc~~init_transformation_matrix_ms~~CallsGraph proc~init_transformation_matrix_ms init_transformation_matrix_MS invert_matrix invert_matrix proc~init_transformation_matrix_ms->invert_matrix proc~get_momentvector get_momentVector proc~init_transformation_matrix_ms->proc~get_momentvector proc~mus_imomvector mus_iMomVector proc~get_momentvector->proc~mus_imomvector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~init_transformation_matrix_ms~~CalledByGraph proc~init_transformation_matrix_ms init_transformation_matrix_MS proc~mus_init_moments mus_init_moments proc~mus_init_moments->proc~init_transformation_matrix_ms proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_init_moments proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_transformation_matrix_ms.html"},{"title":"HRR_Correction_d2q9 – Musubi","text":"public pure subroutine HRR_Correction_d2q9(QQ, weight, gradRHOU3, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho V&#94;3 real(kind=rk), intent(out) :: phi (:) correction term phi real(kind=rk), intent(out) :: dens correction term phi, rho, vel real(kind=rk), intent(out) :: vel (:) correction term phi, rho, vel","tags":"","loc":"proc/hrr_correction_d2q9.html"},{"title":"HRR_Correction_d3q19 – Musubi","text":"public pure subroutine HRR_Correction_d3q19(QQ, weight, gradRHOU3, gradRHOUVZ, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho u&#94;3, rho u v w real(kind=rk), intent(in) :: gradRHOUVZ (:) real(kind=rk), intent(out) :: phi (:) correction term phi, rho, vel real(kind=rk), intent(out) :: dens correction term phi, rho, vel real(kind=rk), intent(out) :: vel (:) correction term phi, rho, vel","tags":"","loc":"proc/hrr_correction_d3q19.html"},{"title":"HRR_Correction_d3q27 – Musubi","text":"public pure subroutine HRR_Correction_d3q27(QQ, weight, gradRHOU3, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho V&#94;3 real(kind=rk), intent(out) :: phi (:) correction term phi real(kind=rk), intent(out) :: dens correction term phi real(kind=rk), intent(out) :: vel (:) correction term phi","tags":"","loc":"proc/hrr_correction_d3q27.html"},{"title":"getHermitepolynomials – Musubi","text":"public  subroutine getHermitepolynomials(nDims, QQ, layout, H_order) This function computes Hermite polinomial. It gives in output minimum Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims number of physical dimensions integer, intent(in) :: QQ number of stencil streaming directions type( mus_scheme_layout_type ), intent(in) :: layout current layout integer, intent(in) :: H_order maximum order of the Hermite polynomials Calls proc~~gethermitepolynomials~~CallsGraph proc~gethermitepolynomials getHermitepolynomials cxdirrk cxdirrk proc~gethermitepolynomials->cxdirrk tem_abort tem_abort proc~gethermitepolynomials->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gethermitepolynomials.html"},{"title":"getHermitepolynomials_D3Q19 – Musubi","text":"public  subroutine getHermitepolynomials_D3Q19(layout) This function computes Hermite polinomial. It gives in output minimum Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(in) :: layout current layout Calls proc~~gethermitepolynomials_d3q19~~CallsGraph proc~gethermitepolynomials_d3q19 getHermitepolynomials_D3Q19 cxdirrk cxdirrk proc~gethermitepolynomials_d3q19->cxdirrk tem_abort tem_abort proc~gethermitepolynomials_d3q19->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gethermitepolynomials_d3q19.html"},{"title":"mus_load_fluid – Musubi","text":"public  subroutine mus_load_fluid(me, conf, parent, minLevel, physics, schemeHeader) Read in the fluid property from the LUA parameter file \"Theory of the lattice Boltzmann method: Dispersion, dissipation,\nisotropy, Galilean invariance, and stability\", Pierre Lallemand and\nLi-Shi Luo, Phys. Rev. E 61, 2000. Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(out) :: me fluid type type( flu_State ) :: conf lua state integer, intent(in), optional :: parent parent handle integer, intent(in) :: minLevel global pdf info type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme Calls proc~~mus_load_fluid~~CallsGraph proc~mus_load_fluid mus_load_fluid aot_get_val aot_get_val proc~mus_load_fluid->aot_get_val aot_table_close aot_table_close proc~mus_load_fluid->aot_table_close aot_table_open aot_table_open proc~mus_load_fluid->aot_table_open mus_nnwtn_load mus_nnwtn_load proc~mus_load_fluid->mus_nnwtn_load proc~mus_load_turbulence mus_load_turbulence proc~mus_load_fluid->proc~mus_load_turbulence tem_abort tem_abort proc~mus_load_fluid->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_fluid->tem_horizontalSpacer tem_load_spacetime tem_load_spacetime proc~mus_load_fluid->tem_load_spacetime proc~mus_load_turbulence->aot_get_val proc~mus_load_turbulence->aot_table_close proc~mus_load_turbulence->aot_table_open proc~mus_load_turbulence->tem_abort proc~mus_load_turbulence->tem_horizontalSpacer upper_to_lower upper_to_lower proc~mus_load_turbulence->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_fluid~~CalledByGraph proc~mus_load_fluid mus_load_fluid proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_prop->proc~mus_load_fluid proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_fluid.html"},{"title":"mus_init_fluid – Musubi","text":"public  subroutine mus_init_fluid(me, physics, schemeHeader, minLevel, maxLevel, levelDesc, pdf, stencil, general, tNow) This routine initilizes fluid visocity and relaxation paramters for each\nlevel Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me fluid type type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header integer, intent(in) :: minLevel min and max level integer, intent(in) :: maxLevel min and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) level descriptor type( pdf_data_type ), intent(in) :: pdf (minLevel:maxLevel) pdf info with neigh array for all levels type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_general_type ), intent(in) :: general general type contains communication pattern and proc info type( tem_time_type ), intent(in) :: tNow current simulation time Calls proc~~mus_init_fluid~~CallsGraph proc~mus_init_fluid mus_init_fluid init init proc~mus_init_fluid->init mus_assign_mrt_ptr mus_assign_mrt_ptr proc~mus_init_fluid->mus_assign_mrt_ptr mus_assign_nnwtnvisc_ptr mus_assign_nnwtnvisc_ptr proc~mus_init_fluid->mus_assign_nnwtnvisc_ptr proc~mus_assign_turbvisc_ptr mus_assign_turbVisc_ptr proc~mus_init_fluid->proc~mus_assign_turbvisc_ptr proc~mus_fluid_dump mus_fluid_dump proc~mus_init_fluid->proc~mus_fluid_dump proc~mus_init_relaxparam mus_init_relaxParam proc~mus_init_fluid->proc~mus_init_relaxparam proc~mus_init_turbulencedata mus_init_turbulenceData proc~mus_init_fluid->proc~mus_init_turbulencedata proc~mus_update_relaxparamfromviscstfun mus_update_relaxParamFromViscSTfun proc~mus_init_fluid->proc~mus_update_relaxparamfromviscstfun tem_abort tem_abort proc~mus_assign_turbvisc_ptr->tem_abort mpi_reduce mpi_reduce proc~mus_fluid_dump->mpi_reduce mus_nnwtn_dump2outunit mus_nnwtn_dump2outunit proc~mus_fluid_dump->mus_nnwtn_dump2outunit proc~cumulant_omega_check cumulant_omega_check proc~mus_fluid_dump->proc~cumulant_omega_check proc~mus_calcomegafromvisc mus_calcOmegaFromVisc proc~mus_fluid_dump->proc~mus_calcomegafromvisc val val proc~mus_fluid_dump->val tem_comm_init tem_comm_init proc~mus_init_turbulencedata->tem_comm_init proc~mus_update_relaxparamfromviscstfun->proc~mus_calcomegafromvisc tem_spacetime_for tem_spacetime_for proc~mus_update_relaxparamfromviscstfun->tem_spacetime_for proc~cumulant_omega_check->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_fluid~~CalledByGraph proc~mus_init_fluid mus_init_fluid proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_fluid.html"},{"title":"mus_fluid_save2lua – Musubi","text":"public  subroutine mus_fluid_save2lua(me, conf) write fluid prop into a lua file Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(in) :: me single fluid type type( aot_out_type ) :: conf Calls proc~~mus_fluid_save2lua~~CallsGraph proc~mus_fluid_save2lua mus_fluid_save2lua aot_out_close_table aot_out_close_table proc~mus_fluid_save2lua->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_fluid_save2lua->aot_out_open_table aot_out_val aot_out_val proc~mus_fluid_save2lua->aot_out_val const const proc~mus_fluid_save2lua->const mus_nnwtn_save2lua mus_nnwtn_save2lua proc~mus_fluid_save2lua->mus_nnwtn_save2lua Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_fluid_save2lua~~CalledByGraph proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out mus_field_prop_out proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_field_out_scal mus_field_out_scal proc~mus_field_out_scal->proc~mus_field_prop_out interface~mus_fields_out mus_fields_out interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_fluid_save2lua.html"},{"title":"mus_fluid_cleanup – Musubi","text":"public  subroutine mus_fluid_cleanup(me) This routines act as a destructor for fluid type Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me single fluid type Called by proc~~mus_fluid_cleanup~~CalledByGraph proc~mus_fluid_cleanup mus_fluid_cleanup proc~mus_field_cleanup mus_field_cleanup proc~mus_field_cleanup->proc~mus_fluid_cleanup proc~mus_scheme_cleanup mus_scheme_cleanup proc~mus_scheme_cleanup->proc~mus_field_cleanup proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_scheme_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_fluid_cleanup.html"},{"title":"mus_fluid_dump – Musubi","text":"private  subroutine mus_fluid_dump(me, minLevel, maxLevel, physics, nSolve, general, outUnit, schemeHeader) Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa integer, intent(in) :: nSolve (minLevel:maxLevel) number of elements to solve per level (fluid+ghost) type( tem_general_type ), intent(in) :: general general type integer, intent(in) :: outUnit type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header Calls proc~~mus_fluid_dump~~CallsGraph proc~mus_fluid_dump mus_fluid_dump mpi_reduce mpi_reduce proc~mus_fluid_dump->mpi_reduce mus_nnwtn_dump2outunit mus_nnwtn_dump2outunit proc~mus_fluid_dump->mus_nnwtn_dump2outunit proc~cumulant_omega_check cumulant_omega_check proc~mus_fluid_dump->proc~cumulant_omega_check proc~mus_calcomegafromvisc mus_calcOmegaFromVisc proc~mus_fluid_dump->proc~mus_calcomegafromvisc val val proc~mus_fluid_dump->val tem_abort tem_abort proc~cumulant_omega_check->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_fluid_dump~~CalledByGraph proc~mus_fluid_dump mus_fluid_dump proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_fluid_dump proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_fluid_dump.html"},{"title":"mus_time_modulo – Musubi","text":"public pure function mus_time_modulo(now, reqInt) result(triggered) Check for multilevel cycle complete by modulo of nIters by scaleFactor\ndepends on acoustic or diffusive scaling.\nAcoustic scaling: scale factor = 2\nDiffusive scaling: scale factor = 4 Arguments Type Intent Optional Attributes Name type( tem_time_type ), intent(in) :: now current simulation time integer, intent(in) :: reqInt Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached. Return Value logical","tags":"","loc":"proc/mus_time_modulo.html"},{"title":"mus_time_homogenize – Musubi","text":"public  subroutine mus_time_homogenize(me, dt, readRestart) Convert itime from restart to real time Arguments Type Intent Optional Attributes Name type( tem_time_type ), intent(inout) :: me real(kind=rk), intent(in) :: dt logical, intent(in) :: readRestart Calls proc~~mus_time_homogenize~~CallsGraph proc~mus_time_homogenize mus_time_homogenize tem_time_dump tem_time_dump proc~mus_time_homogenize->tem_time_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_time_homogenize~~CalledByGraph proc~mus_time_homogenize mus_time_homogenize proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_time_homogenize proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_time_homogenize program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_time_homogenize.html"},{"title":"mus_timeControl_homogenize – Musubi","text":"public  subroutine mus_timeControl_homogenize(me, dt, reqInt) Converts sim time to iter and vice versa depends on which one is defined\nin the configuration file Arguments Type Intent Optional Attributes Name type( tem_timeControl_type ), intent(inout) :: me simulation time control real(kind=rk), intent(in) :: dt dt of maxlevel or smallest dt integer, intent(in) :: reqInt Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached. Calls proc~~mus_timecontrol_homogenize~~CallsGraph proc~mus_timecontrol_homogenize mus_timeControl_homogenize tem_timeControl_dump tem_timeControl_dump proc~mus_timecontrol_homogenize->tem_timeControl_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_timecontrol_homogenize~~CalledByGraph proc~mus_timecontrol_homogenize mus_timeControl_homogenize proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_timecontrol_homogenize proc~mus_init_tracker mus_init_tracker proc~mus_init_aux->proc~mus_init_tracker proc~mus_init_tracker->proc~mus_timecontrol_homogenize proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_timecontrol_homogenize proc~mus_reset_aux->proc~mus_init_tracker proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_tracker proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_timecontrol_homogenize.html"},{"title":"mus_load_mixture – Musubi","text":"public  subroutine mus_load_mixture(me, conf, parent, minLevel, maxLevel, physics, schemeHeader, nFields) This routine load mixture table from scheme table.\nDefine either mass density or number density.\nIf mass density is specified, number density can be computed at runtime\nor vice versa.\n @note Todo\n      Currently, the simulation is initialized by density, extend\n    it to initialize from mixture number density/volume fraction\n    and mole fraction\n    \\verbatim\n    mixture = { rho0 = 1.0, omega }\n    \\endverbatim load paramters for forces Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(out) :: me contains mixture information type( flu_State ) :: conf integer, intent(in), optional :: parent integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields defined in lua file Calls proc~~mus_load_mixture~~CallsGraph proc~mus_load_mixture mus_load_mixture aot_get_val aot_get_val proc~mus_load_mixture->aot_get_val aot_table_close aot_table_close proc~mus_load_mixture->aot_table_close aot_table_open aot_table_open proc~mus_load_mixture->aot_table_open proc~mus_init_enrtl mus_init_eNRTL proc~mus_load_mixture->proc~mus_init_enrtl proc~set_omegaslvl set_omegasLvl proc~mus_load_mixture->proc~set_omegaslvl tem_abort tem_abort proc~mus_load_mixture->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_mixture->tem_horizontalSpacer tem_load_ic tem_load_ic proc~mus_load_mixture->tem_load_ic tem_load_spatial tem_load_spatial proc~mus_load_mixture->tem_load_spatial tem_load_temporal tem_load_temporal proc~mus_load_mixture->tem_load_temporal interface~init_enrtl_loc init_enrtl_loc proc~mus_init_enrtl->interface~init_enrtl_loc proc~set_omegaslvl->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_mixture~~CalledByGraph proc~mus_load_mixture mus_load_mixture proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_mixture proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_mixture.html"},{"title":"mus_mixture_out – Musubi","text":"public  subroutine mus_mixture_out(me, conf, schemeHeader) This routine write mixture properties into lua file Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(in) :: me mixture info type( aot_out_type ) :: conf type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme Calls proc~~mus_mixture_out~~CallsGraph proc~mus_mixture_out mus_mixture_out aot_out_close_table aot_out_close_table proc~mus_mixture_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_mixture_out->aot_out_open_table aot_out_val aot_out_val proc~mus_mixture_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_mixture_out~~CalledByGraph proc~mus_mixture_out mus_mixture_out proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->proc~mus_mixture_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_mixture_out.html"},{"title":"set_omegasLvl – Musubi","text":"private  subroutine set_omegasLvl(mixture, minLevel, maxLevel, physics) Set the omegas according to the time step setting cross check whether omega at each level is set correctly\nby computing physical viscosity from omega and check it with\nspecified physical kinematic viscosity Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(inout) :: mixture integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa Calls proc~~set_omegaslvl~~CallsGraph proc~set_omegaslvl set_omegasLvl tem_abort tem_abort proc~set_omegaslvl->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_omegaslvl~~CalledByGraph proc~set_omegaslvl set_omegasLvl proc~mus_load_mixture mus_load_mixture proc~mus_load_mixture->proc~set_omegaslvl proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_mixture proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/set_omegaslvl.html"},{"title":"mus_hvs_construct – Musubi","text":"public  subroutine mus_hvs_construct(scheme, geometry, params) Initialize Musubi data strucutres based on data provided by Treelm Load the mesh and boundary conditions for this process from disk.\nGet the level-wise treeID lists and create the required ghost and halo\nelements. This is achieved by a two-folded identification of elements. -# the theoretically required elements are collected based on mus_scheme_layout_type \"stencil information\"\nThe tem_construction_module \"find neighbor routine\"\nperforms this task for compute fluid elements.\nFor boundaries which require information from neighbor elements, these\nrequired tem_topology_module \"treeIDs\" are collected into the mus_bc_header_module \"boundary element type\"\n-# All required elements are created in the tem_construction_module \"Level Descriptor creation routine\" Additional Tasks receive tem_construction_module \"horizontal\"\n(within a level for the element updates) and tem_construction \"vertical\"\ndependencies (between levels for ghost-interpolations). The main state vector and the neighbor lists on which the kernel then\n   acts is created The MPI buffers are created. For each mus_scheme_module \"Scheme\", the tem_levelDesc_type \"Level Descriptor\"\nis created Result After this routine, all data structures for starting the main loop of the\nsolver are allocated and ready. Only difference between this routine and mus_construct is then\ncreating of boundary elements and its stencil are omitted for harvesting Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme information including fluid, boundary and flow information type( mus_geom_type ), intent(inout) :: geometry geometric information type( mus_param_type ), intent(inout) :: params run-time Parameters Calls proc~~mus_hvs_construct~~CallsGraph proc~mus_hvs_construct mus_hvs_construct calculate_nelems calculate_nelems proc~mus_hvs_construct->calculate_nelems destroy destroy proc~mus_hvs_construct->destroy my_status_int my_status_int proc~mus_hvs_construct->my_status_int nelems nelems proc~mus_hvs_construct->nelems proc~mus_calc_nelems mus_calc_nElems proc~mus_hvs_construct->proc~mus_calc_nelems proc~mus_finalize_layout mus_finalize_layout proc~mus_hvs_construct->proc~mus_finalize_layout proc~mus_pdf_allocate mus_pdf_allocate proc~mus_hvs_construct->proc~mus_pdf_allocate tem_build_horizontalDependencies tem_build_horizontalDependencies proc~mus_hvs_construct->tem_build_horizontalDependencies tem_debug_HorizontalDependencies tem_debug_HorizontalDependencies proc~mus_hvs_construct->tem_debug_HorizontalDependencies tem_dumpTreeIDlists tem_dumpTreeIDlists proc~mus_hvs_construct->tem_dumpTreeIDlists tem_find_allElements tem_find_allElements proc~mus_hvs_construct->tem_find_allElements tem_getTimerVal tem_getTimerVal proc~mus_hvs_construct->tem_getTimerVal tem_horizontalSpacer tem_horizontalSpacer proc~mus_hvs_construct->tem_horizontalSpacer tem_init_elemLevels tem_init_elemLevels proc~mus_hvs_construct->tem_init_elemLevels tem_startTimer tem_startTimer proc~mus_hvs_construct->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_hvs_construct->tem_stopTimer proc~mus_finalize_layout->destroy append append proc~mus_finalize_layout->append elemlvl elemlvl proc~mus_finalize_layout->elemlvl mpi_gather mpi_gather proc~mus_finalize_layout->mpi_gather mpi_gatherv mpi_gatherv proc~mus_finalize_layout->mpi_gatherv mpi_type_commit mpi_type_commit proc~mus_finalize_layout->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~mus_finalize_layout->mpi_type_contiguous truncate truncate proc~mus_finalize_layout->truncate val val proc~mus_finalize_layout->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_hvs_construct~~CalledByGraph proc~mus_hvs_construct mus_hvs_construct program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_construct Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_hvs_construct.html"},{"title":"mus_calc_nElems – Musubi","text":"public  subroutine mus_calc_nElems(me, nFluids, nGhostFromCoarser, nGhostFromFiner, nHalos) Compute nElems for different types Arguments Type Intent Optional Attributes Name type( pdf_data_type ) :: me integer, intent(in) :: nFluids integer, intent(in) :: nGhostFromCoarser integer, intent(in) :: nGhostFromFiner integer, intent(in) :: nHalos Called by proc~~mus_calc_nelems~~CalledByGraph proc~mus_calc_nelems mus_calc_nElems proc~mus_hvs_construct mus_hvs_construct proc~mus_hvs_construct->proc~mus_calc_nelems program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_construct Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_nelems.html"},{"title":"mus_pdf_allocate – Musubi","text":"public  subroutine mus_pdf_allocate(me, nScalars, QQ, nElems_bcBuffer, isPDF) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me integer, intent(in) :: nScalars integer, intent(in) :: QQ integer, intent(in) :: nElems_bcBuffer logical, intent(in) :: isPDF Called by proc~~mus_pdf_allocate~~CalledByGraph proc~mus_pdf_allocate mus_pdf_allocate proc~mus_hvs_construct mus_hvs_construct proc~mus_hvs_construct->proc~mus_pdf_allocate program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_construct Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_pdf_allocate.html"},{"title":"mus_swap_Now_Next – Musubi","text":"public  subroutine mus_swap_Now_Next(me) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me Called by proc~~mus_swap_now_next~~CalledByGraph proc~mus_swap_now_next mus_swap_Now_Next proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_swap_now_next proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_swap_now_next proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_swap_now_next Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_swap_now_next.html"},{"title":"allocate_momBuf – Musubi","text":"public  subroutine allocate_momBuf(me, nVals) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me integer, intent(in) :: nVals","tags":"","loc":"proc/allocate_mombuf.html"},{"title":"mus_init_sourceTerms – Musubi","text":"public  subroutine mus_init_sourceTerms(field, nFields, globSrc, varSys, tree, bc_prop, stencil, nElems_solve, levelDesc) This routine does set_params and setupIndices for all sources terms\nby gathering points to apply souce term before. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (:) contains sources of all fields integer, intent(in) :: nFields Number of fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_varSys_type ), intent(in) :: varSys global variable system type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: nElems_solve (tree%global%minLevel:) Number of elements to solve in all levels\nnFluids + nGhostFromCoarser type( tem_levelDesc_type ), intent(in) :: levelDesc (tree%global%minLevel:) Level descriptors Calls proc~~mus_init_sourceterms~~CallsGraph proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_internalsource mus_init_internalSource proc~mus_init_sourceterms->proc~mus_init_internalsource proc~mus_setupindices_forsrc mus_setupIndices_forSrc proc~mus_init_sourceterms->proc~mus_setupindices_forsrc tem_horizontalSpacer tem_horizontalSpacer proc~mus_init_sourceterms->tem_horizontalSpacer proc~mus_init_hrrcorrection mus_init_hrrCorrection proc~mus_init_internalsource->proc~mus_init_hrrcorrection val val proc~mus_init_internalsource->val proc~mus_init_absorblayer mus_init_absorbLayer proc~mus_setupindices_forsrc->proc~mus_init_absorblayer proc~mus_init_turbchanforce mus_init_turbChanForce proc~mus_setupindices_forsrc->proc~mus_init_turbchanforce set_params set_params proc~mus_setupindices_forsrc->set_params setup_indices setup_indices proc~mus_setupindices_forsrc->setup_indices proc~mus_setupindices_forsrc->val mpi_allreduce mpi_allreduce proc~mus_init_turbchanforce->mpi_allreduce tem_create_subTree_of tem_create_subTree_of proc~mus_init_turbchanforce->tem_create_subTree_of Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_sourceterms~~CalledByGraph proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_sourceterms.html"},{"title":"mus_apply_sourceTerms – Musubi","text":"public  subroutine mus_apply_sourceTerms(field, nFields, globSrc, pdf, varSys, iLevel, time, phyConvFac, state, auxField, derVarPos) Apply all source terms i.e field specific source and global source on\nall fields. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: field (nFields) contains sources of all fields integer, intent(in) :: nFields Number of fields type( mus_source_type ), intent(in) :: globSrc global source type( pdf_data_type ), intent(inout) :: pdf pdf datatype type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level real(kind=rk), intent(inout) :: state (:,:) state type containing the state vector to update real(kind=rk), intent(in) :: auxField (:) auxField array type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Calls proc~~mus_apply_sourceterms~~CallsGraph proc~mus_apply_sourceterms mus_apply_sourceTerms tem_startTimer tem_startTimer proc~mus_apply_sourceterms->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_apply_sourceterms->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_apply_sourceterms~~CalledByGraph proc~mus_apply_sourceterms mus_apply_sourceTerms proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_apply_sourceterms proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_apply_sourceterms proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_apply_sourceterms Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_apply_sourceterms.html"},{"title":"mus_update_sourceVars – Musubi","text":"public  subroutine mus_update_sourceVars(nFields, field, globSrc, varSys, iLevel, auxField, phyConvFac, derVarPos) Updated all source variables i.e field specific source and global source on\nall fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields Number of fields type( mus_field_type ), intent(inout) :: field (nFields) contains sources of all fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: iLevel current level real(kind=rk), intent(in) :: auxField (:) auxField array type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Calls proc~~mus_update_sourcevars~~CallsGraph proc~mus_update_sourcevars mus_update_sourceVars tem_startTimer tem_startTimer proc~mus_update_sourcevars->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_update_sourcevars->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_update_sourcevars~~CalledByGraph proc~mus_update_sourcevars mus_update_sourceVars proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_sourcevars proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_sourcevars proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_sourcevars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_update_sourcevars.html"},{"title":"mus_setupIndices_forSrc – Musubi","text":"private  subroutine mus_setupIndices_forSrc(source, varSys, nSolve, bary, iLevel, tree, bc_prop, stencil) This routines does setup indices for given source within a field or\nglobal. Index are stored for points which source term is active Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: source Source term to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nSolve Number of elements to apply source term  on this level real(kind=rk), intent(in) :: bary (:,:) Space coordinates to apply source terms integer, intent(in) :: iLevel Current level type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil used to find bcID on certain links Calls proc~~mus_setupindices_forsrc~~CallsGraph proc~mus_setupindices_forsrc mus_setupIndices_forSrc proc~mus_init_absorblayer mus_init_absorbLayer proc~mus_setupindices_forsrc->proc~mus_init_absorblayer proc~mus_init_turbchanforce mus_init_turbChanForce proc~mus_setupindices_forsrc->proc~mus_init_turbchanforce set_params set_params proc~mus_setupindices_forsrc->set_params setup_indices setup_indices proc~mus_setupindices_forsrc->setup_indices val val proc~mus_setupindices_forsrc->val mpi_allreduce mpi_allreduce proc~mus_init_turbchanforce->mpi_allreduce tem_create_subTree_of tem_create_subTree_of proc~mus_init_turbchanforce->tem_create_subTree_of Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_setupindices_forsrc~~CalledByGraph proc~mus_setupindices_forsrc mus_setupIndices_forSrc proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_sourceterms->proc~mus_setupindices_forsrc proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_setupindices_forsrc.html"},{"title":"mus_init_internalSource – Musubi","text":"private  subroutine mus_init_internalSource(source, varSys, nSolve, iLevel, stencil) This routines does setup indices for given source within a field or\nglobal. Index are stored for points which source term is active Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: source Source term to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nSolve Number of elements to apply source term  on this level integer, intent(in) :: iLevel Current level type( tem_stencilHeader_type ), intent(in) :: stencil layout descriptor Calls proc~~mus_init_internalsource~~CallsGraph proc~mus_init_internalsource mus_init_internalSource proc~mus_init_hrrcorrection mus_init_hrrCorrection proc~mus_init_internalsource->proc~mus_init_hrrcorrection val val proc~mus_init_internalsource->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_internalsource~~CalledByGraph proc~mus_init_internalsource mus_init_internalSource proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_sourceterms->proc~mus_init_internalsource proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_internalsource.html"},{"title":"mus_init_turbChanForce – Musubi","text":"private  subroutine mus_init_turbChanForce(turbChanForce, tree, bc_prop, stencil) Create subTree and store nElemsGlobal in all proc for turbulent\nchannel force Arguments Type Intent Optional Attributes Name type( mus_turbChannelForce_type ), intent(inout) :: turbChanForce Contains info for turbulent channel force type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil used to find bcID on certain links Calls proc~~mus_init_turbchanforce~~CallsGraph proc~mus_init_turbchanforce mus_init_turbChanForce mpi_allreduce mpi_allreduce proc~mus_init_turbchanforce->mpi_allreduce tem_create_subTree_of tem_create_subTree_of proc~mus_init_turbchanforce->tem_create_subTree_of Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_turbchanforce~~CalledByGraph proc~mus_init_turbchanforce mus_init_turbChanForce proc~mus_setupindices_forsrc mus_setupIndices_forSrc proc~mus_setupindices_forsrc->proc~mus_init_turbchanforce proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_sourceterms->proc~mus_setupindices_forsrc proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_turbchanforce.html"},{"title":"mus_init_hrrCorrection – Musubi","text":"private  subroutine mus_init_hrrCorrection(HRR_Corr, nElems, nDim) Initialize arrays to store time average density and velocity for\ndynamic hrrCorrection.\n\\todo KM: 20210301 Allocate also for ghost cells! Arguments Type Intent Optional Attributes Name type( mus_HRRCorrectionTerm_type ), intent(inout) :: HRR_Corr HRR correction term type integer, intent(in) :: nElems Number of source elements integer, intent(in) :: nDim number of dimensions Called by proc~~mus_init_hrrcorrection~~CalledByGraph proc~mus_init_hrrcorrection mus_init_hrrCorrection proc~mus_init_internalsource mus_init_internalSource proc~mus_init_internalsource->proc~mus_init_hrrcorrection proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_sourceterms->proc~mus_init_internalsource proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_hrrcorrection.html"},{"title":"mus_getWeights – Musubi","text":"public  subroutine mus_getWeights(weights, tree, minLevel, maxLevel, levelDesc, nBCs, globBC) Calculate weights using timing from compute kernel, interpolation and\n boundary routines * * * * * * * * * * ** ! Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: weights (:) type( treelmesh_type ), intent(in) :: tree geometry infomation integer, intent(in) :: minLevel min level and max level integer, intent(in) :: maxLevel min level and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level descriptor integer, intent(in) :: nBCs global IBM type\nNumber of boundary conditions type(glob_boundary_type), intent(in) :: globBC (nBCs) BC elements information Calls proc~~mus_getweights~~CallsGraph proc~mus_getweights mus_getWeights interface~get_bcbuffertime get_bcBufferTime proc~mus_getweights->interface~get_bcbuffertime interface~get_boundarytime get_boundaryTime proc~mus_getweights->interface~get_boundarytime interface~get_computetime get_computeTime proc~mus_getweights->interface~get_computetime interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~mus_getweights->interface~get_intpfromcoarsertime interface~get_intpfromfinertime get_intpFromFinerTime proc~mus_getweights->interface~get_intpfromfinertime nelems nelems proc~mus_getweights->nelems nelems_fluid nelems_fluid proc~mus_getweights->nelems_fluid tem_LevelOf tem_LevelOf proc~mus_getweights->tem_LevelOf val val proc~mus_getweights->val proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_getweights~~CalledByGraph proc~mus_getweights mus_getWeights proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_getweights.html"},{"title":"mus_dumpWeights – Musubi","text":"public  subroutine mus_dumpWeights(tree, weights, basename) Dump weights to a file. Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: tree real(kind=rk), intent(in) :: weights (:) character(len=pathLen), intent(in) :: basename Calls proc~~mus_dumpweights~~CallsGraph proc~mus_dumpweights mus_dumpWeights tem_create_EndianSuffix tem_create_EndianSuffix proc~mus_dumpweights->tem_create_EndianSuffix tem_dump_weights tem_dump_weights proc~mus_dumpweights->tem_dump_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_dumpweights~~CalledByGraph proc~mus_dumpweights mus_dumpWeights proc~mus_balance mus_balance proc~mus_balance->proc~mus_dumpweights proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_dumpweights.html"},{"title":"mus_adapt_refine – Musubi","text":"public  subroutine mus_adapt_refine(geometry, scheme, proc, adapt) Wrap up the routines required for dynamic load balancing Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: geometry Treelmesh data type( mus_scheme_type ), intent(inout) :: scheme scheme type type( tem_comm_env_type ), intent(in) :: proc type( tem_adapt_type ), intent(in) :: adapt mesh adaptation Calls proc~~mus_adapt_refine~~CallsGraph proc~mus_adapt_refine mus_adapt_refine tem_adapt_dump_newMesh tem_adapt_dump_newMesh proc~mus_adapt_refine->tem_adapt_dump_newMesh Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_adapt_refine.html"},{"title":"mus_init_advRel_Poisson – Musubi","text":"public  subroutine mus_init_advRel_Poisson(relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_poisson~~CallsGraph proc~mus_init_advrel_poisson mus_init_advRel_Poisson tem_abort tem_abort proc~mus_init_advrel_poisson->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_poisson.html"},{"title":"mus_init_advRel_PBLinear – Musubi","text":"public  subroutine mus_init_advRel_PBLinear(relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_pblinear~~CallsGraph proc~mus_init_advrel_pblinear mus_init_advRel_PBLinear tem_abort tem_abort proc~mus_init_advrel_pblinear->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_pblinear.html"},{"title":"mus_init_advRel_PBnonLinear – Musubi","text":"public  subroutine mus_init_advRel_PBnonLinear(relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_pbnonlinear~~CallsGraph proc~mus_init_advrel_pbnonlinear mus_init_advRel_PBnonLinear tem_abort tem_abort proc~mus_init_advrel_pbnonlinear->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_pbnonlinear.html"},{"title":"newton_method – Musubi","text":"private pure function newton_method(velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) This routine computes friction velocity from wall model profile\nusing Newton iteration method Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine Calls proc~~newton_method~~CallsGraph proc~newton_method newton_method get_d_uPlus_d_uTau get_d_uPlus_d_uTau proc~newton_method->get_d_uPlus_d_uTau get_uPlus get_uPlus proc~newton_method->get_uPlus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/newton_method.html"},{"title":"fixedPoint_method – Musubi","text":"private pure function fixedPoint_method(velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) This routine computes friction velocity from wall model profile\nusing fixed-point iterative method Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine Calls proc~~fixedpoint_method~~CallsGraph proc~fixedpoint_method fixedPoint_method get_uPlus get_uPlus proc~fixedpoint_method->get_uPlus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fixedpoint_method.html"},{"title":"mus_load_turb_wallFunc – Musubi","text":"public  subroutine mus_load_turb_wallFunc(me, conf, parent) This routine loads wall model and nonlinear solver type for nonlinear\nequation Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle Calls proc~~mus_load_turb_wallfunc~~CallsGraph proc~mus_load_turb_wallfunc mus_load_turb_wallFunc aot_get_val aot_get_val proc~mus_load_turb_wallfunc->aot_get_val proc~load_iterativemethod load_iterativeMethod proc~mus_load_turb_wallfunc->proc~load_iterativemethod proc~load_wall_function load_wall_function proc~mus_load_turb_wallfunc->proc~load_wall_function tem_abort tem_abort proc~mus_load_turb_wallfunc->tem_abort proc~load_iterativemethod->aot_get_val proc~load_iterativemethod->tem_abort proc~load_wall_function->aot_get_val proc~load_wall_function->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_turb_wallfunc.html"},{"title":"load_iterativeMethod – Musubi","text":"private  subroutine load_iterativeMethod(me, conf, parent) Load the iterativeMethod to use in the turbulent wall model from the user\nconfiguration. Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle Calls proc~~load_iterativemethod~~CallsGraph proc~load_iterativemethod load_iterativeMethod aot_get_val aot_get_val proc~load_iterativemethod->aot_get_val tem_abort tem_abort proc~load_iterativemethod->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~load_iterativemethod~~CalledByGraph proc~load_iterativemethod load_iterativeMethod proc~mus_load_turb_wallfunc mus_load_turb_wallFunc proc~mus_load_turb_wallfunc->proc~load_iterativemethod Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_iterativemethod.html"},{"title":"load_wall_function – Musubi","text":"private  subroutine load_wall_function(me, conf, parent) Load the iterativeMethod to use in the turbulent wall model from the user\nconfiguration. Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle Calls proc~~load_wall_function~~CallsGraph proc~load_wall_function load_wall_function aot_get_val aot_get_val proc~load_wall_function->aot_get_val tem_abort tem_abort proc~load_wall_function->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~load_wall_function~~CalledByGraph proc~load_wall_function load_wall_function proc~mus_load_turb_wallfunc mus_load_turb_wallFunc proc~mus_load_turb_wallfunc->proc~load_wall_function Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_wall_function.html"},{"title":"fricVel_Schmitt – Musubi","text":"private pure subroutine fricVel_Schmitt(this, velTau, velSW, distToBnd, viscKine, nElems) This routine computes friction velocity from Schmitt wall model. Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Pass the calling object as an argument real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays Calls proc~~fricvel_schmitt~~CallsGraph proc~fricvel_schmitt fricVel_Schmitt proc~get_utau_loglayer get_uTau_logLayer proc~fricvel_schmitt->proc~get_utau_loglayer proc~get_utau_subvisouslayer get_uTau_subVisousLayer proc~fricvel_schmitt->proc~get_utau_subvisouslayer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fricvel_schmitt.html"},{"title":"compute_fricVel – Musubi","text":"private pure subroutine compute_fricVel(this, velTau, velSW, distToBnd, viscKine, nElems) This routine computes friction velocity from wall model profile\nusing Newton iteration method Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Pass the calling object as an argument real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays","tags":"","loc":"proc/compute_fricvel.html"},{"title":"computeStreamWiseVel – Musubi","text":"private pure subroutine computeStreamWiseVel(velSW, velTau, distToBnd, viscKine, nElems, wall_function) This routines computes streamWise velocity component from friction velocity\nand distance to boundary using any wall function profile. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: velSW (:) Stream-wise velocity component from wall model real(kind=rk), intent(in) :: velTau (:) Friction velocity computd from wall model real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays class( mus_wall_function_type ), intent(in) :: wall_function Allocate wall function object Calls proc~~computestreamwisevel~~CallsGraph proc~computestreamwisevel computeStreamWiseVel get_uPlus get_uPlus proc~computestreamwisevel->get_uPlus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computestreamwisevel.html"},{"title":"mus_turbVisc_WALE_3D – Musubi","text":"public  subroutine mus_turbVisc_WALE_3D(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)\nmodel\n\\todo add reference and formula Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_turbvisc_wale_3d~~CallsGraph proc~mus_turbvisc_wale_3d mus_turbVisc_WALE_3D u_ptr u_ptr proc~mus_turbvisc_wale_3d->u_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_wale_3d.html"},{"title":"mus_turbVisc_WALE_2D – Musubi","text":"public  subroutine mus_turbVisc_WALE_2D(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)\nmodel\n\\todo add reference and formula gradient of velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_turbvisc_wale_2d~~CallsGraph proc~mus_turbvisc_wale_2d mus_turbVisc_WALE_2D u_ptr u_ptr proc~mus_turbvisc_wale_2d->u_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_wale_2d.html"},{"title":"mus_append_bcVar – Musubi","text":"public  subroutine mus_append_bcVar(varSys, solverData, derVarName, nFields, field, stencil) This routine adds boundary variables for tracking Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( grw_labelarray_type ), intent(inout) :: derVarName array of derive physical variables integer, intent(in) :: nFields number of fields type( mus_field_type ), intent(in) :: field (nFields) Field contains sources and boundary infos type( tem_stencilHeader_type ), intent(in) :: stencil Compute stencil header Calls proc~~mus_append_bcvar~~CallsGraph proc~mus_append_bcvar mus_append_bcVar append append proc~mus_append_bcvar->append init init proc~mus_append_bcvar->init mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_bcvar->mus_get_new_solver_ptr tem_varSys_append_derVar tem_varSys_append_derVar proc~mus_append_bcvar->tem_varSys_append_derVar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_append_bcvar~~CalledByGraph proc~mus_append_bcvar mus_append_bcVar proc~mus_build_varsys mus_build_varSys proc~mus_build_varsys->proc~mus_append_bcvar proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_append_bcvar.html"},{"title":"access_bcNormal_forElement – Musubi","text":"private recursive subroutine access_bcNormal_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns the boundary normal pointing inside the domain The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_bcnormal_forelement~~CallsGraph proc~access_bcnormal_forelement access_bcNormal_forElement bclevelpointer bclevelpointer proc~access_bcnormal_forelement->bclevelpointer globbc globbc proc~access_bcnormal_forelement->globbc minbcid minbcid proc~access_bcnormal_forelement->minbcid posinbndid posinbndid proc~access_bcnormal_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_bcnormal_forelement->tem_LevelOf val val proc~access_bcnormal_forelement->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_bcnormal_forelement.html"},{"title":"access_qVal_forElement – Musubi","text":"private recursive subroutine access_qVal_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns the boundary qValues The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_qval_forelement~~CallsGraph proc~access_qval_forelement access_qVal_forElement bclevelpointer bclevelpointer proc~access_qval_forelement->bclevelpointer globbc globbc proc~access_qval_forelement->globbc minbcid minbcid proc~access_qval_forelement->minbcid posinbndid posinbndid proc~access_qval_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_qval_forelement->tem_LevelOf val val proc~access_qval_forelement->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_qval_forelement.html"},{"title":"access_bcFricVel_forElement – Musubi","text":"private recursive subroutine access_bcFricVel_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns friction velocity computed in turbulent_wall bc and\nstored in mus_turb_wallFunc_data_type routine. The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_bcfricvel_forelement~~CallsGraph proc~access_bcfricvel_forelement access_bcFricVel_forElement bc bc proc~access_bcfricvel_forelement->bc bclevelpointer bclevelpointer proc~access_bcfricvel_forelement->bclevelpointer field field proc~access_bcfricvel_forelement->field minbcid minbcid proc~access_bcfricvel_forelement->minbcid posinbndid posinbndid proc~access_bcfricvel_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_bcfricvel_forelement->tem_LevelOf veltau veltau proc~access_bcfricvel_forelement->veltau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_bcfricvel_forelement.html"},{"title":"access_bcNormDistToBnd_forElement – Musubi","text":"private recursive subroutine access_bcNormDistToBnd_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns normal distance to boundary calculated in\nmus_init_turbWallFunc and stored in mus_turb_wallFunc_data_type routine. The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_bcnormdisttobnd_forelement~~CallsGraph proc~access_bcnormdisttobnd_forelement access_bcNormDistToBnd_forElement bc bc proc~access_bcnormdisttobnd_forelement->bc bclevelpointer bclevelpointer proc~access_bcnormdisttobnd_forelement->bclevelpointer disttobnd disttobnd proc~access_bcnormdisttobnd_forelement->disttobnd field field proc~access_bcnormdisttobnd_forelement->field minbcid minbcid proc~access_bcnormdisttobnd_forelement->minbcid posinbndid posinbndid proc~access_bcnormdisttobnd_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_bcnormdisttobnd_forelement->tem_LevelOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_bcnormdisttobnd_forelement.html"},{"title":"access_bcTurbVisc_forElement – Musubi","text":"private recursive subroutine access_bcTurbVisc_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns turbulent viscosity computed in turbulent_wall bc\naccording to RANS formulation and stored in mus_turb_wallFunc_data_type\nroutine. The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_bcturbvisc_forelement~~CallsGraph proc~access_bcturbvisc_forelement access_bcTurbVisc_forElement bc bc proc~access_bcturbvisc_forelement->bc bclevelpointer bclevelpointer proc~access_bcturbvisc_forelement->bclevelpointer field field proc~access_bcturbvisc_forelement->field minbcid minbcid proc~access_bcturbvisc_forelement->minbcid posinbndid posinbndid proc~access_bcturbvisc_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_bcturbvisc_forelement->tem_LevelOf tvisc tvisc proc~access_bcturbvisc_forelement->tvisc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_bcturbvisc_forelement.html"},{"title":"access_bcYPlus_forElement – Musubi","text":"private recursive subroutine access_bcYPlus_forElement(fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns yPlus = distToBnd * fric_vel / visc The interface has to comply to the abstract interface tem_varSys_proc_element . Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Linearized array dimension:\n(n requested entries) x (nComponents of this variable)\nx (nDegrees of freedom)\nAccess: (iElem-1) fun%nComponents nDofs +\n        (iDof-1)*fun%nComponents + iComp Calls proc~~access_bcyplus_forelement~~CallsGraph proc~access_bcyplus_forelement access_bcYPlus_forElement bc bc proc~access_bcyplus_forelement->bc bclevelpointer bclevelpointer proc~access_bcyplus_forelement->bclevelpointer disttobnd disttobnd proc~access_bcyplus_forelement->disttobnd field field proc~access_bcyplus_forelement->field levelpointer levelpointer proc~access_bcyplus_forelement->levelpointer minbcid minbcid proc~access_bcyplus_forelement->minbcid posinbndid posinbndid proc~access_bcyplus_forelement->posinbndid tem_LevelOf tem_LevelOf proc~access_bcyplus_forelement->tem_LevelOf val val proc~access_bcyplus_forelement->val veltau veltau proc~access_bcyplus_forelement->veltau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/access_bcyplus_forelement.html"},{"title":"mus_init_advRel_fluidIncomp – Musubi","text":"public  subroutine mus_init_advRel_fluidIncomp(relaxation, variant, layout, compute) Initialize the relaxation model for lbm incompressible model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluidincomp~~CallsGraph proc~mus_init_advrel_fluidincomp mus_init_advRel_fluidIncomp proc~mus_init_advrel_fluidincomp_bgk mus_init_advRel_fluidIncomp_bgk proc~mus_init_advrel_fluidincomp->proc~mus_init_advrel_fluidincomp_bgk proc~mus_init_advrel_fluidincomp_mrt mus_init_advRel_fluidIncomp_mrt proc~mus_init_advrel_fluidincomp->proc~mus_init_advrel_fluidincomp_mrt tem_abort tem_abort proc~mus_init_advrel_fluidincomp->tem_abort proc~mus_init_advrel_fluidincomp_bgk->tem_abort proc~mus_init_advrel_fluidincomp_mrt->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluidincomp.html"},{"title":"mus_init_advRel_fluidIncomp_bgk – Musubi","text":"private  subroutine mus_init_advRel_fluidIncomp_bgk(variant, layout, compute) This routine assigns compute routine for bgk relaxation Supported variants are:\n  * standard        - Optimized routines for specifc layouts.\n  * standard_no_opt - no optimized routines for any layouts. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluidincomp_bgk~~CallsGraph proc~mus_init_advrel_fluidincomp_bgk mus_init_advRel_fluidIncomp_bgk tem_abort tem_abort proc~mus_init_advrel_fluidincomp_bgk->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_advrel_fluidincomp_bgk~~CalledByGraph proc~mus_init_advrel_fluidincomp_bgk mus_init_advRel_fluidIncomp_bgk proc~mus_init_advrel_fluidincomp mus_init_advRel_fluidIncomp proc~mus_init_advrel_fluidincomp->proc~mus_init_advrel_fluidincomp_bgk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluidincomp_bgk.html"},{"title":"mus_init_advRel_fluidIncomp_mrt – Musubi","text":"private  subroutine mus_init_advRel_fluidIncomp_mrt(variant, layout, compute) This routine assigns compute routine for mrt relaxation Supported variants are:\n  * standard        - Optimized routines for specifc layouts.\n  * standard_no_opt - no optimized routines for any layouts.\n  * bgk             - Uses no optimized routine but\n                      in mus_mrtRelaxation_module all relaxation parameters\n                      are set to same omega to recover bgk. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluidincomp_mrt~~CallsGraph proc~mus_init_advrel_fluidincomp_mrt mus_init_advRel_fluidIncomp_mrt tem_abort tem_abort proc~mus_init_advrel_fluidincomp_mrt->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_advrel_fluidincomp_mrt~~CalledByGraph proc~mus_init_advrel_fluidincomp_mrt mus_init_advRel_fluidIncomp_mrt proc~mus_init_advrel_fluidincomp mus_init_advRel_fluidIncomp proc~mus_init_advrel_fluidincomp->proc~mus_init_advrel_fluidincomp_mrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluidincomp_mrt.html"},{"title":"mus_perform_dynLoadBal – Musubi","text":"public  subroutine mus_perform_dynLoadBal(scheme, params, geometry, solverData) Wrap up the routines required for dynamic load balancing Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_param_type ), intent(inout) :: params Global parameters type( mus_geom_type ), intent(inout) :: geometry Treelmesh data type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types Calls proc~~mus_perform_dynloadbal~~CallsGraph proc~mus_perform_dynloadbal mus_perform_dynLoadBal mus_construct mus_construct proc~mus_perform_dynloadbal->mus_construct mus_pdf_serialize mus_pdf_serialize proc~mus_perform_dynloadbal->mus_pdf_serialize mus_pdf_unserialize mus_pdf_unserialize proc~mus_perform_dynloadbal->mus_pdf_unserialize mus_reload_ibm mus_reload_ibm proc~mus_perform_dynloadbal->mus_reload_ibm mus_unload_ibm mus_unload_ibm proc~mus_perform_dynloadbal->mus_unload_ibm proc~dump_linear_partition dump_linear_partition proc~mus_perform_dynloadbal->proc~dump_linear_partition proc~exchange_tree_bc exchange_tree_bc proc~mus_perform_dynloadbal->proc~exchange_tree_bc proc~mus_balance mus_balance proc~mus_perform_dynloadbal->proc~mus_balance proc~mus_define_layout mus_define_layout proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_init_scheme mus_init_scheme proc~mus_perform_dynloadbal->proc~mus_init_scheme proc~mus_reset_aux mus_reset_aux proc~mus_perform_dynloadbal->proc~mus_reset_aux proc~mus_scheme_cleanup mus_scheme_cleanup proc~mus_perform_dynloadbal->proc~mus_scheme_cleanup tem_destroy_sparta tem_destroy_sparta proc~mus_perform_dynloadbal->tem_destroy_sparta tem_exchange_sparta tem_exchange_sparta proc~mus_perform_dynloadbal->tem_exchange_sparta tem_init_sparta tem_init_sparta proc~mus_perform_dynloadbal->tem_init_sparta treeid treeid proc~mus_perform_dynloadbal->treeid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_perform_dynloadbal.html"},{"title":"mus_reset_aux – Musubi","text":"private  subroutine mus_reset_aux(scheme, params, geometry) This subroutine initializes musubi after a dynamic load balancing is\nperformed. initialize fluid type which contains relaxation parameter\nand function pointers to get mrt paramter and nonEqScaling factor\nfor interpolation Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_param_type ), intent(inout) :: params Global parameters type( mus_geom_type ), intent(inout) :: geometry Treelmesh data Calls proc~~mus_reset_aux~~CallsGraph proc~mus_reset_aux mus_reset_aux convergence convergence proc~mus_reset_aux->convergence fillhelperelementscoarsetofine fillhelperelementscoarsetofine proc~mus_reset_aux->fillhelperelementscoarsetofine fillhelperelementsfinetocoarse fillhelperelementsfinetocoarse proc~mus_reset_aux->fillhelperelementsfinetocoarse mus_init_bndforce mus_init_bndforce proc~mus_reset_aux->mus_init_bndforce mus_init_boundary mus_init_boundary proc~mus_reset_aux->mus_init_boundary mus_init_graddata mus_init_graddata proc~mus_reset_aux->mus_init_graddata mus_init_interpolate mus_init_interpolate proc~mus_reset_aux->mus_init_interpolate proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange proc~mus_reset_aux->proc~mus_calcauxfieldandexchange proc~mus_init_fluid mus_init_fluid proc~mus_reset_aux->proc~mus_init_fluid proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_init_tracker mus_init_tracker proc~mus_reset_aux->proc~mus_init_tracker proc~mus_init_transport_var mus_init_transport_var proc~mus_reset_aux->proc~mus_init_transport_var proc~mus_intpauxfieldcoarserandexchange mus_intpAuxFieldCoarserAndExchange proc~mus_reset_aux->proc~mus_intpauxfieldcoarserandexchange proc~mus_reset_bctimer mus_reset_bcTimer proc~mus_reset_aux->proc~mus_reset_bctimer proc~mus_reset_leveltimer mus_reset_levelTimer proc~mus_reset_aux->proc~mus_reset_leveltimer proc~mus_timecontrol_homogenize mus_timeControl_homogenize proc~mus_reset_aux->proc~mus_timecontrol_homogenize tem_abort tem_abort proc~mus_reset_aux->tem_abort tem_create_subTree_of_st_funList tem_create_subTree_of_st_funList proc~mus_reset_aux->tem_create_subTree_of_st_funList tem_init_convergence tem_init_convergence proc~mus_reset_aux->tem_init_convergence tem_init_restart tem_init_restart proc~mus_reset_aux->tem_init_restart tem_opVar_reduction_transient_init tem_opVar_reduction_transient_init proc~mus_reset_aux->tem_opVar_reduction_transient_init tem_restart_finalize tem_restart_finalize proc~mus_reset_aux->tem_restart_finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_reset_aux~~CalledByGraph proc~mus_reset_aux mus_reset_aux proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_reset_aux.html"},{"title":"mus_balance – Musubi","text":"private  subroutine mus_balance(tree, minLevel, maxLevel, levelDesc, nBCs, globBC, general, sparta) This routine performs the load balancing for multilevel simulations. The\nweights are calculated on the basis of levelwise run time, which are then\nfed to sparta for calculation of splitting positions. Restart files are\nsaved and the simulation is restarted with the newly distributed mesh Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(inout) :: tree geometry infomation integer, intent(in) :: minLevel min level and max level integer, intent(in) :: maxLevel min level and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level descriptor integer, intent(in) :: nBCs global IBM type\nNumber of boundary conditions type(glob_boundary_type), intent(in) :: globBC (nBCs) BC elements information type( tem_general_type ), intent(in) :: general global parameters type( tem_sparta_type ), intent(inout) :: sparta Sparta data type Calls proc~~mus_balance~~CallsGraph proc~mus_balance mus_balance proc~mus_dumpweights mus_dumpWeights proc~mus_balance->proc~mus_dumpweights proc~mus_getweights mus_getWeights proc~mus_balance->proc~mus_getweights tem_balance_sparta tem_balance_sparta proc~mus_balance->tem_balance_sparta tem_time_sim_stamp tem_time_sim_stamp proc~mus_balance->tem_time_sim_stamp tem_create_EndianSuffix tem_create_EndianSuffix proc~mus_dumpweights->tem_create_EndianSuffix tem_dump_weights tem_dump_weights proc~mus_dumpweights->tem_dump_weights interface~get_bcbuffertime get_bcBufferTime proc~mus_getweights->interface~get_bcbuffertime interface~get_boundarytime get_boundaryTime proc~mus_getweights->interface~get_boundarytime interface~get_computetime get_computeTime proc~mus_getweights->interface~get_computetime interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~mus_getweights->interface~get_intpfromcoarsertime interface~get_intpfromfinertime get_intpFromFinerTime proc~mus_getweights->interface~get_intpfromfinertime nelems nelems proc~mus_getweights->nelems nelems_fluid nelems_fluid proc~mus_getweights->nelems_fluid tem_LevelOf tem_LevelOf proc~mus_getweights->tem_LevelOf val val proc~mus_getweights->val proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_balance~~CalledByGraph proc~mus_balance mus_balance proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_balance.html"},{"title":"exchange_tree_bc – Musubi","text":"private  subroutine exchange_tree_bc(sparta, geometry, comm, comm_size) Arguments Type Intent Optional Attributes Name type( tem_sparta_type ), intent(in) :: sparta type( mus_geom_type ), intent(inout) :: geometry integer, intent(in) :: comm integer, intent(in) :: comm_size Calls proc~~exchange_tree_bc~~CallsGraph proc~exchange_tree_bc exchange_tree_bc exchange_elements exchange_elements proc~exchange_tree_bc->exchange_elements proc~mus_build_posinprop mus_build_posInProp proc~exchange_tree_bc->proc~mus_build_posinprop tem_derive_sparta tem_derive_sparta proc~exchange_tree_bc->tem_derive_sparta tem_destroy_sparta tem_destroy_sparta proc~exchange_tree_bc->tem_destroy_sparta tem_exchange_sparta tem_exchange_sparta proc~exchange_tree_bc->tem_exchange_sparta tem_init_sparta tem_init_sparta proc~exchange_tree_bc->tem_init_sparta proc~mus_build_minbcid mus_build_minBcID proc~mus_build_posinprop->proc~mus_build_minbcid property property proc~mus_build_posinprop->property tem_build_treeToProp_pointer tem_build_treeToProp_pointer proc~mus_build_posinprop->tem_build_treeToProp_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~exchange_tree_bc~~CalledByGraph proc~exchange_tree_bc exchange_tree_bc proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~exchange_tree_bc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/exchange_tree_bc.html"},{"title":"mus_load_scheme_header – Musubi","text":"public  subroutine mus_load_scheme_header(me, conf, parent, scaling) load scheme header info from lua file identify table or from scheme table\n or from config Load scheme label, kind, layoutKind and relaxation identify = { kind = 'simType' , layout = 'stencilLayout' , relaxation = 'relaxationType' } For a possible selection of the other parameters\n - simType: fluid, fluid_incompressible, multispecies_liquid\n - mus_scheme_layout_module : d2q9, d3q19, ...\n - relaxationType: bgk, mrt, ... Arguments Type Intent Optional Attributes Name type( mus_scheme_header_type ), intent(out) :: me returns scheme identify information type( flu_State ) :: conf integer, intent(in), optional :: parent parent handle if scheme table is defined character(len=*), intent(in) :: scaling Calls proc~~mus_load_scheme_header~~CallsGraph proc~mus_load_scheme_header mus_load_scheme_header aot_get_val aot_get_val proc~mus_load_scheme_header->aot_get_val aot_table_close aot_table_close proc~mus_load_scheme_header->aot_table_close aot_table_open aot_table_open proc~mus_load_scheme_header->aot_table_open proc~load_relaxation_header load_relaxation_header proc~mus_load_scheme_header->proc~load_relaxation_header tem_abort tem_abort proc~mus_load_scheme_header->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_scheme_header->tem_horizontalSpacer proc~load_relaxation_header->aot_get_val proc~load_relaxation_header->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_scheme_header~~CalledByGraph proc~mus_load_scheme_header mus_load_scheme_header proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_scheme_header proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_scheme_header.html"},{"title":"mus_scheme_header_out – Musubi","text":"public  subroutine mus_scheme_header_out(me, conf) Dumps scheme header Arguments Type Intent Optional Attributes Name type( mus_scheme_header_type ), intent(in) :: me returns scheme identify information type( aot_out_type ) :: conf Calls proc~~mus_scheme_header_out~~CallsGraph proc~mus_scheme_header_out mus_scheme_header_out aot_out_close_table aot_out_close_table proc~mus_scheme_header_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_scheme_header_out->aot_out_open_table aot_out_val aot_out_val proc~mus_scheme_header_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_scheme_header_out~~CalledByGraph proc~mus_scheme_header_out mus_scheme_header_out proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->proc~mus_scheme_header_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_scheme_header_out.html"},{"title":"load_relaxation_header – Musubi","text":"private  subroutine load_relaxation_header(me, conf, thandle) Load relaxation options from a table Arguments Type Intent Optional Attributes Name type( mus_relaxation_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: thandle relaxation handle Calls proc~~load_relaxation_header~~CallsGraph proc~load_relaxation_header load_relaxation_header aot_get_val aot_get_val proc~load_relaxation_header->aot_get_val tem_abort tem_abort proc~load_relaxation_header->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~load_relaxation_header~~CalledByGraph proc~load_relaxation_header load_relaxation_header proc~mus_load_scheme_header mus_load_scheme_header proc~mus_load_scheme_header->proc~load_relaxation_header proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_scheme_header proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_relaxation_header.html"},{"title":"get_uTau_subVisousLayer – Musubi","text":"public pure function get_uTau_subVisousLayer(visc_div_dist, velSW) result(uTau) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc_div_dist dynamic viscosity divided by vertical distance from the wall real(kind=rk), intent(in) :: velSW velocity stream-wise parallel to wall Return Value real(kind=rk) friction velocity Called by proc~~get_utau_subvisouslayer~~CalledByGraph proc~get_utau_subvisouslayer get_uTau_subVisousLayer proc~fricvel_schmitt fricVel_Schmitt proc~fricvel_schmitt->proc~get_utau_subvisouslayer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_utau_subvisouslayer.html"},{"title":"get_uTau_logLayer – Musubi","text":"public pure function get_uTau_logLayer(visc_div_dist, velSW) result(uTau) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc_div_dist dynamic viscosity divided by vertical distance from the wall real(kind=rk), intent(in) :: velSW velocity stream-wise parallel to wall Return Value real(kind=rk) friction velocity Called by proc~~get_utau_loglayer~~CalledByGraph proc~get_utau_loglayer get_uTau_logLayer proc~fricvel_schmitt fricVel_Schmitt proc~fricvel_schmitt->proc~get_utau_loglayer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_utau_loglayer.html"},{"title":"get_uPlus – Musubi","text":"private pure function get_uPlus(yPlus) result(uPlus) function to get uPlus Type Bound mus_wall_function_schmitt_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk)","tags":"","loc":"proc/get_uplus.html"},{"title":"get_d_uPlus_d_uTau – Musubi","text":"private pure function get_d_uPlus_d_uTau(y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Type Bound mus_wall_function_schmitt_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"proc/get_d_uplus_d_utau.html"},{"title":"mus_init_eNRTL – Musubi","text":"public  function mus_init_eNRTL(filename, nFields) result(success) This function loads property file using external c-function Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer, intent(out) :: nFields number of fields in mixture Return Value logical Calls proc~~mus_init_enrtl~~CallsGraph proc~mus_init_enrtl mus_init_eNRTL interface~init_enrtl_loc init_enrtl_loc proc~mus_init_enrtl->interface~init_enrtl_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_enrtl~~CalledByGraph proc~mus_init_enrtl mus_init_eNRTL proc~mus_load_mixture mus_load_mixture proc~mus_load_mixture->proc~mus_init_enrtl proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_mixture proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_enrtl.html"},{"title":"mus_calc_thermFactor_single – Musubi","text":"private  subroutine mus_calc_thermFactor_single(nFields, temp, press, mole_frac, therm_factors) This routine calculates thermodynamic factor for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix Calls proc~~mus_calc_thermfactor_single~~CallsGraph proc~mus_calc_thermfactor_single mus_calc_thermFactor_single interface~calc_therm_factor_loc calc_therm_factor_loc proc~mus_calc_thermfactor_single->interface~calc_therm_factor_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_calc_thermfactor_single~~CalledByGraph proc~mus_calc_thermfactor_single mus_calc_thermFactor_single interface~mus_calc_thermfactor mus_calc_thermFactor interface~mus_calc_thermfactor->proc~mus_calc_thermfactor_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_thermfactor_single.html"},{"title":"mus_calc_MS_DiffMatrix_single – Musubi","text":"private  subroutine mus_calc_MS_DiffMatrix_single(nFields, temp, press, mole_dens, D_ij_out) This routine calculates Diffusivity coefficients matrix for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix Calls proc~~mus_calc_ms_diffmatrix_single~~CallsGraph proc~mus_calc_ms_diffmatrix_single mus_calc_MS_DiffMatrix_single interface~calc_ms_diff_matrix_from_moledens calc_ms_diff_matrix_from_moledens proc~mus_calc_ms_diffmatrix_single->interface~calc_ms_diff_matrix_from_moledens Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_calc_ms_diffmatrix_single~~CalledByGraph proc~mus_calc_ms_diffmatrix_single mus_calc_MS_DiffMatrix_single interface~mus_calc_ms_diffmatrix mus_calc_MS_DiffMatrix interface~mus_calc_ms_diffmatrix->proc~mus_calc_ms_diffmatrix_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_ms_diffmatrix_single.html"},{"title":"mus_calc_thermFactor – Musubi","text":"public interface mus_calc_thermFactor Calls interface~~mus_calc_thermfactor~~CallsGraph interface~mus_calc_thermfactor mus_calc_thermFactor proc~mus_calc_thermfactor_single mus_calc_thermFactor_single interface~mus_calc_thermfactor->proc~mus_calc_thermfactor_single interface~calc_therm_factor_loc calc_therm_factor_loc proc~mus_calc_thermfactor_single->interface~calc_therm_factor_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) This routine calculates thermodynamic factor for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"interface/mus_calc_thermfactor.html"},{"title":"mus_calc_MS_DiffMatrix – Musubi","text":"public interface mus_calc_MS_DiffMatrix Calls interface~~mus_calc_ms_diffmatrix~~CallsGraph interface~mus_calc_ms_diffmatrix mus_calc_MS_DiffMatrix proc~mus_calc_ms_diffmatrix_single mus_calc_MS_DiffMatrix_single interface~mus_calc_ms_diffmatrix->proc~mus_calc_ms_diffmatrix_single interface~calc_ms_diff_matrix_from_moledens calc_ms_diff_matrix_from_moledens proc~mus_calc_ms_diffmatrix_single->interface~calc_ms_diff_matrix_from_moledens Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) This routine calculates Diffusivity coefficients matrix for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"interface/mus_calc_ms_diffmatrix.html"},{"title":"init_enrtl_loc – Musubi","text":"interface This function initialize eNRTL model by loading liquid mixture\nproperty from filename Called by interface~~init_enrtl_loc~~CalledByGraph interface~init_enrtl_loc init_enrtl_loc proc~mus_init_enrtl mus_init_eNRTL proc~mus_init_enrtl->interface~init_enrtl_loc proc~mus_load_mixture mus_load_mixture proc~mus_load_mixture->proc~mus_init_enrtl proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_mixture proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  function init_enrtl_loc(filename, nSpc) bind(c, name='init_enrtl') Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer(kind=c_int), intent(out) :: nSpc Return Value integer","tags":"","loc":"interface/init_enrtl_loc.html"},{"title":"calc_therm_factor_loc – Musubi","text":"interface This routine calculates thermodynamic factor for given mole_frac\nof all species Called by interface~~calc_therm_factor_loc~~CalledByGraph interface~calc_therm_factor_loc calc_therm_factor_loc proc~mus_calc_thermfactor_single mus_calc_thermFactor_single proc~mus_calc_thermfactor_single->interface~calc_therm_factor_loc interface~mus_calc_thermfactor mus_calc_thermFactor interface~mus_calc_thermfactor->proc~mus_calc_thermfactor_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine calc_therm_factor_loc(nSpc, Temp, Press, Mole_frac, Therm_factors) bind(c, name='calc_therm_factor_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_frac real(kind=c_double), intent(out), dimension(*) :: Therm_factors","tags":"","loc":"interface/calc_therm_factor_loc.html"},{"title":"calc_ms_diff_matrix_from_molefrac – Musubi","text":"interface This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix\nfor given mole_frac of all species private  subroutine calc_ms_diff_matrix_from_molefrac(nSpc, Temp, Press, Mole_frac, D_ij_out) bind(c, name='calc_ms_diff_matrix_from_molefrac_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_frac real(kind=c_double), intent(out), dimension(*) :: D_ij_out","tags":"","loc":"interface/calc_ms_diff_matrix_from_molefrac.html"},{"title":"calc_ms_diff_matrix_from_moledens – Musubi","text":"interface This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix\nfor given mole_frac of all species Called by interface~~calc_ms_diff_matrix_from_moledens~~CalledByGraph interface~calc_ms_diff_matrix_from_moledens calc_ms_diff_matrix_from_moledens proc~mus_calc_ms_diffmatrix_single mus_calc_MS_DiffMatrix_single proc~mus_calc_ms_diffmatrix_single->interface~calc_ms_diff_matrix_from_moledens interface~mus_calc_ms_diffmatrix mus_calc_MS_DiffMatrix interface~mus_calc_ms_diffmatrix->proc~mus_calc_ms_diffmatrix_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine calc_ms_diff_matrix_from_moledens(nSpc, Temp, Press, Mole_dens, D_ij_out) bind(c, name='calc_ms_diff_matrix_from_moledens_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_dens real(kind=c_double), intent(out), dimension(*) :: D_ij_out","tags":"","loc":"interface/calc_ms_diff_matrix_from_moledens.html"},{"title":"mus_init_advRel_fluid – Musubi","text":"public  subroutine mus_init_advRel_fluid(relaxation, variant, layout, compute) Assigning compute kernel routine by scheme relaxation type for fluid kind. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluid~~CallsGraph proc~mus_init_advrel_fluid mus_init_advRel_fluid proc~mus_init_advrel_fluid_bgk mus_init_advRel_fluid_bgk proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_bgk proc~mus_init_advrel_fluid_mrt mus_init_advRel_fluid_mrt proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_mrt proc~mus_init_advrel_fluid_trt mus_init_advRel_fluid_trt proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_trt tem_abort tem_abort proc~mus_init_advrel_fluid->tem_abort proc~mus_init_advrel_fluid_bgk->tem_abort proc~mus_init_advrel_fluid_mrt->tem_abort proc~mus_init_advrel_fluid_trt->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluid.html"},{"title":"mus_init_advRel_fluid_bgk – Musubi","text":"private  subroutine mus_init_advRel_fluid_bgk(variant, layout, compute) This routine assigns compute routine for bgk relaxation. Supported variants are:\n  * standard        - Optimized routines for specifc layouts.\n  * standard_no_opt - Semi or no optimized routines for any layouts.\n  * improved        - improved BGK with Galilean correction term for\n                      specific layouts.\n  * block           - routines for vector machine. Implemented only for\n                      D3Q19 Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluid_bgk~~CallsGraph proc~mus_init_advrel_fluid_bgk mus_init_advRel_fluid_bgk tem_abort tem_abort proc~mus_init_advrel_fluid_bgk->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_advrel_fluid_bgk~~CalledByGraph proc~mus_init_advrel_fluid_bgk mus_init_advRel_fluid_bgk proc~mus_init_advrel_fluid mus_init_advRel_fluid proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_bgk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluid_bgk.html"},{"title":"mus_init_advRel_fluid_mrt – Musubi","text":"private  subroutine mus_init_advRel_fluid_mrt(variant, layout, compute) This routine assigns compute routine for mrt relaxation Supported variants are:\n  * standard        - Optimized routines for specifc layouts.\n  * standard_no_opt - no optimized routines for any layouts.\n  * bgk             - Uses no optimized routine but\n                      in mus_mrtRelaxation_module all relaxation parameters\n                      are set to same omega to recover bgk. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluid_mrt~~CallsGraph proc~mus_init_advrel_fluid_mrt mus_init_advRel_fluid_mrt tem_abort tem_abort proc~mus_init_advrel_fluid_mrt->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_advrel_fluid_mrt~~CalledByGraph proc~mus_init_advrel_fluid_mrt mus_init_advRel_fluid_mrt proc~mus_init_advrel_fluid mus_init_advRel_fluid proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_mrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluid_mrt.html"},{"title":"mus_init_advRel_fluid_trt – Musubi","text":"private  subroutine mus_init_advRel_fluid_trt(variant, layout, compute) This routine assigns compute routine for trt relaxation Supported variants are:\n  * standard        - Optimized routines for specifc layouts. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_fluid_trt~~CallsGraph proc~mus_init_advrel_fluid_trt mus_init_advRel_fluid_trt tem_abort tem_abort proc~mus_init_advrel_fluid_trt->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_advrel_fluid_trt~~CalledByGraph proc~mus_init_advrel_fluid_trt mus_init_advRel_fluid_trt proc~mus_init_advrel_fluid mus_init_advRel_fluid proc~mus_init_advrel_fluid->proc~mus_init_advrel_fluid_trt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_fluid_trt.html"},{"title":"mus_create_poss_srcVar – Musubi","text":"public  subroutine mus_create_poss_srcVar(poss_srcVar, schemeHeader) Routine initialize possible source variable depends on scheme kind Arguments Type Intent Optional Attributes Name type( tem_possible_variable_type ), intent(out) :: poss_srcVar possible source variables type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme Calls proc~~mus_create_poss_srcvar~~CallsGraph proc~mus_create_poss_srcvar mus_create_poss_srcVar append append proc~mus_create_poss_srcvar->append init init proc~mus_create_poss_srcvar->init truncate truncate proc~mus_create_poss_srcvar->truncate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_create_poss_srcvar~~CalledByGraph proc~mus_create_poss_srcvar mus_create_poss_srcVar proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_create_poss_srcvar proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_create_poss_srcvar.html"},{"title":"mus_load_source_var – Musubi","text":"public  subroutine mus_load_source_var(me, possVars, conf, parent, key, varSys) Routine load musubi source terms for given key.\nkey is glob_source or source Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(out) :: me Source variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible source variables type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined character(len=*), intent(in) :: key key to load source term type( tem_varSys_type ), intent(inout) :: varSys Global variable system Calls proc~~mus_load_source_var~~CallsGraph proc~mus_load_source_var mus_load_source_var aot_get_val aot_get_val proc~mus_load_source_var->aot_get_val aot_table_open aot_table_open proc~mus_load_source_var->aot_table_open init init proc~mus_load_source_var->init proc~load_turbchanforce load_turbChanForce proc~mus_load_source_var->proc~load_turbchanforce proc~mus_load_absorblayer mus_load_absorbLayer proc~mus_load_source_var->proc~mus_load_absorblayer tem_abort tem_abort proc~mus_load_source_var->tem_abort tem_variable_loadMapping tem_variable_loadMapping proc~mus_load_source_var->tem_variable_loadMapping truncate truncate proc~mus_load_source_var->truncate val val proc~mus_load_source_var->val proc~load_turbchanforce->aot_get_val proc~load_turbchanforce->aot_table_open proc~load_turbchanforce->tem_abort canond canond proc~load_turbchanforce->canond tem_load_shape tem_load_shape proc~load_turbchanforce->tem_load_shape proc~mus_load_absorblayer->aot_get_val proc~mus_load_absorblayer->aot_table_open proc~mus_load_absorblayer->tem_abort aot_table_close aot_table_close proc~mus_load_absorblayer->aot_table_close upper_to_lower upper_to_lower proc~mus_load_absorblayer->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_source_var~~CalledByGraph proc~mus_load_source_var mus_load_source_var proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_source_var proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_source_var proc~mus_load_fields mus_load_fields proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_load_fields->proc~mus_load_field_single proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_source_var.html"},{"title":"mus_source_cleanup – Musubi","text":"public  subroutine mus_source_cleanup(me) This routine act as a destructor for source type.\nThe arrays allocated in mus_init_sourceTerms are destroyed here Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: me Called by proc~~mus_source_cleanup~~CalledByGraph proc~mus_source_cleanup mus_source_cleanup proc~mus_field_cleanup mus_field_cleanup proc~mus_field_cleanup->proc~mus_source_cleanup proc~mus_scheme_cleanup mus_scheme_cleanup proc~mus_scheme_cleanup->proc~mus_source_cleanup proc~mus_scheme_cleanup->proc~mus_field_cleanup proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_scheme_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_source_cleanup.html"},{"title":"mus_applySrc_dummy – Musubi","text":"public  subroutine mus_applySrc_dummy(fun, inState, outState, neigh, auxField, nPdfSize, iLevel, varSys, time, phyConvFac, derVarPos) Dummy routine for apply source Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(in) :: fun Description of method to update source real(kind=rk), intent(in) :: inState (:) input  pdf vector\n\\todo KM: instate is passed to compute auxField.\nSince auxField is precomputed from instate and passed to this routine.\ninstate can be removed real(kind=rk), intent(inout) :: outState (:) output pdf vector integer, intent(in) :: neigh (:) connectivity Array corresponding to state vector real(kind=rk), intent(in) :: auxField (:) auxField array integer, intent(in) :: nPdfSize number of elements in state Array integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys","tags":"","loc":"proc/mus_applysrc_dummy.html"},{"title":"mus_addSrcToAuxField_dummy – Musubi","text":"public  subroutine mus_addSrcToAuxField_dummy(fun, auxField, iLevel, time, varSys, phyConvFac, derVarPos) Dummy routine for add source to auxField Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(inout) :: auxField (:) output auxField array integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys","tags":"","loc":"proc/mus_addsrctoauxfield_dummy.html"},{"title":"mus_updateSrcVar_dummy – Musubi","text":"public  subroutine mus_updateSrcVar_dummy(fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Dummy routine for update source variable Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys","tags":"","loc":"proc/mus_updatesrcvar_dummy.html"},{"title":"load_turbChanForce – Musubi","text":"private  subroutine load_turbChanForce(me, conf, key, parent) Load shape, bulk velocity and height for turbulent channel force Arguments Type Intent Optional Attributes Name type( mus_turbChannelForce_type ), intent(out) :: me Turbulent channel force type( flu_State ) :: conf flu state character(len=*), intent(in) :: key Table name to load target states integer, intent(in) :: parent parent source handle Calls proc~~load_turbchanforce~~CallsGraph proc~load_turbchanforce load_turbChanForce aot_get_val aot_get_val proc~load_turbchanforce->aot_get_val aot_table_open aot_table_open proc~load_turbchanforce->aot_table_open canond canond proc~load_turbchanforce->canond tem_abort tem_abort proc~load_turbchanforce->tem_abort tem_load_shape tem_load_shape proc~load_turbchanforce->tem_load_shape Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~load_turbchanforce~~CalledByGraph proc~load_turbchanforce load_turbChanForce proc~mus_load_source_var mus_load_source_var proc~mus_load_source_var->proc~load_turbchanforce proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_source_var proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_source_var proc~mus_load_fields mus_load_fields proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_load_fields->proc~mus_load_field_single proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_turbchanforce.html"},{"title":"mus_init_advRel_nernstPlanck – Musubi","text":"public  subroutine mus_init_advRel_nernstPlanck(relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_nernstplanck~~CallsGraph proc~mus_init_advrel_nernstplanck mus_init_advRel_nernstPlanck tem_abort tem_abort proc~mus_init_advrel_nernstplanck->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_nernstplanck.html"},{"title":"mus_init_auxFieldArrays – Musubi","text":"public  subroutine mus_init_auxFieldArrays(me, levelDesc, pattern, nSize, nAuxScalars) This routine initialize auxField var val array and communication buffers Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(out) :: me Auxiliary field variable type( tem_levelDesc_type ), intent(in) :: levelDesc levelDesc to access communication buffers of state array type( tem_commPattern_type ), intent(in) :: pattern communication pattern integer, intent(in) :: nSize Number of elements in state array integer, intent(in) :: nAuxScalars Number of scalars in auxiliary variables Calls proc~~mus_init_auxfieldarrays~~CallsGraph proc~mus_init_auxfieldarrays mus_init_auxFieldArrays tem_comm_init tem_comm_init proc~mus_init_auxfieldarrays->tem_comm_init val val proc~mus_init_auxfieldarrays->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_auxfieldarrays.html"},{"title":"mus_initAuxFieldFluidAndExchange – Musubi","text":"public  subroutine mus_initAuxFieldFluidAndExchange(auxField, state, neigh, nElems, nSize, nFields, stencil, varSys, derVarPos, iLevel, general, quantities) This routine initializes auxField for fluid elements using SAVE access on\nPDF initialized by IC Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(inout) :: auxField auxilary field array real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) connectivity vector integer, intent(in) :: nElems number of elements to compute auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nFields number of fields type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) contains auxField position of all fields in varSys integer, intent(in) :: iLevel current level type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Calls proc~~mus_initauxfieldfluidandexchange~~CallsGraph proc~mus_initauxfieldfluidandexchange mus_initAuxFieldFluidAndExchange exchange_real exchange_real proc~mus_initauxfieldfluidandexchange->exchange_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_initauxfieldfluidandexchange.html"},{"title":"mus_calcAuxFieldAndExchange – Musubi","text":"public  subroutine mus_calcAuxFieldAndExchange(auxField, calcAuxField, state, pdfData, nFields, field, globSrc, stencil, varSys, derVarPos, phyConvFac, general, iLevel, minLevel, schemeHeader, quantities) This routine compute auxField variable from pre-collision pdf and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(inout) :: auxField auxilary field array procedure( mus_proc_calcAuxField ), intent(in), pointer :: calcAuxField function pointer to calculate auxField real(kind=rk), intent(in) :: state (:) state array type( pdf_data_type ), intent(in) :: pdfData contains neigh array and nElems on current level integer, intent(in) :: nFields Number of fields type( mus_field_type ), intent(inout) :: field (nFields) contains sources of all fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) contains auxField position of all fields in varSys type( mus_convertFac_type ), intent(in) :: phyConvFac physics conversion factors for this level type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl integer, intent(in) :: iLevel current level integer, intent(in) :: minLevel minlevel type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Calls proc~~mus_calcauxfieldandexchange~~CallsGraph proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange exchange_real exchange_real proc~mus_calcauxfieldandexchange->exchange_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_calcauxfieldandexchange~~CalledByGraph proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_calcauxfieldandexchange proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_calcauxfieldandexchange proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_calcauxfieldandexchange proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_calcauxfieldandexchange proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calcauxfieldandexchange.html"},{"title":"mus_intpAuxFieldCoarserAndExchange – Musubi","text":"public  subroutine mus_intpAuxFieldCoarserAndExchange(intp, tAuxField, sAuxField, tLevelDesc, stencil, iLevel, nAuxScalars, general) This routine interpolate auxField variable for ghostFromFiner and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: intp Interpolation type type( mus_auxFieldVar_type ), intent(inout) :: tAuxField target auxilary field array type( mus_auxFieldVar_type ), intent(in) :: sAuxField source auxilary field array type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: iLevel current level integer, intent(in) :: nAuxScalars number of scalars to interpolate type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl Calls proc~~mus_intpauxfieldcoarserandexchange~~CallsGraph proc~mus_intpauxfieldcoarserandexchange mus_intpAuxFieldCoarserAndExchange exchange_real exchange_real proc~mus_intpauxfieldcoarserandexchange->exchange_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_intpauxfieldcoarserandexchange~~CalledByGraph proc~mus_intpauxfieldcoarserandexchange mus_intpAuxFieldCoarserAndExchange proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_intpauxfieldcoarserandexchange proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_intpauxfieldcoarserandexchange proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_intpauxfieldcoarserandexchange.html"},{"title":"mus_intpAuxFieldFinerAndExchange – Musubi","text":"public  subroutine mus_intpAuxFieldFinerAndExchange(intp, tAuxField, sAuxField, tLevelDesc, stencil, iLevel, nAuxScalars, general) This routine interpolate auxField variable for ghostFromCoarser and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: intp Interpolation type type( mus_auxFieldVar_type ), intent(inout) :: tAuxField target auxilary field array type( mus_auxFieldVar_type ), intent(in) :: sAuxField source auxilary field array type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: iLevel current level integer, intent(in) :: nAuxScalars number of scalars to interpolate type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl Calls proc~~mus_intpauxfieldfinerandexchange~~CallsGraph proc~mus_intpauxfieldfinerandexchange mus_intpAuxFieldFinerAndExchange exchange_real exchange_real proc~mus_intpauxfieldfinerandexchange->exchange_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_intpauxfieldfinerandexchange.html"},{"title":"mus_derive_FromMacro_dummy – Musubi","text":"public  subroutine mus_derive_FromMacro_dummy(density, velocity, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: density (:) Array of density.\nSingle species: dens_1, dens_2 .. dens_n\nmultispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ...\n               dens_n_sp1, dens_n_sp2\nAccess: (iElem-1)*nFields + iField real(kind=rk), intent(in) :: velocity (:,:) Array of velocity.\nSize: (3, n nFields)\nAccess: ( iComp, (iElem-1) nFields + iField ) integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*nComponents of res Calls proc~~mus_derive_frommacro_dummy~~CallsGraph proc~mus_derive_frommacro_dummy mus_derive_FromMacro_dummy tem_abort tem_abort proc~mus_derive_frommacro_dummy->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_derive_frommacro_dummy.html"},{"title":"mus_derive_FromState_dummy – Musubi","text":"public  subroutine mus_derive_FromState_dummy(state, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp Calls proc~~mus_derive_fromstate_dummy~~CallsGraph proc~mus_derive_fromstate_dummy mus_derive_FromState_dummy tem_abort tem_abort proc~mus_derive_fromstate_dummy->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_derive_fromstate_dummy.html"},{"title":"mus_derive_FromPreColState_dummy – Musubi","text":"public  subroutine mus_derive_FromPreColState_dummy(state, neigh, iField, nSize, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: iField Current field integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp Calls proc~~mus_derive_fromprecolstate_dummy~~CallsGraph proc~mus_derive_fromprecolstate_dummy mus_derive_FromPreColState_dummy tem_abort tem_abort proc~mus_derive_fromprecolstate_dummy->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_derive_fromprecolstate_dummy.html"},{"title":"mus_load_poisson – Musubi","text":"public  subroutine mus_load_poisson(me, conf, parent, minLevel, cs_lattice, physics, schemeKind) load input to solve poisson equation Arguments Type Intent Optional Attributes Name type( mus_poisson_type ), intent(out) :: me poisson type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle integer, intent(in) :: minLevel minlevel real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout\nrequired to compute omega from potential diffusivity type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa character(len=*), intent(in) :: schemeKind scheme kind Calls proc~~mus_load_poisson~~CallsGraph proc~mus_load_poisson mus_load_poisson aot_get_val aot_get_val proc~mus_load_poisson->aot_get_val aot_table_close aot_table_close proc~mus_load_poisson->aot_table_close aot_table_open aot_table_open proc~mus_load_poisson->aot_table_open proc~mus_load_poissonboltzmann mus_load_poissonBoltzmann proc~mus_load_poisson->proc~mus_load_poissonboltzmann tem_abort tem_abort proc~mus_load_poisson->tem_abort tem_toStr tem_toStr proc~mus_load_poisson->tem_toStr proc~mus_load_poissonboltzmann->aot_get_val proc~mus_load_poissonboltzmann->aot_table_close proc~mus_load_poissonboltzmann->aot_table_open proc~mus_load_poissonboltzmann->tem_abort aot_table_length aot_table_length proc~mus_load_poissonboltzmann->aot_table_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_poisson~~CalledByGraph proc~mus_load_poisson mus_load_poisson proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_prop->proc~mus_load_poisson proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_poisson.html"},{"title":"mus_load_poissonBoltzmann – Musubi","text":"public  subroutine mus_load_poissonBoltzmann(me, conf, parent, physics) Load input to solve poisson boltzmann equation Arguments Type Intent Optional Attributes Name type( mus_poisson_boltzmann_type ), intent(out) :: me poisson bolztmann type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa Calls proc~~mus_load_poissonboltzmann~~CallsGraph proc~mus_load_poissonboltzmann mus_load_poissonBoltzmann aot_get_val aot_get_val proc~mus_load_poissonboltzmann->aot_get_val aot_table_close aot_table_close proc~mus_load_poissonboltzmann->aot_table_close aot_table_length aot_table_length proc~mus_load_poissonboltzmann->aot_table_length aot_table_open aot_table_open proc~mus_load_poissonboltzmann->aot_table_open tem_abort tem_abort proc~mus_load_poissonboltzmann->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_poissonboltzmann~~CalledByGraph proc~mus_load_poissonboltzmann mus_load_poissonBoltzmann proc~mus_load_poisson mus_load_poisson proc~mus_load_poisson->proc~mus_load_poissonboltzmann proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_prop->proc~mus_load_poisson proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_poissonboltzmann.html"},{"title":"mus_init_eNRTL – Musubi","text":"public  function mus_init_eNRTL(filename, nFields) result(success) Dummy function to init_enrtl Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer, intent(out) :: nFields Number of fields defined in the property file Return Value logical Result, indicating the status of encode","tags":"","loc":"proc/mus_init_enrtl~2.html"},{"title":"mus_calc_thermFactor_single – Musubi","text":"private  subroutine mus_calc_thermFactor_single(nFields, temp, press, mole_frac, therm_factors) Dummy routine which sets thermodynamic factor matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix Called by proc~~mus_calc_thermfactor_single~2~~CalledByGraph proc~mus_calc_thermfactor_single~2 mus_calc_thermFactor_single interface~mus_calc_thermfactor~2 mus_calc_thermFactor interface~mus_calc_thermfactor~2->proc~mus_calc_thermfactor_single~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_thermfactor_single~2.html"},{"title":"mus_calc_MS_DiffMatrix_single – Musubi","text":"private  subroutine mus_calc_MS_DiffMatrix_single(nFields, temp, press, mole_dens, D_ij_out) Dummy routine which sets diffusivity coeff matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix Called by proc~~mus_calc_ms_diffmatrix_single~2~~CalledByGraph proc~mus_calc_ms_diffmatrix_single~2 mus_calc_MS_DiffMatrix_single interface~mus_calc_ms_diffmatrix~2 mus_calc_MS_DiffMatrix interface~mus_calc_ms_diffmatrix~2->proc~mus_calc_ms_diffmatrix_single~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calc_ms_diffmatrix_single~2.html"},{"title":"mus_calc_thermFactor – Musubi","text":"public interface mus_calc_thermFactor Calls interface~~mus_calc_thermfactor~2~~CallsGraph interface~mus_calc_thermfactor~2 mus_calc_thermFactor proc~mus_calc_thermfactor_single~2 mus_calc_thermFactor_single interface~mus_calc_thermfactor~2->proc~mus_calc_thermfactor_single~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) Dummy routine which sets thermodynamic factor matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"interface/mus_calc_thermfactor~2.html"},{"title":"mus_calc_MS_DiffMatrix – Musubi","text":"public interface mus_calc_MS_DiffMatrix Calls interface~~mus_calc_ms_diffmatrix~2~~CallsGraph interface~mus_calc_ms_diffmatrix~2 mus_calc_MS_DiffMatrix proc~mus_calc_ms_diffmatrix_single~2 mus_calc_MS_DiffMatrix_single interface~mus_calc_ms_diffmatrix~2->proc~mus_calc_ms_diffmatrix_single~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) Dummy routine which sets diffusivity coeff matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"interface/mus_calc_ms_diffmatrix~2.html"},{"title":"mus_updateSrcVar_turbChanForce – Musubi","text":"public  subroutine mus_updateSrcVar_turbChanForce(fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Compute dynamic force term using auxField for turbulent channel\nforce. If wall model BC is applied than compute the friction velocity\nIf wall model BC is not used than compute the friction velocity from\nthe single sided finite difference's and perform the spatial averaging.\nFriction velocity is computed only on elements intersected by\nshape_utau defined in musubi.lua.\nBulk mean velocity part of forcing is independent whether a wall Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Calls proc~~mus_updatesrcvar_turbchanforce~~CallsGraph proc~mus_updatesrcvar_turbchanforce mus_updateSrcVar_turbChanForce auxfield_varpos auxfield_varpos proc~mus_updatesrcvar_turbchanforce->auxfield_varpos bc bc proc~mus_updatesrcvar_turbchanforce->bc fac fac proc~mus_updatesrcvar_turbchanforce->fac field field proc~mus_updatesrcvar_turbchanforce->field globbc globbc proc~mus_updatesrcvar_turbchanforce->globbc graddata graddata proc~mus_updatesrcvar_turbchanforce->graddata levelpointer levelpointer proc~mus_updatesrcvar_turbchanforce->levelpointer map2global map2global proc~mus_updatesrcvar_turbchanforce->map2global mpi_allreduce mpi_allreduce proc~mus_updatesrcvar_turbchanforce->mpi_allreduce tem_LevelOf tem_LevelOf proc~mus_updatesrcvar_turbchanforce->tem_LevelOf treeid treeid proc~mus_updatesrcvar_turbchanforce->treeid u_ptr u_ptr proc~mus_updatesrcvar_turbchanforce->u_ptr val val proc~mus_updatesrcvar_turbchanforce->val veltau veltau proc~mus_updatesrcvar_turbchanforce->veltau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_updatesrcvar_turbchanforce.html"},{"title":"mus_load_turbulence – Musubi","text":"public  subroutine mus_load_turbulence(me, conf, parent) load turbulence table Arguments Type Intent Optional Attributes Name type( mus_turbulence_type ), intent(out) :: me fluid type type( flu_State ) :: conf lua state integer, intent(in), optional :: parent parent handle Calls proc~~mus_load_turbulence~~CallsGraph proc~mus_load_turbulence mus_load_turbulence aot_get_val aot_get_val proc~mus_load_turbulence->aot_get_val aot_table_close aot_table_close proc~mus_load_turbulence->aot_table_close aot_table_open aot_table_open proc~mus_load_turbulence->aot_table_open tem_abort tem_abort proc~mus_load_turbulence->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_turbulence->tem_horizontalSpacer upper_to_lower upper_to_lower proc~mus_load_turbulence->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_turbulence~~CalledByGraph proc~mus_load_turbulence mus_load_turbulence proc~mus_load_fluid mus_load_fluid proc~mus_load_fluid->proc~mus_load_turbulence proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_prop->proc~mus_load_fluid proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_turbulence.html"},{"title":"mus_init_turbulenceData – Musubi","text":"public  subroutine mus_init_turbulenceData(me, levelDesc, pattern, nSize) This initialize turbulence data type which includes velocity array\nand communication buffer Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(out) :: me turbulence data tubulence configuration type( tem_levelDesc_type ), intent(in) :: levelDesc levelDesc to access communication buffers of state array type( tem_commPattern_type ), intent(in) :: pattern communication pattern integer, intent(in) :: nSize Number of elements in state array Calls proc~~mus_init_turbulencedata~~CallsGraph proc~mus_init_turbulencedata mus_init_turbulenceData tem_comm_init tem_comm_init proc~mus_init_turbulencedata->tem_comm_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_turbulencedata~~CalledByGraph proc~mus_init_turbulencedata mus_init_turbulenceData proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_init_turbulencedata proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_turbulencedata.html"},{"title":"mus_turb_calcVisc – Musubi","text":"public  subroutine mus_turb_calcVisc(turbData, turbConfig, calcTurbVisc, state, neigh, auxField, gradData, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine, Grad) This routine compute turbulence viscosity and stores in turbulence data type Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(inout) :: turbData turbulence data type type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence configuration type( mus_turbulence_visc_proc_type ), intent(in) :: calcTurbVisc turbulence function real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array type(mus_gradData_type), intent(in) :: gradData gradient data integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL lattice element size in current level real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Called by proc~~mus_turb_calcvisc~~CalledByGraph proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine mus_update_viscKine proc~mus_update_visckine->proc~mus_turb_calcvisc proc~mus_update_relaxparams mus_update_relaxParams proc~mus_update_relaxparams->proc~mus_update_visckine proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turb_calcvisc.html"},{"title":"mus_turb_updateViscOfTurbWall – Musubi","text":"public  subroutine mus_turb_updateViscOfTurbWall(turbData, viscTurbWall, nElems_bnd, elemPos) This routine update turbulent viscosity of boundary elements from RANS\nviscosity computed in turbulent_wall boundary. Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(inout) :: turbData turbulence data type real(kind=rk), intent(in) :: viscTurbWall (:) Turbulent viscosity on turbulent wall boundary computed in set boundary integer, intent(in) :: nElems_bnd Number of elements in turbulent_wall boundary integer, intent(in) :: elemPos (:) Position of boundary element in levelwise total list or state array Called by proc~~mus_turb_updateviscofturbwall~~CalledByGraph proc~mus_turb_updateviscofturbwall mus_turb_updateViscOfTurbWall proc~mus_update_relaxparams mus_update_relaxParams proc~mus_update_relaxparams->proc~mus_turb_updateviscofturbwall proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turb_updateviscofturbwall.html"},{"title":"moleDens_nonEqExpol_curved – Musubi","text":"public  subroutine moleDens_nonEqExpol_curved(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Todo add comment This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\ncallable via boundary_type function pointer. Pre-calculate velocitiy terms Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~moledens_noneqexpol_curved~~CallsGraph proc~moledens_noneqexpol_curved moleDens_nonEqExpol_curved c_f c_f proc~moledens_noneqexpol_curved->c_f c_ff c_ff proc~moledens_noneqexpol_curved->c_ff c_neq_f c_neq_f proc~moledens_noneqexpol_curved->c_neq_f c_neq_ff c_neq_ff proc~moledens_noneqexpol_curved->c_neq_ff c_w c_w proc~moledens_noneqexpol_curved->c_w cxdirrk cxdirrk proc~moledens_noneqexpol_curved->cxdirrk get_valofindex get_valofindex proc~moledens_noneqexpol_curved->get_valofindex idir idir proc~moledens_noneqexpol_curved->idir links links proc~moledens_noneqexpol_curved->links neighbufferpost neighbufferpost proc~moledens_noneqexpol_curved->neighbufferpost nelems nelems proc~moledens_noneqexpol_curved->nelems posinbuffer posinbuffer proc~moledens_noneqexpol_curved->posinbuffer posinneighbuf posinneighbuf proc~moledens_noneqexpol_curved->posinneighbuf val val proc~moledens_noneqexpol_curved->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/moledens_noneqexpol_curved.html"},{"title":"moleDens_neumann_curved – Musubi","text":"public  subroutine moleDens_neumann_curved(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Todo add comment This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\ncallable via boundary_type function pointer. Pre-calculate velocitiy terms Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~moledens_neumann_curved~~CallsGraph proc~moledens_neumann_curved moleDens_neumann_curved c_neq_f c_neq_f proc~moledens_neumann_curved->c_neq_f c_neq_ff c_neq_ff proc~moledens_neumann_curved->c_neq_ff cxdirrk cxdirrk proc~moledens_neumann_curved->cxdirrk get_valofindex get_valofindex proc~moledens_neumann_curved->get_valofindex idir idir proc~moledens_neumann_curved->idir links links proc~moledens_neumann_curved->links neighbufferpost neighbufferpost proc~moledens_neumann_curved->neighbufferpost nelems nelems proc~moledens_neumann_curved->nelems posinbcelems posinbcelems proc~moledens_neumann_curved->posinbcelems posinbuffer posinbuffer proc~moledens_neumann_curved->posinbuffer posinneighbuf posinneighbuf proc~moledens_neumann_curved->posinneighbuf val val proc~moledens_neumann_curved->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/moledens_neumann_curved.html"},{"title":"moleDens_nonEqExpol – Musubi","text":"public  subroutine moleDens_nonEqExpol(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Todo add comment\nThis subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\ncallable via boundary_type function pointer. Pre-calculate velocitiy terms Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~moledens_noneqexpol~~CallsGraph proc~moledens_noneqexpol moleDens_nonEqExpol cxdirrk cxdirrk proc~moledens_noneqexpol->cxdirrk get_valofindex get_valofindex proc~moledens_noneqexpol->get_valofindex idir idir proc~moledens_noneqexpol->idir links links proc~moledens_noneqexpol->links nelems nelems proc~moledens_noneqexpol->nelems posinbuffer posinbuffer proc~moledens_noneqexpol->posinbuffer val val proc~moledens_noneqexpol->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/moledens_noneqexpol.html"},{"title":"moleDens_neumann – Musubi","text":"public  subroutine moleDens_neumann(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Todo add comment This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\ncallable via boundary_type function pointer. Pre-calculate velocitiy terms Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~moledens_neumann~~CallsGraph proc~moledens_neumann moleDens_neumann cxdirrk cxdirrk proc~moledens_neumann->cxdirrk get_valofindex get_valofindex proc~moledens_neumann->get_valofindex idir idir proc~moledens_neumann->idir links links proc~moledens_neumann->links neighbufferpost neighbufferpost proc~moledens_neumann->neighbufferpost nelems nelems proc~moledens_neumann->nelems posinbcelems posinbcelems proc~moledens_neumann->posinbcelems posinbuffer posinbuffer proc~moledens_neumann->posinbuffer posinneighbuf posinneighbuf proc~moledens_neumann->posinneighbuf val val proc~moledens_neumann->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/moledens_neumann.html"},{"title":"mus_calculate_speed_of_sound – Musubi","text":"private  function mus_calculate_speed_of_sound(layout) result(c_sound) Calculate lattice speed of sound for given stencil Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state Return Value real(kind=rk) Calls proc~~mus_calculate_speed_of_sound~~CallsGraph proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_calculate_speed_of_sound~~CalledByGraph proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d1q3 mus_define_d1q3 proc~mus_define_d1q3->proc~mus_calculate_speed_of_sound proc~mus_define_d2q5 mus_define_d2q5 proc~mus_define_d2q5->proc~mus_calculate_speed_of_sound proc~mus_define_d2q9 mus_define_d2q9 proc~mus_define_d2q9->proc~mus_calculate_speed_of_sound proc~mus_define_d3q13 mus_define_d3q13 proc~mus_define_d3q13->proc~mus_calculate_speed_of_sound proc~mus_define_d3q19 mus_define_d3q19 proc~mus_define_d3q19->proc~mus_calculate_speed_of_sound proc~mus_define_d3q27 mus_define_d3q27 proc~mus_define_d3q27->proc~mus_calculate_speed_of_sound proc~mus_define_d3q6 mus_define_d3q6 proc~mus_define_d3q6->proc~mus_calculate_speed_of_sound proc~mus_define_d3q7 mus_define_d3q7 proc~mus_define_d3q7->proc~mus_calculate_speed_of_sound proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d1q3 proc~mus_define_layout->proc~mus_define_d2q5 proc~mus_define_layout->proc~mus_define_d2q9 proc~mus_define_layout->proc~mus_define_d3q13 proc~mus_define_layout->proc~mus_define_d3q19 proc~mus_define_layout->proc~mus_define_d3q27 proc~mus_define_layout->proc~mus_define_d3q6 proc~mus_define_layout->proc~mus_define_d3q7 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calculate_speed_of_sound.html"},{"title":"mus_load_newLayout – Musubi","text":"public  subroutine mus_load_newLayout(me, parent_handle, conf) load a new stencil definition from the lua file a label the stencil (predefined or new) for a new defined stencil ( weights, inverse directions, prevailing\n  directions ) Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ) :: me integer, intent(in), optional :: parent_handle type( flu_State ) :: conf Calls proc~~mus_load_newlayout~~CallsGraph proc~mus_load_newlayout mus_load_newLayout aot_get_val aot_get_val proc~mus_load_newlayout->aot_get_val aot_table_close aot_table_close proc~mus_load_newlayout->aot_table_close aot_table_length aot_table_length proc~mus_load_newlayout->aot_table_length aot_table_open aot_table_open proc~mus_load_newlayout->aot_table_open cxdirinv cxdirinv proc~mus_load_newlayout->cxdirinv tem_abort tem_abort proc~mus_load_newlayout->tem_abort tem_identify_inverseDirections tem_identify_inverseDirections proc~mus_load_newlayout->tem_identify_inverseDirections tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_load_newlayout->tem_identify_prevailDirections tem_loadStencil tem_loadStencil proc~mus_load_newlayout->tem_loadStencil tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_load_newlayout->tem_stencil_zeroPos Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_newlayout~~CalledByGraph proc~mus_load_newlayout mus_load_newLayout proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_newlayout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_newlayout.html"},{"title":"mus_weights_out – Musubi","text":"public  subroutine mus_weights_out(me, conf) Dump the weights in lua format. The style is: weights = {w1, w2, ... , wN} Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: me (:) weights type( aot_out_type ) :: conf Calls proc~~mus_weights_out~~CallsGraph proc~mus_weights_out mus_weights_out aot_out_val aot_out_val proc~mus_weights_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_weights_out.html"},{"title":"mus_init_layout – Musubi","text":"public  subroutine mus_init_layout(layout) Initialize growing array of stencils Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout musubi schemes layout type Calls proc~~mus_init_layout~~CallsGraph proc~mus_init_layout mus_init_layout init init proc~mus_init_layout->init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_layout.html"},{"title":"mus_finalize_layout – Musubi","text":"public  subroutine mus_finalize_layout(layout, nElemsInTree, minLevel, maxLevel, proc) This routine finialize grwStencil by truncating stencil elem arrays and\nset stencil%nElems Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout integer, intent(in) :: nElemsInTree fluid tree from mesh integer, intent(in) :: minLevel min and max level integer, intent(in) :: maxLevel min and max level type( tem_comm_env_type ), intent(in) :: proc mpi communication type Calls proc~~mus_finalize_layout~~CallsGraph proc~mus_finalize_layout mus_finalize_layout append append proc~mus_finalize_layout->append destroy destroy proc~mus_finalize_layout->destroy elemlvl elemlvl proc~mus_finalize_layout->elemlvl mpi_gather mpi_gather proc~mus_finalize_layout->mpi_gather mpi_gatherv mpi_gatherv proc~mus_finalize_layout->mpi_gatherv mpi_type_commit mpi_type_commit proc~mus_finalize_layout->mpi_type_commit mpi_type_contiguous mpi_type_contiguous proc~mus_finalize_layout->mpi_type_contiguous truncate truncate proc~mus_finalize_layout->truncate val val proc~mus_finalize_layout->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_finalize_layout~~CalledByGraph proc~mus_finalize_layout mus_finalize_layout proc~mus_hvs_construct mus_hvs_construct proc~mus_hvs_construct->proc~mus_finalize_layout program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_construct Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_finalize_layout.html"},{"title":"mus_destroy_stencil – Musubi","text":"public  subroutine mus_destroy_stencil(stencil) Destroy the stencil Arguments Type Intent Optional Attributes Name type( tem_stencilHeader_type ), intent(out), allocatable :: stencil (:) musubi schemes stencil type","tags":"","loc":"proc/mus_destroy_stencil.html"},{"title":"mus_define_layout – Musubi","text":"public  subroutine mus_define_layout(layout, stencilName, nElems) This routine defines layout for predefined stencils Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state character(len=*), intent(in) :: stencilName Name of the stencil to create integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_layout~~CallsGraph proc~mus_define_layout mus_define_layout proc~mus_define_d1q3 mus_define_d1q3 proc~mus_define_layout->proc~mus_define_d1q3 proc~mus_define_d2q5 mus_define_d2q5 proc~mus_define_layout->proc~mus_define_d2q5 proc~mus_define_d2q9 mus_define_d2q9 proc~mus_define_layout->proc~mus_define_d2q9 proc~mus_define_d3q13 mus_define_d3q13 proc~mus_define_layout->proc~mus_define_d3q13 proc~mus_define_d3q19 mus_define_d3q19 proc~mus_define_layout->proc~mus_define_d3q19 proc~mus_define_d3q27 mus_define_d3q27 proc~mus_define_layout->proc~mus_define_d3q27 proc~mus_define_d3q6 mus_define_d3q6 proc~mus_define_layout->proc~mus_define_d3q6 proc~mus_define_d3q7 mus_define_d3q7 proc~mus_define_layout->proc~mus_define_d3q7 tem_abort tem_abort proc~mus_define_layout->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_define_layout->tem_horizontalSpacer proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d1q3->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d1q3 mus_set_weights_d1q3 proc~mus_define_d1q3->proc~mus_set_weights_d1q3 tem_create_stencil tem_create_stencil proc~mus_define_d1q3->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d1q3->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d1q3->tem_stencil_zeroPos proc~mus_define_d2q5->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d2q5 mus_set_weights_d2q5 proc~mus_define_d2q5->proc~mus_set_weights_d2q5 proc~mus_define_d2q5->tem_create_stencil proc~mus_define_d2q5->tem_identify_prevailDirections proc~mus_define_d2q5->tem_stencil_zeroPos proc~mus_define_d2q9->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d2q9 mus_set_weights_d2q9 proc~mus_define_d2q9->proc~mus_set_weights_d2q9 proc~mus_define_d2q9->tem_create_stencil proc~mus_define_d2q9->tem_identify_prevailDirections proc~mus_define_d2q9->tem_stencil_zeroPos proc~mus_define_d3q13->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q13 mus_set_weights_d3q13 proc~mus_define_d3q13->proc~mus_set_weights_d3q13 proc~mus_define_d3q13->tem_create_stencil proc~mus_define_d3q13->tem_identify_prevailDirections proc~mus_define_d3q13->tem_stencil_zeroPos proc~mus_define_d3q19->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q19 mus_set_weights_d3q19 proc~mus_define_d3q19->proc~mus_set_weights_d3q19 proc~mus_define_d3q19->tem_create_stencil proc~mus_define_d3q19->tem_identify_prevailDirections proc~mus_define_d3q19->tem_stencil_zeroPos proc~mus_define_d3q27->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q27 mus_set_weights_d3q27 proc~mus_define_d3q27->proc~mus_set_weights_d3q27 proc~mus_define_d3q27->tem_create_stencil proc~mus_define_d3q27->tem_identify_prevailDirections proc~mus_define_d3q27->tem_stencil_zeroPos proc~mus_define_d3q6->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q6 mus_set_weights_d3q6 proc~mus_define_d3q6->proc~mus_set_weights_d3q6 proc~mus_define_d3q6->tem_create_stencil proc~mus_define_d3q6->tem_identify_prevailDirections proc~mus_define_d3q6->tem_stencil_zeroPos proc~mus_define_d3q7->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q7 mus_set_weights_d3q7 proc~mus_define_d3q7->proc~mus_set_weights_d3q7 proc~mus_define_d3q7->tem_create_stencil proc~mus_define_d3q7->tem_identify_prevailDirections proc~mus_define_d3q7->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_layout~~CalledByGraph proc~mus_define_layout mus_define_layout proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_layout.html"},{"title":"mus_define_d3q19 – Musubi","text":"public  subroutine mus_define_d3q19(layout, nElems) This subroutine sets the parameters for the predefined d3q19 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d3q19~~CallsGraph proc~mus_define_d3q19 mus_define_d3q19 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d3q19->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q19 mus_set_weights_d3q19 proc~mus_define_d3q19->proc~mus_set_weights_d3q19 tem_create_stencil tem_create_stencil proc~mus_define_d3q19->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d3q19->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d3q19->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d3q19~~CalledByGraph proc~mus_define_d3q19 mus_define_d3q19 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q19 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d3q19.html"},{"title":"mus_set_weights_d3q19 – Musubi","text":"public  subroutine mus_set_weights_d3q19(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (19) Called by proc~~mus_set_weights_d3q19~~CalledByGraph proc~mus_set_weights_d3q19 mus_set_weights_d3q19 proc~mus_define_d3q19 mus_define_d3q19 proc~mus_define_d3q19->proc~mus_set_weights_d3q19 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q19 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d3q19.html"},{"title":"mus_define_d3q27 – Musubi","text":"public  subroutine mus_define_d3q27(layout, nElems) This subroutine sets the parameters for the predefined d3q27 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d3q27~~CallsGraph proc~mus_define_d3q27 mus_define_d3q27 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d3q27->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q27 mus_set_weights_d3q27 proc~mus_define_d3q27->proc~mus_set_weights_d3q27 tem_create_stencil tem_create_stencil proc~mus_define_d3q27->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d3q27->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d3q27->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d3q27~~CalledByGraph proc~mus_define_d3q27 mus_define_d3q27 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q27 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d3q27.html"},{"title":"mus_set_weights_d3q27 – Musubi","text":"public  subroutine mus_set_weights_d3q27(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (27) Called by proc~~mus_set_weights_d3q27~~CalledByGraph proc~mus_set_weights_d3q27 mus_set_weights_d3q27 proc~mus_define_d3q27 mus_define_d3q27 proc~mus_define_d3q27->proc~mus_set_weights_d3q27 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q27 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d3q27.html"},{"title":"mus_define_d3q7 – Musubi","text":"public  subroutine mus_define_d3q7(layout, nElems) This subroutine sets the parameters for the predefined d3q7 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d3q7~~CallsGraph proc~mus_define_d3q7 mus_define_d3q7 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d3q7->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q7 mus_set_weights_d3q7 proc~mus_define_d3q7->proc~mus_set_weights_d3q7 tem_create_stencil tem_create_stencil proc~mus_define_d3q7->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d3q7->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d3q7->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d3q7~~CalledByGraph proc~mus_define_d3q7 mus_define_d3q7 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q7 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d3q7.html"},{"title":"mus_set_weights_d3q7 – Musubi","text":"public  subroutine mus_set_weights_d3q7(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (7) Called by proc~~mus_set_weights_d3q7~~CalledByGraph proc~mus_set_weights_d3q7 mus_set_weights_d3q7 proc~mus_define_d3q7 mus_define_d3q7 proc~mus_define_d3q7->proc~mus_set_weights_d3q7 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q7 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d3q7.html"},{"title":"mus_define_d3q6 – Musubi","text":"public  subroutine mus_define_d3q6(layout, nElems) This subroutine sets the parameters for the predefined d3q6\nlayout%fStencil, used by the Flekkoy model of passive scalar transport. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d3q6~~CallsGraph proc~mus_define_d3q6 mus_define_d3q6 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d3q6->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q6 mus_set_weights_d3q6 proc~mus_define_d3q6->proc~mus_set_weights_d3q6 tem_create_stencil tem_create_stencil proc~mus_define_d3q6->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d3q6->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d3q6->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d3q6~~CalledByGraph proc~mus_define_d3q6 mus_define_d3q6 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q6 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d3q6.html"},{"title":"mus_set_weights_d3q6 – Musubi","text":"public  subroutine mus_set_weights_d3q6(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (6) Called by proc~~mus_set_weights_d3q6~~CalledByGraph proc~mus_set_weights_d3q6 mus_set_weights_d3q6 proc~mus_define_d3q6 mus_define_d3q6 proc~mus_define_d3q6->proc~mus_set_weights_d3q6 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q6 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d3q6.html"},{"title":"mus_define_d2q9 – Musubi","text":"public  subroutine mus_define_d2q9(layout, nElems) This subroutine sets the parameters for the predefined d2q9 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d2q9~~CallsGraph proc~mus_define_d2q9 mus_define_d2q9 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d2q9->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d2q9 mus_set_weights_d2q9 proc~mus_define_d2q9->proc~mus_set_weights_d2q9 tem_create_stencil tem_create_stencil proc~mus_define_d2q9->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d2q9->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d2q9->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d2q9~~CalledByGraph proc~mus_define_d2q9 mus_define_d2q9 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d2q9 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d2q9.html"},{"title":"mus_set_weights_d2q9 – Musubi","text":"public  subroutine mus_set_weights_d2q9(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (9) Called by proc~~mus_set_weights_d2q9~~CalledByGraph proc~mus_set_weights_d2q9 mus_set_weights_d2q9 proc~mus_define_d2q9 mus_define_d2q9 proc~mus_define_d2q9->proc~mus_set_weights_d2q9 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d2q9 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d2q9.html"},{"title":"mus_define_d1q3 – Musubi","text":"public  subroutine mus_define_d1q3(layout, nElems) This subroutine sets the parameters for the predefined d2q9 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d1q3~~CallsGraph proc~mus_define_d1q3 mus_define_d1q3 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d1q3->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d1q3 mus_set_weights_d1q3 proc~mus_define_d1q3->proc~mus_set_weights_d1q3 tem_create_stencil tem_create_stencil proc~mus_define_d1q3->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d1q3->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d1q3->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d1q3~~CalledByGraph proc~mus_define_d1q3 mus_define_d1q3 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d1q3 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d1q3.html"},{"title":"mus_set_weights_d1q3 – Musubi","text":"public  subroutine mus_set_weights_d1q3(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (3) Called by proc~~mus_set_weights_d1q3~~CalledByGraph proc~mus_set_weights_d1q3 mus_set_weights_d1q3 proc~mus_define_d1q3 mus_define_d1q3 proc~mus_define_d1q3->proc~mus_set_weights_d1q3 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d1q3 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d1q3.html"},{"title":"mus_define_d3q13 – Musubi","text":"private  subroutine mus_define_d3q13(layout, nElems) This subroutine sets the parameters for the predefined d3q13 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d3q13~~CallsGraph proc~mus_define_d3q13 mus_define_d3q13 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d3q13->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d3q13 mus_set_weights_d3q13 proc~mus_define_d3q13->proc~mus_set_weights_d3q13 tem_create_stencil tem_create_stencil proc~mus_define_d3q13->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d3q13->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d3q13->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d3q13~~CalledByGraph proc~mus_define_d3q13 mus_define_d3q13 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q13 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d3q13.html"},{"title":"mus_set_weights_d3q13 – Musubi","text":"private  subroutine mus_set_weights_d3q13(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (13) Called by proc~~mus_set_weights_d3q13~~CalledByGraph proc~mus_set_weights_d3q13 mus_set_weights_d3q13 proc~mus_define_d3q13 mus_define_d3q13 proc~mus_define_d3q13->proc~mus_set_weights_d3q13 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d3q13 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d3q13.html"},{"title":"mus_define_d2q5 – Musubi","text":"private  subroutine mus_define_d2q5(layout, nElems) This subroutine sets the parameters for the predefined d2q5 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout Calls proc~~mus_define_d2q5~~CallsGraph proc~mus_define_d2q5 mus_define_d2q5 proc~mus_calculate_speed_of_sound mus_calculate_speed_of_sound proc~mus_define_d2q5->proc~mus_calculate_speed_of_sound proc~mus_set_weights_d2q5 mus_set_weights_d2q5 proc~mus_define_d2q5->proc~mus_set_weights_d2q5 tem_create_stencil tem_create_stencil proc~mus_define_d2q5->tem_create_stencil tem_identify_prevailDirections tem_identify_prevailDirections proc~mus_define_d2q5->tem_identify_prevailDirections tem_stencil_zeroPos tem_stencil_zeroPos proc~mus_define_d2q5->tem_stencil_zeroPos cxcx cxcx proc~mus_calculate_speed_of_sound->cxcx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_define_d2q5~~CalledByGraph proc~mus_define_d2q5 mus_define_d2q5 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d2q5 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_define_d2q5.html"},{"title":"mus_set_weights_d2q5 – Musubi","text":"private  subroutine mus_set_weights_d2q5(weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (5) Called by proc~~mus_set_weights_d2q5~~CalledByGraph proc~mus_set_weights_d2q5 mus_set_weights_d2q5 proc~mus_define_d2q5 mus_define_d2q5 proc~mus_define_d2q5->proc~mus_set_weights_d2q5 proc~mus_define_layout mus_define_layout proc~mus_define_layout->proc~mus_define_d2q5 proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_define_layout proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_define_layout proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_weights_d2q5.html"},{"title":"mus_create_poss_transVar – Musubi","text":"public  subroutine mus_create_poss_transVar(poss_transVar, schemeHeader) Routine initialize possible transport variable depends on scheme kind Arguments Type Intent Optional Attributes Name type( tem_possible_variable_type ), intent(out) :: poss_transVar possible transport variables type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme Calls proc~~mus_create_poss_transvar~~CallsGraph proc~mus_create_poss_transvar mus_create_poss_transVar append append proc~mus_create_poss_transvar->append init init proc~mus_create_poss_transvar->init truncate truncate proc~mus_create_poss_transvar->truncate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_create_poss_transvar~~CalledByGraph proc~mus_create_poss_transvar mus_create_poss_transVar proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_create_poss_transvar proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_create_poss_transvar.html"},{"title":"mus_load_transport_var – Musubi","text":"public  subroutine mus_load_transport_var(me, possVars, conf, parent, varSys, schemeHeader) Routine load musubi transport variables Arguments Type Intent Optional Attributes Name type( mus_transport_var_type ), intent(out) :: me transport variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible transport variables type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined type( tem_varSys_type ), intent(inout) :: varSys Global variable system type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme Calls proc~~mus_load_transport_var~~CallsGraph proc~mus_load_transport_var mus_load_transport_var init init proc~mus_load_transport_var->init tem_abort tem_abort proc~mus_load_transport_var->tem_abort tem_variable_loadMapping tem_variable_loadMapping proc~mus_load_transport_var->tem_variable_loadMapping truncate truncate proc~mus_load_transport_var->truncate val val proc~mus_load_transport_var->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_transport_var~~CalledByGraph proc~mus_load_transport_var mus_load_transport_var proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_transport_var proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_transport_var.html"},{"title":"mus_init_transport_var – Musubi","text":"public  subroutine mus_init_transport_var(me, varSys, tree, nElems_solve, levelDesc) Initialize transport variable by calling setupIndices for every variable\nand store pntIndex Arguments Type Intent Optional Attributes Name type( mus_transport_var_type ), intent(inout) :: me transport variable to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system type( treelmesh_type ), intent(in) :: tree global treelm mesh integer, intent(in) :: nElems_solve (tree%global%minLevel:) Number of elements to solve in all levels\nnFluids + nGhosts type( tem_levelDesc_type ), intent(in) :: levelDesc (tree%global%minLevel:) Level descriptors Calls proc~~mus_init_transport_var~~CallsGraph proc~mus_init_transport_var mus_init_transport_var append append proc~mus_init_transport_var->append indexlvl indexlvl proc~mus_init_transport_var->indexlvl positionofval positionofval proc~mus_init_transport_var->positionofval set_params set_params proc~mus_init_transport_var->set_params setup_indices setup_indices proc~mus_init_transport_var->setup_indices tem_BaryOfId tem_BaryOfId proc~mus_init_transport_var->tem_BaryOfId tem_abort tem_abort proc~mus_init_transport_var->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_init_transport_var->tem_horizontalSpacer val val proc~mus_init_transport_var->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_transport_var~~CalledByGraph proc~mus_init_transport_var mus_init_transport_var proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_transport_var proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_transport_var proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_transport_var.html"},{"title":"mus_load_geom – Musubi","text":"public  subroutine mus_load_geom(me, restart, solverHead, simControl, proc, scaleFactor, initial_balance) This routine load all geometry related datas like mesh, boundary\nand immersed_boundary. Restart is also loaded here because mesh is loaded\nin tem_load_restart if restart read is defined. Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(out) :: me type( tem_restart_type ), intent(out) :: restart contains restart information type( tem_solveHead_type ), intent(inout) :: solverHead contains general description of the solver including flu_state type( tem_simControl_type ), intent(inout) :: simControl contains simulation time control information type( tem_comm_env_type ), intent(in) :: proc contains MPI communication environment integer, intent(in) :: scaleFactor Temporal scaling factor for multilevel mesh logical, intent(in) :: initial_balance If true, do initial balancing using level_weights Calls proc~~mus_load_geom~~CallsGraph proc~mus_load_geom mus_load_geom load_tem load_tem proc~mus_load_geom->load_tem mus_load_ibm mus_load_ibm proc~mus_load_geom->mus_load_ibm proc~mus_geomincrhead_load mus_geomIncrHead_load proc~mus_load_geom->proc~mus_geomincrhead_load proc~mus_load_bc_data mus_load_bc_data proc~mus_load_geom->proc~mus_load_bc_data tem_global_mesh_read tem_global_mesh_read proc~mus_load_geom->tem_global_mesh_read tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_geom->tem_horizontalSpacer tem_load_restart tem_load_restart proc~mus_load_geom->tem_load_restart tem_timeControl_start_at_sim tem_timeControl_start_at_sim proc~mus_load_geom->tem_timeControl_start_at_sim aot_table_close aot_table_close proc~mus_geomincrhead_load->aot_table_close aot_table_length aot_table_length proc~mus_geomincrhead_load->aot_table_length aot_table_open aot_table_open proc~mus_geomincrhead_load->aot_table_open proc~mus_geomincrhead_load_single mus_geomIncrHead_load_single proc~mus_geomincrhead_load->proc~mus_geomincrhead_load_single init_tem_bc_prop init_tem_bc_prop proc~mus_load_bc_data->init_tem_bc_prop load_tem_BC_qVal load_tem_BC_qVal proc~mus_load_bc_data->load_tem_BC_qVal proc~mus_build_posinprop mus_build_posInProp proc~mus_load_bc_data->proc~mus_build_posinprop property property proc~mus_load_bc_data->property qval qval proc~mus_load_bc_data->qval proc~mus_build_posinprop->property proc~mus_build_minbcid mus_build_minBcID proc~mus_build_posinprop->proc~mus_build_minbcid tem_build_treeToProp_pointer tem_build_treeToProp_pointer proc~mus_build_posinprop->tem_build_treeToProp_pointer proc~mus_geomincrhead_load_single->tem_horizontalSpacer aot_get_val aot_get_val proc~mus_geomincrhead_load_single->aot_get_val tem_timeControl_load tem_timeControl_load proc~mus_geomincrhead_load_single->tem_timeControl_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_geom~~CalledByGraph proc~mus_load_geom mus_load_geom proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_geom.html"},{"title":"mus_load_bc_data – Musubi","text":"public  subroutine mus_load_bc_data(geometry, rank, comm) This routine invokes the treelm routines to load the boundary conditions Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: geometry integer, intent(in) :: rank integer, intent(in) :: comm Calls proc~~mus_load_bc_data~~CallsGraph proc~mus_load_bc_data mus_load_bc_data init_tem_bc_prop init_tem_bc_prop proc~mus_load_bc_data->init_tem_bc_prop load_tem_BC_qVal load_tem_BC_qVal proc~mus_load_bc_data->load_tem_BC_qVal proc~mus_build_posinprop mus_build_posInProp proc~mus_load_bc_data->proc~mus_build_posinprop property property proc~mus_load_bc_data->property qval qval proc~mus_load_bc_data->qval proc~mus_build_posinprop->property proc~mus_build_minbcid mus_build_minBcID proc~mus_build_posinprop->proc~mus_build_minbcid tem_build_treeToProp_pointer tem_build_treeToProp_pointer proc~mus_build_posinprop->tem_build_treeToProp_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_bc_data~~CalledByGraph proc~mus_load_bc_data mus_load_bc_data proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_load_bc_data proc~mus_load_geom mus_load_geom proc~mus_load_geom->proc~mus_load_bc_data proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_bc_data.html"},{"title":"mus_build_posInProp – Musubi","text":"public  subroutine mus_build_posInProp(me) This routine builds mapping between elements in tree to to propery list Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: me Calls proc~~mus_build_posinprop~~CallsGraph proc~mus_build_posinprop mus_build_posInProp proc~mus_build_minbcid mus_build_minBcID proc~mus_build_posinprop->proc~mus_build_minbcid property property proc~mus_build_posinprop->property tem_build_treeToProp_pointer tem_build_treeToProp_pointer proc~mus_build_posinprop->tem_build_treeToProp_pointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_build_posinprop~~CalledByGraph proc~mus_build_posinprop mus_build_posInProp proc~exchange_tree_bc exchange_tree_bc proc~exchange_tree_bc->proc~mus_build_posinprop proc~mus_load_bc_data mus_load_bc_data proc~mus_load_bc_data->proc~mus_build_posinprop proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_load_bc_data proc~mus_load_geom mus_load_geom proc~mus_load_geom->proc~mus_load_bc_data proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~exchange_tree_bc proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_build_posinprop.html"},{"title":"mus_build_minBcID – Musubi","text":"private  subroutine mus_build_minBcID(minBcID, bc_prop, posInBndID) This routine build minBcID for boundary elements, it is required if a\nelement has more than one boundary in its directions.\nif a element has more than one boundary then use minBcID which depends\non boundary order in seeder configuration Arguments Type Intent Optional Attributes Name integer, intent(out), allocatable :: minBcID (:) type( tem_BC_prop_type ), intent(in) :: bc_prop boundary information from mesh integer, intent(in) :: posInBndID (:) tree element position in boundaryID Called by proc~~mus_build_minbcid~~CalledByGraph proc~mus_build_minbcid mus_build_minBcID proc~mus_build_posinprop mus_build_posInProp proc~mus_build_posinprop->proc~mus_build_minbcid proc~exchange_tree_bc exchange_tree_bc proc~exchange_tree_bc->proc~mus_build_posinprop proc~mus_load_bc_data mus_load_bc_data proc~mus_load_bc_data->proc~mus_build_posinprop proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_load_bc_data proc~mus_load_geom mus_load_geom proc~mus_load_geom->proc~mus_load_bc_data proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~exchange_tree_bc proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_build_minbcid.html"},{"title":"mus_init_advRel_isotherm_acEq – Musubi","text":"public  subroutine mus_init_advRel_isotherm_acEq(relaxation, layout, compute) Assigning compute kernel routine by scheme relaxation type for\nisotherm_acEq kind. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_isotherm_aceq~~CallsGraph proc~mus_init_advrel_isotherm_aceq mus_init_advRel_isotherm_acEq tem_abort tem_abort proc~mus_init_advrel_isotherm_aceq->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_isotherm_aceq.html"},{"title":"mus_get_timerHandles – Musubi","text":"public  function mus_get_timerHandles() result(timerHandles) This function returns musubi modular variable mus_timerHandles to apesmate\nand deallocate mus_timerHandles level timers. Arguments None Return Value type( mus_timer_handle_type )","tags":"","loc":"proc/mus_get_timerhandles.html"},{"title":"get_communicateTime – Musubi","text":"public  function get_communicateTime() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_communicatetime~~CallsGraph proc~get_communicatetime get_communicateTime tem_getTimerVal tem_getTimerVal proc~get_communicatetime->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_communicatetime~~CalledByGraph proc~get_communicatetime get_communicateTime proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->proc~get_communicatetime proc~get_communicateratio get_communicateRatio proc~get_communicateratio->proc~get_communicatetime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~get_communicatetime proc~dump_timing dump_timing proc~mus_perf_measure->proc~dump_timing proc~dump_timing->proc~get_communicateratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_communicatetime.html"},{"title":"get_communicateRatio – Musubi","text":"public  function get_communicateRatio() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_communicateratio~~CallsGraph proc~get_communicateratio get_communicateRatio proc~get_communicatetime get_communicateTime proc~get_communicateratio->proc~get_communicatetime proc~get_mainlooptime get_mainLoopTime proc~get_communicateratio->proc~get_mainlooptime tem_getTimerVal tem_getTimerVal proc~get_communicatetime->tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_communicateratio~~CalledByGraph proc~get_communicateratio get_communicateRatio proc~dump_timing dump_timing proc~dump_timing->proc~get_communicateratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_communicateratio.html"},{"title":"get_boundaryRatio – Musubi","text":"public  function get_boundaryRatio() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_boundaryratio~~CallsGraph proc~get_boundaryratio get_boundaryRatio interface~get_boundarytime get_boundaryTime proc~get_boundaryratio->interface~get_boundarytime proc~get_mainlooptime get_mainLoopTime proc~get_boundaryratio->proc~get_mainlooptime proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_boundaryratio~~CalledByGraph proc~get_boundaryratio get_boundaryRatio proc~dump_timing dump_timing proc~dump_timing->proc~get_boundaryratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_boundaryratio.html"},{"title":"get_intpRatio – Musubi","text":"public  function get_intpRatio() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_intpratio~~CallsGraph proc~get_intpratio get_intpRatio proc~get_intptime get_intpTime proc~get_intpratio->proc~get_intptime proc~get_mainlooptime get_mainLoopTime proc~get_intpratio->proc~get_mainlooptime interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intptime->interface~get_intpfromcoarsertime interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intptime->interface~get_intpfromfinertime tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpratio~~CalledByGraph proc~get_intpratio get_intpRatio proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpratio.html"},{"title":"get_mainLoopTime – Musubi","text":"public  function get_mainLoopTime() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_mainlooptime~~CallsGraph proc~get_mainlooptime get_mainLoopTime tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_mainlooptime~~CalledByGraph proc~get_mainlooptime get_mainLoopTime proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->proc~get_mainlooptime proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel proc~get_bcbufferratio_atlevel->proc~get_mainlooptime proc~get_bcbufferratio_total get_bcBufferRatio_total proc~get_bcbufferratio_total->proc~get_mainlooptime proc~get_boundaryratio get_boundaryRatio proc~get_boundaryratio->proc~get_mainlooptime proc~get_communicateratio get_communicateRatio proc~get_communicateratio->proc~get_mainlooptime proc~get_computeratio_atlevel get_computeRatio_atLevel proc~get_computeratio_atlevel->proc~get_mainlooptime proc~get_computeratio_total get_computeRatio_total proc~get_computeratio_total->proc~get_mainlooptime proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel proc~get_intpfromcoarserratio_atlevel->proc~get_mainlooptime proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total proc~get_intpfromcoarserratio_total->proc~get_mainlooptime proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel proc~get_intpfromfinerratio_atlevel->proc~get_mainlooptime proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total proc~get_intpfromfinerratio_total->proc~get_mainlooptime proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_mainlooptime proc~get_stageratio get_stageRatio proc~get_stageratio->proc~get_mainlooptime proc~get_stagetime get_stageTime proc~get_stageratio->proc~get_stagetime proc~get_stagetime->proc~get_mainlooptime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~get_mainlooptime proc~dump_timing dump_timing proc~mus_perf_measure->proc~dump_timing interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel interface~get_bcbufferratio->proc~get_bcbufferratio_total interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_atlevel interface~get_computeratio->proc~get_computeratio_total interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total proc~dump_timing->proc~get_boundaryratio proc~dump_timing->proc~get_communicateratio proc~dump_timing->proc~get_intpratio proc~dump_timing->interface~get_bcbufferratio proc~dump_timing->interface~get_computeratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_mainlooptime.html"},{"title":"get_stageTime – Musubi","text":"public  function get_stageTime(ii) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii Return Value real(kind=rk) Calls proc~~get_stagetime~~CallsGraph proc~get_stagetime get_stageTime proc~get_mainlooptime get_mainLoopTime proc~get_stagetime->proc~get_mainlooptime tem_getTimerVal tem_getTimerVal proc~get_stagetime->tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_stagetime~~CalledByGraph proc~get_stagetime get_stageTime proc~get_stageratio get_stageRatio proc~get_stageratio->proc~get_stagetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_stagetime.html"},{"title":"get_stageRatio – Musubi","text":"public  function get_stageRatio(ii) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii Return Value real(kind=rk) Calls proc~~get_stageratio~~CallsGraph proc~get_stageratio get_stageRatio proc~get_mainlooptime get_mainLoopTime proc~get_stageratio->proc~get_mainlooptime proc~get_stagetime get_stageTime proc~get_stageratio->proc~get_stagetime tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_stagetime->proc~get_mainlooptime proc~get_stagetime->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_stageratio.html"},{"title":"get_computeTime_total – Musubi","text":"private  function get_computeTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_computetime_total~~CallsGraph proc~get_computetime_total get_computeTime_total interface~get_computetime get_computeTime proc~get_computetime_total->interface~get_computetime interface~get_computetime->proc~get_computetime_total proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel tem_getTimerVal tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_computetime_total~~CalledByGraph proc~get_computetime_total get_computeTime_total interface~get_computetime get_computeTime proc~get_computetime_total->interface~get_computetime interface~get_computetime->proc~get_computetime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_computetime proc~get_computeratio_atlevel get_computeRatio_atLevel proc~get_computeratio_atlevel->interface~get_computetime proc~get_computeratio_total get_computeRatio_total proc~get_computeratio_total->interface~get_computetime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_computetime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->interface~get_computetime interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_atlevel interface~get_computeratio->proc~get_computeratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->interface~get_computeratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_computetime_total.html"},{"title":"get_computeTime_atLevel – Musubi","text":"private  function get_computeTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_computetime_atlevel~~CallsGraph proc~get_computetime_atlevel get_computeTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_computetime_atlevel~~CalledByGraph proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime get_computeTime interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_computetime proc~get_computeratio_atlevel get_computeRatio_atLevel proc~get_computeratio_atlevel->interface~get_computetime proc~get_computeratio_total get_computeRatio_total proc~get_computeratio_total->interface~get_computetime proc~get_computetime_total->interface~get_computetime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_computetime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->interface~get_computetime interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_atlevel interface~get_computeratio->proc~get_computeratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->interface~get_computeratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_computetime_atlevel.html"},{"title":"get_computeRatio_total – Musubi","text":"private  function get_computeRatio_total() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_computeratio_total~~CallsGraph proc~get_computeratio_total get_computeRatio_total interface~get_computetime get_computeTime proc~get_computeratio_total->interface~get_computetime proc~get_mainlooptime get_mainLoopTime proc~get_computeratio_total->proc~get_mainlooptime proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_computeratio_total~~CalledByGraph proc~get_computeratio_total get_computeRatio_total interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_total proc~dump_timing dump_timing proc~dump_timing->interface~get_computeratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_computeratio_total.html"},{"title":"get_computeRatio_atLevel – Musubi","text":"private  function get_computeRatio_atLevel(level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_computeratio_atlevel~~CallsGraph proc~get_computeratio_atlevel get_computeRatio_atLevel interface~get_computetime get_computeTime proc~get_computeratio_atlevel->interface~get_computetime proc~get_mainlooptime get_mainLoopTime proc~get_computeratio_atlevel->proc~get_mainlooptime proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_computeratio_atlevel~~CalledByGraph proc~get_computeratio_atlevel get_computeRatio_atLevel interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_atlevel proc~dump_timing dump_timing proc~dump_timing->interface~get_computeratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_computeratio_atlevel.html"},{"title":"get_auxTime_total – Musubi","text":"private  function get_auxTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_auxtime_total~~CallsGraph proc~get_auxtime_total get_auxTime_total interface~get_auxtime get_auxTime proc~get_auxtime_total->interface~get_auxtime interface~get_auxtime->proc~get_auxtime_total proc~get_auxtime_atlevel get_auxTime_atLevel interface~get_auxtime->proc~get_auxtime_atlevel tem_getTimerVal tem_getTimerVal proc~get_auxtime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_auxtime_total~~CalledByGraph proc~get_auxtime_total get_auxTime_total interface~get_auxtime get_auxTime proc~get_auxtime_total->interface~get_auxtime interface~get_auxtime->proc~get_auxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_auxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_auxtime_total.html"},{"title":"get_auxTime_atLevel – Musubi","text":"private  function get_auxTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_auxtime_atlevel~~CallsGraph proc~get_auxtime_atlevel get_auxTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_auxtime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_auxtime_atlevel~~CalledByGraph proc~get_auxtime_atlevel get_auxTime_atLevel interface~get_auxtime get_auxTime interface~get_auxtime->proc~get_auxtime_atlevel proc~get_auxtime_total get_auxTime_total interface~get_auxtime->proc~get_auxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_auxtime proc~get_auxtime_total->interface~get_auxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_auxtime_atlevel.html"},{"title":"get_relaxTime_total – Musubi","text":"private  function get_relaxTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_relaxtime_total~~CallsGraph proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime get_relaxTime proc~get_relaxtime_total->interface~get_relaxtime interface~get_relaxtime->proc~get_relaxtime_total proc~get_relaxtime_atlevel get_relaxTime_atLevel interface~get_relaxtime->proc~get_relaxtime_atlevel tem_getTimerVal tem_getTimerVal proc~get_relaxtime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_relaxtime_total~~CalledByGraph proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime get_relaxTime proc~get_relaxtime_total->interface~get_relaxtime interface~get_relaxtime->proc~get_relaxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_relaxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_relaxtime_total.html"},{"title":"get_relaxTime_atLevel – Musubi","text":"private  function get_relaxTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_relaxtime_atlevel~~CallsGraph proc~get_relaxtime_atlevel get_relaxTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_relaxtime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_relaxtime_atlevel~~CalledByGraph proc~get_relaxtime_atlevel get_relaxTime_atLevel interface~get_relaxtime get_relaxTime interface~get_relaxtime->proc~get_relaxtime_atlevel proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime->proc~get_relaxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_relaxtime proc~get_relaxtime_total->interface~get_relaxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_relaxtime_atlevel.html"},{"title":"get_intpFromCoarserTime_total – Musubi","text":"private  function get_intpFromCoarserTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_intpfromcoarsertime_total~~CallsGraph proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel tem_getTimerVal tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromcoarsertime_total~~CalledByGraph proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel proc~get_intpfromcoarserratio_atlevel->interface~get_intpfromcoarsertime proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total proc~get_intpfromcoarserratio_total->interface~get_intpfromcoarsertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromcoarsertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromcoarsertime interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromcoarsertime_total.html"},{"title":"get_intpFromCoarserTime_atLevel – Musubi","text":"private  function get_intpFromCoarserTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_intpfromcoarsertime_atlevel~~CallsGraph proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromcoarsertime_atlevel~~CalledByGraph proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime get_intpFromCoarserTime interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel proc~get_intpfromcoarserratio_atlevel->interface~get_intpfromcoarsertime proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total proc~get_intpfromcoarserratio_total->interface~get_intpfromcoarsertime proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromcoarsertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromcoarsertime interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromcoarsertime_atlevel.html"},{"title":"get_intpFromCoarserRatio_total – Musubi","text":"private  function get_intpFromCoarserRatio_total() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_intpfromcoarserratio_total~~CallsGraph proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarserratio_total->interface~get_intpfromcoarsertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromcoarserratio_total->proc~get_mainlooptime proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromcoarserratio_total~~CalledByGraph proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromcoarserratio_total.html"},{"title":"get_intpFromCoarserRatio_atLevel – Musubi","text":"private  function get_intpFromCoarserRatio_atLevel(level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) Calls proc~~get_intpfromcoarserratio_atlevel~~CallsGraph proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarserratio_atlevel->interface~get_intpfromcoarsertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromcoarserratio_atlevel->proc~get_mainlooptime proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromcoarserratio_atlevel~~CalledByGraph proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromcoarserratio_atlevel.html"},{"title":"get_intpFromFinerTime_total – Musubi","text":"private  function get_intpFromFinerTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_intpfromfinertime_total~~CallsGraph proc~get_intpfromfinertime_total get_intpFromFinerTime_total tem_getTimerVal tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromfinertime_total~~CalledByGraph proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime get_intpFromFinerTime interface~get_intpfromfinertime->proc~get_intpfromfinertime_total proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel proc~get_intpfromfinerratio_atlevel->interface~get_intpfromfinertime proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total proc~get_intpfromfinerratio_total->interface~get_intpfromfinertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromfinertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromfinertime interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromfinertime_total.html"},{"title":"get_intpFromFinerTime_atLevel – Musubi","text":"private  function get_intpFromFinerTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_intpfromfinertime_atlevel~~CallsGraph proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_intpfromfinertime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromfinertime_atlevel~~CalledByGraph proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime get_intpFromFinerTime interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel proc~get_intpfromfinerratio_atlevel->interface~get_intpfromfinertime proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total proc~get_intpfromfinerratio_total->interface~get_intpfromfinertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromfinertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromfinertime interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromfinertime_atlevel.html"},{"title":"get_intpFromFinerRatio_total – Musubi","text":"private  function get_intpFromFinerRatio_total() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_intpfromfinerratio_total~~CallsGraph proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intpfromfinerratio_total->interface~get_intpfromfinertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromfinerratio_total->proc~get_mainlooptime proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromfinerratio_total~~CalledByGraph proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromfinerratio_total.html"},{"title":"get_intpFromFinerRatio_atLevel – Musubi","text":"private  function get_intpFromFinerRatio_atLevel(level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) Calls proc~~get_intpfromfinerratio_atlevel~~CallsGraph proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intpfromfinerratio_atlevel->interface~get_intpfromfinertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromfinerratio_atlevel->proc~get_mainlooptime proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intpfromfinerratio_atlevel~~CalledByGraph proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intpfromfinerratio_atlevel.html"},{"title":"get_boundaryTime_byID – Musubi","text":"private  function get_boundaryTime_byID(bcID) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: bcID Return Value real(kind=rk) Calls proc~~get_boundarytime_byid~~CallsGraph proc~get_boundarytime_byid get_boundaryTime_byID tem_getTimerVal tem_getTimerVal proc~get_boundarytime_byid->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_boundarytime_byid~~CalledByGraph proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime get_boundaryTime interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_boundarytime proc~get_boundaryratio get_boundaryRatio proc~get_boundaryratio->interface~get_boundarytime proc~get_boundarytime_total->interface~get_boundarytime proc~mus_bc_timing mus_BC_timing proc~mus_bc_timing->interface~get_boundarytime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_boundarytime proc~dump_timing dump_timing proc~dump_timing->proc~get_boundaryratio proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_boundarytime_byid.html"},{"title":"get_boundaryTime_total – Musubi","text":"private  function get_boundaryTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_boundarytime_total~~CallsGraph proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime get_boundaryTime proc~get_boundarytime_total->interface~get_boundarytime interface~get_boundarytime->proc~get_boundarytime_total proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid tem_getTimerVal tem_getTimerVal proc~get_boundarytime_byid->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_boundarytime_total~~CalledByGraph proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime get_boundaryTime proc~get_boundarytime_total->interface~get_boundarytime interface~get_boundarytime->proc~get_boundarytime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_boundarytime proc~get_boundaryratio get_boundaryRatio proc~get_boundaryratio->interface~get_boundarytime proc~mus_bc_timing mus_BC_timing proc~mus_bc_timing->interface~get_boundarytime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_boundarytime proc~dump_timing dump_timing proc~dump_timing->proc~get_boundaryratio proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_boundarytime_total.html"},{"title":"get_intpTime – Musubi","text":"private  function get_intpTime() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_intptime~~CallsGraph proc~get_intptime get_intpTime interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intptime->interface~get_intpfromcoarsertime interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intptime->interface~get_intpfromfinertime proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_intptime~~CalledByGraph proc~get_intptime get_intpTime proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intptime.html"},{"title":"get_bcBufferTime_atLevel – Musubi","text":"private  function get_bcBufferTime_atLevel(level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_bcbuffertime_atlevel~~CallsGraph proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel tem_getTimerVal tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_bcbuffertime_atlevel~~CalledByGraph proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime get_bcBufferTime interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_bcbuffertime proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_bcbufferratio_total get_bcBufferRatio_total proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~get_bcbuffertime_total->interface~get_bcbuffertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_bcbuffertime interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_bcbuffertime_atlevel.html"},{"title":"get_bcBufferTime_total – Musubi","text":"private  function get_bcBufferTime_total() result(time) Arguments None Return Value real(kind=rk) Calls proc~~get_bcbuffertime_total~~CallsGraph proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime get_bcBufferTime proc~get_bcbuffertime_total->interface~get_bcbuffertime interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel tem_getTimerVal tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_bcbuffertime_total~~CalledByGraph proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime get_bcBufferTime proc~get_bcbuffertime_total->interface~get_bcbuffertime interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_bcbuffertime proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_bcbufferratio_total get_bcBufferRatio_total proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_bcbuffertime interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_bcbuffertime_total.html"},{"title":"get_bcBufferRatio_atLevel – Musubi","text":"private  function get_bcBufferRatio_atLevel(level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Calls proc~~get_bcbufferratio_atlevel~~CallsGraph proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel interface~get_bcbuffertime get_bcBufferTime proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_mainlooptime get_mainLoopTime proc~get_bcbufferratio_atlevel->proc~get_mainlooptime proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_bcbufferratio_atlevel~~CalledByGraph proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_bcbufferratio_atlevel.html"},{"title":"get_bcBufferRatio_total – Musubi","text":"private  function get_bcBufferRatio_total() result(ratio) Arguments None Return Value real(kind=rk) Calls proc~~get_bcbufferratio_total~~CallsGraph proc~get_bcbufferratio_total get_bcBufferRatio_total interface~get_bcbuffertime get_bcBufferTime proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~get_mainlooptime get_mainLoopTime proc~get_bcbufferratio_total->proc~get_mainlooptime proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_bcbufferratio_total~~CalledByGraph proc~get_bcbufferratio_total get_bcBufferRatio_total interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_bcbufferratio_total.html"},{"title":"mus_init_mainTimer – Musubi","text":"public  subroutine mus_init_mainTimer() Timers initialization routine for whatever Arguments None Calls proc~~mus_init_maintimer~~CallsGraph proc~mus_init_maintimer mus_init_mainTimer tem_addTimer tem_addTimer proc~mus_init_maintimer->tem_addTimer tem_getNTimers tem_getNTimers proc~mus_init_maintimer->tem_getNTimers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_maintimer~~CalledByGraph proc~mus_init_maintimer mus_init_mainTimer program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_maintimer program~musubi musubi program~musubi->proc~mus_init_maintimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_maintimer.html"},{"title":"mus_init_levelTimer – Musubi","text":"public  subroutine mus_init_levelTimer(minLevel, maxLevel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Calls proc~~mus_init_leveltimer~~CallsGraph proc~mus_init_leveltimer mus_init_levelTimer tem_addTimer tem_addTimer proc~mus_init_leveltimer->tem_addTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_leveltimer~~CalledByGraph proc~mus_init_leveltimer mus_init_levelTimer program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_leveltimer program~musubi musubi program~musubi->proc~mus_init_leveltimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_leveltimer.html"},{"title":"mus_reset_levelTimer – Musubi","text":"public  subroutine mus_reset_levelTimer() Arguments None Calls proc~~mus_reset_leveltimer~~CallsGraph proc~mus_reset_leveltimer mus_reset_levelTimer tem_resetTimer tem_resetTimer proc~mus_reset_leveltimer->tem_resetTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_reset_leveltimer~~CalledByGraph proc~mus_reset_leveltimer mus_reset_levelTimer proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_reset_leveltimer proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_reset_leveltimer.html"},{"title":"mus_reset_mainTimer – Musubi","text":"public  subroutine mus_reset_mainTimer() Arguments None Calls proc~~mus_reset_maintimer~~CallsGraph proc~mus_reset_maintimer mus_reset_mainTimer tem_resetTimer tem_resetTimer proc~mus_reset_maintimer->tem_resetTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_reset_maintimer.html"},{"title":"mus_set_timerHandles – Musubi","text":"public  subroutine mus_set_timerHandles(timerHandles) This routine sets mus_timerHandles passed by apesmate Arguments Type Intent Optional Attributes Name type( mus_timer_handle_type ), intent(in) :: timerHandles","tags":"","loc":"proc/mus_set_timerhandles.html"},{"title":"mus_init_bcTimer – Musubi","text":"public  subroutine mus_init_bcTimer(nBCs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nBCs Calls proc~~mus_init_bctimer~~CallsGraph proc~mus_init_bctimer mus_init_bcTimer tem_addTimer tem_addTimer proc~mus_init_bctimer->tem_addTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_bctimer~~CalledByGraph proc~mus_init_bctimer mus_init_bcTimer program~musubi musubi program~musubi->proc~mus_init_bctimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_bctimer.html"},{"title":"mus_reset_bcTimer – Musubi","text":"public  subroutine mus_reset_bcTimer() Arguments None Calls proc~~mus_reset_bctimer~~CallsGraph proc~mus_reset_bctimer mus_reset_bcTimer tem_resetTimer tem_resetTimer proc~mus_reset_bctimer->tem_resetTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_reset_bctimer~~CalledByGraph proc~mus_reset_bctimer mus_reset_bcTimer proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_reset_bctimer proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_reset_bctimer.html"},{"title":"get_boundaryTime – Musubi","text":"public interface get_boundaryTime Calls interface~~get_boundarytime~~CallsGraph interface~get_boundarytime get_boundaryTime proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total tem_getTimerVal tem_getTimerVal proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_boundarytime~~CalledByGraph interface~get_boundarytime get_boundaryTime proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_boundarytime proc~get_boundaryratio get_boundaryRatio proc~get_boundaryratio->interface~get_boundarytime proc~get_boundarytime_total->interface~get_boundarytime proc~mus_bc_timing mus_BC_timing proc~mus_bc_timing->interface~get_boundarytime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_boundarytime proc~dump_timing dump_timing proc~dump_timing->proc~get_boundaryratio proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_boundaryTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_boundaryTime_byID (bcID) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: bcID Return Value real(kind=rk)","tags":"","loc":"interface/get_boundarytime.html"},{"title":"get_computeTime – Musubi","text":"public interface get_computeTime Calls interface~~get_computetime~~CallsGraph interface~get_computetime get_computeTime proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total tem_getTimerVal tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_computetime~~CalledByGraph interface~get_computetime get_computeTime proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_computetime proc~get_computeratio_atlevel get_computeRatio_atLevel proc~get_computeratio_atlevel->interface~get_computetime proc~get_computeratio_total get_computeRatio_total proc~get_computeratio_total->interface~get_computetime proc~get_computetime_total->interface~get_computetime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_computetime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->interface~get_computetime proc~dump_timing dump_timing proc~mus_perf_measure->proc~dump_timing interface~get_computeratio get_computeRatio interface~get_computeratio->proc~get_computeratio_atlevel interface~get_computeratio->proc~get_computeratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing->interface~get_computeratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_computeTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_computeTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_computetime.html"},{"title":"get_computeRatio – Musubi","text":"public interface get_computeRatio Calls interface~~get_computeratio~~CallsGraph interface~get_computeratio get_computeRatio proc~get_computeratio_atlevel get_computeRatio_atLevel interface~get_computeratio->proc~get_computeratio_atlevel proc~get_computeratio_total get_computeRatio_total interface~get_computeratio->proc~get_computeratio_total interface~get_computetime get_computeTime proc~get_computeratio_atlevel->interface~get_computetime proc~get_mainlooptime get_mainLoopTime proc~get_computeratio_atlevel->proc~get_mainlooptime proc~get_computeratio_total->interface~get_computetime proc~get_computeratio_total->proc~get_mainlooptime proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_computeratio~~CalledByGraph interface~get_computeratio get_computeRatio proc~dump_timing dump_timing proc~dump_timing->interface~get_computeratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_computeRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_computeRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_computeratio.html"},{"title":"get_auxTime – Musubi","text":"public interface get_auxTime Calls interface~~get_auxtime~~CallsGraph interface~get_auxtime get_auxTime proc~get_auxtime_atlevel get_auxTime_atLevel interface~get_auxtime->proc~get_auxtime_atlevel proc~get_auxtime_total get_auxTime_total interface~get_auxtime->proc~get_auxtime_total tem_getTimerVal tem_getTimerVal proc~get_auxtime_atlevel->tem_getTimerVal proc~get_auxtime_total->interface~get_auxtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_auxtime~~CalledByGraph interface~get_auxtime get_auxTime proc~get_auxtime_total get_auxTime_total interface~get_auxtime->proc~get_auxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_auxtime proc~get_auxtime_total->interface~get_auxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_auxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_auxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_auxtime.html"},{"title":"get_relaxTime – Musubi","text":"public interface get_relaxTime Calls interface~~get_relaxtime~~CallsGraph interface~get_relaxtime get_relaxTime proc~get_relaxtime_atlevel get_relaxTime_atLevel interface~get_relaxtime->proc~get_relaxtime_atlevel proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime->proc~get_relaxtime_total tem_getTimerVal tem_getTimerVal proc~get_relaxtime_atlevel->tem_getTimerVal proc~get_relaxtime_total->interface~get_relaxtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_relaxtime~~CalledByGraph interface~get_relaxtime get_relaxTime proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime->proc~get_relaxtime_total proc~dump_timing dump_timing proc~dump_timing->interface~get_relaxtime proc~get_relaxtime_total->interface~get_relaxtime proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_relaxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_relaxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_relaxtime.html"},{"title":"get_intpFromCoarserTime – Musubi","text":"public interface get_intpFromCoarserTime Calls interface~~get_intpfromcoarsertime~~CallsGraph interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total tem_getTimerVal tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_intpfromcoarsertime~~CalledByGraph interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel proc~get_intpfromcoarserratio_atlevel->interface~get_intpfromcoarsertime proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total proc~get_intpfromcoarserratio_total->interface~get_intpfromcoarsertime proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromcoarsertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromcoarsertime interface~get_intpfromcoarserratio get_intpFromCoarserRatio interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_intpFromCoarserTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_intpfromcoarsertime.html"},{"title":"get_intpFromCoarserRatio – Musubi","text":"public interface get_intpFromCoarserRatio Calls interface~~get_intpfromcoarserratio~~CallsGraph interface~get_intpfromcoarserratio get_intpFromCoarserRatio proc~get_intpfromcoarserratio_atlevel get_intpFromCoarserRatio_atLevel interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_atlevel proc~get_intpfromcoarserratio_total get_intpFromCoarserRatio_total interface~get_intpfromcoarserratio->proc~get_intpfromcoarserratio_total interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intpfromcoarserratio_atlevel->interface~get_intpfromcoarsertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromcoarserratio_atlevel->proc~get_mainlooptime proc~get_intpfromcoarserratio_total->interface~get_intpfromcoarsertime proc~get_intpfromcoarserratio_total->proc~get_mainlooptime proc~get_intpfromcoarsertime_atlevel get_intpFromCoarserTime_atLevel interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_atlevel proc~get_intpfromcoarsertime_total get_intpFromCoarserTime_total interface~get_intpfromcoarsertime->proc~get_intpfromcoarsertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromcoarsertime_atlevel->tem_getTimerVal proc~get_intpfromcoarsertime_total->interface~get_intpfromcoarsertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_intpFromCoarserRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_intpfromcoarserratio.html"},{"title":"get_intpFromFinerTime – Musubi","text":"public interface get_intpFromFinerTime Calls interface~~get_intpfromfinertime~~CallsGraph interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_intpfromfinertime~~CalledByGraph interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel proc~get_intpfromfinerratio_atlevel->interface~get_intpfromfinertime proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total proc~get_intpfromfinerratio_total->interface~get_intpfromfinertime proc~get_intptime get_intpTime proc~get_intptime->interface~get_intpfromfinertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_intpfromfinertime interface~get_intpfromfinerratio get_intpFromFinerRatio interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total proc~get_intpratio get_intpRatio proc~get_intpratio->proc~get_intptime proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->proc~get_intpratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_intpFromFinerTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_intpfromfinertime.html"},{"title":"get_intpFromFinerRatio – Musubi","text":"public interface get_intpFromFinerRatio Calls interface~~get_intpfromfinerratio~~CallsGraph interface~get_intpfromfinerratio get_intpFromFinerRatio proc~get_intpfromfinerratio_atlevel get_intpFromFinerRatio_atLevel interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_atlevel proc~get_intpfromfinerratio_total get_intpFromFinerRatio_total interface~get_intpfromfinerratio->proc~get_intpfromfinerratio_total interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intpfromfinerratio_atlevel->interface~get_intpfromfinertime proc~get_mainlooptime get_mainLoopTime proc~get_intpfromfinerratio_atlevel->proc~get_mainlooptime proc~get_intpfromfinerratio_total->interface~get_intpfromfinertime proc~get_intpfromfinerratio_total->proc~get_mainlooptime proc~get_intpfromfinertime_atlevel get_intpFromFinerTime_atLevel interface~get_intpfromfinertime->proc~get_intpfromfinertime_atlevel proc~get_intpfromfinertime_total get_intpFromFinerTime_total interface~get_intpfromfinertime->proc~get_intpfromfinertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_intpfromfinertime_atlevel->tem_getTimerVal proc~get_intpfromfinertime_total->tem_getTimerVal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_intpFromFinerRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_intpfromfinerratio.html"},{"title":"get_bcBufferTime – Musubi","text":"public interface get_bcBufferTime Calls interface~~get_bcbuffertime~~CallsGraph interface~get_bcbuffertime get_bcBufferTime proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total tem_getTimerVal tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_bcbuffertime~~CalledByGraph interface~get_bcbuffertime get_bcBufferTime proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~dump_bc_timing dump_bc_timing proc~dump_bc_timing->interface~get_bcbuffertime proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_bcbufferratio_total get_bcBufferRatio_total proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~get_bcbuffertime_total->interface~get_bcbuffertime proc~mus_getweights mus_getWeights proc~mus_getweights->interface~get_bcbuffertime interface~get_bcbufferratio get_bcBufferRatio interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~mus_balance mus_balance proc~mus_balance->proc~mus_getweights proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_balance proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_bcBufferTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_bcBufferTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_bcbuffertime.html"},{"title":"get_bcBufferRatio – Musubi","text":"public interface get_bcBufferRatio Calls interface~~get_bcbufferratio~~CallsGraph interface~get_bcbufferratio get_bcBufferRatio proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel proc~get_bcbufferratio_total get_bcBufferRatio_total interface~get_bcbufferratio->proc~get_bcbufferratio_total interface~get_bcbuffertime get_bcBufferTime proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_mainlooptime get_mainLoopTime proc~get_bcbufferratio_atlevel->proc~get_mainlooptime proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~get_bcbufferratio_total->proc~get_mainlooptime proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total tem_getTimerVal tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~get_bcbufferratio~~CalledByGraph interface~get_bcbufferratio get_bcBufferRatio proc~dump_timing dump_timing proc~dump_timing->interface~get_bcbufferratio proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function get_bcBufferRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_bcBufferRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk)","tags":"","loc":"interface/get_bcbufferratio.html"},{"title":"mus_load_config – Musubi","text":"public  subroutine mus_load_config(scheme, solverData, geometry, params, adapt) Read in LUA parameter file\nSee http://www.lua.org for a reference on how to use\nLua is a scripting language in itself which allows\nmore complex parameter files including comments\nAnd load / create the mesh depending on the configuration Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(out), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters type( tem_adapt_type ), intent(inout) :: adapt mesh adaptation Calls proc~~mus_load_config~~CallsGraph proc~mus_load_config mus_load_config conf conf proc~mus_load_config->conf proc~dump_linear_partition dump_linear_partition proc~mus_load_config->proc~dump_linear_partition proc~mus_init_latticeunit mus_init_latticeUnit proc~mus_load_config->proc~mus_init_latticeunit proc~mus_load_geom mus_load_geom proc~mus_load_config->proc~mus_load_geom proc~mus_load_param mus_load_param proc~mus_load_config->proc~mus_load_param proc~mus_load_physics mus_load_physics proc~mus_load_config->proc~mus_load_physics proc~mus_load_scheme mus_load_scheme proc~mus_load_config->proc~mus_load_scheme proc~mus_open_config mus_open_config proc~mus_load_config->proc~mus_open_config tem_debug_load_main tem_debug_load_main proc~mus_load_config->tem_debug_load_main tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_config->tem_horizontalSpacer tem_load_adapt tem_load_adapt proc~mus_load_config->tem_load_adapt tem_load_general tem_load_general proc~mus_load_config->tem_load_general tem_logging_load_primary tem_logging_load_primary proc~mus_load_config->tem_logging_load_primary tem_startTimer tem_startTimer proc~mus_load_config->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_load_config->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_config~~CalledByGraph proc~mus_load_config mus_load_config program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_config.html"},{"title":"mus_open_config – Musubi","text":"public  subroutine mus_open_config(conf, filename, proc) This routine loads musubi specific lua function from string and musubi\ninput configuration file Arguments Type Intent Optional Attributes Name type( flu_State ), allocatable :: conf (:) lua state to be stored character(len=*), intent(in) :: filename name of the config file to be opened type( tem_comm_env_type ), intent(in) :: proc process description to use Calls proc~~mus_open_config~~CallsGraph proc~mus_open_config mus_open_config open_config_chunk open_config_chunk proc~mus_open_config->open_config_chunk proc~mus_create_funcstr mus_create_funcStr proc~mus_open_config->proc~mus_create_funcstr tem_open_distconf_array tem_open_distconf_array proc~mus_open_config->tem_open_distconf_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_open_config~~CalledByGraph proc~mus_open_config mus_open_config proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_open_config proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_open_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_open_config.html"},{"title":"check_mrt_matrix_d3q19 – Musubi","text":"public  function check_mrt_matrix_d3q19() result(test) Unoptimized explicit implementation This subroutine interface must match the abstract interface definition kernel in scheme/ mus_scheme_type_module .f90 in order to be callable\nvia compute function pointer. Arguments None Return Value logical","tags":"","loc":"proc/check_mrt_matrix_d3q19.html"},{"title":"check_mrt_matrix_d3q27 – Musubi","text":"public  function check_mrt_matrix_d3q27() result(test) Unoptimized explicit implementation This subroutine interface must match the abstract interface definition kernel in scheme/ mus_scheme_type_module .f90 in order to be callable\nvia compute function pointer. Arguments None Return Value logical","tags":"","loc":"proc/check_mrt_matrix_d3q27.html"},{"title":"mus_assign_turbVisc_ptr – Musubi","text":"public  subroutine mus_assign_turbVisc_ptr(turb, schemeHeader) This routine assigns function pointer to compute turbulence viscosity\nbased on turbulence model and scheme header definition Arguments Type Intent Optional Attributes Name type( mus_turbulence_type ), intent(inout) :: turb turbulence type type( mus_scheme_header_type ), intent(in) :: schemeHeader Scheme header information Calls proc~~mus_assign_turbvisc_ptr~~CallsGraph proc~mus_assign_turbvisc_ptr mus_assign_turbVisc_ptr tem_abort tem_abort proc~mus_assign_turbvisc_ptr->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_assign_turbvisc_ptr~~CalledByGraph proc~mus_assign_turbvisc_ptr mus_assign_turbVisc_ptr proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_assign_turbvisc_ptr proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_assign_turbvisc_ptr.html"},{"title":"mus_turbVisc_fromGradU_dummy – Musubi","text":"private  subroutine mus_turbVisc_fromGradU_dummy(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Dummy function for turbulent viscosity from Gradu procedure Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence config contains oefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL turbulence coefficients\ncurrent level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_turbvisc_fromgradu_dummy~~CallsGraph proc~mus_turbvisc_fromgradu_dummy mus_turbVisc_fromGradU_dummy tem_abort tem_abort proc~mus_turbvisc_fromgradu_dummy->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_fromgradu_dummy.html"},{"title":"mus_turbVisc_fromPreColPDF_dummy – Musubi","text":"private  subroutine mus_turbVisc_fromPreColPDF_dummy(turbVisc, turbConfig, state, neigh, auxField, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine) Dummy function to compute turbulent viscosity from PDF Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence type is implicitly passed to access turbulence coefficients real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL Calls proc~~mus_turbvisc_fromprecolpdf_dummy~~CallsGraph proc~mus_turbvisc_fromprecolpdf_dummy mus_turbVisc_fromPreColPDF_dummy tem_abort tem_abort proc~mus_turbvisc_fromprecolpdf_dummy->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_fromprecolpdf_dummy.html"},{"title":"init_cxDirWeightedAvg – Musubi","text":"private  function init_cxDirWeightedAvg(QQ, nSources) result(me) Initialize stencil for weighted average interpolation Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: nSources Return Value integer, (nSources,8) Calls proc~~init_cxdirweightedavg~~CallsGraph proc~init_cxdirweightedavg init_cxDirWeightedAvg tem_abort tem_abort proc~init_cxdirweightedavg->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~init_cxdirweightedavg~~CalledByGraph proc~init_cxdirweightedavg init_cxDirWeightedAvg proc~mus_set_nsources mus_set_nSources proc~mus_set_nsources->proc~init_cxdirweightedavg proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_set_nsources proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_cxdirweightedavg.html"},{"title":"mus_load_interpolate – Musubi","text":"public  subroutine mus_load_interpolate(me, conf, parent) Read in the type of interpolation scheme interpolation_method = 'linear' -- simple definition interpolation_method = { method = 'debug' , value = 1. } -- definition in a table Arguments Type Intent Optional Attributes Name type( mus_interpolation_config_type ), intent(out) :: me interpolation type to load info to type( flu_State ) :: conf lua state to load from integer, intent(in), optional :: parent optional parent table to load from Calls proc~~mus_load_interpolate~~CallsGraph proc~mus_load_interpolate mus_load_interpolate aot_get_val aot_get_val proc~mus_load_interpolate->aot_get_val aot_table_close aot_table_close proc~mus_load_interpolate->aot_table_close aot_table_length aot_table_length proc~mus_load_interpolate->aot_table_length aot_table_open aot_table_open proc~mus_load_interpolate->aot_table_open proc~interpolate_dump interpolate_dump proc~mus_load_interpolate->proc~interpolate_dump tem_abort tem_abort proc~mus_load_interpolate->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~interpolate_dump->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_interpolate~~CalledByGraph proc~mus_load_interpolate mus_load_interpolate proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_interpolate proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_interpolate.html"},{"title":"mus_set_nSources – Musubi","text":"public  subroutine mus_set_nSources(me, nDims, QQ, layout) Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: me integer, intent(in) :: nDims integer, intent(in) :: QQ character(len=*), intent(in) :: layout Calls proc~~mus_set_nsources~~CallsGraph proc~mus_set_nsources mus_set_nSources init init proc~mus_set_nsources->init proc~init_cxdirweightedavg init_cxDirWeightedAvg proc~mus_set_nsources->proc~init_cxdirweightedavg tem_abort tem_abort proc~mus_set_nsources->tem_abort proc~init_cxdirweightedavg->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_set_nsources~~CalledByGraph proc~mus_set_nsources mus_set_nSources proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_set_nsources proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_nsources.html"},{"title":"mus_interpolate_out – Musubi","text":"public  subroutine mus_interpolate_out(me, conf) Dump interpolation method to lua Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(in) :: me interpolation type to dump info to type( aot_out_type ), intent(inout), optional :: conf aotus type handling the output to the file in lua format Calls proc~~mus_interpolate_out~~CallsGraph proc~mus_interpolate_out mus_interpolate_out aot_out_val aot_out_val proc~mus_interpolate_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_interpolate_out~~CalledByGraph proc~mus_interpolate_out mus_interpolate_out proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->proc~mus_interpolate_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_interpolate_out.html"},{"title":"interpolate_dump – Musubi","text":"private  subroutine interpolate_dump(me, outUnit) Dump interpolation method to logUnit Arguments Type Intent Optional Attributes Name type( mus_interpolation_config_type ), intent(in) :: me interpolation type to dump info to integer, intent(in) :: outUnit File unit to write to Calls proc~~interpolate_dump~~CallsGraph proc~interpolate_dump interpolate_dump tem_horizontalSpacer tem_horizontalSpacer proc~interpolate_dump->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~interpolate_dump~~CalledByGraph proc~interpolate_dump interpolate_dump proc~mus_load_interpolate mus_load_interpolate proc~mus_load_interpolate->proc~interpolate_dump proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_interpolate proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/interpolate_dump.html"},{"title":"mus_init_advRel_lbm_ps – Musubi","text":"public  subroutine mus_init_advRel_lbm_ps(relaxation, layout, relaxation_variant, compute) Initialize the relaxation model for lbm passive scalar scheme kind Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout character(len=labelLen), intent(in) :: relaxation_variant procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_lbm_ps~~CallsGraph proc~mus_init_advrel_lbm_ps mus_init_advRel_lbm_ps tem_abort tem_abort proc~mus_init_advrel_lbm_ps->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_lbm_ps.html"},{"title":"mus_turbVisc_Vreman_3D – Musubi","text":"public  subroutine mus_turbVisc_Vreman_3D(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with Vreman model for 3D stencil\nFortran implementation of this model:\nhttp://www.vremanresearch.nl/Vreman_Subgridmodel_Fortran.txt with , - Smagorinsky constant, , , . - Resolved velocity gradient. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_turbvisc_vreman_3d~~CallsGraph proc~mus_turbvisc_vreman_3d mus_turbVisc_Vreman_3D u_ptr u_ptr proc~mus_turbvisc_vreman_3d->u_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_vreman_3d.html"},{"title":"mus_turbVisc_Vreman_2D – Musubi","text":"public  subroutine mus_turbVisc_Vreman_2D(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with Vreman model for 2D stencil\nmodel\n\\todo add reference and formula Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_turbvisc_vreman_2d~~CallsGraph proc~mus_turbvisc_vreman_2d mus_turbVisc_Vreman_2D u_ptr u_ptr proc~mus_turbvisc_vreman_2d->u_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_turbvisc_vreman_2d.html"},{"title":"set_values_by_levels – Musubi","text":"public pure function set_values_by_levels(valMinLevel, minLevel, maxLevel, scaleFac) result(values) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: valMinLevel integer, intent(in) :: minLevel integer, intent(in) :: maxLevel integer, intent(in) :: scaleFac Return Value real(kind=rk), (minLevel:maxLevel) Called by proc~~set_values_by_levels~~CalledByGraph proc~set_values_by_levels set_values_by_levels proc~mus_init_latticeunit mus_init_latticeUnit proc~mus_init_latticeunit->proc~set_values_by_levels proc~mus_load_physics mus_load_physics proc~mus_load_physics->proc~set_values_by_levels proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_init_latticeunit proc~mus_load_config->proc~mus_load_physics proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/set_values_by_levels.html"},{"title":"mus_load_physics – Musubi","text":"public  subroutine mus_load_physics(me, conf, tree, scaleFactor, dtRef, dxRef) This routine loads the physics table from musubi config file If no physics table is provided, the conversion factors default to\n1, resulting in the lattice units being directly used.\ndx_ref and dt_ref are set according to the provided arguments, or if\nnot provided default to 1.\nSee the [mus_physics_type] for a description of the various factors that\ncan be set here. Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(out) :: me physics type type( flu_State ) :: conf flu state type( treelmesh_type ), intent(in) :: tree global treelm mesh integer, intent(in) :: scaleFactor scaling factor: diffusive -> 4; acoustic -> 2 real(kind=rk), intent(in), optional :: dtRef reference time step if none real(kind=rk), intent(in), optional :: dxRef reference spacestep if none Calls proc~~mus_load_physics~~CallsGraph proc~mus_load_physics mus_load_physics aot_get_val aot_get_val proc~mus_load_physics->aot_get_val aot_table_close aot_table_close proc~mus_load_physics->aot_table_close aot_table_open aot_table_open proc~mus_load_physics->aot_table_open proc~mus_physics_dump2outunit mus_physics_dump2outUnit proc~mus_load_physics->proc~mus_physics_dump2outunit proc~mus_set_convfac mus_set_convFac proc~mus_load_physics->proc~mus_set_convfac proc~mus_set_scalefac mus_set_scaleFac proc~mus_load_physics->proc~mus_set_scalefac proc~set_values_by_levels set_values_by_levels proc~mus_load_physics->proc~set_values_by_levels tem_ElemSizeLevel tem_ElemSizeLevel proc~mus_load_physics->tem_ElemSizeLevel tem_abort tem_abort proc~mus_load_physics->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_physics->tem_horizontalSpacer tem_toStr tem_toStr proc~mus_physics_dump2outunit->tem_toStr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_physics~~CalledByGraph proc~mus_load_physics mus_load_physics proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_physics proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_physics.html"},{"title":"mus_set_convFac – Musubi","text":"public  subroutine mus_set_convFac(me, minLevel, maxLevel) This routine computed conversion factors for lattice to physical units.\ninverse of this factors can be used to convert from physical to lattice\nunits.\\n\nuse reference density to parmeterize kg and reference mole density\nto parmeterize mol.\\n\nMultiply these factors with the LB quantity to get the physical quantity\nDivide the physical quantity by these factors to get the LB units. Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(inout) :: me integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Called by proc~~mus_set_convfac~~CalledByGraph proc~mus_set_convfac mus_set_convFac proc~mus_load_physics mus_load_physics proc~mus_load_physics->proc~mus_set_convfac proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_physics proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_convfac.html"},{"title":"mus_create_funcStr – Musubi","text":"public  subroutine mus_create_funcStr(fun_str) This routine creates musubi specific lua function to compute dx and dt. Arguments Type Intent Optional Attributes Name character(len=*) :: fun_str This string contains lua functions to compute dt from visocosity or\nvelocity Called by proc~~mus_create_funcstr~~CalledByGraph proc~mus_create_funcstr mus_create_funcStr proc~mus_open_config mus_open_config proc~mus_open_config->proc~mus_create_funcstr proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_open_config proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_open_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_create_funcstr.html"},{"title":"mus_physics_out – Musubi","text":"public  subroutine mus_physics_out(me, conf) This routine write reference physics parameters into solver specific\nstring in lua format. This dumped table is loaded back using mus_load_physics Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me type( aot_out_type ) :: conf Calls proc~~mus_physics_out~~CallsGraph proc~mus_physics_out mus_physics_out aot_out_close_table aot_out_close_table proc~mus_physics_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_physics_out->aot_out_open_table aot_out_val aot_out_val proc~mus_physics_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_physics_out~~CalledByGraph proc~mus_physics_out mus_physics_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_physics_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_physics_out.html"},{"title":"mus_physics_out_conv – Musubi","text":"public  subroutine mus_physics_out_conv(me, conf, minLevel, maxLevel) This routine write physics convert factor into solver specific string in\nlua format.\nuse reference density to parmeterize kg and reference mole density\nto parmeterize mol. Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me type( aot_out_type ) :: conf integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Calls proc~~mus_physics_out_conv~~CallsGraph proc~mus_physics_out_conv mus_physics_out_conv aot_out_close_table aot_out_close_table proc~mus_physics_out_conv->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_physics_out_conv->aot_out_open_table aot_out_val aot_out_val proc~mus_physics_out_conv->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_physics_out_conv.html"},{"title":"mus_physics_dump2outUnit – Musubi","text":"public  subroutine mus_physics_dump2outUnit(me, outUnit, minLevel, maxLevel) Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me integer, intent(in) :: outUnit integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Calls proc~~mus_physics_dump2outunit~~CallsGraph proc~mus_physics_dump2outunit mus_physics_dump2outUnit tem_toStr tem_toStr proc~mus_physics_dump2outunit->tem_toStr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_physics_dump2outunit~~CalledByGraph proc~mus_physics_dump2outunit mus_physics_dump2outUnit proc~mus_load_physics mus_load_physics proc~mus_load_physics->proc~mus_physics_dump2outunit proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_physics proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_physics_dump2outunit.html"},{"title":"mus_set_scaleFac – Musubi","text":"public  subroutine mus_set_scaleFac(me, minLevel, maxLevel) Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(inout) :: me integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Called by proc~~mus_set_scalefac~~CalledByGraph proc~mus_set_scalefac mus_set_scaleFac proc~mus_load_physics mus_load_physics proc~mus_load_physics->proc~mus_set_scalefac proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_physics proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_physics proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_scalefac.html"},{"title":"mus_geomIncrHead_load – Musubi","text":"public  subroutine mus_geomIncrHead_load(me, conf, parent, dynamicGeom) Read all the necessary information for the geometry increase from the lua\n config file. This routine basically provides as a wrapper to the routine\n which reads single values Example to geomIncr table: variable = { { name = 'vel_threshold' , ncomponents = 1 , var_type = st_fun , st_fun = 0.01 }, { name = 'incr_condition' , ncomponents = 1 , var_type = 'operation' , operation = { kind = '<' , input_varname = { 'vel_mag' , 'vel_threshold' } } }, } geomIncr = { condition = 'incr_condition' } Arguments Type Intent Optional Attributes Name type( mus_geomIncrHead_type ), intent(inout), allocatable :: me (:) type( flu_State ) :: conf integer, intent(in), optional :: parent logical, intent(inout) :: dynamicGeom Calls proc~~mus_geomincrhead_load~~CallsGraph proc~mus_geomincrhead_load mus_geomIncrHead_load aot_table_close aot_table_close proc~mus_geomincrhead_load->aot_table_close aot_table_length aot_table_length proc~mus_geomincrhead_load->aot_table_length aot_table_open aot_table_open proc~mus_geomincrhead_load->aot_table_open proc~mus_geomincrhead_load_single mus_geomIncrHead_load_single proc~mus_geomincrhead_load->proc~mus_geomincrhead_load_single aot_get_val aot_get_val proc~mus_geomincrhead_load_single->aot_get_val tem_horizontalSpacer tem_horizontalSpacer proc~mus_geomincrhead_load_single->tem_horizontalSpacer tem_timeControl_load tem_timeControl_load proc~mus_geomincrhead_load_single->tem_timeControl_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_geomincrhead_load~~CalledByGraph proc~mus_geomincrhead_load mus_geomIncrHead_load proc~mus_load_geom mus_load_geom proc~mus_load_geom->proc~mus_geomincrhead_load proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_geomincrhead_load.html"},{"title":"mus_geomIncrHead_load_single – Musubi","text":"private  subroutine mus_geomIncrHead_load_single(me, conf, thandle) Reads various parameters from the lua file defined for geometry increase\nThis routine reads single values and is wrapped around in another function\nwhere it is called multiple times as required Arguments Type Intent Optional Attributes Name type( mus_geomIncrHead_type ), intent(inout) :: me type( flu_State ), intent(in) :: conf integer, intent(in) :: thandle Calls proc~~mus_geomincrhead_load_single~~CallsGraph proc~mus_geomincrhead_load_single mus_geomIncrHead_load_single aot_get_val aot_get_val proc~mus_geomincrhead_load_single->aot_get_val tem_horizontalSpacer tem_horizontalSpacer proc~mus_geomincrhead_load_single->tem_horizontalSpacer tem_timeControl_load tem_timeControl_load proc~mus_geomincrhead_load_single->tem_timeControl_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_geomincrhead_load_single~~CalledByGraph proc~mus_geomincrhead_load_single mus_geomIncrHead_load_single proc~mus_geomincrhead_load mus_geomIncrHead_load proc~mus_geomincrhead_load->proc~mus_geomincrhead_load_single proc~mus_load_geom mus_load_geom proc~mus_load_geom->proc~mus_geomincrhead_load proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_geom program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_geomincrhead_load_single.html"},{"title":"get_uPlus_interface – Musubi","text":"interface public pure function get_uPlus_interface(yPlus) result(uPlus) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) Description function interface to get u_Plus","tags":"","loc":"interface/get_uplus_interface.html"},{"title":"get_d_uPlus_d_uTau_interface – Musubi","text":"interface public pure function get_d_uPlus_d_uTau_interface(y, uTau, nu) result(d_uPlus_d_uTau) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk) Description function interface to get the derivative of uPlus with respect to uTau","tags":"","loc":"interface/get_d_uplus_d_utau_interface.html"},{"title":"mus_calcOmegaFromVisc – Musubi","text":"public elemental function mus_calcOmegaFromVisc(visc) result(omega) This function compute relaxation paramter omega from viscosity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc scaled lattice viscosity i.e vL_c/dtL Return Value real(kind=rk) lattice time step size in current level\nreal(kind=rk), intent(in) :: dtL\n output: relaxation parameter omega Called by proc~~mus_calcomegafromvisc~~CalledByGraph proc~mus_calcomegafromvisc mus_calcOmegaFromVisc proc~mus_fluid_dump mus_fluid_dump proc~mus_fluid_dump->proc~mus_calcomegafromvisc proc~mus_update_relaxparamfromviscstfun mus_update_relaxParamFromViscSTfun proc~mus_update_relaxparamfromviscstfun->proc~mus_calcomegafromvisc proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_fluid_dump proc~mus_init_fluid->proc~mus_update_relaxparamfromviscstfun proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_calcomegafromvisc.html"},{"title":"mus_init_relaxParam – Musubi","text":"public  subroutine mus_init_relaxParam(omLvl, minLevel, maxLevel, nElems) This routine initialize relaxation parameter Arguments Type Intent Optional Attributes Name type( mus_relaxationParam_type ), intent(out), allocatable :: omLvl (:) relaxation paramter integer, intent(in) :: minLevel minlevel and maxLevel integer, intent(in) :: maxLevel minlevel and maxLevel integer, intent(in) :: nElems (minLevel:maxLevel) number of local elements per level Called by proc~~mus_init_relaxparam~~CalledByGraph proc~mus_init_relaxparam mus_init_relaxParam proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_init_relaxparam proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_relaxparam.html"},{"title":"mus_update_viscKine – Musubi","text":"public  subroutine mus_update_viscKine(viscKine, state, neigh, auxField, gradData, layout, baryOfTotal, tNow, nSize, nFluids, nGhostFromCoarser, nGhostFromFiner, nHalo, varSys, iLevel, convFac, dxL, dtL, derVarPos, turb, nNwtn, Grad) Update kinematic viscosity from STfun and calculate turbulent viscosity\nfrom velocity gradient or nonEqPDF\nViscosity obtained from this routine are normalized to the level calculate turbulence viscosity for nFluids and ghostFromCoarser,\nfor ghostFromFiner elements, turb visc is interpolated Arguments Type Intent Optional Attributes Name type( mus_viscosity_type ), intent(inout) :: viscKine Kinematic viscosity real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neighbor connectivity array real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array type(mus_gradData_type), intent(in) :: gradData gradient data type( mus_scheme_layout_type ), intent(in) :: layout stencil layout real(kind=rk), intent(in) :: baryOfTotal (:,:) bary of treeID in total list type( tem_time_type ), intent(in) :: tNow current simulation time integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nFluids number of fluid elements in state array integer, intent(in) :: nGhostFromCoarser Number of ghostFromCoarser element in state array integer, intent(in) :: nGhostFromFiner Number of ghostFromFiner element in state array integer, intent(in) :: nHalo Number of halo element in state array type( tem_varSys_type ), intent(in) :: varSys variable system integer, intent(in) :: iLevel current level type( mus_convertFac_type ), intent(in) :: convFac reference physical conversion factors for current level real(kind=rk), intent(in) :: dxL lattice element size in current level real(kind=rk), intent(in) :: dtL lattice time step size in current level type( mus_derVarPos_type ), intent(in) :: derVarPos contains position of in varSys type( mus_turbulence_type ), intent(inout) :: turb turbulence type type(mus_nNwtn_type), intent(in) :: nNwtn non-Newtonian type type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients Calls proc~~mus_update_visckine~~CallsGraph proc~mus_update_visckine mus_update_viscKine auxfield_varpos auxfield_varpos proc~mus_update_visckine->auxfield_varpos calcvisc calcvisc proc~mus_update_visckine->calcvisc proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine->proc~mus_turb_calcvisc tem_spacetime_for tem_spacetime_for proc~mus_update_visckine->tem_spacetime_for val val proc~mus_update_visckine->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_update_visckine~~CalledByGraph proc~mus_update_visckine mus_update_viscKine proc~mus_update_relaxparams mus_update_relaxParams proc~mus_update_relaxparams->proc~mus_update_visckine proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_update_visckine.html"},{"title":"mus_update_relaxParamKine – Musubi","text":"public  subroutine mus_update_relaxParamKine(viscKine, turb, nSolve, iLevel) Update kinematic relaxation parameter from viscosity and check omega Arguments Type Intent Optional Attributes Name type( mus_viscosity_type ), intent(inout) :: viscKine Kinematic viscosity type( mus_turbulence_type ), intent(in) :: turb turbulence type integer, intent(in) :: nSolve Number of elements to solve in compute kernel integer, intent(in) :: iLevel current level Calls proc~~mus_update_relaxparamkine~~CallsGraph proc~mus_update_relaxparamkine mus_update_relaxParamKine val val proc~mus_update_relaxparamkine->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_update_relaxparamkine~~CalledByGraph proc~mus_update_relaxparamkine mus_update_relaxParamKine proc~mus_update_relaxparams mus_update_relaxParams proc~mus_update_relaxparams->proc~mus_update_relaxparamkine proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_update_relaxparamkine.html"},{"title":"mus_update_relaxParamFromViscSTfun – Musubi","text":"public  subroutine mus_update_relaxParamFromViscSTfun(omega, visc, viscSTfun, nElems, baryOfTotal, tNow, viscRef) This routine is used to initialize relaxation paramter and update\nbulk viscosity at every time step\nBulk visocisty is defined as space-time function to apply\nramping and spatial sponge in bulk viscosity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: omega (:) relaxation parameter real(kind=rk), intent(inout) :: visc (:) Kinematic viscosity type( tem_spacetime_fun_type ), intent(in) :: viscSTfun viscosity space-time function integer, intent(in) :: nElems Number of local elements including halos real(kind=rk), intent(in) :: baryOfTotal (:,:) baryID of total list type( tem_time_type ), intent(in) :: tNow current simulation time real(kind=rk), intent(in) :: viscRef reference physical viscosity on current level i.e. (dxP_l)&#94;2/dtP_l\nDividing physical viscosity with the viscRef gives vL_l/dtL_l Calls proc~~mus_update_relaxparamfromviscstfun~~CallsGraph proc~mus_update_relaxparamfromviscstfun mus_update_relaxParamFromViscSTfun proc~mus_calcomegafromvisc mus_calcOmegaFromVisc proc~mus_update_relaxparamfromviscstfun->proc~mus_calcomegafromvisc tem_spacetime_for tem_spacetime_for proc~mus_update_relaxparamfromviscstfun->tem_spacetime_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_update_relaxparamfromviscstfun~~CalledByGraph proc~mus_update_relaxparamfromviscstfun mus_update_relaxParamFromViscSTfun proc~mus_init_fluid mus_init_fluid proc~mus_init_fluid->proc~mus_update_relaxparamfromviscstfun proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_fluid proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_fluid proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_update_relaxparamfromviscstfun.html"},{"title":"mus_check_omegaKine – Musubi","text":"public  subroutine mus_check_omegaKine(schemeRelax, omLvlKine, nSolve, minLevel, maxLevel, general) This routine checks whether omega is within the stability limit.\nIf not it will terminate the simulation with error message.\nUsing limits given in\nTölke, J., Freudiger, S., & Krafczyk, M. (2006). An adaptive scheme using\nhierarchical grids for lattice Boltzmann multi-phase flow simulations.\nComputers & Fluids, 35(8–9), 820–830.\nFor BGK: 2/3 < omega < 1.976\nFor MRT: 2/3 < omega < 1.999 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: schemeRelax scheme relaxation type type( mus_relaxationParam_type ), intent(in) :: omLvlKine (minLevel:maxLevel) array of kinematic relaxation parameter on all levels integer, intent(in) :: nSolve (minLevel:maxLevel) Number of elements to solve in compute kernel integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel type( tem_general_type ), intent(inout) :: general Contains proc, simControl, solveHead Calls proc~~mus_check_omegakine~~CallsGraph proc~mus_check_omegakine mus_check_omegaKine bits bits proc~mus_check_omegakine->bits mpi_reduce mpi_reduce proc~mus_check_omegakine->mpi_reduce tem_abort tem_abort proc~mus_check_omegakine->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_check_omegakine~~CalledByGraph proc~mus_check_omegakine mus_check_omegaKine proc~perform_checks perform_checks proc~perform_checks->proc~mus_check_omegakine proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_check_omegakine.html"},{"title":"mus_init_control – Musubi","text":"public  subroutine mus_init_control(controlRoutine, me, minLevel, maxLevel) This routines sets the function pointer to main control routine control routine is chosen based on the type of simulation.\nlike single level, multi-level because multilevel requires\nrecursive routine in the lua file you can now select control_routine = '...' where possible values are currently benchmark : strongly reduced control routine with only single level,\n               no sources, etc.\nmainly for benchmarking multiLevel : full multilevel, multiLevel routine if nothing is given, the full multilevel, multiLevel routine is chosen Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: controlRoutine type( mus_control_type ), intent(out) :: me contains function pointer to point control routine integer, intent(in) :: minLevel integer, intent(in) :: maxLevel","tags":"","loc":"proc/mus_init_control.html"},{"title":"do_recursive_multiLevel – Musubi","text":"private recursive subroutine do_recursive_multiLevel(me, scheme, geometry, params, iLevel) Main control routine: Update the time step for all levels.\nMain steps:\n  * if iLevel < maxLevel do recursive at iLevel+1\n  * do BC at iLevel\n  * do auxField calculation at iLevel\n  * do compute kernel at iLevel\n  * do apply source at iLevel\n  * do do_IntpFinerAndExchange at iLevel if iLevel < maxLevel\n    * intp My Coarser ghost (iLevel) from Finer (iLevel+1)\n    * do exchange bufferFromFiner at iLevel\n  * exchange buffer at iLevel\n  * exchange bufferFromCoarser at iLevel if iLevel > minLevel\n  * do do_intpCoarserAndExchange at iLevel if iLevel < maxLevel\n    * intp Finer Ghost (iLevel+1) from my coarser (iLevel)\n    * exchange bufferFromCoarser at iLevel+1 Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel the current level Calls proc~~do_recursive_multilevel~~CallsGraph proc~do_recursive_multilevel do_recursive_multiLevel exchange_real exchange_real proc~do_recursive_multilevel->exchange_real proc~do_intpcoarserandexchange do_intpCoarserAndExchange proc~do_recursive_multilevel->proc~do_intpcoarserandexchange proc~do_intpfinerandexchange do_intpFinerAndExchange proc~do_recursive_multilevel->proc~do_intpfinerandexchange proc~mus_apply_sourceterms mus_apply_sourceTerms proc~do_recursive_multilevel->proc~mus_apply_sourceterms proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange proc~do_recursive_multilevel->proc~mus_calcauxfieldandexchange proc~mus_intpauxfieldcoarserandexchange mus_intpAuxFieldCoarserAndExchange proc~do_recursive_multilevel->proc~mus_intpauxfieldcoarserandexchange proc~mus_swap_now_next mus_swap_Now_Next proc~do_recursive_multilevel->proc~mus_swap_now_next proc~mus_update_relaxparams mus_update_relaxParams proc~do_recursive_multilevel->proc~mus_update_relaxparams proc~mus_update_sourcevars mus_update_sourceVars proc~do_recursive_multilevel->proc~mus_update_sourcevars proc~start_stagetimer start_stageTimer proc~do_recursive_multilevel->proc~start_stagetimer proc~stop_stagetimer stop_stageTimer proc~do_recursive_multilevel->proc~stop_stagetimer set_boundary set_boundary proc~do_recursive_multilevel->set_boundary tem_startTimer tem_startTimer proc~do_recursive_multilevel->tem_startTimer tem_stopTimer tem_stopTimer proc~do_recursive_multilevel->tem_stopTimer tem_time_advance tem_time_advance proc~do_recursive_multilevel->tem_time_advance proc~do_intpcoarserandexchange->exchange_real proc~do_intpcoarserandexchange->proc~start_stagetimer proc~do_intpcoarserandexchange->proc~stop_stagetimer proc~do_intpcoarserandexchange->tem_startTimer proc~do_intpcoarserandexchange->tem_stopTimer proc~do_intpfinerandexchange->exchange_real proc~do_intpfinerandexchange->proc~start_stagetimer proc~do_intpfinerandexchange->proc~stop_stagetimer proc~do_intpfinerandexchange->tem_startTimer proc~do_intpfinerandexchange->tem_stopTimer proc~mus_apply_sourceterms->tem_startTimer proc~mus_apply_sourceterms->tem_stopTimer proc~mus_calcauxfieldandexchange->exchange_real proc~mus_intpauxfieldcoarserandexchange->exchange_real nelems nelems proc~mus_update_relaxparams->nelems proc~mus_turb_updateviscofturbwall mus_turb_updateViscOfTurbWall proc~mus_update_relaxparams->proc~mus_turb_updateviscofturbwall proc~mus_update_relaxparamkine mus_update_relaxParamKine proc~mus_update_relaxparams->proc~mus_update_relaxparamkine proc~mus_update_visckine mus_update_viscKine proc~mus_update_relaxparams->proc~mus_update_visckine proc~setparameters_multispecies setParameters_multispecies proc~mus_update_relaxparams->proc~setparameters_multispecies tvisc tvisc proc~mus_update_relaxparams->tvisc proc~mus_update_sourcevars->tem_startTimer proc~mus_update_sourcevars->tem_stopTimer proc~start_stagetimer->tem_startTimer proc~stop_stagetimer->tem_stopTimer val val proc~mus_update_relaxparamkine->val auxfield_varpos auxfield_varpos proc~mus_update_visckine->auxfield_varpos calcvisc calcvisc proc~mus_update_visckine->calcvisc proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine->proc~mus_turb_calcvisc tem_spacetime_for tem_spacetime_for proc~mus_update_visckine->tem_spacetime_for proc~mus_update_visckine->val invert_matrix invert_matrix proc~setparameters_multispecies->invert_matrix tem_temporal_for tem_temporal_for proc~setparameters_multispecies->tem_temporal_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_recursive_multilevel.html"},{"title":"do_intpFinerAndExchange – Musubi","text":"private  subroutine do_intpFinerAndExchange(scheme, params, iLevel) This routine does:\n1. interpolate my coarse ghost element (iLevel) from finer level (iLevel+1)\n2. exchange the data of my coarse ghost elements between process Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Calls proc~~do_intpfinerandexchange~~CallsGraph proc~do_intpfinerandexchange do_intpFinerAndExchange exchange_real exchange_real proc~do_intpfinerandexchange->exchange_real proc~start_stagetimer start_stageTimer proc~do_intpfinerandexchange->proc~start_stagetimer proc~stop_stagetimer stop_stageTimer proc~do_intpfinerandexchange->proc~stop_stagetimer tem_startTimer tem_startTimer proc~do_intpfinerandexchange->tem_startTimer tem_stopTimer tem_stopTimer proc~do_intpfinerandexchange->tem_stopTimer proc~start_stagetimer->tem_startTimer proc~stop_stagetimer->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~do_intpfinerandexchange~~CalledByGraph proc~do_intpfinerandexchange do_intpFinerAndExchange proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~do_intpfinerandexchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_intpfinerandexchange.html"},{"title":"do_intpCoarserAndExchange – Musubi","text":"private  subroutine do_intpCoarserAndExchange(scheme, params, iLevel) This routine utilizes fluid elements on my level (L) to fill finer\nghost elements on next level (L+1).\nThen it exchanges the datas of finer ghost elements (L+1) between process. Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_param_type ), intent(in) :: params global parameters integer, intent(in) :: iLevel Level counter variable Calls proc~~do_intpcoarserandexchange~~CallsGraph proc~do_intpcoarserandexchange do_intpCoarserAndExchange exchange_real exchange_real proc~do_intpcoarserandexchange->exchange_real proc~start_stagetimer start_stageTimer proc~do_intpcoarserandexchange->proc~start_stagetimer proc~stop_stagetimer stop_stageTimer proc~do_intpcoarserandexchange->proc~stop_stagetimer tem_startTimer tem_startTimer proc~do_intpcoarserandexchange->tem_startTimer tem_stopTimer tem_stopTimer proc~do_intpcoarserandexchange->tem_stopTimer proc~start_stagetimer->tem_startTimer proc~stop_stagetimer->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~do_intpcoarserandexchange~~CalledByGraph proc~do_intpcoarserandexchange do_intpCoarserAndExchange proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~do_intpcoarserandexchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_intpcoarserandexchange.html"},{"title":"do_fast_singleLevel – Musubi","text":"private  subroutine do_fast_singleLevel(me, scheme, geometry, params, iLevel) Control routine for an optimized workflow with reduced functionality. No sources, no multilevel, no multiLevel.\nUse for benchmarking Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type\ndummy variable in this routine, required by interface type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable Calls proc~~do_fast_singlelevel~~CallsGraph proc~do_fast_singlelevel do_fast_singleLevel exchange_real exchange_real proc~do_fast_singlelevel->exchange_real mus_buildbuffibm mus_buildbuffibm proc~do_fast_singlelevel->mus_buildbuffibm mus_inamuro_ibm mus_inamuro_ibm proc~do_fast_singlelevel->mus_inamuro_ibm proc~mus_apply_sourceterms mus_apply_sourceTerms proc~do_fast_singlelevel->proc~mus_apply_sourceterms proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange proc~do_fast_singlelevel->proc~mus_calcauxfieldandexchange proc~mus_swap_now_next mus_swap_Now_Next proc~do_fast_singlelevel->proc~mus_swap_now_next proc~mus_update_relaxparams mus_update_relaxParams proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~mus_update_sourcevars mus_update_sourceVars proc~do_fast_singlelevel->proc~mus_update_sourcevars set_boundary set_boundary proc~do_fast_singlelevel->set_boundary tem_startTimer tem_startTimer proc~do_fast_singlelevel->tem_startTimer tem_stopTimer tem_stopTimer proc~do_fast_singlelevel->tem_stopTimer tem_time_advance tem_time_advance proc~do_fast_singlelevel->tem_time_advance proc~mus_apply_sourceterms->tem_startTimer proc~mus_apply_sourceterms->tem_stopTimer proc~mus_calcauxfieldandexchange->exchange_real nelems nelems proc~mus_update_relaxparams->nelems proc~mus_turb_updateviscofturbwall mus_turb_updateViscOfTurbWall proc~mus_update_relaxparams->proc~mus_turb_updateviscofturbwall proc~mus_update_relaxparamkine mus_update_relaxParamKine proc~mus_update_relaxparams->proc~mus_update_relaxparamkine proc~mus_update_visckine mus_update_viscKine proc~mus_update_relaxparams->proc~mus_update_visckine proc~setparameters_multispecies setParameters_multispecies proc~mus_update_relaxparams->proc~setparameters_multispecies tvisc tvisc proc~mus_update_relaxparams->tvisc proc~mus_update_sourcevars->tem_startTimer proc~mus_update_sourcevars->tem_stopTimer val val proc~mus_update_relaxparamkine->val auxfield_varpos auxfield_varpos proc~mus_update_visckine->auxfield_varpos calcvisc calcvisc proc~mus_update_visckine->calcvisc proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine->proc~mus_turb_calcvisc tem_spacetime_for tem_spacetime_for proc~mus_update_visckine->tem_spacetime_for proc~mus_update_visckine->val invert_matrix invert_matrix proc~setparameters_multispecies->invert_matrix tem_temporal_for tem_temporal_for proc~setparameters_multispecies->tem_temporal_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_fast_singlelevel.html"},{"title":"do_benchmark – Musubi","text":"private  subroutine do_benchmark(me, scheme, geometry, params, iLevel) Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type\ndummy variable in this routine, required by interface type( mus_scheme_type ), intent(inout) :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable Calls proc~~do_benchmark~~CallsGraph proc~do_benchmark do_benchmark exchange_real exchange_real proc~do_benchmark->exchange_real proc~mus_apply_sourceterms mus_apply_sourceTerms proc~do_benchmark->proc~mus_apply_sourceterms proc~mus_calcauxfieldandexchange mus_calcAuxFieldAndExchange proc~do_benchmark->proc~mus_calcauxfieldandexchange proc~mus_swap_now_next mus_swap_Now_Next proc~do_benchmark->proc~mus_swap_now_next proc~mus_update_relaxparams mus_update_relaxParams proc~do_benchmark->proc~mus_update_relaxparams proc~mus_update_sourcevars mus_update_sourceVars proc~do_benchmark->proc~mus_update_sourcevars set_boundary set_boundary proc~do_benchmark->set_boundary tem_startTimer tem_startTimer proc~do_benchmark->tem_startTimer tem_stopTimer tem_stopTimer proc~do_benchmark->tem_stopTimer tem_time_advance tem_time_advance proc~do_benchmark->tem_time_advance proc~mus_apply_sourceterms->tem_startTimer proc~mus_apply_sourceterms->tem_stopTimer proc~mus_calcauxfieldandexchange->exchange_real nelems nelems proc~mus_update_relaxparams->nelems proc~mus_turb_updateviscofturbwall mus_turb_updateViscOfTurbWall proc~mus_update_relaxparams->proc~mus_turb_updateviscofturbwall proc~mus_update_relaxparamkine mus_update_relaxParamKine proc~mus_update_relaxparams->proc~mus_update_relaxparamkine proc~mus_update_visckine mus_update_viscKine proc~mus_update_relaxparams->proc~mus_update_visckine proc~setparameters_multispecies setParameters_multispecies proc~mus_update_relaxparams->proc~setparameters_multispecies tvisc tvisc proc~mus_update_relaxparams->tvisc proc~mus_update_sourcevars->tem_startTimer proc~mus_update_sourcevars->tem_stopTimer val val proc~mus_update_relaxparamkine->val auxfield_varpos auxfield_varpos proc~mus_update_visckine->auxfield_varpos calcvisc calcvisc proc~mus_update_visckine->calcvisc proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine->proc~mus_turb_calcvisc tem_spacetime_for tem_spacetime_for proc~mus_update_visckine->tem_spacetime_for proc~mus_update_visckine->val invert_matrix invert_matrix proc~setparameters_multispecies->invert_matrix tem_temporal_for tem_temporal_for proc~setparameters_multispecies->tem_temporal_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_benchmark.html"},{"title":"start_stageTimer – Musubi","text":"private  subroutine start_stageTimer() Arguments None Calls proc~~start_stagetimer~~CallsGraph proc~start_stagetimer start_stageTimer tem_startTimer tem_startTimer proc~start_stagetimer->tem_startTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~start_stagetimer~~CalledByGraph proc~start_stagetimer start_stageTimer proc~do_intpcoarserandexchange do_intpCoarserAndExchange proc~do_intpcoarserandexchange->proc~start_stagetimer proc~do_intpfinerandexchange do_intpFinerAndExchange proc~do_intpfinerandexchange->proc~start_stagetimer proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~start_stagetimer proc~do_recursive_multilevel->proc~do_intpcoarserandexchange proc~do_recursive_multilevel->proc~do_intpfinerandexchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/start_stagetimer.html"},{"title":"stop_stageTimer – Musubi","text":"private  subroutine stop_stageTimer() Arguments None Calls proc~~stop_stagetimer~~CallsGraph proc~stop_stagetimer stop_stageTimer tem_stopTimer tem_stopTimer proc~stop_stagetimer->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~stop_stagetimer~~CalledByGraph proc~stop_stagetimer stop_stageTimer proc~do_intpcoarserandexchange do_intpCoarserAndExchange proc~do_intpcoarserandexchange->proc~stop_stagetimer proc~do_intpfinerandexchange do_intpFinerAndExchange proc~do_intpfinerandexchange->proc~stop_stagetimer proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~stop_stagetimer proc~do_recursive_multilevel->proc~do_intpcoarserandexchange proc~do_recursive_multilevel->proc~do_intpfinerandexchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/stop_stagetimer.html"},{"title":"mus_init_tracker – Musubi","text":"public  subroutine mus_init_tracker(scheme, geometry, params) This routine initialize tracking subTree to remove empty tracking objects.\nOn active tracking objects: Homogenize time control, write solver speific\ninfo for harvester output format and initialize output using\ntem_init_tracker Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_geom_type ), intent(in) :: geometry Treelmesh data type( mus_param_type ), intent(in) :: params Global parameters Calls proc~~mus_init_tracker~~CallsGraph proc~mus_init_tracker mus_init_tracker config config proc~mus_init_tracker->config instance instance proc~mus_init_tracker->instance proc~mus_timecontrol_homogenize mus_timeControl_homogenize proc~mus_init_tracker->proc~mus_timecontrol_homogenize tem_init_tracker tem_init_tracker proc~mus_init_tracker->tem_init_tracker tem_init_tracker_subTree tem_init_tracker_subTree proc~mus_init_tracker->tem_init_tracker_subTree tem_timeControl_dump tem_timeControl_dump proc~mus_timecontrol_homogenize->tem_timeControl_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_tracker~~CalledByGraph proc~mus_init_tracker mus_init_tracker proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~mus_init_tracker proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_tracker proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_tracker proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_tracker.html"},{"title":"mus_init_advRel_multispecies_gas – Musubi","text":"public  subroutine mus_init_advRel_multispecies_gas(relaxation, layout, nFields, compute) Initialize the relaxation model for multispecies gas model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout integer, intent(in) :: nFields procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_multispecies_gas~~CallsGraph proc~mus_init_advrel_multispecies_gas mus_init_advRel_multispecies_gas tem_abort tem_abort proc~mus_init_advrel_multispecies_gas->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_multispecies_gas.html"},{"title":"mus_init_advRel_multispecies_liquid – Musubi","text":"public  subroutine mus_init_advRel_multispecies_liquid(relaxation, layout, nFields, compute) Initialize the relaxation model for multispecies liquid model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout integer, intent(in) :: nFields procedure( kernel ), intent(out), pointer :: compute Calls proc~~mus_init_advrel_multispecies_liquid~~CallsGraph proc~mus_init_advrel_multispecies_liquid mus_init_advRel_multispecies_liquid tem_abort tem_abort proc~mus_init_advrel_multispecies_liquid->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_advrel_multispecies_liquid.html"},{"title":"mus_build_varSys – Musubi","text":"public  subroutine mus_build_varSys(varSys, solverData, schemeHeader, stencil, nFields, derVarPos, luaVar, field, globSrc, poss_srcVar, st_funList) Build global variable system for Musubi Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_stencilHeader_type ), intent(in) :: stencil Compute stencil header integer, intent(in) :: nFields number of fields type( mus_derVarPos_type ), intent(out), allocatable :: derVarPos (:) store position of each variable for each field and mixture\nsize: nFields+1 type( tem_variable_type ), intent(in), allocatable :: luaVar (:) additional variable defined in the lua file.\nFunction pointer for this variables depends on its varType. type( mus_field_type ), intent(inout) :: field (:) Field contains sources and boundary infos type( mus_source_type ), intent(inout) :: globSrc global source type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( tem_st_fun_linkedList_type ), intent(out) :: st_funList contains spacetime functions of all variables Calls proc~~mus_build_varsys~~CallsGraph proc~mus_build_varsys mus_build_varSys init init proc~mus_build_varsys->init mus_append_dervar_fluid mus_append_dervar_fluid proc~mus_build_varsys->mus_append_dervar_fluid mus_append_dervar_fluidincomp mus_append_dervar_fluidincomp proc~mus_build_varsys->mus_append_dervar_fluidincomp mus_append_dervar_isotherm_aceq mus_append_dervar_isotherm_aceq proc~mus_build_varsys->mus_append_dervar_isotherm_aceq mus_append_dervar_lbmps mus_append_dervar_lbmps proc~mus_build_varsys->mus_append_dervar_lbmps mus_append_dervar_msgas mus_append_dervar_msgas proc~mus_build_varsys->mus_append_dervar_msgas mus_append_dervar_msliquid mus_append_dervar_msliquid proc~mus_build_varsys->mus_append_dervar_msliquid mus_append_dervar_physics mus_append_dervar_physics proc~mus_build_varsys->mus_append_dervar_physics mus_append_dervar_poisson mus_append_dervar_poisson proc~mus_build_varsys->mus_append_dervar_poisson mus_append_materialvar mus_append_materialvar proc~mus_build_varsys->mus_append_materialvar mus_append_turbvar mus_append_turbvar proc~mus_build_varsys->mus_append_turbvar proc~mus_append_auxfield mus_append_auxField proc~mus_build_varsys->proc~mus_append_auxfield proc~mus_append_bcvar mus_append_bcVar proc~mus_build_varsys->proc~mus_append_bcvar proc~mus_append_sourcevar mus_append_sourceVar proc~mus_build_varsys->proc~mus_append_sourcevar proc~mus_store_bcvarpos mus_store_bcVarPos proc~mus_build_varsys->proc~mus_store_bcvarpos proc~mus_store_dervarpos mus_store_derVarPos proc~mus_build_varsys->proc~mus_store_dervarpos tem_abort tem_abort proc~mus_build_varsys->tem_abort tem_varSys_append_luaVar tem_varSys_append_luaVar proc~mus_build_varsys->tem_varSys_append_luaVar tem_varSys_append_meshInfoVar tem_varSys_append_meshInfoVar proc~mus_build_varsys->tem_varSys_append_meshInfoVar tem_varSys_dump tem_varSys_dump proc~mus_build_varsys->tem_varSys_dump proc~mus_append_auxfield->tem_abort append append proc~mus_append_auxfield->append mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_auxfield->mus_get_new_solver_ptr tem_varSys_append_auxFieldVar tem_varSys_append_auxFieldVar proc~mus_append_auxfield->tem_varSys_append_auxFieldVar proc~mus_append_bcvar->init proc~mus_append_bcvar->append proc~mus_append_bcvar->mus_get_new_solver_ptr tem_varSys_append_derVar tem_varSys_append_derVar proc~mus_append_bcvar->tem_varSys_append_derVar proc~mus_append_sourcevar->tem_abort proc~mus_append_sourcevar->tem_varSys_dump input_varpos input_varpos proc~mus_append_sourcevar->input_varpos proc~mus_append_sourcevar->mus_get_new_solver_ptr positionofval positionofval proc~mus_append_sourcevar->positionofval proc~mus_append_sourcevar->tem_varSys_append_derVar val val proc~mus_append_sourcevar->val proc~mus_store_bcvarpos->tem_abort proc~mus_store_bcvarpos->positionofval proc~mus_store_bcvarpos->val proc~mus_store_dervarpos->positionofval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_build_varsys~~CalledByGraph proc~mus_build_varsys mus_build_varSys proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_build_varsys.html"},{"title":"mus_append_readVarAsStateVar – Musubi","text":"public  subroutine mus_append_readVarAsStateVar(varSys, readVarIsPdf, read_varSys, stateVarMap, solverData, nFields, fldLabel) Append variable read from restart file as state variables Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system logical, intent(out) :: readVarIsPdf Is true if read_varSys has pdf variable type( tem_varSys_type ), intent(in) :: read_varSys Variable system loaded from restart header file type( tem_varMap_type ), intent(out) :: stateVarMap Store position of state variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields Calls proc~~mus_append_readvarasstatevar~~CallsGraph proc~mus_append_readvarasstatevar mus_append_readVarAsStateVar append append proc~mus_append_readvarasstatevar->append init init proc~mus_append_readvarasstatevar->init mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_readvarasstatevar->mus_get_new_solver_ptr proc~check_varsys_forpdfvar check_varSys_forPdfVar proc~mus_append_readvarasstatevar->proc~check_varsys_forpdfvar tem_abort tem_abort proc~mus_append_readvarasstatevar->tem_abort tem_varSys_append_stateVar tem_varSys_append_stateVar proc~mus_append_readvarasstatevar->tem_varSys_append_stateVar truncate truncate proc~mus_append_readvarasstatevar->truncate val val proc~mus_append_readvarasstatevar->val proc~check_varsys_forpdfvar->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_append_readvarasstatevar~~CalledByGraph proc~mus_append_readvarasstatevar mus_append_readVarAsStateVar proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_append_readvarasstatevar proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_append_readvarasstatevar.html"},{"title":"mus_append_stateVar – Musubi","text":"public  subroutine mus_append_stateVar(varSys, stateVarMap, solverData, schemeHeader, stencil, nFields, fldLabel) Append state variable depends on the scheme kind allocate function pointers, and append pdf to scheme%varSys Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type( tem_varMap_type ), intent(out) :: stateVarMap Store position of state variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_stencilHeader_type ), intent(in) :: stencil compute stencil defintion integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields Calls proc~~mus_append_statevar~~CallsGraph proc~mus_append_statevar mus_append_stateVar append append proc~mus_append_statevar->append init init proc~mus_append_statevar->init mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_statevar->mus_get_new_solver_ptr tem_abort tem_abort proc~mus_append_statevar->tem_abort tem_varSys_append_stateVar tem_varSys_append_stateVar proc~mus_append_statevar->tem_varSys_append_stateVar truncate truncate proc~mus_append_statevar->truncate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_append_statevar~~CalledByGraph proc~mus_append_statevar mus_append_stateVar proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_append_statevar proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_append_statevar.html"},{"title":"mus_append_auxField – Musubi","text":"public  subroutine mus_append_auxField(varSys, solverData, schemeHeader, nFields, fldLabel, derVarName) Append auxiliary variables which are computed from state and stored\nin auxField array using calcAuxField function Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields type( grw_labelarray_type ), intent(inout) :: derVarName array of derive physical variables Calls proc~~mus_append_auxfield~~CallsGraph proc~mus_append_auxfield mus_append_auxField append append proc~mus_append_auxfield->append mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_auxfield->mus_get_new_solver_ptr tem_abort tem_abort proc~mus_append_auxfield->tem_abort tem_varSys_append_auxFieldVar tem_varSys_append_auxFieldVar proc~mus_append_auxfield->tem_varSys_append_auxFieldVar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_append_auxfield~~CalledByGraph proc~mus_append_auxfield mus_append_auxField proc~mus_build_varsys mus_build_varSys proc~mus_build_varsys->proc~mus_append_auxfield proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_append_auxfield.html"},{"title":"mus_store_derVarPos – Musubi","text":"public  subroutine mus_store_derVarPos(derVarPos, derVarName, varSys, nFields, fldLabel) Store the position of each variable in the global system in the derVarPos\nThis function is also called in Harvester. Arguments Type Intent Optional Attributes Name type( mus_derVarPos_type ), intent(inout) :: derVarPos (:) Position of derived variables type( grw_labelarray_type ), intent(in) :: derVarName array of derive physical variables type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields Calls proc~~mus_store_dervarpos~~CallsGraph proc~mus_store_dervarpos mus_store_derVarPos positionofval positionofval proc~mus_store_dervarpos->positionofval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_store_dervarpos~~CalledByGraph proc~mus_store_dervarpos mus_store_derVarPos proc~mus_build_varsys mus_build_varSys proc~mus_build_varsys->proc~mus_store_dervarpos proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_store_dervarpos.html"},{"title":"mus_append_sourceVar – Musubi","text":"private  subroutine mus_append_sourceVar(me, solverData, schemeHeader, varSys, nFields, stencil, poss_srcVar, fldLabel) Build a variable system of all possible source terms for the given\nschemeKind Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: me Contains source function pointer,\nsource variable definition from lua and\nmapping of source variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme type( tem_varSys_type ), intent(inout) :: varSys Global variable system integer, intent(in) :: nFields number of fields type( tem_stencilHeader_type ), intent(in) :: stencil compute stencil defintion type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables character(len=*), intent(in), optional :: fldLabel array of field label prefix required only for field source.\nIf not present, it is assumed as global source Calls proc~~mus_append_sourcevar~~CallsGraph proc~mus_append_sourcevar mus_append_sourceVar input_varpos input_varpos proc~mus_append_sourcevar->input_varpos mus_get_new_solver_ptr mus_get_new_solver_ptr proc~mus_append_sourcevar->mus_get_new_solver_ptr positionofval positionofval proc~mus_append_sourcevar->positionofval tem_abort tem_abort proc~mus_append_sourcevar->tem_abort tem_varSys_append_derVar tem_varSys_append_derVar proc~mus_append_sourcevar->tem_varSys_append_derVar tem_varSys_dump tem_varSys_dump proc~mus_append_sourcevar->tem_varSys_dump val val proc~mus_append_sourcevar->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_append_sourcevar~~CalledByGraph proc~mus_append_sourcevar mus_append_sourceVar proc~mus_build_varsys mus_build_varSys proc~mus_build_varsys->proc~mus_append_sourcevar proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_append_sourcevar.html"},{"title":"mus_store_bcVarPos – Musubi","text":"private  subroutine mus_store_bcVarPos(field, nFields, varSys) Store the position of each boundary variable in the global varSys\nin the field%bc%varPos% .\nThis routine also checks if boundary variable defined in config file\nhas same number of components as expected. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (:) Field containing boundary infos integer, intent(in) :: nFields number of fields type( tem_varSys_type ), intent(in) :: varSys global variable system Calls proc~~mus_store_bcvarpos~~CallsGraph proc~mus_store_bcvarpos mus_store_bcVarPos positionofval positionofval proc~mus_store_bcvarpos->positionofval tem_abort tem_abort proc~mus_store_bcvarpos->tem_abort val val proc~mus_store_bcvarpos->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_store_bcvarpos~~CalledByGraph proc~mus_store_bcvarpos mus_store_bcVarPos proc~mus_build_varsys mus_build_varSys proc~mus_build_varsys->proc~mus_store_bcvarpos proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_build_varsys proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_store_bcvarpos.html"},{"title":"check_varSys_forPdfVar – Musubi","text":"private  subroutine check_varSys_forPdfVar(readVarIsPdf, varSys, nFields, fldLabel) This function runs over all variable loaded from restart file check if\nvariables loaded are pdf variable or derive variable Variable read from restart file can have variables other than pdf but pdf\nmust be the 1st variable if not stateVarIsPdf will be false Arguments Type Intent Optional Attributes Name logical, intent(out) :: readVarIsPdf return true if variable read from restart file has pdf type( tem_varSys_type ), intent(in) :: varSys variable system loaded from restart file integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields Calls proc~~check_varsys_forpdfvar~~CallsGraph proc~check_varsys_forpdfvar check_varSys_forPdfVar val val proc~check_varsys_forpdfvar->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_varsys_forpdfvar~~CalledByGraph proc~check_varsys_forpdfvar check_varSys_forPdfVar proc~mus_append_readvarasstatevar mus_append_readVarAsStateVar proc~mus_append_readvarasstatevar->proc~check_varsys_forpdfvar proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_append_readvarasstatevar proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_varsys_forpdfvar.html"},{"title":"mus_load_param – Musubi","text":"public  subroutine mus_load_param(params, conf) load global parameter from conf KM: To calculate turbulent viscosity, velocity on buffer ghost elements\nshould be valid to nesting is set to same as scaling Factor Arguments Type Intent Optional Attributes Name type( mus_param_type ), intent(inout) :: params global parameter info type( flu_State ) :: conf lua state Calls proc~~mus_load_param~~CallsGraph proc~mus_load_param mus_load_param aot_get_val aot_get_val proc~mus_load_param->aot_get_val tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_param->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_param~~CalledByGraph proc~mus_load_param mus_load_param proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_param proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_param proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_param.html"},{"title":"mus_param_out – Musubi","text":"public  subroutine mus_param_out(me, conf) This routine writes global parameter into solver specific string in lua\nformat Arguments Type Intent Optional Attributes Name type( mus_param_type ), intent(in) :: me type( aot_out_type ) :: conf Calls proc~~mus_param_out~~CallsGraph proc~mus_param_out mus_param_out aot_out_val aot_out_val proc~mus_param_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_param_out~~CalledByGraph proc~mus_param_out mus_param_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_param_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_param_out.html"},{"title":"mus_init_latticeUnit – Musubi","text":"public  subroutine mus_init_latticeUnit(lattice, minLevel, maxLevel, scaleFactor) This routine initialize lattice dx and dt Arguments Type Intent Optional Attributes Name type( mus_latticeUnit_type ), intent(out) :: lattice Lattice unit integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel integer, intent(in) :: scaleFactor scaleFactor depending on acoustic or diffusive scaling Calls proc~~mus_init_latticeunit~~CallsGraph proc~mus_init_latticeunit mus_init_latticeUnit proc~set_values_by_levels set_values_by_levels proc~mus_init_latticeunit->proc~set_values_by_levels tem_horizontalSpacer tem_horizontalSpacer proc~mus_init_latticeunit->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_latticeunit~~CalledByGraph proc~mus_init_latticeunit mus_init_latticeUnit proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_init_latticeunit program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_latticeunit.html"},{"title":"mus_load_scheme – Musubi","text":"public  subroutine mus_load_scheme(me, solverData, geometry, conf, params, parent, isMusHvs) load single scheme defined in lua file with or without scheme handle This routines checks whether schemes table boundary_conditions = {...}, is defined. If yes then it will\n load schemes table and set mus_scheme_type.\n If no special scheme table is defined, default tables are loaded from the\n root level of the lua file\n fluid, boundary conditions and initial condiitions fluid = { ... } boundary_conditions = {...} initial_conditions = {...} Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: me scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(in), target :: geometry geometry information like tree and boundary type( flu_State ) :: conf flu state type( mus_param_type ), intent(inout), target :: params global parameter type integer, intent(in), optional :: parent parent handle if scheme table is defined logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False Calls proc~~mus_load_scheme~~CallsGraph proc~mus_load_scheme mus_load_scheme mus_init_varsys_solverdata mus_init_varsys_solverdata proc~mus_load_scheme->mus_init_varsys_solverdata proc~mus_append_readvarasstatevar mus_append_readVarAsStateVar proc~mus_load_scheme->proc~mus_append_readvarasstatevar proc~mus_append_statevar mus_append_stateVar proc~mus_load_scheme->proc~mus_append_statevar proc~mus_create_poss_srcvar mus_create_poss_srcVar proc~mus_load_scheme->proc~mus_create_poss_srcvar proc~mus_create_poss_transvar mus_create_poss_transVar proc~mus_load_scheme->proc~mus_create_poss_transvar proc~mus_define_layout mus_define_layout proc~mus_load_scheme->proc~mus_define_layout proc~mus_load_fieldbaseinfos mus_load_fieldBaseInfos proc~mus_load_scheme->proc~mus_load_fieldbaseinfos proc~mus_load_fields mus_load_fields proc~mus_load_scheme->proc~mus_load_fields proc~mus_load_interpolate mus_load_interpolate proc~mus_load_scheme->proc~mus_load_interpolate proc~mus_load_newlayout mus_load_newLayout proc~mus_load_scheme->proc~mus_load_newlayout proc~mus_load_scheme_header mus_load_scheme_header proc~mus_load_scheme->proc~mus_load_scheme_header proc~mus_load_source_var mus_load_source_var proc~mus_load_scheme->proc~mus_load_source_var proc~mus_load_transport_var mus_load_transport_var proc~mus_load_scheme->proc~mus_load_transport_var tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_scheme->tem_horizontalSpacer tem_load_tracking tem_load_tracking proc~mus_load_scheme->tem_load_tracking tem_varSys_init tem_varSys_init proc~mus_load_scheme->tem_varSys_init tem_variable_load tem_variable_load proc~mus_load_scheme->tem_variable_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_scheme~~CalledByGraph proc~mus_load_scheme mus_load_scheme proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_scheme.html"},{"title":"mus_init_scheme – Musubi","text":"public  subroutine mus_init_scheme(me, tree, solverData) Initialize single scheme stencil and variable system Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: me single scheme to initialize type( treelmesh_type ), intent(in) :: tree global treelm mesh type(mus_varSys_solverData_type), intent(in), target :: solverData contains pointer to scheme, physics types Calls proc~~mus_init_scheme~~CallsGraph proc~mus_init_scheme mus_init_scheme append append proc~mus_init_scheme->append mus_assign_calcauxfield_ptr mus_assign_calcauxfield_ptr proc~mus_init_scheme->mus_assign_calcauxfield_ptr mus_assign_gradcalculation_ptr mus_assign_gradcalculation_ptr proc~mus_init_scheme->mus_assign_gradcalculation_ptr proc~mus_assign_derived_functions_ptr mus_assign_derived_functions_ptr proc~mus_init_scheme->proc~mus_assign_derived_functions_ptr proc~mus_build_varsys mus_build_varSys proc~mus_init_scheme->proc~mus_build_varsys proc~mus_init_moments mus_init_moments proc~mus_init_scheme->proc~mus_init_moments proc~mus_set_nsources mus_set_nSources proc~mus_init_scheme->proc~mus_set_nsources tem_horizontalSpacer tem_horizontalSpacer proc~mus_init_scheme->tem_horizontalSpacer tem_stencil_map_toTreelmDef tem_stencil_map_toTreelmDef proc~mus_init_scheme->tem_stencil_map_toTreelmDef tem_treelmDef_map_toStencil tem_treelmDef_map_toStencil proc~mus_init_scheme->tem_treelmDef_map_toStencil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_init_scheme~~CalledByGraph proc~mus_init_scheme mus_init_scheme proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_scheme.html"},{"title":"mus_scheme_out – Musubi","text":"public  subroutine mus_scheme_out(me, conf) Dump single scheme info into restart solver specific conf to dump\nsolver specific information in restart header file Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: me schemes to dump to restart header file type( aot_out_type ), intent(inout), optional :: conf aotus type handling the output to the file in lua format Calls proc~~mus_scheme_out~~CallsGraph proc~mus_scheme_out mus_scheme_out interface~mus_fields_out mus_fields_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_interpolate_out mus_interpolate_out proc~mus_scheme_out->proc~mus_interpolate_out proc~mus_mixture_out mus_mixture_out proc~mus_scheme_out->proc~mus_mixture_out proc~mus_scheme_header_out mus_scheme_header_out proc~mus_scheme_out->proc~mus_scheme_header_out proc~mus_field_out_scal mus_field_out_scal interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec aot_out_val aot_out_val proc~mus_interpolate_out->aot_out_val aot_out_close_table aot_out_close_table proc~mus_mixture_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_mixture_out->aot_out_open_table proc~mus_mixture_out->aot_out_val proc~mus_scheme_header_out->aot_out_close_table proc~mus_scheme_header_out->aot_out_open_table proc~mus_scheme_header_out->aot_out_val proc~mus_field_out_scal->aot_out_close_table proc~mus_field_out_scal->aot_out_open_table proc~mus_field_out_scal->aot_out_val proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal->proc~mus_field_prop_out proc~mus_fields_out_vec->aot_out_close_table proc~mus_fields_out_vec->aot_out_open_table proc~mus_fields_out_vec->aot_out_val proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_species_out mus_species_out proc~mus_field_prop_out->proc~mus_species_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_scheme_out~~CalledByGraph proc~mus_scheme_out mus_scheme_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_scheme_out.html"},{"title":"mus_scheme_cleanup – Musubi","text":"public  subroutine mus_scheme_cleanup(me, minLevel, maxLevel, nBCs) This subroutine acts as a destructor for the construct routine Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: me scheme information including fluid, boundary and flow information integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(in) :: nBCs Number of boundary conditions Calls proc~~mus_scheme_cleanup~~CallsGraph proc~mus_scheme_cleanup mus_scheme_cleanup destroy destroy proc~mus_scheme_cleanup->destroy instance instance proc~mus_scheme_cleanup->instance proc~mus_field_cleanup mus_field_cleanup proc~mus_scheme_cleanup->proc~mus_field_cleanup proc~mus_source_cleanup mus_source_cleanup proc~mus_scheme_cleanup->proc~mus_source_cleanup tem_destroy_subTree_of_st_funList tem_destroy_subTree_of_st_funList proc~mus_scheme_cleanup->tem_destroy_subTree_of_st_funList proc~mus_field_cleanup->proc~mus_source_cleanup mus_fieldbc_cleanup mus_fieldbc_cleanup proc~mus_field_cleanup->mus_fieldbc_cleanup proc~mus_fluid_cleanup mus_fluid_cleanup proc~mus_field_cleanup->proc~mus_fluid_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_scheme_cleanup~~CalledByGraph proc~mus_scheme_cleanup mus_scheme_cleanup proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_scheme_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_scheme_cleanup.html"},{"title":"mus_check_allWall – Musubi","text":"public pure function mus_check_allWall(nFields, fields, iBC) result(allWall) Check if a BC is wall or symmetry for all fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields type( mus_field_type ), intent(in) :: fields (nFields) integer, intent(in) :: iBC Return Value logical","tags":"","loc":"proc/mus_check_allwall.html"},{"title":"mus_load_fields – Musubi","text":"public  subroutine mus_load_fields(me, varSys, nFields, mixture, nernstPlanck, bc_prop, conf, parent, minLevel, maxLevel, schemeHeader, poss_srcVar, physics, scaling, layout, isMusHvs) Subroutine to load the field table from the lua configuration file. If field table is not defined than load bc, ic, fluid, species from scheme\ntable. If scheme table is not defined than load field variables from\nconfig parent. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me (:) array of field type type( tem_varSys_type ), intent(inout) :: varSys Global variable system required to append annoymous source and\nboundary variables integer, intent(in) :: nFields type( mus_mixture_type ), intent(out) :: mixture contains mixture information type( mus_nernstPlanck_type ), intent(out) :: nernstPlanck contains solvent information type( tem_BC_prop_type ), intent(in) :: bc_prop boundary data from mesh type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined integer, intent(in) :: minLevel global pdf info integer, intent(in) :: maxLevel global pdf info type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa character(len=labelLen), intent(in) :: scaling scaling type type( mus_scheme_layout_type ), intent(in) :: layout fluid stencil info logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False Calls proc~~mus_load_fields~~CallsGraph proc~mus_load_fields mus_load_fields aot_table_close aot_table_close proc~mus_load_fields->aot_table_close aot_table_open aot_table_open proc~mus_load_fields->aot_table_open proc~compute_bulkviscomega compute_bulkViscOmega proc~mus_load_fields->proc~compute_bulkviscomega proc~compute_molweightratio compute_molWeightRatio proc~mus_load_fields->proc~compute_molweightratio proc~mus_load_field_single mus_load_field_single proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_mixture mus_load_mixture proc~mus_load_fields->proc~mus_load_mixture proc~mus_load_nernstplanck mus_load_nernstPlanck proc~mus_load_fields->proc~mus_load_nernstplanck tem_abort tem_abort proc~mus_load_fields->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_fields->tem_horizontalSpacer proc~compute_molweightratio->tem_horizontalSpacer proc~mus_load_field_single->tem_abort proc~mus_load_field_single->tem_horizontalSpacer mus_load_bc mus_load_bc proc~mus_load_field_single->mus_load_bc proc~mus_add_internal_source_var mus_add_internal_source_var proc~mus_load_field_single->proc~mus_add_internal_source_var proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_source_var mus_load_source_var proc~mus_load_field_single->proc~mus_load_source_var proc~mus_set_ic_states mus_set_ic_states proc~mus_load_field_single->proc~mus_set_ic_states tem_load_ic tem_load_ic proc~mus_load_field_single->tem_load_ic proc~mus_load_mixture->aot_table_close proc~mus_load_mixture->aot_table_open proc~mus_load_mixture->tem_abort proc~mus_load_mixture->tem_horizontalSpacer aot_get_val aot_get_val proc~mus_load_mixture->aot_get_val proc~mus_init_enrtl mus_init_eNRTL proc~mus_load_mixture->proc~mus_init_enrtl proc~set_omegaslvl set_omegasLvl proc~mus_load_mixture->proc~set_omegaslvl proc~mus_load_mixture->tem_load_ic tem_load_spatial tem_load_spatial proc~mus_load_mixture->tem_load_spatial tem_load_temporal tem_load_temporal proc~mus_load_mixture->tem_load_temporal proc~mus_load_nernstplanck->aot_table_close proc~mus_load_nernstplanck->aot_table_open proc~mus_load_nernstplanck->tem_abort proc~mus_load_nernstplanck->aot_get_val tem_toStr tem_toStr proc~mus_load_nernstplanck->tem_toStr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_fields~~CalledByGraph proc~mus_load_fields mus_load_fields proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_fields.html"},{"title":"mus_load_fieldBaseInfos – Musubi","text":"public  subroutine mus_load_fieldBaseInfos(me, nFields, parent, conf) This routine returns nFields and field labels from config file.\nIt is required to initialize variable system.\nlabels are loaded only if field table is present else default\nis set to empty string. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(out), allocatable :: me (:) array of field type integer, intent(out) :: nFields number of fields defined in lua file integer, intent(in), optional :: parent parent handle if scheme table is defined type( flu_State ), intent(inout) :: conf flu state Calls proc~~mus_load_fieldbaseinfos~~CallsGraph proc~mus_load_fieldbaseinfos mus_load_fieldBaseInfos aot_get_val aot_get_val proc~mus_load_fieldbaseinfos->aot_get_val aot_table_close aot_table_close proc~mus_load_fieldbaseinfos->aot_table_close aot_table_length aot_table_length proc~mus_load_fieldbaseinfos->aot_table_length aot_table_open aot_table_open proc~mus_load_fieldbaseinfos->aot_table_open tem_abort tem_abort proc~mus_load_fieldbaseinfos->tem_abort tem_checkLabel tem_checkLabel proc~mus_load_fieldbaseinfos->tem_checkLabel tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_fieldbaseinfos->tem_horizontalSpacer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_fieldbaseinfos~~CalledByGraph proc~mus_load_fieldbaseinfos mus_load_fieldBaseInfos proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fieldbaseinfos proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_config_load Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_fieldbaseinfos.html"},{"title":"setParameters_multispecies – Musubi","text":"public  subroutine setParameters_multispecies(field, nFields, mixture, header, layout, iLevel, tNow) Set parameters for multispecies Relaxation parameter for each level\nkine_viscosity = dt c&#94;2 (1/omega - 0.5)\n   =>   omega = dt / (viscosity/c&#94;2 + dt/2)\nomega for each level is stored at fluid%omLvl Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (nFields) integer, intent(in) :: nFields type( mus_mixture_type ), intent(inout) :: mixture type( mus_scheme_header_type ), intent(in) :: header type( mus_scheme_layout_type ), intent(in) :: layout integer, intent(in) :: iLevel type( tem_time_type ), intent(in) :: tNow solver general info Calls proc~~setparameters_multispecies~~CallsGraph proc~setparameters_multispecies setParameters_multispecies invert_matrix invert_matrix proc~setparameters_multispecies->invert_matrix tem_temporal_for tem_temporal_for proc~setparameters_multispecies->tem_temporal_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~setparameters_multispecies~~CalledByGraph proc~setparameters_multispecies setParameters_multispecies proc~mus_update_relaxparams mus_update_relaxParams proc~mus_update_relaxparams->proc~setparameters_multispecies proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/setparameters_multispecies.html"},{"title":"remove_solid_in_bc – Musubi","text":"public  subroutine remove_solid_in_bc(minLevel, maxLevel, nBCs, nFields, levelPointer, levelDesc, globBC, fields) First check count number of valid elements (non-solid) in each BC.\nThen rearrange BC elements list so it contains only valid elements.\nUpdate fields%bc%elemLvl%stencilPos fields%bc%elemLvl%posInNghElems\naccordingly. \\todo: do this for both SBB and LIBB? Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel integer, intent(in) :: nBCs integer, intent(in) :: nFields integer, intent(in) :: levelPointer (:) Level pointer type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level Descriptor type(glob_boundary_type) :: globBC (nBCs) type( mus_field_type ) :: fields (nFields) Calls proc~~remove_solid_in_bc~~CallsGraph proc~remove_solid_in_bc remove_solid_in_bc bc_kind bc_kind proc~remove_solid_in_bc->bc_kind check_solid_in_bc check_solid_in_bc proc~remove_solid_in_bc->check_solid_in_bc nelems nelems proc~remove_solid_in_bc->nelems posinnghelems posinnghelems proc~remove_solid_in_bc->posinnghelems rearrange_bc_elems rearrange_bc_elems proc~remove_solid_in_bc->rearrange_bc_elems stencilpos stencilpos proc~remove_solid_in_bc->stencilpos Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/remove_solid_in_bc.html"},{"title":"mus_field_getSymmetricBCs – Musubi","text":"public  subroutine mus_field_getSymmetricBCs(symmetricBCs, nSymBCs, nBCs, nFields, field) This routine checks for the existence of symmetric boundaries and\nreturns the boundary IDs which are defined as symmetry Arguments Type Intent Optional Attributes Name integer, intent(out) :: symmetricBCs (nBCs) Symmetric boundary ids integer, intent(out) :: nSymBCs Number of symmetric boundary conditions integer, intent(in) :: nBCs number of boundary conditions integer, intent(in) :: nFields number of fields type( mus_field_type ), intent(in) :: field (nFields) all fields to access their boundary definitions Calls proc~~mus_field_getsymmetricbcs~~CallsGraph proc~mus_field_getsymmetricbcs mus_field_getSymmetricBCs tem_abort tem_abort proc~mus_field_getsymmetricbcs->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_field_getsymmetricbcs.html"},{"title":"mus_field_cleanup – Musubi","text":"public  subroutine mus_field_cleanup(me, schemeHeader, minLevel, maxLevel, nBCs, nFields) This routines act as a destructor for field type.\nOnly allocatable arrays which are allocated in mus_construct routine\nare deallocated.\nKM: DO NOT DESTROY FIELD ARRAY AS IT CONTAINS ALL CONFIG INFO Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me (:) single field type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(in) :: nBCs Number of boundary conditions integer, intent(in) :: nFields Number of fields Calls proc~~mus_field_cleanup~~CallsGraph proc~mus_field_cleanup mus_field_cleanup mus_fieldbc_cleanup mus_fieldbc_cleanup proc~mus_field_cleanup->mus_fieldbc_cleanup proc~mus_fluid_cleanup mus_fluid_cleanup proc~mus_field_cleanup->proc~mus_fluid_cleanup proc~mus_source_cleanup mus_source_cleanup proc~mus_field_cleanup->proc~mus_source_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_field_cleanup~~CalledByGraph proc~mus_field_cleanup mus_field_cleanup proc~mus_scheme_cleanup mus_scheme_cleanup proc~mus_scheme_cleanup->proc~mus_field_cleanup proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_scheme_cleanup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_field_cleanup.html"},{"title":"mus_load_field_single – Musubi","text":"private  subroutine mus_load_field_single(me, varSys, nFields, bc_prop, conf, parent, minLevel, maxLevel, poss_srcVar, physics, schemeHeader, scaling, layout, isMusHvs) load a single field table\nIn includes:\n  load field property\n  load source variables\n  load boundary defination\n  load immersed boundary method\n  load initial condition defination and its property Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me field type type( tem_varSys_type ), intent(inout) :: varSys Global variable system required to append annoymous source and\nboundary variables integer, intent(in) :: nFields number of fields defined in lua file type( tem_BC_prop_type ), intent(in) :: bc_prop boundary data from mesh type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined integer, intent(in) :: minLevel global pdf info integer, intent(in) :: maxLevel global pdf info type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme character(len=labelLen), intent(in) :: scaling scaling type type( mus_scheme_layout_type ), intent(in) :: layout fluid stencil info logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False Calls proc~~mus_load_field_single~~CallsGraph proc~mus_load_field_single mus_load_field_single mus_load_bc mus_load_bc proc~mus_load_field_single->mus_load_bc proc~mus_add_internal_source_var mus_add_internal_source_var proc~mus_load_field_single->proc~mus_add_internal_source_var proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_source_var mus_load_source_var proc~mus_load_field_single->proc~mus_load_source_var proc~mus_set_ic_states mus_set_ic_states proc~mus_load_field_single->proc~mus_set_ic_states tem_abort tem_abort proc~mus_load_field_single->tem_abort tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_field_single->tem_horizontalSpacer tem_load_ic tem_load_ic proc~mus_load_field_single->tem_load_ic append append proc~mus_add_internal_source_var->append init init proc~mus_add_internal_source_var->init positionofval positionofval proc~mus_add_internal_source_var->positionofval tem_varSys_append_stfun tem_varSys_append_stfun proc~mus_add_internal_source_var->tem_varSys_append_stfun truncate truncate proc~mus_add_internal_source_var->truncate val val proc~mus_add_internal_source_var->val proc~mus_load_field_prop->tem_abort proc~mus_load_fluid mus_load_fluid proc~mus_load_field_prop->proc~mus_load_fluid proc~mus_load_poisson mus_load_poisson proc~mus_load_field_prop->proc~mus_load_poisson proc~mus_load_species mus_load_species proc~mus_load_field_prop->proc~mus_load_species proc~mus_load_source_var->tem_abort aot_get_val aot_get_val proc~mus_load_source_var->aot_get_val aot_table_open aot_table_open proc~mus_load_source_var->aot_table_open proc~mus_load_source_var->init proc~load_turbchanforce load_turbChanForce proc~mus_load_source_var->proc~load_turbchanforce proc~mus_load_absorblayer mus_load_absorbLayer proc~mus_load_source_var->proc~mus_load_absorblayer tem_variable_loadMapping tem_variable_loadMapping proc~mus_load_source_var->tem_variable_loadMapping proc~mus_load_source_var->truncate proc~mus_load_source_var->val proc~mus_set_ic_states->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_field_single~~CalledByGraph proc~mus_load_field_single mus_load_field_single proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_field_single.html"},{"title":"mus_fields_out_vec – Musubi","text":"private  subroutine mus_fields_out_vec(me, conf, schemeHeader) write array of fields into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me (:) array of field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme Calls proc~~mus_fields_out_vec~~CallsGraph proc~mus_fields_out_vec mus_fields_out_vec aot_out_close_table aot_out_close_table proc~mus_fields_out_vec->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_fields_out_vec->aot_out_open_table aot_out_val aot_out_val proc~mus_fields_out_vec->aot_out_val proc~mus_field_out_scal mus_field_out_scal proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_field_out_scal->aot_out_close_table proc~mus_field_out_scal->aot_out_open_table proc~mus_field_out_scal->aot_out_val proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal->proc~mus_field_prop_out proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_species_out mus_species_out proc~mus_field_prop_out->proc~mus_species_out proc~mus_fluid_save2lua->aot_out_close_table proc~mus_fluid_save2lua->aot_out_open_table proc~mus_fluid_save2lua->aot_out_val const const proc~mus_fluid_save2lua->const mus_nnwtn_save2lua mus_nnwtn_save2lua proc~mus_fluid_save2lua->mus_nnwtn_save2lua proc~mus_species_out->aot_out_close_table proc~mus_species_out->aot_out_open_table proc~mus_species_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_fields_out_vec~~CalledByGraph proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out mus_fields_out interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_fields_out_vec.html"},{"title":"mus_field_out_scal – Musubi","text":"private  subroutine mus_field_out_scal(me, conf, schemeHeader, level) write single field into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in), optional :: level To dump field with or without key Calls proc~~mus_field_out_scal~~CallsGraph proc~mus_field_out_scal mus_field_out_scal aot_out_close_table aot_out_close_table proc~mus_field_out_scal->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_field_out_scal->aot_out_open_table aot_out_val aot_out_val proc~mus_field_out_scal->aot_out_val proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal->proc~mus_field_prop_out proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_species_out mus_species_out proc~mus_field_prop_out->proc~mus_species_out proc~mus_fluid_save2lua->aot_out_close_table proc~mus_fluid_save2lua->aot_out_open_table proc~mus_fluid_save2lua->aot_out_val const const proc~mus_fluid_save2lua->const mus_nnwtn_save2lua mus_nnwtn_save2lua proc~mus_fluid_save2lua->mus_nnwtn_save2lua proc~mus_species_out->aot_out_close_table proc~mus_species_out->aot_out_open_table proc~mus_species_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_field_out_scal~~CalledByGraph proc~mus_field_out_scal mus_field_out_scal interface~mus_fields_out mus_fields_out interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_field_out_scal.html"},{"title":"mus_set_ic_states – Musubi","text":"private  subroutine mus_set_ic_states(scheme_kind, ic_states, IC_nVars) Set ic states labels by scheme kind Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: scheme_kind character(len=labelLen), allocatable :: ic_states (:) integer, intent(out) :: IC_nVars Number of initial condition variables required to initialize state Calls proc~~mus_set_ic_states~~CallsGraph proc~mus_set_ic_states mus_set_ic_states tem_abort tem_abort proc~mus_set_ic_states->tem_abort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_set_ic_states~~CalledByGraph proc~mus_set_ic_states mus_set_ic_states proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_set_ic_states proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_set_ic_states.html"},{"title":"mus_fields_out – Musubi","text":"public interface mus_fields_out Interface for dumping a single field or a set of fields in a file in lua\nformat. Calls interface~~mus_fields_out~~CallsGraph interface~mus_fields_out mus_fields_out proc~mus_field_out_scal mus_field_out_scal interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec aot_out_close_table aot_out_close_table proc~mus_field_out_scal->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_field_out_scal->aot_out_open_table aot_out_val aot_out_val proc~mus_field_out_scal->aot_out_val proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal->proc~mus_field_prop_out proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_fields_out_vec->aot_out_close_table proc~mus_fields_out_vec->aot_out_open_table proc~mus_fields_out_vec->aot_out_val proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_species_out mus_species_out proc~mus_field_prop_out->proc~mus_species_out proc~mus_fluid_save2lua->aot_out_close_table proc~mus_fluid_save2lua->aot_out_open_table proc~mus_fluid_save2lua->aot_out_val const const proc~mus_fluid_save2lua->const mus_nnwtn_save2lua mus_nnwtn_save2lua proc~mus_fluid_save2lua->mus_nnwtn_save2lua proc~mus_species_out->aot_out_close_table proc~mus_species_out->aot_out_open_table proc~mus_species_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~mus_fields_out~~CalledByGraph interface~mus_fields_out mus_fields_out proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine mus_fields_out_vec (me, conf, schemeHeader) write array of fields into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me (:) array of field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme private  subroutine mus_field_out_scal (me, conf, schemeHeader, level) write single field into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in), optional :: level To dump field with or without key","tags":"","loc":"interface/mus_fields_out.html"},{"title":"mus_updateSrcVar_dynSponFld – Musubi","text":"public  subroutine mus_updateSrcVar_dynSponFld(fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Compute density and velocity in sponge layer for dynamic sponge Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Calls proc~~mus_updatesrcvar_dynsponfld~~CallsGraph proc~mus_updatesrcvar_dynsponfld mus_updateSrcVar_dynSponFld auxfield_varpos auxfield_varpos proc~mus_updatesrcvar_dynsponfld->auxfield_varpos Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_updatesrcvar_dynsponfld.html"},{"title":"mus_add_internal_source_var – Musubi","text":"public  subroutine mus_add_internal_source_var(me, possVars, varSys, schemeHeader) Routine load musubi source terms for given key.\nkey is glob_source or source Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(out) :: me Source variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible source variables type( tem_varSys_type ), intent(inout) :: varSys Global variable system type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme Calls proc~~mus_add_internal_source_var~~CallsGraph proc~mus_add_internal_source_var mus_add_internal_source_var append append proc~mus_add_internal_source_var->append init init proc~mus_add_internal_source_var->init positionofval positionofval proc~mus_add_internal_source_var->positionofval tem_varSys_append_stfun tem_varSys_append_stfun proc~mus_add_internal_source_var->tem_varSys_append_stfun truncate truncate proc~mus_add_internal_source_var->truncate val val proc~mus_add_internal_source_var->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_add_internal_source_var~~CalledByGraph proc~mus_add_internal_source_var mus_add_internal_source_var proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_add_internal_source_var proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_add_internal_source_var.html"},{"title":"mus_assign_derived_functions_ptr – Musubi","text":"public  function mus_assign_derived_functions_ptr(label_stencil, label_fluid) result(getQuantities) This function assigns the pointers for the respective derived function in Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: label_stencil Scheme header information character(len=labelLen), intent(in) :: label_fluid Fluid label information Return Value type( mus_scheme_derived_quantities_type ) getQuantities function Called by proc~~mus_assign_derived_functions_ptr~~CalledByGraph proc~mus_assign_derived_functions_ptr mus_assign_derived_functions_ptr proc~mus_init_scheme mus_init_scheme proc~mus_init_scheme->proc~mus_assign_derived_functions_ptr proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_init_scheme program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_init_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_assign_derived_functions_ptr.html"},{"title":"get_pdfEq_incompressible_iDir – Musubi","text":"private pure function get_pdfEq_incompressible_iDir(rho, vel, iDir, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk)","tags":"","loc":"proc/get_pdfeq_incompressible_idir.html"},{"title":"get_pdfEq_compressible_iDir – Musubi","text":"private pure function get_pdfEq_compressible_iDir(rho, vel, iDir, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk)","tags":"","loc":"proc/get_pdfeq_compressible_idir.html"},{"title":"get_pdfEq_incompressible – Musubi","text":"private pure function get_pdfEq_incompressible(rho, vel, QQ, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ)","tags":"","loc":"proc/get_pdfeq_incompressible.html"},{"title":"get_pdfEq_compressible – Musubi","text":"private pure function get_pdfEq_compressible(rho, vel, QQ, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ)","tags":"","loc":"proc/get_pdfeq_compressible.html"},{"title":"get_sigma_d2q9 – Musubi","text":"private pure function get_sigma_d2q9(vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (9) Called by proc~~get_sigma_d2q9~~CalledByGraph proc~get_sigma_d2q9 get_sigma_d2q9 proc~get_pdfeq_d2q9 get_pdfEq_d2q9 proc~get_pdfeq_d2q9->proc~get_sigma_d2q9 proc~get_pdfeq_incomp_d2q9 get_pdfEq_incomp_d2q9 proc~get_pdfeq_incomp_d2q9->proc~get_sigma_d2q9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_sigma_d2q9.html"},{"title":"get_pdfEq_d2q9 – Musubi","text":"private pure function get_pdfEq_d2q9(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_d2q9~~CallsGraph proc~get_pdfeq_d2q9 get_pdfEq_d2q9 proc~get_sigma_d2q9 get_sigma_d2q9 proc~get_pdfeq_d2q9->proc~get_sigma_d2q9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_d2q9.html"},{"title":"get_pdfEq_incomp_d2q9 – Musubi","text":"private pure function get_pdfEq_incomp_d2q9(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_incomp_d2q9~~CallsGraph proc~get_pdfeq_incomp_d2q9 get_pdfEq_incomp_d2q9 proc~get_sigma_d2q9 get_sigma_d2q9 proc~get_pdfeq_incomp_d2q9->proc~get_sigma_d2q9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_incomp_d2q9.html"},{"title":"get_sigma_d3q19 – Musubi","text":"private pure function get_sigma_d3q19(vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (22) Called by proc~~get_sigma_d3q19~~CalledByGraph proc~get_sigma_d3q19 get_sigma_d3q19 proc~get_pdfeq_d3q19 get_pdfEq_d3q19 proc~get_pdfeq_d3q19->proc~get_sigma_d3q19 proc~get_pdfeq_incomp_d3q19 get_pdfEq_incomp_d3q19 proc~get_pdfeq_incomp_d3q19->proc~get_sigma_d3q19 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_sigma_d3q19.html"},{"title":"get_pdfEq_d3q19 – Musubi","text":"private pure function get_pdfEq_d3q19(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_d3q19~~CallsGraph proc~get_pdfeq_d3q19 get_pdfEq_d3q19 proc~get_sigma_d3q19 get_sigma_d3q19 proc~get_pdfeq_d3q19->proc~get_sigma_d3q19 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_d3q19.html"},{"title":"get_pdfEq_incomp_d3q19 – Musubi","text":"private pure function get_pdfEq_incomp_d3q19(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_incomp_d3q19~~CallsGraph proc~get_pdfeq_incomp_d3q19 get_pdfEq_incomp_d3q19 proc~get_sigma_d3q19 get_sigma_d3q19 proc~get_pdfeq_incomp_d3q19->proc~get_sigma_d3q19 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_incomp_d3q19.html"},{"title":"get_sigma_d3q27 – Musubi","text":"private pure function get_sigma_d3q27(vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (34) Called by proc~~get_sigma_d3q27~~CalledByGraph proc~get_sigma_d3q27 get_sigma_d3q27 proc~get_pdfeq_d3q27 get_pdfEq_d3q27 proc~get_pdfeq_d3q27->proc~get_sigma_d3q27 proc~get_pdfeq_incomp_d3q27 get_pdfEq_incomp_d3q27 proc~get_pdfeq_incomp_d3q27->proc~get_sigma_d3q27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_sigma_d3q27.html"},{"title":"get_pdfEq_d3q27 – Musubi","text":"private pure function get_pdfEq_d3q27(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_d3q27~~CallsGraph proc~get_pdfeq_d3q27 get_pdfEq_d3q27 proc~get_sigma_d3q27 get_sigma_d3q27 proc~get_pdfeq_d3q27->proc~get_sigma_d3q27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_d3q27.html"},{"title":"get_pdfEq_incomp_d3q27 – Musubi","text":"private pure function get_pdfEq_incomp_d3q27(rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) Calls proc~~get_pdfeq_incomp_d3q27~~CallsGraph proc~get_pdfeq_incomp_d3q27 get_pdfEq_incomp_d3q27 proc~get_sigma_d3q27 get_sigma_d3q27 proc~get_pdfeq_incomp_d3q27->proc~get_sigma_d3q27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_pdfeq_incomp_d3q27.html"},{"title":"get_vel_from_pdf_compressible – Musubi","text":"private pure function get_vel_from_pdf_compressible(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_compressible~~CalledByGraph proc~get_vel_from_pdf_compressible get_vel_from_pdf_compressible proc~get_vel_from_pdf_compressible_vectorized get_vel_from_pdf_compressible_vectorized proc~get_vel_from_pdf_compressible_vectorized->proc~get_vel_from_pdf_compressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_compressible.html"},{"title":"get_vel_from_pdf_compressible_vectorized – Musubi","text":"private pure function get_vel_from_pdf_compressible_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_compressible_vectorized~~CallsGraph proc~get_vel_from_pdf_compressible_vectorized get_vel_from_pdf_compressible_vectorized proc~get_vel_from_pdf_compressible get_vel_from_pdf_compressible proc~get_vel_from_pdf_compressible_vectorized->proc~get_vel_from_pdf_compressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_compressible_vectorized.html"},{"title":"get_vel_from_pdf_incompressible – Musubi","text":"private pure function get_vel_from_pdf_incompressible(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_incompressible~~CalledByGraph proc~get_vel_from_pdf_incompressible get_vel_from_pdf_incompressible proc~get_vel_from_pdf_incompressible_vectorized get_vel_from_pdf_incompressible_vectorized proc~get_vel_from_pdf_incompressible_vectorized->proc~get_vel_from_pdf_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_incompressible.html"},{"title":"get_vel_from_pdf_incompressible_vectorized – Musubi","text":"private pure function get_vel_from_pdf_incompressible_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_incompressible_vectorized~~CallsGraph proc~get_vel_from_pdf_incompressible_vectorized get_vel_from_pdf_incompressible_vectorized proc~get_vel_from_pdf_incompressible get_vel_from_pdf_incompressible proc~get_vel_from_pdf_incompressible_vectorized->proc~get_vel_from_pdf_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_incompressible_vectorized.html"},{"title":"get_vel_from_pdf_d2q9 – Musubi","text":"private pure function get_vel_from_pdf_d2q9(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d2q9 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d2q9~~CalledByGraph proc~get_vel_from_pdf_d2q9 get_vel_from_pdf_d2q9 proc~get_vel_from_pdf_d2q9_vectorized get_vel_from_pdf_d2q9_vectorized proc~get_vel_from_pdf_d2q9_vectorized->proc~get_vel_from_pdf_d2q9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d2q9.html"},{"title":"get_vel_from_pdf_d2q9_vectorized – Musubi","text":"private pure function get_vel_from_pdf_d2q9_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d2q9_vectorized~~CallsGraph proc~get_vel_from_pdf_d2q9_vectorized get_vel_from_pdf_d2q9_vectorized proc~get_vel_from_pdf_d2q9 get_vel_from_pdf_d2q9 proc~get_vel_from_pdf_d2q9_vectorized->proc~get_vel_from_pdf_d2q9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d2q9_vectorized.html"},{"title":"get_vel_from_pdf_d2q9_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d2q9_incompressible(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d2q9 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d2q9_incompressible~~CalledByGraph proc~get_vel_from_pdf_d2q9_incompressible get_vel_from_pdf_d2q9_incompressible proc~get_vel_from_pdf_d2q9_vectorized_incompressible get_vel_from_pdf_d2q9_vectorized_incompressible proc~get_vel_from_pdf_d2q9_vectorized_incompressible->proc~get_vel_from_pdf_d2q9_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d2q9_incompressible.html"},{"title":"get_vel_from_pdf_d2q9_vectorized_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d2q9_vectorized_incompressible(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d2q9_vectorized_incompressible~~CallsGraph proc~get_vel_from_pdf_d2q9_vectorized_incompressible get_vel_from_pdf_d2q9_vectorized_incompressible proc~get_vel_from_pdf_d2q9_incompressible get_vel_from_pdf_d2q9_incompressible proc~get_vel_from_pdf_d2q9_vectorized_incompressible->proc~get_vel_from_pdf_d2q9_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d2q9_vectorized_incompressible.html"},{"title":"get_vel_from_pdf_d3q19 – Musubi","text":"private pure function get_vel_from_pdf_d3q19(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q19 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d3q19~~CalledByGraph proc~get_vel_from_pdf_d3q19 get_vel_from_pdf_d3q19 proc~get_vel_from_pdf_d3q19_vectorized get_vel_from_pdf_d3q19_vectorized proc~get_vel_from_pdf_d3q19_vectorized->proc~get_vel_from_pdf_d3q19 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q19.html"},{"title":"get_vel_from_pdf_d3q19_vectorized – Musubi","text":"private pure function get_vel_from_pdf_d3q19_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d3q19_vectorized~~CallsGraph proc~get_vel_from_pdf_d3q19_vectorized get_vel_from_pdf_d3q19_vectorized proc~get_vel_from_pdf_d3q19 get_vel_from_pdf_d3q19 proc~get_vel_from_pdf_d3q19_vectorized->proc~get_vel_from_pdf_d3q19 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q19_vectorized.html"},{"title":"get_vel_from_pdf_d3q19_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d3q19_incompressible(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q19 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d3q19_incompressible~~CalledByGraph proc~get_vel_from_pdf_d3q19_incompressible get_vel_from_pdf_d3q19_incompressible proc~get_vel_from_pdf_d3q19_vectorized_incompressible get_vel_from_pdf_d3q19_vectorized_incompressible proc~get_vel_from_pdf_d3q19_vectorized_incompressible->proc~get_vel_from_pdf_d3q19_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q19_incompressible.html"},{"title":"get_vel_from_pdf_d3q19_vectorized_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d3q19_vectorized_incompressible(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d3q19_vectorized_incompressible~~CallsGraph proc~get_vel_from_pdf_d3q19_vectorized_incompressible get_vel_from_pdf_d3q19_vectorized_incompressible proc~get_vel_from_pdf_d3q19_incompressible get_vel_from_pdf_d3q19_incompressible proc~get_vel_from_pdf_d3q19_vectorized_incompressible->proc~get_vel_from_pdf_d3q19_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q19_vectorized_incompressible.html"},{"title":"get_vel_from_pdf_d3q27 – Musubi","text":"private pure function get_vel_from_pdf_d3q27(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q27 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d3q27~~CalledByGraph proc~get_vel_from_pdf_d3q27 get_vel_from_pdf_d3q27 proc~get_vel_from_pdf_d3q27_vectorized get_vel_from_pdf_d3q27_vectorized proc~get_vel_from_pdf_d3q27_vectorized->proc~get_vel_from_pdf_d3q27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q27.html"},{"title":"get_vel_from_pdf_d3q27_vectorized – Musubi","text":"private pure function get_vel_from_pdf_d3q27_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d3q27_vectorized~~CallsGraph proc~get_vel_from_pdf_d3q27_vectorized get_vel_from_pdf_d3q27_vectorized proc~get_vel_from_pdf_d3q27 get_vel_from_pdf_d3q27 proc~get_vel_from_pdf_d3q27_vectorized->proc~get_vel_from_pdf_d3q27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q27_vectorized.html"},{"title":"get_vel_from_pdf_d3q27_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d3q27_incompressible(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q27 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity Called by proc~~get_vel_from_pdf_d3q27_incompressible~~CalledByGraph proc~get_vel_from_pdf_d3q27_incompressible get_vel_from_pdf_d3q27_incompressible proc~get_vel_from_pdf_d3q27_vectorized_incompressible get_vel_from_pdf_d3q27_vectorized_incompressible proc~get_vel_from_pdf_d3q27_vectorized_incompressible->proc~get_vel_from_pdf_d3q27_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q27_incompressible.html"},{"title":"get_vel_from_pdf_d3q27_vectorized_incompressible – Musubi","text":"private pure function get_vel_from_pdf_d3q27_vectorized_incompressible(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity Calls proc~~get_vel_from_pdf_d3q27_vectorized_incompressible~~CallsGraph proc~get_vel_from_pdf_d3q27_vectorized_incompressible get_vel_from_pdf_d3q27_vectorized_incompressible proc~get_vel_from_pdf_d3q27_incompressible get_vel_from_pdf_d3q27_incompressible proc~get_vel_from_pdf_d3q27_vectorized_incompressible->proc~get_vel_from_pdf_d3q27_incompressible Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_vel_from_pdf_d3q27_vectorized_incompressible.html"},{"title":"get_momentum_from_vel_dens_compressible – Musubi","text":"private pure function get_momentum_from_vel_dens_compressible(vel, dens) result(vector) function pointer to get momentum from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk), (3) momentum","tags":"","loc":"proc/get_momentum_from_vel_dens_compressible.html"},{"title":"get_momentum_from_vel_dens_incompressible – Musubi","text":"private pure function get_momentum_from_vel_dens_incompressible(vel, dens) result(vector) function pointer to get momentum from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk), (3) momentum","tags":"","loc":"proc/get_momentum_from_vel_dens_incompressible.html"},{"title":"get_kineticEnergy_from_vel_dens_compressible – Musubi","text":"private pure function get_kineticEnergy_from_vel_dens_compressible(vel, dens) result(scalar) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy","tags":"","loc":"proc/get_kineticenergy_from_vel_dens_compressible.html"},{"title":"get_kineticEnergy_from_vel_dens_incompressible – Musubi","text":"private pure function get_kineticEnergy_from_vel_dens_incompressible(vel, dens) result(scalar) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy","tags":"","loc":"proc/get_kineticenergy_from_vel_dens_incompressible.html"},{"title":"get_rho0Inv_compressible – Musubi","text":"private pure function get_rho0Inv_compressible(dens) result(inv_rho0) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy","tags":"","loc":"proc/get_rho0inv_compressible.html"},{"title":"get_rho0Inv_incompressible – Musubi","text":"private pure function get_rho0Inv_incompressible(dens) result(inv_rho0) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy","tags":"","loc":"proc/get_rho0inv_incompressible.html"},{"title":"mus_abortCriteria_load – Musubi","text":"private  subroutine mus_abortCriteria_load(me, conf, abort_table) Loading Musubi specific abort criteria from the abort_criteria table. This routine is passed to the loading of abort criteria in tem_abortCriteria_load . Type Bound mus_abortCriteria_type Arguments Type Intent Optional Attributes Name class( mus_abortCriteria_type ), intent(inout) :: me Object to hold the solver specific configuration parameters. type( flu_State ), intent(in) :: conf Handle to the Lua script with the configuration. integer, intent(in) :: abort_table Handle to the opened abort_criteria table that holds the\nabort parameters to load. Calls proc~~mus_abortcriteria_load~~CallsGraph proc~mus_abortcriteria_load mus_abortCriteria_type%mus_abortCriteria_load aot_get_val aot_get_val proc~mus_abortcriteria_load->aot_get_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_abortcriteria_load.html"},{"title":"potential_nonEqExpol – Musubi","text":"public  subroutine potential_nonEqExpol(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise Dirichlet potential non-equilibrium boundary condition for curved\n and straight walls. For straight wall, physical boundary overlaps with\n boundary node i.e. qVal=0.0. The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part:\n f = f_eq(x_b,t) + f_neq(x_f,t) Usage boundary_condition = { { label = 'inner' , kind = 'potential_noneq_expol' , potential = pot_inner , } } For straight boundaries, qVal=1.0:\n Luo, K., Wu, J., Yi, H., & Tan, H. (2016). Lattice Boltzmann model for\n Coulomb-driven flows in dielectric liquids dielectric liquids.\n Physical Review E, 23309(93), 1–11.\n http://doi.org/10.1103/PhysRevE.93.023309 This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\n callable via boundary_type function pointer. Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~potential_noneqexpol~~CallsGraph proc~potential_noneqexpol potential_nonEqExpol get_valofindex get_valofindex proc~potential_noneqexpol->get_valofindex idir idir proc~potential_noneqexpol->idir links links proc~potential_noneqexpol->links neigh neigh proc~potential_noneqexpol->neigh neighbufferpost neighbufferpost proc~potential_noneqexpol->neighbufferpost nelems nelems proc~potential_noneqexpol->nelems noneqexpol noneqexpol proc~potential_noneqexpol->noneqexpol posinbcelems posinbcelems proc~potential_noneqexpol->posinbcelems posinbuffer posinbuffer proc~potential_noneqexpol->posinbuffer posinneighbuf posinneighbuf proc~potential_noneqexpol->posinneighbuf val val proc~potential_noneqexpol->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/potential_noneqexpol.html"},{"title":"potential_nonEqExpol_curved – Musubi","text":"public  subroutine potential_nonEqExpol_curved(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise Dirichlet potential non-equilibrium boundary condition for curved\n wall The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part:\n f = f_eq + f_neq\n - f_eq is calculated by weighting a fictitious potential, which is obtained\n   by an extrapolation using the fluid neighbor(s)\n - f_neq is approximated by second-order extrapolation using the fluid\n   neighbor(s)\n - for qVal < 0.75 even the second neighbor is used for the extrapolations\n - Dirichlet: potential on wall is directly known\n - Linkwise: as much as possible is outsourced to the subroutine\n             \"mus_set_nonEqExpol\" Usage boundary_condition = { { label = 'inner' , kind = 'potential_noneq_expol' , potential = pot_inner , curved = true } } This is described in the paper:\n Luo, K.; Wu, J.; Yi HL. & Tan HP. (2016). A lattice Boltzmann method for\n electric field-space charge coupled problems.\n Proceedings of the 2016 Electrostatics Joint Conference (June 2016). This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\n callable via boundary_type function pointer. Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~potential_noneqexpol_curved~~CallsGraph proc~potential_noneqexpol_curved potential_nonEqExpol_curved c_f c_f proc~potential_noneqexpol_curved->c_f c_ff c_ff proc~potential_noneqexpol_curved->c_ff c_neq_f c_neq_f proc~potential_noneqexpol_curved->c_neq_f c_neq_ff c_neq_ff proc~potential_noneqexpol_curved->c_neq_ff c_w c_w proc~potential_noneqexpol_curved->c_w get_valofindex get_valofindex proc~potential_noneqexpol_curved->get_valofindex idir idir proc~potential_noneqexpol_curved->idir links links proc~potential_noneqexpol_curved->links neighbufferpost neighbufferpost proc~potential_noneqexpol_curved->neighbufferpost posinbuffer posinbuffer proc~potential_noneqexpol_curved->posinbuffer posinneighbuf posinneighbuf proc~potential_noneqexpol_curved->posinneighbuf val val proc~potential_noneqexpol_curved->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/potential_noneqexpol_curved.html"},{"title":"potential_neumann – Musubi","text":"public  subroutine potential_neumann(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise neumann potential non-equilibrium boundary condition for curved\n and straight walls (zero gradient).\n For straight wall, values are extrapolated along\n boundary normal instead of along the link. The accuracy of straight wall\n depends on the qVal defined in config file and default is set to 0.5 The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part:\n - f_eq is calculated by weighting a fictitious potential, which is obtained\n   by an extrapolation using the fluid neighbor(s)\n - f_neq is approximated by second-order extrapolation using the fluid\n   neighbor(s)\n - for qVal < 0.75 even the second neighbor is used for the extrapolations\n - boundary potential (pot_b) has to be extrapolated using two fluid neighb:\n   pot_b = (4*pot_f - pot_ff)/3 (typo in paper)\n - Linkwise: as much as possible is outsourced to the subroutine\n             \"mus_set_nonEqExpol\" NOTE: - possibility to extend the equation to extraplotate pot_b by a\n         gradient if a non-zero one is desired\n         (see: Huang H, Lee T S, and Shu C. “Thermal curved boundary\n               treatment for the thermal lattice Boltzmann equation,”\n               Int. J. Mod. Phys. C, vol. 17(05), pp. 631-643, 2006)\n       - more accurate schemes to determine pot_b can be found in:\n         Chen Q, Zhang X, and Zhang J. “Improved treatments for general\n         boundary conditions in the lattice Boltzmann method for convection-\n         diffusion and heat transfer processes,” Phys Rev E, vol. 88(3),\n         033304, 2013 Usage boundary_condition = { { label = 'outer' , kind = 'potential_neumann_link' , curved = true } } This is described in the paper:\n Luo, K.; Wu, J.; Yi HL. & Tan HP. (2016). A lattice Boltzmann method for\n electric field-space charge coupled problems.\n Proceedings of the 2016 Electrostatics Joint Conference (June 2016). This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\n callable via boundary_type function pointer. Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~potential_neumann~~CallsGraph proc~potential_neumann potential_neumann cxdirrk cxdirrk proc~potential_neumann->cxdirrk get_valofindex get_valofindex proc~potential_neumann->get_valofindex idir idir proc~potential_neumann->idir links links proc~potential_neumann->links neigh neigh proc~potential_neumann->neigh neighbufferpost neighbufferpost proc~potential_neumann->neighbufferpost noneqexpol noneqexpol proc~potential_neumann->noneqexpol posinbcelems posinbcelems proc~potential_neumann->posinbcelems posinbuffer posinbuffer proc~potential_neumann->posinbuffer posinneighbuf posinneighbuf proc~potential_neumann->posinneighbuf val val proc~potential_neumann->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/potential_neumann.html"},{"title":"potential_neumann_curved – Musubi","text":"public  subroutine potential_neumann_curved(me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Todo add comment This subroutine's interface must match the abstract interface definition boundaryRoutine in bc/ mus_bc_header_module .f90 in order to be\ncallable via boundary_type function pointer. Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info Calls proc~~potential_neumann_curved~~CallsGraph proc~potential_neumann_curved potential_neumann_curved c_neq_f c_neq_f proc~potential_neumann_curved->c_neq_f c_neq_ff c_neq_ff proc~potential_neumann_curved->c_neq_ff cxdirrk cxdirrk proc~potential_neumann_curved->cxdirrk get_valofindex get_valofindex proc~potential_neumann_curved->get_valofindex idir idir proc~potential_neumann_curved->idir links links proc~potential_neumann_curved->links neighbufferpost neighbufferpost proc~potential_neumann_curved->neighbufferpost posinbcelems posinbcelems proc~potential_neumann_curved->posinbcelems posinbuffer posinbuffer proc~potential_neumann_curved->posinbuffer posinneighbuf posinneighbuf proc~potential_neumann_curved->posinneighbuf val val proc~potential_neumann_curved->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/potential_neumann_curved.html"},{"title":"mus_load_absorbLayer – Musubi","text":"public  subroutine mus_load_absorbLayer(me, conf, key, parent, loadPres, loadVel) This routine load additional information for absorblayer Arguments Type Intent Optional Attributes Name type( absorbLayer_config_type ), intent(out) :: me Absorb layer type( flu_State ) :: conf flu state character(len=*), intent(in) :: key Table name to load target states integer, intent(in) :: parent parent source handle logical, intent(in) :: loadPres Load pressure if true else set to dynamic logical, intent(in) :: loadVel Load velocity if true else set to dynamic Calls proc~~mus_load_absorblayer~~CallsGraph proc~mus_load_absorblayer mus_load_absorbLayer aot_get_val aot_get_val proc~mus_load_absorblayer->aot_get_val aot_table_close aot_table_close proc~mus_load_absorblayer->aot_table_close aot_table_open aot_table_open proc~mus_load_absorblayer->aot_table_open tem_abort tem_abort proc~mus_load_absorblayer->tem_abort upper_to_lower upper_to_lower proc~mus_load_absorblayer->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_absorblayer~~CalledByGraph proc~mus_load_absorblayer mus_load_absorbLayer proc~mus_load_source_var mus_load_source_var proc~mus_load_source_var->proc~mus_load_absorblayer proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_source_var proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_source_var proc~mus_load_fields mus_load_fields proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme proc~mus_load_fields->proc~mus_load_field_single proc~mus_hvs_config_load mus_hvs_config_load proc~mus_hvs_config_load->proc~mus_hvs_load_solverdata program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_absorblayer.html"},{"title":"mus_init_absorbLayer – Musubi","text":"public  subroutine mus_init_absorbLayer(absLayer, dynAvg, nElems) Initialize arrays to store time average density and velocity for\ndynamic absorbing layer.\n\\todo KM: 20210301 Allocate only pressure or velocity depending on\nabsorb_layer_inlet or absorb_layer_outlet Arguments Type Intent Optional Attributes Name type( mus_absorbLayer_type ), intent(inout) :: absLayer Absorblayer type type( mus_absorbLayer_dynAvg_type ), intent(inout) :: dynAvg Contains dynamic average density and velocity for absorblayer integer, intent(in) :: nElems Number of source elements Called by proc~~mus_init_absorblayer~~CalledByGraph proc~mus_init_absorblayer mus_init_absorbLayer proc~mus_setupindices_forsrc mus_setupIndices_forSrc proc~mus_setupindices_forsrc->proc~mus_init_absorblayer proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_sourceterms->proc~mus_setupindices_forsrc proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_reset_aux mus_reset_aux proc~mus_reset_aux->proc~mus_init_sourceterms proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~mus_reset_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_absorblayer.html"},{"title":"check_flow_status – Musubi","text":"public  subroutine check_flow_status(scheme, geometry, general, physics, mus_aborts, restart_triggered) This routine performs several tasks: geometry increment, time updating,\ntracking, density checking, restart Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( tem_general_type ), intent(inout) :: general Global parameters type( mus_physics_type ), intent(in) :: physics physics conversion tyoe type( mus_abortCriteria_type ), intent(in) :: mus_aborts logical, intent(inout) :: restart_triggered Indication whether a restart output was triggered Calls proc~~check_flow_status~~CallsGraph proc~check_flow_status check_flow_status mus_calcbndforce mus_calcbndforce proc~check_flow_status->mus_calcbndforce mus_geomincr mus_geomincr proc~check_flow_status->mus_geomincr proc~mus_dumpdata mus_dumpData proc~check_flow_status->proc~mus_dumpdata proc~perform_checks perform_checks proc~check_flow_status->proc~perform_checks tem_convergence_check tem_convergence_check proc~check_flow_status->tem_convergence_check tem_opVar_reduction_transient_update tem_opVar_reduction_transient_update proc~check_flow_status->tem_opVar_reduction_transient_update tem_simControl_syncUpdate tem_simControl_syncUpdate proc~check_flow_status->tem_simControl_syncUpdate val val proc~check_flow_status->val proc~mus_writerestart mus_writeRestart proc~mus_dumpdata->proc~mus_writerestart tem_timeControl_check tem_timeControl_check proc~mus_dumpdata->tem_timeControl_check tem_time_dump tem_time_dump proc~mus_dumpdata->tem_time_dump tem_tracker tem_tracker proc~mus_dumpdata->tem_tracker proc~check_density check_density proc~perform_checks->proc~check_density proc~check_potential check_potential proc~perform_checks->proc~check_potential proc~check_velocityfluid check_velocityFluid proc~perform_checks->proc~check_velocityfluid proc~check_velocityms check_velocityMS proc~perform_checks->proc~check_velocityms proc~mus_check_omegakine mus_check_omegaKine proc~perform_checks->proc~mus_check_omegakine tem_abort tem_abort proc~perform_checks->tem_abort tem_timeControl_globalTriggered tem_timeControl_globalTriggered proc~perform_checks->tem_timeControl_globalTriggered proc~check_density->tem_time_dump auxfield_varpos auxfield_varpos proc~check_density->auxfield_varpos bits bits proc~check_density->bits mpi_reduce mpi_reduce proc~check_density->mpi_reduce tem_isNaN tem_isNaN proc~check_density->tem_isNaN total total proc~check_density->total proc~check_potential->tem_time_dump proc~check_potential->bits proc~check_potential->mpi_reduce proc~check_potential->tem_isNaN proc~check_velocityfluid->auxfield_varpos proc~check_velocityfluid->bits proc~check_velocityfluid->mpi_reduce proc~check_velocityfluid->tem_isNaN proc~check_velocityms->auxfield_varpos proc~check_velocityms->bits proc~check_velocityms->mpi_reduce proc~check_velocityms->tem_isNaN proc~mus_check_omegakine->tem_abort proc~mus_check_omegakine->bits proc~mus_check_omegakine->mpi_reduce mus_pdf_serialize mus_pdf_serialize proc~mus_writerestart->mus_pdf_serialize tem_restart_closeWrite tem_restart_closeWrite proc~mus_writerestart->tem_restart_closeWrite tem_restart_openWrite tem_restart_openWrite proc~mus_writerestart->tem_restart_openWrite tem_restart_writeData tem_restart_writeData proc~mus_writerestart->tem_restart_writeData tem_startTimer tem_startTimer proc~mus_writerestart->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_writerestart->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_flow_status.html"},{"title":"mus_banner – Musubi","text":"public  subroutine mus_banner(solver) Initialize musubi solverHead and print musubi banner to screen Arguments Type Intent Optional Attributes Name type( tem_solveHead_type ), intent(in) :: solver solver definition Calls proc~~mus_banner~~CallsGraph proc~mus_banner mus_banner mus_print_ppinfo mus_print_ppinfo proc~mus_banner->mus_print_ppinfo tem_print_execInfo tem_print_execInfo proc~mus_banner->tem_print_execInfo utc_date_string utc_date_string proc~mus_banner->utc_date_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_banner~~CalledByGraph proc~mus_banner mus_banner program~musubi musubi program~musubi->proc~mus_banner Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_banner.html"},{"title":"mus_init_aux – Musubi","text":"public  subroutine mus_init_aux(scheme, geometry, params) Init auxiliary features such as interpolation boundaries, restart and\nthe tracker initialize fluid type which contains relaxation parameter\nand function pointers to get mrt paramter and nonEqScaling factor\nfor interpolation Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry information type( mus_param_type ), intent(inout) :: params global parameters Calls proc~~mus_init_aux~~CallsGraph proc~mus_init_aux mus_init_aux convergence convergence proc~mus_init_aux->convergence debug_dependencies debug_dependencies proc~mus_init_aux->debug_dependencies dump_intplists dump_intplists proc~mus_init_aux->dump_intplists mus_ibm_setparentids mus_ibm_setparentids proc~mus_init_aux->mus_ibm_setparentids mus_init_bndforce mus_init_bndforce proc~mus_init_aux->mus_init_bndforce mus_init_geomincr mus_init_geomincr proc~mus_init_aux->mus_init_geomincr mus_init_graddata mus_init_graddata proc~mus_init_aux->mus_init_graddata mus_init_interpolate mus_init_interpolate proc~mus_init_aux->mus_init_interpolate proc~check_streaming_layout check_streaming_layout proc~mus_init_aux->proc~check_streaming_layout proc~mus_init_fluid mus_init_fluid proc~mus_init_aux->proc~mus_init_fluid proc~mus_init_sourceterms mus_init_sourceTerms proc~mus_init_aux->proc~mus_init_sourceterms proc~mus_init_tracker mus_init_tracker proc~mus_init_aux->proc~mus_init_tracker proc~mus_init_transport_var mus_init_transport_var proc~mus_init_aux->proc~mus_init_transport_var proc~mus_time_homogenize mus_time_homogenize proc~mus_init_aux->proc~mus_time_homogenize proc~mus_timecontrol_homogenize mus_timeControl_homogenize proc~mus_init_aux->proc~mus_timecontrol_homogenize tem_abort tem_abort proc~mus_init_aux->tem_abort tem_create_subTree_of_st_funList tem_create_subTree_of_st_funList proc~mus_init_aux->tem_create_subTree_of_st_funList tem_horizontalSpacer tem_horizontalSpacer proc~mus_init_aux->tem_horizontalSpacer tem_init_convergence tem_init_convergence proc~mus_init_aux->tem_init_convergence tem_init_restart tem_init_restart proc~mus_init_aux->tem_init_restart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_init_aux.html"},{"title":"mus_update_relaxParams – Musubi","text":"public  subroutine mus_update_relaxParams(scheme, iLevel, tNow, physics, lattice, nBCs) Set relaxation parameters for MRT Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type integer, intent(in) :: iLevel level type( tem_time_type ), intent(in) :: tNow global parameters type( mus_physics_type ), intent(in) :: physics contains factors to convert physical to lattice unit and vice versa type( mus_latticeUnit_type ), intent(in) :: lattice contains lattice dx and dt integer, intent(in) :: nBCs Number of boundaries Calls proc~~mus_update_relaxparams~~CallsGraph proc~mus_update_relaxparams mus_update_relaxParams nelems nelems proc~mus_update_relaxparams->nelems proc~mus_turb_updateviscofturbwall mus_turb_updateViscOfTurbWall proc~mus_update_relaxparams->proc~mus_turb_updateviscofturbwall proc~mus_update_relaxparamkine mus_update_relaxParamKine proc~mus_update_relaxparams->proc~mus_update_relaxparamkine proc~mus_update_visckine mus_update_viscKine proc~mus_update_relaxparams->proc~mus_update_visckine proc~setparameters_multispecies setParameters_multispecies proc~mus_update_relaxparams->proc~setparameters_multispecies tvisc tvisc proc~mus_update_relaxparams->tvisc val val proc~mus_update_relaxparamkine->val auxfield_varpos auxfield_varpos proc~mus_update_visckine->auxfield_varpos calcvisc calcvisc proc~mus_update_visckine->calcvisc proc~mus_turb_calcvisc mus_turb_calcVisc proc~mus_update_visckine->proc~mus_turb_calcvisc tem_spacetime_for tem_spacetime_for proc~mus_update_visckine->tem_spacetime_for proc~mus_update_visckine->val invert_matrix invert_matrix proc~setparameters_multispecies->invert_matrix tem_temporal_for tem_temporal_for proc~setparameters_multispecies->tem_temporal_for Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_update_relaxparams~~CalledByGraph proc~mus_update_relaxparams mus_update_relaxParams proc~do_benchmark do_benchmark proc~do_benchmark->proc~mus_update_relaxparams proc~do_fast_singlelevel do_fast_singleLevel proc~do_fast_singlelevel->proc~mus_update_relaxparams proc~do_recursive_multilevel do_recursive_multiLevel proc~do_recursive_multilevel->proc~mus_update_relaxparams Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_update_relaxparams.html"},{"title":"mus_dumpData – Musubi","text":"public  subroutine mus_dumpData(scheme, tree, levelPointer, general, restart_triggered) This routine dumps tracking and restart when timeControl is active Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( treelmesh_type ), intent(in) :: tree Treelmesh data integer, intent(in) :: levelPointer (:) Level Pointer type( tem_general_type ), intent(inout) :: general Global parameters logical, intent(inout) :: restart_triggered Calls proc~~mus_dumpdata~~CallsGraph proc~mus_dumpdata mus_dumpData proc~mus_writerestart mus_writeRestart proc~mus_dumpdata->proc~mus_writerestart tem_timeControl_check tem_timeControl_check proc~mus_dumpdata->tem_timeControl_check tem_time_dump tem_time_dump proc~mus_dumpdata->tem_time_dump tem_tracker tem_tracker proc~mus_dumpdata->tem_tracker mus_pdf_serialize mus_pdf_serialize proc~mus_writerestart->mus_pdf_serialize tem_restart_closeWrite tem_restart_closeWrite proc~mus_writerestart->tem_restart_closeWrite tem_restart_openWrite tem_restart_openWrite proc~mus_writerestart->tem_restart_openWrite tem_restart_writeData tem_restart_writeData proc~mus_writerestart->tem_restart_writeData tem_startTimer tem_startTimer proc~mus_writerestart->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_writerestart->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_dumpdata~~CalledByGraph proc~mus_dumpdata mus_dumpData proc~check_flow_status check_flow_status proc~check_flow_status->proc~mus_dumpdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_dumpdata.html"},{"title":"mus_load_field_prop – Musubi","text":"public  subroutine mus_load_field_prop(me, conf, parent, minLevel, schemeHeader, nFields, physics, cs_lattice) load fluid properties like fluid and species table from\nlua file based on the scheme kind Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(out) :: me field property type type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent lua handle integer, intent(in) :: minLevel type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields defined in lua file type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout Calls proc~~mus_load_field_prop~~CallsGraph proc~mus_load_field_prop mus_load_field_prop proc~mus_load_fluid mus_load_fluid proc~mus_load_field_prop->proc~mus_load_fluid proc~mus_load_poisson mus_load_poisson proc~mus_load_field_prop->proc~mus_load_poisson proc~mus_load_species mus_load_species proc~mus_load_field_prop->proc~mus_load_species tem_abort tem_abort proc~mus_load_field_prop->tem_abort proc~mus_load_fluid->tem_abort aot_get_val aot_get_val proc~mus_load_fluid->aot_get_val aot_table_close aot_table_close proc~mus_load_fluid->aot_table_close aot_table_open aot_table_open proc~mus_load_fluid->aot_table_open mus_nnwtn_load mus_nnwtn_load proc~mus_load_fluid->mus_nnwtn_load proc~mus_load_turbulence mus_load_turbulence proc~mus_load_fluid->proc~mus_load_turbulence tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_fluid->tem_horizontalSpacer tem_load_spacetime tem_load_spacetime proc~mus_load_fluid->tem_load_spacetime proc~mus_load_poisson->tem_abort proc~mus_load_poisson->aot_get_val proc~mus_load_poisson->aot_table_close proc~mus_load_poisson->aot_table_open proc~mus_load_poissonboltzmann mus_load_poissonBoltzmann proc~mus_load_poisson->proc~mus_load_poissonboltzmann tem_toStr tem_toStr proc~mus_load_poisson->tem_toStr proc~mus_load_species->tem_abort proc~mus_load_species->aot_get_val proc~mus_load_species->aot_table_close aot_table_length aot_table_length proc~mus_load_species->aot_table_length proc~mus_load_species->aot_table_open proc~mus_load_species->tem_horizontalSpacer proc~mus_load_poissonboltzmann->tem_abort proc~mus_load_poissonboltzmann->aot_get_val proc~mus_load_poissonboltzmann->aot_table_close proc~mus_load_poissonboltzmann->aot_table_length proc~mus_load_poissonboltzmann->aot_table_open proc~mus_load_turbulence->tem_abort proc~mus_load_turbulence->aot_get_val proc~mus_load_turbulence->aot_table_close proc~mus_load_turbulence->aot_table_open proc~mus_load_turbulence->tem_horizontalSpacer upper_to_lower upper_to_lower proc~mus_load_turbulence->upper_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_load_field_prop~~CalledByGraph proc~mus_load_field_prop mus_load_field_prop proc~mus_load_field_single mus_load_field_single proc~mus_load_field_single->proc~mus_load_field_prop proc~mus_load_fields mus_load_fields proc~mus_load_fields->proc~mus_load_field_single proc~mus_load_scheme mus_load_scheme proc~mus_load_scheme->proc~mus_load_fields proc~mus_hvs_load_solverdata mus_hvs_load_solverData proc~mus_hvs_load_solverdata->proc~mus_load_scheme proc~mus_load_config mus_load_config proc~mus_load_config->proc~mus_load_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_load_field_prop.html"},{"title":"mus_field_prop_out – Musubi","text":"public  subroutine mus_field_prop_out(me, conf, schemeHeader) write field prop into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme Calls proc~~mus_field_prop_out~~CallsGraph proc~mus_field_prop_out mus_field_prop_out proc~mus_fluid_save2lua mus_fluid_save2lua proc~mus_field_prop_out->proc~mus_fluid_save2lua proc~mus_species_out mus_species_out proc~mus_field_prop_out->proc~mus_species_out aot_out_close_table aot_out_close_table proc~mus_fluid_save2lua->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_fluid_save2lua->aot_out_open_table aot_out_val aot_out_val proc~mus_fluid_save2lua->aot_out_val const const proc~mus_fluid_save2lua->const mus_nnwtn_save2lua mus_nnwtn_save2lua proc~mus_fluid_save2lua->mus_nnwtn_save2lua proc~mus_species_out->aot_out_close_table proc~mus_species_out->aot_out_open_table proc~mus_species_out->aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_field_prop_out~~CalledByGraph proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal mus_field_out_scal proc~mus_field_out_scal->proc~mus_field_prop_out interface~mus_fields_out mus_fields_out interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_fields_out_vec->proc~mus_field_out_scal proc~mus_scheme_out mus_scheme_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_writesolverspecinfo mus_writeSolverSpecInfo proc~mus_writesolverspecinfo->proc~mus_scheme_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_field_prop_out.html"},{"title":"mus_hvs_init_aux – Musubi","text":"public  subroutine mus_hvs_init_aux(scheme, geometry, params) Init auxiliary features such as interpolation boundaries, restart and\nthe tracker initialize fluid type which contains relaxation parameter\nand function pointers to get mrt paramter and nonEqScaling factor\nfor interpolation Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters Calls proc~~mus_hvs_init_aux~~CallsGraph proc~mus_hvs_init_aux mus_hvs_init_aux debug_dependencies debug_dependencies proc~mus_hvs_init_aux->debug_dependencies dump_intplists dump_intplists proc~mus_hvs_init_aux->dump_intplists mus_init_bndforce mus_init_bndforce proc~mus_hvs_init_aux->mus_init_bndforce mus_init_graddata mus_init_graddata proc~mus_hvs_init_aux->mus_init_graddata mus_init_interpolate mus_init_interpolate proc~mus_hvs_init_aux->mus_init_interpolate proc~check_streaming_layout check_streaming_layout proc~mus_hvs_init_aux->proc~check_streaming_layout proc~mus_init_fluid mus_init_fluid proc~mus_hvs_init_aux->proc~mus_init_fluid proc~mus_init_tracker mus_init_tracker proc~mus_hvs_init_aux->proc~mus_init_tracker proc~mus_time_homogenize mus_time_homogenize proc~mus_hvs_init_aux->proc~mus_time_homogenize tem_abort tem_abort proc~mus_hvs_init_aux->tem_abort tem_create_subTree_of_st_funList tem_create_subTree_of_st_funList proc~mus_hvs_init_aux->tem_create_subTree_of_st_funList tem_horizontalSpacer tem_horizontalSpacer proc~mus_hvs_init_aux->tem_horizontalSpacer tem_init_restart tem_init_restart proc~mus_hvs_init_aux->tem_init_restart init init proc~mus_init_fluid->init mus_assign_mrt_ptr mus_assign_mrt_ptr proc~mus_init_fluid->mus_assign_mrt_ptr mus_assign_nnwtnvisc_ptr mus_assign_nnwtnvisc_ptr proc~mus_init_fluid->mus_assign_nnwtnvisc_ptr proc~mus_assign_turbvisc_ptr mus_assign_turbVisc_ptr proc~mus_init_fluid->proc~mus_assign_turbvisc_ptr proc~mus_fluid_dump mus_fluid_dump proc~mus_init_fluid->proc~mus_fluid_dump proc~mus_init_relaxparam mus_init_relaxParam proc~mus_init_fluid->proc~mus_init_relaxparam proc~mus_init_turbulencedata mus_init_turbulenceData proc~mus_init_fluid->proc~mus_init_turbulencedata proc~mus_update_relaxparamfromviscstfun mus_update_relaxParamFromViscSTfun proc~mus_init_fluid->proc~mus_update_relaxparamfromviscstfun config config proc~mus_init_tracker->config instance instance proc~mus_init_tracker->instance proc~mus_timecontrol_homogenize mus_timeControl_homogenize proc~mus_init_tracker->proc~mus_timecontrol_homogenize tem_init_tracker tem_init_tracker proc~mus_init_tracker->tem_init_tracker tem_init_tracker_subTree tem_init_tracker_subTree proc~mus_init_tracker->tem_init_tracker_subTree tem_time_dump tem_time_dump proc~mus_time_homogenize->tem_time_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mus_hvs_init_aux~~CalledByGraph proc~mus_hvs_init_aux mus_hvs_init_aux program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_hvs_init_aux.html"},{"title":"get_uPlus – Musubi","text":"private pure function get_uPlus(yPlus) result(uPlus) function to get uPlus Type Bound mus_wall_function_musker_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk)","tags":"","loc":"proc/get_uplus~2.html"},{"title":"get_d_uPlus_d_uTau – Musubi","text":"private pure function get_d_uPlus_d_uTau(y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Type Bound mus_wall_function_musker_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"proc/get_d_uplus_d_utau~2.html"},{"title":"calc_MLUPS – Musubi","text":"private pure function calc_MLUPS(minLevel, maxLevel, scaleFactor, nElems, iter, time) result(mlups) Calculate the MLUPS or MFLUPS for the simulation Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel level range integer, intent(in) :: maxLevel level range integer, intent(in) :: scaleFactor global parameter integer(kind=long_k), intent(in) :: nElems (minLevel:maxLevel) array of nElems levelwise integer, intent(in) :: iter number of iterations on maxLevel\nnumber of iteration on iLevel = iter / scaleFactor**(maxLevel-iLevel) real(kind=rk), intent(in) :: time time consumed for running iter iterations Return Value real(kind=rk) resulting mlups Called by proc~~calc_mlups~~CalledByGraph proc~calc_mlups calc_MLUPS proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~calc_mlups Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_mlups.html"},{"title":"perform_checks – Musubi","text":"public  subroutine perform_checks(scheme, minLevel, maxLevel, general, mus_aborts, initCheck) Perform run-time checks if interval is active Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts logical, intent(in) :: initCheck True for initial check before main time toop Calls proc~~perform_checks~~CallsGraph proc~perform_checks perform_checks proc~check_density check_density proc~perform_checks->proc~check_density proc~check_potential check_potential proc~perform_checks->proc~check_potential proc~check_velocityfluid check_velocityFluid proc~perform_checks->proc~check_velocityfluid proc~check_velocityms check_velocityMS proc~perform_checks->proc~check_velocityms proc~mus_check_omegakine mus_check_omegaKine proc~perform_checks->proc~mus_check_omegakine tem_abort tem_abort proc~perform_checks->tem_abort tem_timeControl_globalTriggered tem_timeControl_globalTriggered proc~perform_checks->tem_timeControl_globalTriggered auxfield_varpos auxfield_varpos proc~check_density->auxfield_varpos bits bits proc~check_density->bits mpi_reduce mpi_reduce proc~check_density->mpi_reduce tem_isNaN tem_isNaN proc~check_density->tem_isNaN tem_time_dump tem_time_dump proc~check_density->tem_time_dump total total proc~check_density->total proc~check_potential->bits proc~check_potential->mpi_reduce proc~check_potential->tem_isNaN proc~check_potential->tem_time_dump proc~check_velocityfluid->auxfield_varpos proc~check_velocityfluid->bits proc~check_velocityfluid->mpi_reduce proc~check_velocityfluid->tem_isNaN proc~check_velocityms->auxfield_varpos proc~check_velocityms->bits proc~check_velocityms->mpi_reduce proc~check_velocityms->tem_isNaN proc~mus_check_omegakine->tem_abort proc~mus_check_omegakine->bits proc~mus_check_omegakine->mpi_reduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~perform_checks~~CalledByGraph proc~perform_checks perform_checks proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/perform_checks.html"},{"title":"check_potential – Musubi","text":"public  subroutine check_potential(scheme, minLevel, maxLevel, general, total_potential) Check the total potential for poisson scheme The output might be delayed by using arrays which are then dumped\nto keep disc access more restricted Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general real(kind=rk), intent(out), optional :: total_potential Calls proc~~check_potential~~CallsGraph proc~check_potential check_potential bits bits proc~check_potential->bits mpi_reduce mpi_reduce proc~check_potential->mpi_reduce tem_isNaN tem_isNaN proc~check_potential->tem_isNaN tem_time_dump tem_time_dump proc~check_potential->tem_time_dump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_potential~~CalledByGraph proc~check_potential check_potential proc~perform_checks perform_checks proc~perform_checks->proc~check_potential proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_potential.html"},{"title":"check_density – Musubi","text":"public  subroutine check_density(scheme, minLevel, maxLevel, general, total_density) Check the total density for a selected scheme and write to unit The output might be delayed by using arrays which are then dumped\nto keep disc access more restricted Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general real(kind=rk), intent(out), optional :: total_density Calls proc~~check_density~~CallsGraph proc~check_density check_density auxfield_varpos auxfield_varpos proc~check_density->auxfield_varpos bits bits proc~check_density->bits mpi_reduce mpi_reduce proc~check_density->mpi_reduce tem_isNaN tem_isNaN proc~check_density->tem_isNaN tem_time_dump tem_time_dump proc~check_density->tem_time_dump total total proc~check_density->total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_density~~CalledByGraph proc~check_density check_density proc~perform_checks perform_checks proc~perform_checks->proc~check_density proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_density.html"},{"title":"mus_perf_measure – Musubi","text":"public  subroutine mus_perf_measure(totalDens, DomSize, minLevel, maxLevel, nElems, scaleFactor, general) This routine measures performance imbalance, MLUPS and dumps timings\nto disk Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: totalDens Total density from check_density integer(kind=long_k), intent(in) :: DomSize Total number of elements in tree integer, intent(in) :: minLevel level range integer, intent(in) :: maxLevel level range integer, intent(in) :: nElems (minLevel:maxLevel) array of nElems levelwise integer, intent(in) :: scaleFactor global parameter type( tem_general_type ), intent(in) :: general Contains proc, simControl, solveHead Calls proc~~mus_perf_measure~~CallsGraph proc~mus_perf_measure mus_perf_measure interface~get_computetime get_computeTime proc~mus_perf_measure->interface~get_computetime mpi_allreduce mpi_allreduce proc~mus_perf_measure->mpi_allreduce proc~calc_mlups calc_MLUPS proc~mus_perf_measure->proc~calc_mlups proc~dump_timing dump_timing proc~mus_perf_measure->proc~dump_timing proc~get_communicatetime get_communicateTime proc~mus_perf_measure->proc~get_communicatetime proc~get_mainlooptime get_mainLoopTime proc~mus_perf_measure->proc~get_mainlooptime tem_calc_imbalance tem_calc_imbalance proc~mus_perf_measure->tem_calc_imbalance tem_getMaxTimerVal tem_getMaxTimerVal proc~mus_perf_measure->tem_getMaxTimerVal proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total interface~get_auxtime get_auxTime proc~dump_timing->interface~get_auxtime interface~get_bcbufferratio get_bcBufferRatio proc~dump_timing->interface~get_bcbufferratio interface~get_computeratio get_computeRatio proc~dump_timing->interface~get_computeratio interface~get_relaxtime get_relaxTime proc~dump_timing->interface~get_relaxtime newunit newunit proc~dump_timing->newunit proc~get_boundaryratio get_boundaryRatio proc~dump_timing->proc~get_boundaryratio proc~get_communicateratio get_communicateRatio proc~dump_timing->proc~get_communicateratio proc~get_intpratio get_intpRatio proc~dump_timing->proc~get_intpratio tem_getTimerName tem_getTimerName proc~dump_timing->tem_getTimerName tem_getTimerVal tem_getTimerVal proc~dump_timing->tem_getTimerVal proc~get_communicatetime->tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_auxtime_atlevel get_auxTime_atLevel interface~get_auxtime->proc~get_auxtime_atlevel proc~get_auxtime_total get_auxTime_total interface~get_auxtime->proc~get_auxtime_total proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel proc~get_bcbufferratio_total get_bcBufferRatio_total interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~get_computeratio_atlevel get_computeRatio_atLevel interface~get_computeratio->proc~get_computeratio_atlevel proc~get_computeratio_total get_computeRatio_total interface~get_computeratio->proc~get_computeratio_total proc~get_relaxtime_atlevel get_relaxTime_atLevel interface~get_relaxtime->proc~get_relaxtime_atlevel proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime->proc~get_relaxtime_total proc~get_boundaryratio->proc~get_mainlooptime interface~get_boundarytime get_boundaryTime proc~get_boundaryratio->interface~get_boundarytime proc~get_communicateratio->proc~get_communicatetime proc~get_communicateratio->proc~get_mainlooptime proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime proc~get_intpratio->proc~get_mainlooptime proc~get_intptime get_intpTime proc~get_intpratio->proc~get_intptime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_perf_measure.html"},{"title":"check_streaming_layout – Musubi","text":"public  subroutine check_streaming_layout(minLevel, maxLevel) Check for the streaming layout. Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel Called by proc~~check_streaming_layout~~CalledByGraph proc~check_streaming_layout check_streaming_layout proc~mus_hvs_init_aux mus_hvs_init_aux proc~mus_hvs_init_aux->proc~check_streaming_layout proc~mus_init_aux mus_init_aux proc~mus_init_aux->proc~check_streaming_layout program~mus_harvesting mus_harvesting program~mus_harvesting->proc~mus_hvs_init_aux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_streaming_layout.html"},{"title":"mus_writeSolverSpecInfo – Musubi","text":"public  subroutine mus_writeSolverSpecInfo(scheme, params, rank, outUnit) Write solver specific info to scratch file Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type type( mus_param_type ), intent(in) :: params Contains physical convertion info and scaling type integer, intent(in) :: rank Rank of the process either from\nglobal communicator or tracking output communicator integer, intent(inout) :: outUnit unit to output solver info in lua format Calls proc~~mus_writesolverspecinfo~~CallsGraph proc~mus_writesolverspecinfo mus_writeSolverSpecInfo aot_out_close aot_out_close proc~mus_writesolverspecinfo->aot_out_close aot_out_open aot_out_open proc~mus_writesolverspecinfo->aot_out_open newunit newunit proc~mus_writesolverspecinfo->newunit proc~mus_param_out mus_param_out proc~mus_writesolverspecinfo->proc~mus_param_out proc~mus_physics_out mus_physics_out proc~mus_writesolverspecinfo->proc~mus_physics_out proc~mus_scheme_out mus_scheme_out proc~mus_writesolverspecinfo->proc~mus_scheme_out aot_out_val aot_out_val proc~mus_param_out->aot_out_val aot_out_close_table aot_out_close_table proc~mus_physics_out->aot_out_close_table aot_out_open_table aot_out_open_table proc~mus_physics_out->aot_out_open_table proc~mus_physics_out->aot_out_val interface~mus_fields_out mus_fields_out proc~mus_scheme_out->interface~mus_fields_out proc~mus_interpolate_out mus_interpolate_out proc~mus_scheme_out->proc~mus_interpolate_out proc~mus_mixture_out mus_mixture_out proc~mus_scheme_out->proc~mus_mixture_out proc~mus_scheme_header_out mus_scheme_header_out proc~mus_scheme_out->proc~mus_scheme_header_out proc~mus_field_out_scal mus_field_out_scal interface~mus_fields_out->proc~mus_field_out_scal proc~mus_fields_out_vec mus_fields_out_vec interface~mus_fields_out->proc~mus_fields_out_vec proc~mus_interpolate_out->aot_out_val proc~mus_mixture_out->aot_out_close_table proc~mus_mixture_out->aot_out_open_table proc~mus_mixture_out->aot_out_val proc~mus_scheme_header_out->aot_out_close_table proc~mus_scheme_header_out->aot_out_open_table proc~mus_scheme_header_out->aot_out_val proc~mus_field_out_scal->aot_out_close_table proc~mus_field_out_scal->aot_out_open_table proc~mus_field_out_scal->aot_out_val proc~mus_field_prop_out mus_field_prop_out proc~mus_field_out_scal->proc~mus_field_prop_out proc~mus_fields_out_vec->aot_out_close_table proc~mus_fields_out_vec->aot_out_open_table proc~mus_fields_out_vec->aot_out_val proc~mus_fields_out_vec->proc~mus_field_out_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_writesolverspecinfo.html"},{"title":"dump_linear_partition – Musubi","text":"public  subroutine dump_linear_partition(treeID, nElems, offset, myRank, iter) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: treeID (1:nElems) integer, intent(in) :: nElems integer(kind=long_k), intent(in) :: offset integer, intent(in) :: myRank integer, intent(in) :: iter Calls proc~~dump_linear_partition~~CallsGraph proc~dump_linear_partition dump_linear_partition newunit newunit proc~dump_linear_partition->newunit tem_LevelOf tem_LevelOf proc~dump_linear_partition->tem_LevelOf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dump_linear_partition~~CalledByGraph proc~dump_linear_partition dump_linear_partition proc~mus_load_config mus_load_config proc~mus_load_config->proc~dump_linear_partition proc~mus_perform_dynloadbal mus_perform_dynLoadBal proc~mus_perform_dynloadbal->proc~dump_linear_partition program~musubi musubi program~musubi->proc~mus_load_config Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dump_linear_partition.html"},{"title":"mus_BC_timing – Musubi","text":"public  subroutine mus_BC_timing(nBCs, bc_labels, comm) Output the min and max time across all ranks,\nwhich are spent on each boundary condition. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nBCs character(len=labelLen), intent(in) :: bc_labels (nBCs) integer, intent(in) :: comm Calls proc~~mus_bc_timing~~CallsGraph proc~mus_bc_timing mus_BC_timing interface~get_boundarytime get_boundaryTime proc~mus_bc_timing->interface~get_boundarytime mpi_reduce mpi_reduce proc~mus_bc_timing->mpi_reduce tem_horizontalSpacer tem_horizontalSpacer proc~mus_bc_timing->tem_horizontalSpacer proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total tem_getTimerVal tem_getTimerVal proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mus_bc_timing.html"},{"title":"dump_bc_timing – Musubi","text":"public  subroutine dump_bc_timing(proc, nFluids, nBCElems, DomSize, iter, send) This routine dump compute and BC timing for all ranks\nrank    nFluids     tCompute     nBCElems     tBC    tCPU    tMainLoop Arguments Type Intent Optional Attributes Name type( tem_comm_env_type ), intent(in) :: proc integer, intent(in) :: nFluids integer, intent(in) :: nBCElems integer(kind=long_k), intent(in) :: DomSize integer, intent(in) :: iter type( tem_communication_type ), intent(in) :: send Calls proc~~dump_bc_timing~~CallsGraph proc~dump_bc_timing dump_bc_timing check_mpi_error check_mpi_error proc~dump_bc_timing->check_mpi_error interface~get_bcbuffertime get_bcBufferTime proc~dump_bc_timing->interface~get_bcbuffertime interface~get_boundarytime get_boundaryTime proc~dump_bc_timing->interface~get_boundarytime interface~get_computetime get_computeTime proc~dump_bc_timing->interface~get_computetime mpi_barrier mpi_barrier proc~dump_bc_timing->mpi_barrier mpi_file_close mpi_file_close proc~dump_bc_timing->mpi_file_close mpi_file_open mpi_file_open proc~dump_bc_timing->mpi_file_open mpi_file_write_ordered mpi_file_write_ordered proc~dump_bc_timing->mpi_file_write_ordered mpi_reduce mpi_reduce proc~dump_bc_timing->mpi_reduce newunit newunit proc~dump_bc_timing->newunit proc~get_communicatetime get_communicateTime proc~dump_bc_timing->proc~get_communicatetime proc~get_mainlooptime get_mainLoopTime proc~dump_bc_timing->proc~get_mainlooptime proc~get_bcbuffertime_atlevel get_bcBufferTime_atLevel interface~get_bcbuffertime->proc~get_bcbuffertime_atlevel proc~get_bcbuffertime_total get_bcBufferTime_total interface~get_bcbuffertime->proc~get_bcbuffertime_total proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~get_computetime_atlevel get_computeTime_atLevel interface~get_computetime->proc~get_computetime_atlevel proc~get_computetime_total get_computeTime_total interface~get_computetime->proc~get_computetime_total tem_getTimerVal tem_getTimerVal proc~get_communicatetime->tem_getTimerVal proc~get_mainlooptime->tem_getTimerVal proc~get_bcbuffertime_atlevel->tem_getTimerVal proc~get_bcbuffertime_total->interface~get_bcbuffertime proc~get_boundarytime_byid->tem_getTimerVal proc~get_boundarytime_total->interface~get_boundarytime proc~get_computetime_atlevel->tem_getTimerVal proc~get_computetime_total->interface~get_computetime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dump_bc_timing.html"},{"title":"check_velocityFluid – Musubi","text":"private  subroutine check_velocityFluid(scheme, minLevel, maxLevel, general, mus_aborts) Check the maximum velocity whether it is above Ma>0.1 Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts Calls proc~~check_velocityfluid~~CallsGraph proc~check_velocityfluid check_velocityFluid auxfield_varpos auxfield_varpos proc~check_velocityfluid->auxfield_varpos bits bits proc~check_velocityfluid->bits mpi_reduce mpi_reduce proc~check_velocityfluid->mpi_reduce tem_isNaN tem_isNaN proc~check_velocityfluid->tem_isNaN Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_velocityfluid~~CalledByGraph proc~check_velocityfluid check_velocityFluid proc~perform_checks perform_checks proc~perform_checks->proc~check_velocityfluid proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_velocityfluid.html"},{"title":"check_velocityMS – Musubi","text":"private  subroutine check_velocityMS(scheme, minLevel, maxLevel, general, mus_aborts) Check the maximum velocity whether it is above Ma>0.1 Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts Calls proc~~check_velocityms~~CallsGraph proc~check_velocityms check_velocityMS auxfield_varpos auxfield_varpos proc~check_velocityms->auxfield_varpos bits bits proc~check_velocityms->bits mpi_reduce mpi_reduce proc~check_velocityms->mpi_reduce tem_isNaN tem_isNaN proc~check_velocityms->tem_isNaN Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_velocityms~~CalledByGraph proc~check_velocityms check_velocityMS proc~perform_checks perform_checks proc~perform_checks->proc~check_velocityms proc~check_flow_status check_flow_status proc~check_flow_status->proc~perform_checks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_velocityms.html"},{"title":"dump_timing – Musubi","text":"private  subroutine dump_timing(totalDens, DomSize, MLUPS, MLUPS_kernel, timerVal, imbalance, general) Performance results (MLUPs) are written to a file for statistical review\nThe file-format is simple can be evaluated with gnuplot Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: totalDens integer(kind=long_k), intent(in) :: DomSize real(kind=rk), intent(in) :: MLUPS real(kind=rk), intent(in) :: MLUPS_kernel real(kind=rk), intent(in) :: timerVal (:) Max. timers of all process real(kind=rk), intent(in) :: imbalance type( tem_general_type ), intent(in) :: general Calls proc~~dump_timing~~CallsGraph proc~dump_timing dump_timing interface~get_auxtime get_auxTime proc~dump_timing->interface~get_auxtime interface~get_bcbufferratio get_bcBufferRatio proc~dump_timing->interface~get_bcbufferratio interface~get_computeratio get_computeRatio proc~dump_timing->interface~get_computeratio interface~get_relaxtime get_relaxTime proc~dump_timing->interface~get_relaxtime newunit newunit proc~dump_timing->newunit proc~get_boundaryratio get_boundaryRatio proc~dump_timing->proc~get_boundaryratio proc~get_communicateratio get_communicateRatio proc~dump_timing->proc~get_communicateratio proc~get_intpratio get_intpRatio proc~dump_timing->proc~get_intpratio tem_getTimerName tem_getTimerName proc~dump_timing->tem_getTimerName tem_getTimerVal tem_getTimerVal proc~dump_timing->tem_getTimerVal proc~get_auxtime_atlevel get_auxTime_atLevel interface~get_auxtime->proc~get_auxtime_atlevel proc~get_auxtime_total get_auxTime_total interface~get_auxtime->proc~get_auxtime_total proc~get_bcbufferratio_atlevel get_bcBufferRatio_atLevel interface~get_bcbufferratio->proc~get_bcbufferratio_atlevel proc~get_bcbufferratio_total get_bcBufferRatio_total interface~get_bcbufferratio->proc~get_bcbufferratio_total proc~get_computeratio_atlevel get_computeRatio_atLevel interface~get_computeratio->proc~get_computeratio_atlevel proc~get_computeratio_total get_computeRatio_total interface~get_computeratio->proc~get_computeratio_total proc~get_relaxtime_atlevel get_relaxTime_atLevel interface~get_relaxtime->proc~get_relaxtime_atlevel proc~get_relaxtime_total get_relaxTime_total interface~get_relaxtime->proc~get_relaxtime_total interface~get_boundarytime get_boundaryTime proc~get_boundaryratio->interface~get_boundarytime proc~get_mainlooptime get_mainLoopTime proc~get_boundaryratio->proc~get_mainlooptime proc~get_communicatetime get_communicateTime proc~get_communicateratio->proc~get_communicatetime proc~get_communicateratio->proc~get_mainlooptime proc~get_intptime get_intpTime proc~get_intpratio->proc~get_intptime proc~get_intpratio->proc~get_mainlooptime proc~get_boundarytime_byid get_boundaryTime_byID interface~get_boundarytime->proc~get_boundarytime_byid proc~get_boundarytime_total get_boundaryTime_total interface~get_boundarytime->proc~get_boundarytime_total proc~get_auxtime_atlevel->tem_getTimerVal proc~get_auxtime_total->interface~get_auxtime proc~get_bcbufferratio_atlevel->proc~get_mainlooptime interface~get_bcbuffertime get_bcBufferTime proc~get_bcbufferratio_atlevel->interface~get_bcbuffertime proc~get_bcbufferratio_total->proc~get_mainlooptime proc~get_bcbufferratio_total->interface~get_bcbuffertime proc~get_communicatetime->tem_getTimerVal proc~get_computeratio_atlevel->proc~get_mainlooptime interface~get_computetime get_computeTime proc~get_computeratio_atlevel->interface~get_computetime proc~get_computeratio_total->proc~get_mainlooptime proc~get_computeratio_total->interface~get_computetime interface~get_intpfromcoarsertime get_intpFromCoarserTime proc~get_intptime->interface~get_intpfromcoarsertime interface~get_intpfromfinertime get_intpFromFinerTime proc~get_intptime->interface~get_intpfromfinertime proc~get_mainlooptime->tem_getTimerVal proc~get_relaxtime_atlevel->tem_getTimerVal proc~get_relaxtime_total->interface~get_relaxtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dump_timing~~CalledByGraph proc~dump_timing dump_timing proc~mus_perf_measure mus_perf_measure proc~mus_perf_measure->proc~dump_timing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dump_timing.html"},{"title":"get_uPlus – Musubi","text":"private pure function get_uPlus(yPlus) result(uPlus) function to get uPlus Type Bound mus_wall_function_reichardt_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk)","tags":"","loc":"proc/get_uplus~3.html"},{"title":"get_d_uPlus_d_uTau – Musubi","text":"private pure function get_d_uPlus_d_uTau(y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Type Bound mus_wall_function_reichardt_type Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"proc/get_d_uplus_d_utau~3.html"},{"title":"mus_restart_module – Musubi","text":"This module provides the MUSUBI subroutines needed for the restart\nfunctionality. This module makes the restart IO functionality available for MUSUBI. When\nusing the write functionality the workflow is as follows\n- open the file and write the 'normal header'\n- run over the chunks and\n  + serialize the data\n  + write them to file\n- close the file and write the 'last header'\nFor reading the restart files the workflow is as follows:\n- open the file\n- read the solver specific character\n- loop over the chunks and\n  + read the data from disc\n  + unserialize the data and store it in the state vector\n- close the file Further information on the treelm functions and the usage can be found in\nthe tem_restart_module and inside the Restart Usage section itself. Uses tem_debug_module env_module mpi mus_scheme_type_module treelmesh_module tem_time_module tem_timer_module tem_logging_module tem_restart_module mus_buffer_module module~~mus_restart_module~~UsesGraph module~mus_restart_module mus_restart_module env_module env_module module~mus_restart_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module mpi mpi module~mus_restart_module->mpi mus_buffer_module mus_buffer_module module~mus_restart_module->mus_buffer_module tem_debug_module tem_debug_module module~mus_restart_module->tem_debug_module tem_logging_module tem_logging_module module~mus_restart_module->tem_logging_module tem_restart_module tem_restart_module module~mus_restart_module->tem_restart_module tem_time_module tem_time_module module~mus_restart_module->tem_time_module tem_timer_module tem_timer_module module~mus_restart_module->tem_timer_module treelmesh_module treelmesh_module module~mus_restart_module->treelmesh_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_restart_module~~UsedByGraph module~mus_restart_module mus_restart_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_restart_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_restart_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_writeRestart (levelPointer, restart, scheme, tree, timing, timerHandle, suffix) Write the serialized buffer assembled in mus_serializeData to disk Arguments Type Intent Optional Attributes Name integer, intent(in) :: levelPointer (:) global pdf info type( tem_restart_type ), intent(inout) :: restart restart information type( mus_scheme_type ), intent(inout) :: scheme array of schemes including the data to be serialized and dumped type( treelmesh_type ), intent(in) :: tree mesh, provided in treelm format type( tem_time_type ), intent(inout) :: timing current simulation time information integer, intent(in) :: timerHandle Timer handle character(len=*), intent(in), optional :: suffix optional suffix (if present NO timestamp will be added!!!!) public  subroutine mus_readRestart (levelPointer, restart, scheme, tree) Read the serialized restart file into the state vectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: levelPointer (tree%nElems) Level pointer, from tree mesh to level descriptor type( tem_restart_type ), intent(inout) :: restart restart information type( mus_scheme_type ), intent(inout) :: scheme array of schemes including the data to be serialized and dumped type( treelmesh_type ), intent(in) :: tree mesh, provided in treelm format","tags":"","loc":"module/mus_restart_module.html"},{"title":"mus_species_module – Musubi","text":"This module contains mus_species_type and routines to load species table\nfrom config file. Uses env_module tem_aux_module aotus_module tem_logging_module aot_out_module aot_table_module mus_physics_module tem_param_module tem_tools_module module~~mus_species_module~~UsesGraph module~mus_species_module mus_species_module aot_out_module aot_out_module module~mus_species_module->aot_out_module aot_table_module aot_table_module module~mus_species_module->aot_table_module aotus_module aotus_module module~mus_species_module->aotus_module env_module env_module module~mus_species_module->env_module module~mus_physics_module mus_physics_module module~mus_species_module->module~mus_physics_module tem_aux_module tem_aux_module module~mus_species_module->tem_aux_module tem_logging_module tem_logging_module module~mus_species_module->tem_logging_module tem_param_module tem_param_module module~mus_species_module->tem_param_module tem_tools_module tem_tools_module module~mus_species_module->tem_tools_module module~mus_physics_module->aot_out_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_species_module~~UsedByGraph module~mus_species_module mus_species_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_species_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_species_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_source_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_source_module->module~mus_field_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_species_type this type contains species parameters Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public :: molWeight molecular weight of the species real(kind=rk), public :: molWeightInv Inverse of molecular weight of the species.\nThis parameter is required to convert mass density to mole density real(kind=rk), public :: molWeigRatio ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma i \\f$ real(kind=rk), public, allocatable :: diff_coeff (:) coefficient of diffusivity  of the species (size of nspecies) real(kind=rk), public, allocatable :: resi_coeff (:) coefficient of resisivity of species which is\nreciprocal of diffusivity of the species Read more… type( mrt_species_type ), public :: mrt (globalMaxLevels) molar fraction of this species in the mixture\nVolume fraction of is species in the mixture\nmrt relaxation for each level real(kind=rk), public :: omBulk bulk relaxation parameter\nomBulk_k = (2-phi_k)/3*bulkViscosity real(kind=rk), public :: ombulkLvl (globalMaxLevels) bulk relaxation parameter for each level real(kind=rk), public :: omega relaxation parameter for Nernst-Planck equation real(kind=rk), public :: lambda relaxation parameter for trt scheme real(kind=rk), public :: chargeNr charge number of the species type, private :: mrt_species_type MRT species type Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: s_mrt (:,:) relaxation matrix for mrt\nsize of this matrix is (layout%QQ, layout%QQ) real(kind=rk), public, allocatable :: omegaMoments (:,:) transformed relaxation matrix-moments factor\nomegaMoments = (Moments&#94;-1.s_mrt.Moments)\n              .(I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1 real(kind=rk), public, allocatable :: omegaMomForce (:,:) Omega factor for 2nd order force term\nomegaMomForce = (I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1 Subroutines public  subroutine mus_load_species (me, conf, parent, minLevel, nFields, physics, cs_lattice) this routines load species table from config file Read more… Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in), optional :: parent integer, intent(in) :: minLevel integer, intent(in) :: nFields type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout\nrequired to compute omega from potential diffusivity public  subroutine compute_molWeightRatio (molWeights, molWeigRatios) This routine computes the molecular weight ratio for all species\nbased asinari model Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: molWeights (:) molecular weight of the species real(kind=rk), intent(out) :: molWeigRatios (:) ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma \\f$ public  subroutine compute_bulkViscOmega (species, bulkvisc, bulkviscLvl, minLevel, maxLevel) This routine compute bulk viscosity omega for species for all levels\nomega_bulk = (2-molWeigRatio_k)/(3*bulk_visc) Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(inout) :: species contains species information real(kind=rk), intent(in) :: bulkvisc bulk viscosity of the mixture real(kind=rk), intent(in) :: bulkviscLvl (globalMaxLevels) integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_species_out (me, conf) writes species propertries into a lua file Arguments Type Intent Optional Attributes Name type( mus_species_type ), intent(in) :: me type( aot_out_type ) :: conf","tags":"","loc":"module/mus_species_module.html"},{"title":"mus_hvs_config_module – Musubi","text":"In this module, all parameter files are read in\nas lua script or a sample configuration is being loaded Possible Parameter configuration\n- General Parameters\n- mus_scheme_layout_module \"Scheme Definitions\"\n- tem_debug_module \"Debug Parameters\" Uses env_module mus_scheme_type_module aotus_module mus_varSys_module mus_geom_module tem_timeControl_module mus_timer_module tem_tracking_module tem_general_module mus_param_module tem_tools_module mus_config_module mus_scheme_module tem_logging_module tem_restart_module tem_debug_module mpi tem_bc_prop_module tem_aux_module mus_geomIncrHead_module tem_timer_module mus_physics_module tem_property_module hvs_output_module tem_geometry_module module~~mus_hvs_config_module~~UsesGraph module~mus_hvs_config_module mus_hvs_config_module aotus_module aotus_module module~mus_hvs_config_module->aotus_module env_module env_module module~mus_hvs_config_module->env_module hvs_output_module hvs_output_module module~mus_hvs_config_module->hvs_output_module module~mus_config_module mus_config_module module~mus_hvs_config_module->module~mus_config_module module~mus_geom_module mus_geom_module module~mus_hvs_config_module->module~mus_geom_module module~mus_geomincrhead_module mus_geomIncrHead_module module~mus_hvs_config_module->module~mus_geomincrhead_module module~mus_param_module mus_param_module module~mus_hvs_config_module->module~mus_param_module module~mus_physics_module mus_physics_module module~mus_hvs_config_module->module~mus_physics_module module~mus_scheme_module mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_scheme_type_module mus_scheme_type_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_timer_module mus_timer_module module~mus_hvs_config_module->module~mus_timer_module mpi mpi module~mus_hvs_config_module->mpi mus_varSys_module mus_varSys_module module~mus_hvs_config_module->mus_varSys_module tem_aux_module tem_aux_module module~mus_hvs_config_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~mus_hvs_config_module->tem_bc_prop_module tem_debug_module tem_debug_module module~mus_hvs_config_module->tem_debug_module tem_general_module tem_general_module module~mus_hvs_config_module->tem_general_module tem_geometry_module tem_geometry_module module~mus_hvs_config_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_hvs_config_module->tem_logging_module tem_property_module tem_property_module module~mus_hvs_config_module->tem_property_module tem_restart_module tem_restart_module module~mus_hvs_config_module->tem_restart_module tem_timeControl_module tem_timeControl_module module~mus_hvs_config_module->tem_timeControl_module tem_timer_module tem_timer_module module~mus_hvs_config_module->tem_timer_module tem_tools_module tem_tools_module module~mus_hvs_config_module->tem_tools_module tem_tracking_module tem_tracking_module module~mus_hvs_config_module->tem_tracking_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_hvs_config_module~~UsedByGraph module~mus_hvs_config_module mus_hvs_config_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_hvs_config_type This datatype describes the various settings to load from the configuration\nfile. Components Type Visibility Attributes Name Initial character(len=pathLen), public :: prefix Location on disk to load the mesh data from. Read more… type( hvs_output_config_type ), public :: output Description of how the visualization output should be done. Subroutines public  subroutine mus_hvs_config_load (me, scheme, solverData, geometry, params) Read in LUA parameter file\nSee http://www.lua.org for a reference on how to use\nLua is a scripting language in itself which allows\nmore complex parameter files including comments\nAnd load / create the mesh depending on the configuration Arguments Type Intent Optional Attributes Name type( mus_hvs_config_type ), intent(out) :: me Musubi harvesting configuration to load when no tracking table is defined type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(inout), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters private  subroutine mus_hvs_load_solverData (scheme, solverData, geometry, params) This routines load solver data from config file except tracking Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(inout), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters","tags":"","loc":"module/mus_hvs_config_module.html"},{"title":"mus_moments_type_module – Musubi","text":"This module provides a data type for moment definition Uses env_module tem_matrix_module module~~mus_moments_type_module~~UsesGraph module~mus_moments_type_module mus_moments_type_module env_module env_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_moments_type_module~~UsedByGraph module~mus_moments_type_module mus_moments_type_module module~mus_moments_module mus_moments_module module~mus_moments_module->module~mus_moments_type_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_moments_type_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_relaxationparam_module->module~mus_scheme_layout_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_relaxationparam_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_scheme_layout_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_scheme_layout_module module~mus_dervarpos_module mus_derVarPos_module module~mus_dervarpos_module->module~mus_scheme_layout_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_layout_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_scheme_layout_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_relaxationparam_module module~mus_hrrinit_module mus_hrrInit_module module~mus_hrrinit_module->module~mus_scheme_layout_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_layout_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_scheme_layout_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_moments_module module~mus_scheme_module->module~mus_scheme_layout_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_tools_module mus_tools_module module~mus_tools_module->module~mus_relaxationparam_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_scheme_layout_module module~mus_turbulence_module mus_turbulence_module module~mus_turbulence_module->module~mus_scheme_layout_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_scheme_layout_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_moment_type moment space definition Components Type Visibility Attributes Name Initial logical, public :: mom_ready = .false. is true if this type is already filled and no need\nto fill again after load balancing type( tem_matrix_type ), public :: toMoments transformation matrix from pdf space to moments type( tem_matrix_type ), public :: toPDF transformation matrix from moment space to pdf character(len=labelLen), public, allocatable :: momLabel (:) Labels of the moments integer, public, allocatable :: first_moments (:) position of first order moments in moments vector integer, public, allocatable :: second_moments (:) position of second order moments in moments vector integer, public, allocatable :: third_moments (:) position of third order moments in moments vector integer, public, allocatable :: fourth_moments (:) position of fourth order moments in moments vector","tags":"","loc":"module/mus_moments_type_module.html"},{"title":"mus_comm_module – Musubi","text":"This module provides the definition and methods for musubi-specific\ncommunication.\nIt includes the wrapper functions for the actual communication, which is\ndefined in tem_comm_module . Uses env_module tem_comm_env_module mpi tem_comm_module module~~mus_comm_module~~UsesGraph module~mus_comm_module mus_comm_module env_module env_module module~mus_comm_module->env_module mpi mpi module~mus_comm_module->mpi tem_comm_env_module tem_comm_env_module module~mus_comm_module->tem_comm_env_module tem_comm_module tem_comm_module module~mus_comm_module->tem_comm_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_longBuffers (comm, pattern) Wrapper around the actual communication, to avoid copy-in, copy-out by the\nIntel compiler. (At least the intel compiler on pigeon (v12.0) seems to do\ncopying here, if a sub-array is passed to an assumed size dummy argument.\nTherefore we use this wrapping with an assumed shape dummy argument, so we\ncan pass a complete field to the actual exchange which has an assumed size\nargument, without copying complete state field around, just for\ncommunication. Ugly, but it doesn't seem to have an impact on performance,\nand right it seems to be the most suitable solution. Read more… Arguments Type Intent Optional Attributes Name type( tem_communication_type ), intent(inout) :: comm type( tem_commPattern_type ), intent(in) :: pattern","tags":"","loc":"module/mus_comm_module.html"},{"title":"mus_cumulantInit_module – Musubi","text":"This module contains functions for initializing Cumulant relaxation paramaters\nauthor: Gregorio Gerardo Spinelli Uses env_module tem_logging_module tem_aux_module module~~mus_cumulantinit_module~~UsesGraph module~mus_cumulantinit_module mus_cumulantInit_module env_module env_module module~mus_cumulantinit_module->env_module tem_aux_module tem_aux_module module~mus_cumulantinit_module->tem_aux_module tem_logging_module tem_logging_module module~mus_cumulantinit_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_cumulantinit_module~~UsedByGraph module~mus_cumulantinit_module mus_cumulantInit_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_cumulantinit_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: QQ = 27 integer, private, parameter :: q000 = 27 Subroutines public  subroutine cumulant_omega_check (omegaVisc, omegaBulk, omegaIn, nSolve, level) Checking the stability regions of omegas for the parametrized Cumulant\nJust omega(2) is given in input. omega(2)=-1 means omega2=omegaBulk.\nLimiters read from input. lim(N)=10&#94;10 means unlimited.\nlim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper.\nomega(6:10) = 1._rk Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: omegaVisc (:) vector of omegas in the level real(kind=rk), intent(in) :: omegaBulk omega bulk value in the level real(kind=rk), intent(in) :: omegaIn (:) vector of omegas as given in musubi.lua integer, intent(in) :: nSolve number of elements solved in kernel integer, intent(in) :: level current level","tags":"","loc":"module/mus_cumulantinit_module.html"},{"title":"mus_statistics_module – Musubi","text":"In this module we collect routines  and type definitions related to\nstatistics for the runtime of the code. Uses tem_logging_module mpi module~~mus_statistics_module~~UsesGraph module~mus_statistics_module mus_statistics_module mpi mpi module~mus_statistics_module->mpi tem_logging_module tem_logging_module module~mus_statistics_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_statistics_type runtime statistics\nthis includes memory consumption, amount of data to communciate,\nruntimes etc. Components Type Visibility Attributes Name Initial integer, public :: nLinks_comm = 0 number of links to communicate\nSubset of nLinks_total integer, public :: nLinks_total = 0 number of total links available which theoretically can be communciated integer, public :: nProcs_send = 0 Mean number of neighbor processes to which one process needs to send Subroutines public  subroutine mus_calc_commAmount (stat, comm, nProcs) Calculate the number of links to be communicated Arguments Type Intent Optional Attributes Name type( mus_statistics_type ), intent(inout) :: stat runtime statistic integer, intent(in) :: comm integer, intent(in) :: nProcs","tags":"","loc":"module/mus_statistics_module.html"},{"title":"mus_nernstPlanck_module – Musubi","text":"Uses env_module tem_aux_module aotus_module tem_logging_module aot_out_module aot_table_module mus_physics_module module~~mus_nernstplanck_module~~UsesGraph module~mus_nernstplanck_module mus_nernstPlanck_module aot_out_module aot_out_module module~mus_nernstplanck_module->aot_out_module aot_table_module aot_table_module module~mus_nernstplanck_module->aot_table_module aotus_module aotus_module module~mus_nernstplanck_module->aotus_module env_module env_module module~mus_nernstplanck_module->env_module module~mus_physics_module mus_physics_module module~mus_nernstplanck_module->module~mus_physics_module tem_aux_module tem_aux_module module~mus_nernstplanck_module->tem_aux_module tem_logging_module tem_logging_module module~mus_nernstplanck_module->tem_logging_module module~mus_physics_module->aot_out_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module tem_tools_module tem_tools_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_nernstplanck_module~~UsedByGraph module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_nernstplanck_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_scheme_type_module->module~mus_field_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_source_module->module~mus_field_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_nernstPlanck_type Contains configuration to calculate nernst_planck equation.\nMore information can be found in\nA Coupled Lattice Boltzmann Method to Solve Nernst_Planck Model for\nsimulating Electro-Osmatic Flows by Yang x., Shi B., Chai Z., Guo Z. Components Type Visibility Attributes Name Initial real(kind=rk), public :: temp abosulte temperature in Kelvin real(kind=rk), public :: moleDens Molar density of ions Subroutines public  subroutine mus_load_nernstPlanck (me, conf, parent, physics) load input to solve nernst_planck equation Arguments Type Intent Optional Attributes Name type( mus_nernstPlanck_type ), intent(out) :: me nernst_planck type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa","tags":"","loc":"module/mus_nernstplanck_module.html"},{"title":"mus_solSpecHelpers_module – Musubi","text":"This module provides MUSUBI specific helper functions for extracting\ninformation from the solver specific character. Uses env_module tem_aux_module tem_variable_module aotus_module tem_time_module tem_stencil_module tem_logging_module aot_table_module module~~mus_solspechelpers_module~~UsesGraph module~mus_solspechelpers_module mus_solSpecHelpers_module aot_table_module aot_table_module module~mus_solspechelpers_module->aot_table_module aotus_module aotus_module module~mus_solspechelpers_module->aotus_module env_module env_module module~mus_solspechelpers_module->env_module tem_aux_module tem_aux_module module~mus_solspechelpers_module->tem_aux_module tem_logging_module tem_logging_module module~mus_solspechelpers_module->tem_logging_module tem_stencil_module tem_stencil_module module~mus_solspechelpers_module->tem_stencil_module tem_time_module tem_time_module module~mus_solspechelpers_module->tem_time_module tem_variable_module tem_variable_module module~mus_solspechelpers_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface getFieldVariable private  function getFieldVariable_scalar (conf, varLabel, varName, fieldVar, fieldProp) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' Return Value real(kind=rk) val to be returned private  function getFieldVariable_array (conf, varLabel, varName, fieldVar, fieldProp, nVals) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' integer, intent(in) :: nVals number of entries in the array to read out Return Value real(kind=rk), (nVals) val to be returned Functions public  function getIdentifyChar (conf, key) result(resChar) Get a character from the identify table using a given solver specific\ncharacter handle and a given key word. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: key key to search for Return Value character(len=labelLen) scheme kind to be returned public  function getVariable_FromTable (conf, varLabel, table) result(val) Get the value of variable inside the table name 'key' in scheme\n @note Todo\n      extent it for vectors Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label character(len=*), intent(in) :: table table name Return Value real(kind=rk) val to be returned public  function getNFields (conf) result(nFields) Get the number of fields from a given solver specific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character Return Value integer number of fields to be returned public  function getFieldPrefixes (conf, nFields) result(prefix) Get the right field prefixes from a given solver specific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character integer, intent(in) :: nFields Return Value character(len=labelLen), (nFields) field prefixes to be returned public  function getWeights (conf, stencil) result(weights) Get the the weights of a used stencil from a given solver specific\ncharacter handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character type( tem_stencilHeader_type ), intent(in) :: stencil stencil information Return Value real(kind=rk), (stencil%QQ) weights to be returned public  function getConversionFac (conf, facName, nLevels) result(val) Get the conversion factor variable from physics table from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: facName conversion factor variable label integer, intent(in) :: nLevels Return Value real(kind=rk), (nLevels) val to be returned private  function getFieldVariable_scalar (conf, varLabel, varName, fieldVar, fieldProp) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' Return Value real(kind=rk) val to be returned private  function getFieldVariable_array (conf, varLabel, varName, fieldVar, fieldProp, nVals) result(val) Get the field variable name for given field type from a given solver\nspecific character handle. Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: conf handle of the solver specific character character(len=*), intent(in) :: varLabel complete variable label (prefix + pure variable name) character(len=*), intent(in) :: varName pure variable name (e.g. density) character(len=*), intent(in) :: fieldVar required name of the field variable character(len=*), intent(in) :: fieldProp Which field type does the field variable belong to.\nExample: 'fluid'/'species' integer, intent(in) :: nVals number of entries in the array to read out Return Value real(kind=rk), (nVals) val to be returned","tags":"","loc":"module/mus_solspechelpers_module.html"},{"title":"mus_moments_module – Musubi","text":"This module deals with the calculation of moments from pdfs Uses env_module tem_matrix_module mus_mrtInit_module tem_math_module tem_aux_module mus_moments_type_module tem_logging_module mus_scheme_header_module tem_debug_module module~~mus_moments_module~~UsesGraph module~mus_moments_module mus_moments_module env_module env_module module~mus_moments_module->env_module module~mus_moments_type_module mus_moments_type_module module~mus_moments_module->module~mus_moments_type_module module~mus_mrtinit_module mus_mrtInit_module module~mus_moments_module->module~mus_mrtinit_module module~mus_scheme_header_module mus_scheme_header_module module~mus_moments_module->module~mus_scheme_header_module tem_aux_module tem_aux_module module~mus_moments_module->tem_aux_module tem_debug_module tem_debug_module module~mus_moments_module->tem_debug_module tem_logging_module tem_logging_module module~mus_moments_module->tem_logging_module tem_math_module tem_math_module module~mus_moments_module->tem_math_module tem_matrix_module tem_matrix_module module~mus_moments_module->tem_matrix_module module~mus_moments_type_module->env_module module~mus_moments_type_module->tem_matrix_module module~mus_mrtinit_module->env_module tem_param_module tem_param_module module~mus_mrtinit_module->tem_param_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module aot_out_module aot_out_module module~mus_scheme_header_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_header_module->aot_table_module aotus_module aotus_module module~mus_scheme_header_module->aotus_module tem_tools_module tem_tools_module module~mus_scheme_header_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_moments_module~~UsedByGraph module~mus_moments_module mus_moments_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_moments_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_aux_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module program~musubi->module~mus_aux_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function get_moment (QQ, cxDir, expX, pdf) result(mom) Calculate the moment of a centain order\nThe moment of a distribution is defined as:\\n The fucntion argument expX is array of size 3,\nwhich contains the values of \\f$p, q, r\\f$ Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) integer, intent(in) :: expX (3) real(kind=rk), intent(in) :: pdf (QQ) distribution value Return Value real(kind=rk) public pure function get_momentVector (QQ, cxDir, expX) result(mom) get the moment vector to calculate the moment from the pdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) integer, intent(in) :: expX (3) exponents of the moments Return Value real(kind=rk), (QQ) moment vector private pure function mus_iMomVector (cxDir, expX, QQ) result(iMom) The integer moment vector for a given cxDir and order. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: cxDir (:,:) discrete velocity integer, intent(in) :: expX (3) order in each direction integer, intent(in) :: QQ number of velocity channels (include rest) Return Value integer, (QQ) Subroutines public  subroutine mus_init_moments (me, QQ, cxDir, label, schemeHeader) Initialize the moment space Arguments Type Intent Optional Attributes Name type( mus_moment_type ), intent(inout) :: me integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme public  subroutine set_momentIndices (nDims, iPress, iVelMin, iVelMax, iSMin, iSMax) set indices for accessing the pressure, velocity and the shear from a 1d\nvector Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims number of dimensions integer, intent(out) :: iPress index for the pressure / density integer, intent(out) :: iVelMin starting index for velocity integer, intent(out) :: iVelMax ending index for velocity integer, intent(out) :: iSMin starting index for shear integer, intent(out) :: iSMax ending index for shear public  subroutine mus_dump_moments (me, outUnit) Dump moments matrix: toPDF and toMoment Arguments Type Intent Optional Attributes Name type( mus_moment_type ), intent(in) :: me integer, intent(in) :: outUnit private  subroutine init_transformation_matrix_fluid (QQ, cxDir, label, me, toMoment, toPdf) Initialize Moments transformation matrix for LBM compressible and\nincompressible fluid model. This matrix must be consistent with the\nrelaxation matrix used in compute kernel and interpolation routines Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_moment_type ), intent(inout) :: me real(kind=rk), intent(inout) :: toMoment (me%toMoments%nEntries(1),me%toMoments%nEntries(2)) real(kind=rk), intent(inout) :: toPdf (me%toPDF%nEntries(1),me%toPDF%nEntries(2)) private  subroutine init_transformation_matrix_MS (QQ, cxDir, label, me, toMoment, toPdf) Intialize the moment transformation matrix for multispecies.\nThis matrix must be consistent with relaxation matrix used for\nmultispecies MRT collision routines Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: cxDir (3,QQ) character(len=labelLen) :: label type( mus_moment_type ), intent(inout) :: me real(kind=rk), intent(inout) :: toMoment (me%toMoments%nEntries(1),me%toMoments%nEntries(2)) real(kind=rk), intent(inout) :: toPdf (me%toPDF%nEntries(1),me%toPDF%nEntries(2))","tags":"","loc":"module/mus_moments_module.html"},{"title":"mus_hrrInit_module – Musubi","text":"This module provides the definitions of M and Minv for\nMRT advection relaxation scheme for all stencils. The weighted MRT (D3Q27) is based on the following paper\nAbbas Fakhari, Diogo Bolster, Li-Shi Luo\n\"A weighted multiple-relaxation-time lattice Boltzmann method for multiphase\nflows and its application to partial coalescence cascades\"\nJournal of Computational Physics, 2017 The MRT (D3Q19) implementation here is taken from:\\n\nJ. Toelke, S. Freudiger, and M. Krafczyk,\n\"An adaptive scheme using hierarchical grids for lattice Boltzmann\nmulti-phase flow simulations,\" Comput. Fluids, vol. 35, pp. 820–830,\n2006. \\n Uses env_module tem_aux_module mus_scheme_layout_module tem_param_module tem_debug_module module~~mus_hrrinit_module~~UsesGraph module~mus_hrrinit_module mus_hrrInit_module env_module env_module module~mus_hrrinit_module->env_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_hrrinit_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_hrrinit_module->tem_aux_module tem_debug_module tem_debug_module module~mus_hrrinit_module->tem_debug_module tem_param_module tem_param_module module~mus_hrrinit_module->tem_param_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_param_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_layout_module->aot_table_module aotus_module aotus_module module~mus_scheme_layout_module->aotus_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_scheme_layout_module->tem_logging_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module tem_tools_module tem_tools_module module~mus_scheme_layout_module->tem_tools_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_param_module module~mus_scheme_derived_quantities_module->tem_logging_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public pure subroutine HRR_Correction_d2q9 (QQ, weight, gradRHOU3, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho V&#94;3 real(kind=rk), intent(out) :: phi (:) correction term phi real(kind=rk), intent(out) :: dens correction term phi, rho, vel real(kind=rk), intent(out) :: vel (:) correction term phi, rho, vel public pure subroutine HRR_Correction_d3q19 (QQ, weight, gradRHOU3, gradRHOUVZ, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho u&#94;3, rho u v w real(kind=rk), intent(in) :: gradRHOUVZ (:) real(kind=rk), intent(out) :: phi (:) correction term phi, rho, vel real(kind=rk), intent(out) :: dens correction term phi, rho, vel real(kind=rk), intent(out) :: vel (:) correction term phi, rho, vel public pure subroutine HRR_Correction_d3q27 (QQ, weight, gradRHOU3, phi, dens, vel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ stencil size real(kind=rk), intent(in) :: weight (:) weights of the stencil real(kind=rk), intent(in) :: gradRHOU3 (:) gradient rho V&#94;3 real(kind=rk), intent(out) :: phi (:) correction term phi real(kind=rk), intent(out) :: dens correction term phi real(kind=rk), intent(out) :: vel (:) correction term phi public  subroutine getHermitepolynomials (nDims, QQ, layout, H_order) This function computes Hermite polinomial. It gives in output minimum Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDims number of physical dimensions integer, intent(in) :: QQ number of stencil streaming directions type( mus_scheme_layout_type ), intent(in) :: layout current layout integer, intent(in) :: H_order maximum order of the Hermite polynomials public  subroutine getHermitepolynomials_D3Q19 (layout) This function computes Hermite polinomial. It gives in output minimum Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(in) :: layout current layout","tags":"","loc":"module/mus_hrrinit_module.html"},{"title":"mus_fluid_module – Musubi","text":"This module keeps all information about the fluid In this module, all infos about the fluid is collected.\nThe file type mus_fluid_type contains all relevant information.\nThis includes physical parameters such as the viscosity and reference\ndensity. Also, LBM-specific parameters such as the relaxation rates are\ndefined. Uses env_module aotus_module mus_turb_viscosity_module tem_stencil_module mus_scheme_header_module tem_param_module mus_relaxationParam_module tem_time_module mus_mrtRelaxation_module tem_general_module mus_pdf_module mus_cumulantInit_module tem_tools_module mus_nonNewtonian_module tem_grow_array_module tem_spacetime_fun_module tem_logging_module aot_table_module mpi tem_aux_module mus_turbulence_module aot_out_module mus_physics_module tem_construction_module module~~mus_fluid_module~~UsesGraph module~mus_fluid_module mus_fluid_module aot_out_module aot_out_module module~mus_fluid_module->aot_out_module aot_table_module aot_table_module module~mus_fluid_module->aot_table_module aotus_module aotus_module module~mus_fluid_module->aotus_module env_module env_module module~mus_fluid_module->env_module module~mus_cumulantinit_module mus_cumulantInit_module module~mus_fluid_module->module~mus_cumulantinit_module module~mus_pdf_module mus_pdf_module module~mus_fluid_module->module~mus_pdf_module module~mus_physics_module mus_physics_module module~mus_fluid_module->module~mus_physics_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_fluid_module->module~mus_relaxationparam_module module~mus_scheme_header_module mus_scheme_header_module module~mus_fluid_module->module~mus_scheme_header_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_turbulence_module mus_turbulence_module module~mus_fluid_module->module~mus_turbulence_module mpi mpi module~mus_fluid_module->mpi mus_mrtRelaxation_module mus_mrtRelaxation_module module~mus_fluid_module->mus_mrtRelaxation_module mus_nonNewtonian_module mus_nonNewtonian_module module~mus_fluid_module->mus_nonNewtonian_module tem_aux_module tem_aux_module module~mus_fluid_module->tem_aux_module tem_construction_module tem_construction_module module~mus_fluid_module->tem_construction_module tem_general_module tem_general_module module~mus_fluid_module->tem_general_module tem_grow_array_module tem_grow_array_module module~mus_fluid_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_fluid_module->tem_logging_module tem_param_module tem_param_module module~mus_fluid_module->tem_param_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_fluid_module->tem_spacetime_fun_module tem_stencil_module tem_stencil_module module~mus_fluid_module->tem_stencil_module tem_time_module tem_time_module module~mus_fluid_module->tem_time_module tem_tools_module tem_tools_module module~mus_fluid_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_fluid_module~~UsedByGraph module~mus_fluid_module mus_fluid_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_auxfield_module mus_auxField_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_scheme_module mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_source_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_source_module->module~mus_field_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module module~mus_hvs_config_module mus_hvs_config_module program~mus_harvesting->module~mus_hvs_config_module module~mus_hvs_construction_module mus_hvs_construction_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module module~mus_config_module mus_config_module program~musubi->module~mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_fluid_type collection of properties of the fluid Components Type Visibility Attributes Name Initial logical, public :: active = .false. real(kind=rk), public :: lambda = 0.25_rk Magic value for TRT collision model\nLambda = ( 1/omega_+ - 0.5 ) * ( 1/omega_- - 0.5 ) real(kind=rk), public, allocatable :: omegaBulkLvl (:) level-wise bulk omegas, used as relaxation in mrt model\nallocated in mus_init_fluid real(kind=rk), public, allocatable :: viscBulkLvl (:) Level wise bulk viscosity in lattice type( mus_turbulence_type ), public :: turbulence Contains information for turbulence model type(mus_nNwtn_type), public :: nNwtn nonNewtonian fluid parameter procedure(mus_proc_mrt), public, nopass, pointer :: mrtPtr => null() function pointer to get MRT diagonal relaxation matrix type( mus_viscosity_type ), public :: viscKine kinematic viscosity\n\\todo KM: implement interpolation routine for constant viscosity real(kind=rk), public :: viscBulk_phy real(kind=rk), public :: force (3) real(kind=rk), public :: HRR_sigma = 0.98_rk real(kind=rk), public :: DRT_tauN = 0.70_rk real(kind=rk), public :: omega_Cum (10) real(kind=rk), public :: omega_Lim (3) Subroutines public  subroutine mus_load_fluid (me, conf, parent, minLevel, physics, schemeHeader) Read in the fluid property from the LUA parameter file Read more… Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(out) :: me fluid type type( flu_State ) :: conf lua state integer, intent(in), optional :: parent parent handle integer, intent(in) :: minLevel global pdf info type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme public  subroutine mus_init_fluid (me, physics, schemeHeader, minLevel, maxLevel, levelDesc, pdf, stencil, general, tNow) This routine initilizes fluid visocity and relaxation paramters for each\nlevel Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me fluid type type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header integer, intent(in) :: minLevel min and max level integer, intent(in) :: maxLevel min and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) level descriptor type( pdf_data_type ), intent(in) :: pdf (minLevel:maxLevel) pdf info with neigh array for all levels type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_general_type ), intent(in) :: general general type contains communication pattern and proc info type( tem_time_type ), intent(in) :: tNow current simulation time public  subroutine mus_fluid_save2lua (me, conf) write fluid prop into a lua file Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(in) :: me single fluid type type( aot_out_type ) :: conf public  subroutine mus_fluid_cleanup (me) This routines act as a destructor for fluid type Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me single fluid type private  subroutine mus_fluid_dump (me, minLevel, maxLevel, physics, nSolve, general, outUnit, schemeHeader) Arguments Type Intent Optional Attributes Name type( mus_fluid_type ), intent(inout) :: me integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa integer, intent(in) :: nSolve (minLevel:maxLevel) number of elements to solve per level (fluid+ghost) type( tem_general_type ), intent(in) :: general general type integer, intent(in) :: outUnit type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header","tags":"","loc":"module/mus_fluid_module.html"},{"title":"mus_time_module – Musubi","text":"This module contains time definition needed for musubi Uses env_module tem_logging_module tem_timeControl_module tem_time_module module~~mus_time_module~~UsesGraph module~mus_time_module mus_time_module env_module env_module module~mus_time_module->env_module tem_logging_module tem_logging_module module~mus_time_module->tem_logging_module tem_timeControl_module tem_timeControl_module module~mus_time_module->tem_timeControl_module tem_time_module tem_time_module module~mus_time_module->tem_time_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_time_module~~UsedByGraph module~mus_time_module mus_time_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_time_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_time_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_time_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_time_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function mus_time_modulo (now, reqInt) result(triggered) Check for multilevel cycle complete by modulo of nIters by scaleFactor\ndepends on acoustic or diffusive scaling.\nAcoustic scaling: scale factor = 2\nDiffusive scaling: scale factor = 4 Arguments Type Intent Optional Attributes Name type( tem_time_type ), intent(in) :: now current simulation time integer, intent(in) :: reqInt Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached. Return Value logical Subroutines public  subroutine mus_time_homogenize (me, dt, readRestart) Convert itime from restart to real time Arguments Type Intent Optional Attributes Name type( tem_time_type ), intent(inout) :: me real(kind=rk), intent(in) :: dt logical, intent(in) :: readRestart public  subroutine mus_timeControl_homogenize (me, dt, reqInt) Converts sim time to iter and vice versa depends on which one is defined\nin the configuration file Arguments Type Intent Optional Attributes Name type( tem_timeControl_type ), intent(inout) :: me simulation time control real(kind=rk), intent(in) :: dt dt of maxlevel or smallest dt integer, intent(in) :: reqInt Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached.","tags":"","loc":"module/mus_time_module.html"},{"title":"mus_mixture_module – Musubi","text":"This module contains all information about fluid mixture Uses env_module iso_c_binding tem_aux_module tem_spacetime_fun_module tem_spatial_module aotus_module tem_temporal_module mus_eNRTL_module tem_logging_module aot_out_module tem_ini_condition_module mus_physics_module tem_param_module aot_table_module tem_tools_module mus_scheme_header_module module~~mus_mixture_module~~UsesGraph module~mus_mixture_module mus_mixture_module aot_out_module aot_out_module module~mus_mixture_module->aot_out_module aot_table_module aot_table_module module~mus_mixture_module->aot_table_module aotus_module aotus_module module~mus_mixture_module->aotus_module env_module env_module module~mus_mixture_module->env_module iso_c_binding iso_c_binding module~mus_mixture_module->iso_c_binding module~mus_enrtl_module~2 mus_eNRTL_module module~mus_mixture_module->module~mus_enrtl_module~2 module~mus_physics_module mus_physics_module module~mus_mixture_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_mixture_module->module~mus_scheme_header_module tem_aux_module tem_aux_module module~mus_mixture_module->tem_aux_module tem_ini_condition_module tem_ini_condition_module module~mus_mixture_module->tem_ini_condition_module tem_logging_module tem_logging_module module~mus_mixture_module->tem_logging_module tem_param_module tem_param_module module~mus_mixture_module->tem_param_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_mixture_module->tem_spacetime_fun_module tem_spatial_module tem_spatial_module module~mus_mixture_module->tem_spatial_module tem_temporal_module tem_temporal_module module~mus_mixture_module->tem_temporal_module tem_tools_module tem_tools_module module~mus_mixture_module->tem_tools_module module~mus_enrtl_module~2->env_module module~mus_enrtl_module~2->iso_c_binding module~mus_physics_module->aot_out_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module module~mus_scheme_header_module->aot_out_module module~mus_scheme_header_module->aot_table_module module~mus_scheme_header_module->aotus_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module module~mus_scheme_header_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_mixture_module~~UsedByGraph module~mus_mixture_module mus_mixture_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_mixture_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_mixture_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_mixture_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_mixture_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_scheme_type_module->module~mus_field_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_source_module->module~mus_field_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_mixture_type This type contains mixture information Read more… Components Type Visibility Attributes Name Initial type( tem_ini_condition_type ), public :: ic initialization case, initial condition of the mixture real(kind=rk), public :: rho0 mass density of the mixture\nSI unit: kg/m&#94;3.\nPhysics to lattice conversion: rho0/physics%rho0 real(kind=rk), public :: rho0LB lattice mass density of the mixture real(kind=rk), public :: moleDens0 number density of the mixture or total mixture molar density\nSI unit: mol/m&#94;3.\nphysics to lattice conversion:\nnT0/physics%mol*physics%fac(minlevel)%length&#94;3.\nmixture molar density is required if initial condition\nare defined by molar fraction.\nset only if initial molefraction is space independent real(kind=rk), public :: moleDens0LB lattice number density of the mixture or total mixture molar density\nphysics to lattice conversion:\nmoleDens0/physics%mol*physics%fac(minlevel)%length&#94;3. real(kind=rk), public :: kine_viscosityLB lattice kinematic shear viscosity of the mixture real(kind=rk), public :: kine_viscosity physical kinematic shear viscosity of the mixture real(kind=rk), public :: bulk_viscosityLB lattice bulk viscosity real(kind=rk), public :: bulk_viscosity physical bulk viscosity real(kind=rk), public :: bulk_modulusLB lattice bulk modulus of the liquid mixture , - speed of sound (in lattice unit: \\f$ 1/\\sqrt{3} \\f$ real(kind=rk), public :: omega_diff relaxation parameter, , B - free parameter unit same as resistivity real(kind=rk), public :: omega_kine real(kind=rk), public :: omega_hom omega for higher order moments type( mixRelaxation_type ), public :: relaxLvl (globalMaxLevels) relaxation parameters for each level type( tem_temporal_type ), public :: omega_ramping temporal omega for ramping etc. real(kind=rk), public :: paramB free parameter\n\\f$ B = \\omega*\\rho/K \\f$ real(kind=rk), public :: temp0 temperature real(kind=rk), public :: temp0LB temperature real(kind=rk), public :: theta_eq equilibrium theta to choose between mixture velocity\nand equilibrium species velocity in the quadratic term\nequilibrium function.\ntheta = 0 -> mixture velocity\ntheta = 1 -> equilibrium species velocity\n\\todo KM: remove theta_eq and use\nmixture velocity in quadratic term of equilibrium function type( tem_spatial_type ), public :: viscSpatial spatial omega definition, e.g. for sponge layers real(kind=rk), public :: electricField (3) external electrical force real(kind=rk), public :: gravityField (3) gravitational force real(kind=rk), public :: faraday faraday constant(C/mol) real(kind=rk), public :: faradayLB faraday constant in lattice real(kind=rk), public :: gasConst_R gas constant R (Nm/(mol *K)) real(kind=rk), public :: gasConst_R_LB gas constant R in lattice character(kind=c_char, len=labelLen), public :: prop_file eNRTL file with species properties real(kind=rk), public :: atm_press atmospheric pressure real(kind=rk), public :: atm_pressLB atmospheric pressure type, private :: mixRelaxation_type relaxation paraemters multispecies required for each level Components Type Visibility Attributes Name Initial real(kind=rk), public :: visc lattice shear viscosity of the mixture for different level real(kind=rk), public :: paramB lattice free parameter B for different level real(kind=rk), public :: bulkVisc lattice bulk viscosity for different level real(kind=rk), public :: omega_diff relaxation parameter, , B - free parameter unit same as resistivity real(kind=rk), public :: omega_kine Subroutines public  subroutine mus_load_mixture (me, conf, parent, minLevel, maxLevel, physics, schemeHeader, nFields) This routine load mixture table from scheme table.\nDefine either mass density or number density.\nIf mass density is specified, number density can be computed at runtime\nor vice versa.\n @note Todo\n      Currently, the simulation is initialized by density, extend\n    it to initialize from mixture number density/volume fraction\n    and mole fraction\n    \\verbatim\n    mixture = { rho0 = 1.0, omega }\n    \\endverbatim Read more… Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(out) :: me contains mixture information type( flu_State ) :: conf integer, intent(in), optional :: parent integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields defined in lua file public  subroutine mus_mixture_out (me, conf, schemeHeader) This routine write mixture properties into lua file Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(in) :: me mixture info type( aot_out_type ) :: conf type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme private  subroutine set_omegasLvl (mixture, minLevel, maxLevel, physics) Set the omegas according to the time step setting Read more… Arguments Type Intent Optional Attributes Name type( mus_mixture_type ), intent(inout) :: mixture integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa","tags":"","loc":"module/mus_mixture_module.html"},{"title":"mus_hvs_construction_module – Musubi","text":"mus_hvs_construct \"Creation of the data structures\"\nfrom the information in the configuration and\nfrom the mesh read from disk for the musubi harvesting Uses env_module tem_comm_module mus_scheme_type_module mus_geom_module tem_dyn_array_module mus_construction_module mus_timer_module mus_pdf_module mus_param_module tem_tools_module tem_element_module tem_grow_array_module mus_scheme_layout_module treelmesh_module tem_logging_module tem_debug_module mpi tem_aux_module tem_timer_module tem_construction_module module~~mus_hvs_construction_module~~UsesGraph module~mus_hvs_construction_module mus_hvs_construction_module env_module env_module module~mus_hvs_construction_module->env_module module~mus_geom_module mus_geom_module module~mus_hvs_construction_module->module~mus_geom_module module~mus_param_module mus_param_module module~mus_hvs_construction_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_hvs_construction_module->module~mus_pdf_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_hvs_construction_module->module~mus_scheme_layout_module module~mus_scheme_type_module mus_scheme_type_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_timer_module mus_timer_module module~mus_hvs_construction_module->module~mus_timer_module mpi mpi module~mus_hvs_construction_module->mpi mus_construction_module mus_construction_module module~mus_hvs_construction_module->mus_construction_module tem_aux_module tem_aux_module module~mus_hvs_construction_module->tem_aux_module tem_comm_module tem_comm_module module~mus_hvs_construction_module->tem_comm_module tem_construction_module tem_construction_module module~mus_hvs_construction_module->tem_construction_module tem_debug_module tem_debug_module module~mus_hvs_construction_module->tem_debug_module tem_dyn_array_module tem_dyn_array_module module~mus_hvs_construction_module->tem_dyn_array_module tem_element_module tem_element_module module~mus_hvs_construction_module->tem_element_module tem_grow_array_module tem_grow_array_module module~mus_hvs_construction_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_hvs_construction_module->tem_logging_module tem_timer_module tem_timer_module module~mus_hvs_construction_module->tem_timer_module tem_tools_module tem_tools_module module~mus_hvs_construction_module->tem_tools_module treelmesh_module treelmesh_module module~mus_hvs_construction_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_hvs_construction_module~~UsedByGraph module~mus_hvs_construction_module mus_hvs_construction_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_construction_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_hvs_construct (scheme, geometry, params) Initialize Musubi data strucutres based on data provided by Treelm Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme information including fluid, boundary and flow information type( mus_geom_type ), intent(inout) :: geometry geometric information type( mus_param_type ), intent(inout) :: params run-time Parameters","tags":"","loc":"module/mus_hvs_construction_module.html"},{"title":"mus_pdf_module – Musubi","text":"Definitions for the main state and neighbor arrays Uses tem_debug_module env_module tem_logging_module tem_construction_module module~~mus_pdf_module~~UsesGraph module~mus_pdf_module mus_pdf_module env_module env_module module~mus_pdf_module->env_module tem_construction_module tem_construction_module module~mus_pdf_module->tem_construction_module tem_debug_module tem_debug_module module~mus_pdf_module->tem_debug_module tem_logging_module tem_logging_module module~mus_pdf_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_pdf_module~~UsedByGraph module~mus_pdf_module mus_pdf_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_pdf_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_pdf_module module~mus_control_module->module~mus_auxfield_module module~mus_scheme_type_module mus_scheme_type_module module~mus_control_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_control_module->module~mus_source_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_pdf_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_pdf_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_source_module->module~mus_pdf_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_aux_module->module~mus_scheme_type_module module~mus_aux_module->module~mus_source_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_tools_module mus_tools_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module mus_tracking_module module~mus_tracking_module->module~mus_scheme_type_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_scheme_type_module program~musubi musubi program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: pdf_data_type This level-wise data type contains the PDF arrays which are fed into the\nkernel.\nThe solver updates the state vector and finds the position of the neighbor\nvectors by looking it up in the neigh array Components Type Visibility Attributes Name Initial integer, public :: nElems_fluid number of local fluid elements integer, public :: nElems_halo number of halo elements (from remote processes) integer, public :: nElems_ghostFromCoarser number of ghost elements (from other levels) integer, public :: nElems_ghostFromFiner number of ghost elements (from other levels) integer, public :: nElems_ghost number of ghost elements (from other levels) integer, public :: nElems_local number of local elements (fluid+halos+ghost) integer, public :: nElems_solve fluid elements + ghostFromCoarser elements (elements for solver).\nPDF and auxFied are interpolated for ghostFromFiner and there is no\nneed to do collision on these elements. integer, public :: nElems_computed fluid elements + ghostFromCoarse + ghostFromFiner integer, public :: nSize number of elements padded to 4 integer, public :: nNow = 1 which buffer to use for current time step integer, public :: nNext = 2 which buffer to use for next time step integer, public, allocatable, dimension(:) :: neigh Connectivity array\nPoints to where to send respective pdfs\nAccess in a neigh way\nSize: QQ * nSize\nallocated in routine: mus_pdf_allocate real(kind=rk), public, allocatable, dimension(:) :: bcBuffer containing state vector values of elements which have a boundary\nIt always uses AOS data layout\nallocated in routine: mus_pdf_allocate\nfilled for each iteration in routine: fill_bcBuffer real(kind=rk), public, allocatable :: momBuf (:,:) Buffer storing the moments of all source from Coarser Subroutines public  subroutine mus_calc_nElems (me, nFluids, nGhostFromCoarser, nGhostFromFiner, nHalos) Compute nElems for different types Arguments Type Intent Optional Attributes Name type( pdf_data_type ) :: me integer, intent(in) :: nFluids integer, intent(in) :: nGhostFromCoarser integer, intent(in) :: nGhostFromFiner integer, intent(in) :: nHalos public  subroutine mus_pdf_allocate (me, nScalars, QQ, nElems_bcBuffer, isPDF) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me integer, intent(in) :: nScalars integer, intent(in) :: QQ integer, intent(in) :: nElems_bcBuffer logical, intent(in) :: isPDF public  subroutine mus_swap_Now_Next (me) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me public  subroutine allocate_momBuf (me, nVals) Arguments Type Intent Optional Attributes Name type( pdf_data_type ), intent(inout) :: me integer, intent(in) :: nVals","tags":"","loc":"module/mus_pdf_module.html"},{"title":"mus_source_module – Musubi","text":"Module containing subroutines for initialize Musubi source\nvariables and update source terms Uses env_module mus_absorbLayer_module tem_varSys_module mus_source_type_module tem_stencil_module mus_field_module tem_time_module mus_timer_module mus_pdf_module tem_tools_module treelmesh_module tem_logging_module mus_derVarPos_module tem_debug_module mpi tem_aux_module tem_bc_prop_module tem_subTree_module tem_timer_module mus_physics_module tem_construction_module tem_geometry_module module~~mus_source_module~~UsesGraph module~mus_source_module mus_source_module env_module env_module module~mus_source_module->env_module module~mus_absorblayer_module mus_absorbLayer_module module~mus_source_module->module~mus_absorblayer_module module~mus_dervarpos_module mus_derVarPos_module module~mus_source_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_source_module->module~mus_field_module module~mus_pdf_module mus_pdf_module module~mus_source_module->module~mus_pdf_module module~mus_physics_module mus_physics_module module~mus_source_module->module~mus_physics_module module~mus_source_type_module mus_source_type_module module~mus_source_module->module~mus_source_type_module module~mus_timer_module mus_timer_module module~mus_source_module->module~mus_timer_module mpi mpi module~mus_source_module->mpi tem_aux_module tem_aux_module module~mus_source_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~mus_source_module->tem_bc_prop_module tem_construction_module tem_construction_module module~mus_source_module->tem_construction_module tem_debug_module tem_debug_module module~mus_source_module->tem_debug_module tem_geometry_module tem_geometry_module module~mus_source_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_source_module->tem_logging_module tem_stencil_module tem_stencil_module module~mus_source_module->tem_stencil_module tem_subTree_module tem_subTree_module module~mus_source_module->tem_subTree_module tem_time_module tem_time_module module~mus_source_module->tem_time_module tem_timer_module tem_timer_module module~mus_source_module->tem_timer_module tem_tools_module tem_tools_module module~mus_source_module->tem_tools_module tem_varSys_module tem_varSys_module module~mus_source_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_source_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_source_module~~UsedByGraph module~mus_source_module mus_source_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_source_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_source_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_source_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_sourceTerms (field, nFields, globSrc, varSys, tree, bc_prop, stencil, nElems_solve, levelDesc) This routine does set_params and setupIndices for all sources terms\nby gathering points to apply souce term before. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (:) contains sources of all fields integer, intent(in) :: nFields Number of fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_varSys_type ), intent(in) :: varSys global variable system type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: nElems_solve (tree%global%minLevel:) Number of elements to solve in all levels\nnFluids + nGhostFromCoarser type( tem_levelDesc_type ), intent(in) :: levelDesc (tree%global%minLevel:) Level descriptors public  subroutine mus_apply_sourceTerms (field, nFields, globSrc, pdf, varSys, iLevel, time, phyConvFac, state, auxField, derVarPos) Apply all source terms i.e field specific source and global source on\nall fields. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: field (nFields) contains sources of all fields integer, intent(in) :: nFields Number of fields type( mus_source_type ), intent(in) :: globSrc global source type( pdf_data_type ), intent(inout) :: pdf pdf datatype type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level real(kind=rk), intent(inout) :: state (:,:) state type containing the state vector to update real(kind=rk), intent(in) :: auxField (:) auxField array type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys public  subroutine mus_update_sourceVars (nFields, field, globSrc, varSys, iLevel, auxField, phyConvFac, derVarPos) Updated all source variables i.e field specific source and global source on\nall fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields Number of fields type( mus_field_type ), intent(inout) :: field (nFields) contains sources of all fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: iLevel current level real(kind=rk), intent(in) :: auxField (:) auxField array type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys private  subroutine mus_setupIndices_forSrc (source, varSys, nSolve, bary, iLevel, tree, bc_prop, stencil) This routines does setup indices for given source within a field or\nglobal. Index are stored for points which source term is active Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: source Source term to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nSolve Number of elements to apply source term  on this level real(kind=rk), intent(in) :: bary (:,:) Space coordinates to apply source terms integer, intent(in) :: iLevel Current level type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil used to find bcID on certain links private  subroutine mus_init_internalSource (source, varSys, nSolve, iLevel, stencil) This routines does setup indices for given source within a field or\nglobal. Index are stored for points which source term is active Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: source Source term to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nSolve Number of elements to apply source term  on this level integer, intent(in) :: iLevel Current level type( tem_stencilHeader_type ), intent(in) :: stencil layout descriptor private  subroutine mus_init_turbChanForce (turbChanForce, tree, bc_prop, stencil) Create subTree and store nElemsGlobal in all proc for turbulent\nchannel force Arguments Type Intent Optional Attributes Name type( mus_turbChannelForce_type ), intent(inout) :: turbChanForce Contains info for turbulent channel force type( treelmesh_type ), intent(in) :: tree global treelm mesh type( tem_BC_prop_type ), intent(in) :: bc_prop bc property which is used to identify elements belong to certain BCs type( tem_stencilHeader_type ), intent(in) :: stencil stencil used to find bcID on certain links private  subroutine mus_init_hrrCorrection (HRR_Corr, nElems, nDim) Initialize arrays to store time average density and velocity for\ndynamic hrrCorrection.\n\\todo KM: 20210301 Allocate also for ghost cells! Arguments Type Intent Optional Attributes Name type( mus_HRRCorrectionTerm_type ), intent(inout) :: HRR_Corr HRR correction term type integer, intent(in) :: nElems Number of source elements integer, intent(in) :: nDim number of dimensions","tags":"","loc":"module/mus_source_module.html"},{"title":"mus_weights_module – Musubi","text":"This module include the routine required for element wie dumping weight\nfor better load balancing.\nDump weights at end of simulation if 'write_weights' is defined in the config\nfile. Weights are based on element wise time measurements Uses env_module tem_topology_module treelmesh_module mus_timer_module tem_logging_module tem_construction_module mus_bc_header_module tem_debug_module tem_element_module module~~mus_weights_module~~UsesGraph module~mus_weights_module mus_weights_module env_module env_module module~mus_weights_module->env_module module~mus_timer_module mus_timer_module module~mus_weights_module->module~mus_timer_module mus_bc_header_module mus_bc_header_module module~mus_weights_module->mus_bc_header_module tem_construction_module tem_construction_module module~mus_weights_module->tem_construction_module tem_debug_module tem_debug_module module~mus_weights_module->tem_debug_module tem_element_module tem_element_module module~mus_weights_module->tem_element_module tem_logging_module tem_logging_module module~mus_weights_module->tem_logging_module tem_topology_module tem_topology_module module~mus_weights_module->tem_topology_module treelmesh_module treelmesh_module module~mus_weights_module->treelmesh_module module~mus_timer_module->env_module tem_timer_module tem_timer_module module~mus_timer_module->tem_timer_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_weights_module~~UsedByGraph module~mus_weights_module mus_weights_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_weights_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_getWeights (weights, tree, minLevel, maxLevel, levelDesc, nBCs, globBC) Calculate weights using timing from compute kernel, interpolation and\n boundary routines Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: weights (:) type( treelmesh_type ), intent(in) :: tree geometry infomation integer, intent(in) :: minLevel min level and max level integer, intent(in) :: maxLevel min level and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level descriptor integer, intent(in) :: nBCs global IBM type\nNumber of boundary conditions type(glob_boundary_type), intent(in) :: globBC (nBCs) BC elements information public  subroutine mus_dumpWeights (tree, weights, basename) Dump weights to a file. Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(in) :: tree real(kind=rk), intent(in) :: weights (:) character(len=pathLen), intent(in) :: basename","tags":"","loc":"module/mus_weights_module.html"},{"title":"mus_mesh_adaptation_module – Musubi","text":"This module contains the code responsible for adaptively refining the mesh\nduring run time. Uses env_module tem_adaptation_module mpi mus_scheme_type_module tem_adaptation_config_module mus_geom_module tem_comm_env_module module~~mus_mesh_adaptation_module~~UsesGraph module~mus_mesh_adaptation_module mus_mesh_adaptation_module env_module env_module module~mus_mesh_adaptation_module->env_module module~mus_geom_module mus_geom_module module~mus_mesh_adaptation_module->module~mus_geom_module module~mus_scheme_type_module mus_scheme_type_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module mpi mpi module~mus_mesh_adaptation_module->mpi tem_adaptation_config_module tem_adaptation_config_module module~mus_mesh_adaptation_module->tem_adaptation_config_module tem_adaptation_module tem_adaptation_module module~mus_mesh_adaptation_module->tem_adaptation_module tem_comm_env_module tem_comm_env_module module~mus_mesh_adaptation_module->tem_comm_env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_adapt_refine (geometry, scheme, proc, adapt) Wrap up the routines required for dynamic load balancing Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: geometry Treelmesh data type( mus_scheme_type ), intent(inout) :: scheme scheme type type( tem_comm_env_type ), intent(in) :: proc type( tem_adapt_type ), intent(in) :: adapt mesh adaptation","tags":"","loc":"module/mus_mesh_adaptation_module.html"},{"title":"mus_initPoisson_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for lbm incompressible model. Uses env_module tem_aux_module mus_scheme_type_module tem_logging_module mus_compute_Poisson_module module~~mus_initpoisson_module~~UsesGraph module~mus_initpoisson_module mus_initPoisson_module env_module env_module module~mus_initpoisson_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initpoisson_module->module~mus_scheme_type_module mus_compute_Poisson_module mus_compute_Poisson_module module~mus_initpoisson_module->mus_compute_Poisson_module tem_aux_module tem_aux_module module~mus_initpoisson_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initpoisson_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_Poisson (relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute public  subroutine mus_init_advRel_PBLinear (relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute public  subroutine mus_init_advRel_PBnonLinear (relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initpoisson_module.html"},{"title":"mus_turb_wallFunc_module – Musubi","text":"This module contains turbulent wall function type and routines to calculate\nfriction velocity and stream-wise velocity component. Constant parameters for Implicit equation solver Uses env_module mus_wall_function_reichardt_module mus_wall_function_schmitt_module tem_aux_module aotus_module tem_float_module mus_wall_function_abstract_module tem_logging_module mus_wall_function_musker_module module~~mus_turb_wallfunc_module~~UsesGraph module~mus_turb_wallfunc_module mus_turb_wallFunc_module aotus_module aotus_module module~mus_turb_wallfunc_module->aotus_module env_module env_module module~mus_turb_wallfunc_module->env_module module~mus_wall_function_abstract_module mus_wall_function_abstract_module module~mus_turb_wallfunc_module->module~mus_wall_function_abstract_module module~mus_wall_function_musker_module mus_wall_function_musker_module module~mus_turb_wallfunc_module->module~mus_wall_function_musker_module module~mus_wall_function_reichardt_module mus_wall_function_reichardt_module module~mus_turb_wallfunc_module->module~mus_wall_function_reichardt_module module~mus_wall_function_schmitt_module mus_wall_function_schmitt_module module~mus_turb_wallfunc_module->module~mus_wall_function_schmitt_module tem_aux_module tem_aux_module module~mus_turb_wallfunc_module->tem_aux_module tem_float_module tem_float_module module~mus_turb_wallfunc_module->tem_float_module tem_logging_module tem_logging_module module~mus_turb_wallfunc_module->tem_logging_module module~mus_wall_function_abstract_module->env_module module~mus_wall_function_musker_module->env_module module~mus_wall_function_musker_module->module~mus_wall_function_abstract_module module~mus_wall_function_reichardt_module->env_module module~mus_wall_function_reichardt_module->module~mus_wall_function_abstract_module module~mus_wall_function_schmitt_module->env_module module~mus_wall_function_schmitt_module->module~mus_wall_function_abstract_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: imEq_nIter = 1000 real(kind=rk), private, parameter :: imEq_tol = 1e-10 Abstract Interfaces abstract interface Interface definition for the turbulent wall bc routines private pure function mus_iterative_method_interface(velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) This routine computes friction velocity from wall model profile\nusing Newton iteration method Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine abstract interface Interface definition for the turbulent wall bc routines private pure subroutine mus_proc_calcFricVel(this, velTau, velSW, distToBnd, viscKine, nElems) This abstract interface defines the interface to calculate turbulent wall\nfriction velocity from given velocity and distance to boundary.\nAll inputs and output are in lattice units. Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Turbulent wall model to use for the computation real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normal direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays abstract interface Interface definition for the turbulent wall bc routines private pure subroutine mus_proc_calcStreamWiseVel(velSW, velTau, distToBnd, viscKine, nElems, wall_function) This abstract interface defines the interface to calculate stream-wise\nvelocity component from friction velocity and distance to boundary.\nAll inputs and output are in lattice units. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: velSW (:) Stream-wise velocity component from wall model real(kind=rk), intent(in) :: velTau (:) Friction velocity computd from wall model real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays class( mus_wall_function_type ), intent(in) :: wall_function Allocate wall function object Derived Types type, public :: mus_turb_wallFunc_type Contains function pointers to compute friction velocity and stream-wise\nvelocity component Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. is true if wall function is active character(len=labelLen), public :: wall_func Wall model function character(len=labelLen), public :: nonlinear_solver Nonlinear solver type real(kind=rk), public :: vonKarman = 0.4_rk Von-Karman constant. Default = 0.4_rk logical, public :: useVanDriest = .true. Use vanDriest damping function to damp turbulent viscosity type( mus_turb_wallFunc_data_type ), public, allocatable :: dataOnLvl (:) Contains data computed in turbulent wall bc routine on each level procedure( mus_proc_calcFricVel ), public, pointer, pass(this) :: calcFricVel => null() Function pointer to compute friction velocity procedure( mus_proc_calcStreamWiseVel ), public, pointer, nopass :: calcStreamWiseVel => null() Function pointer to compute strean-wise velocity component class( mus_wall_function_type ), public, allocatable :: wall_function Allocate wall function object procedure( mus_iterative_method_interface ), public, pointer, nopass :: iterativeMethod => null() Function pointer to the iterative method type, private :: mus_turb_wallFunc_data_type Contains friction velocity and turbulent viscosity on boundary elements on\neach level Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: tVisc (:) Turbulent viscosity on boundary element computed using mixing length\nformulation in lattice unit\nnu_t = (vonKarman distToBnd) *2 * |du/dy| real(kind=rk), public, allocatable :: velTau (:) Friction velocity on first neighbor in normal direction in lattice unit\ncomputed from wall model real(kind=rk), public, allocatable :: distToBnd (:) Distance to boundary from first fluid in normal direction\nin lattice unit. real(kind=rk), public, allocatable :: neighDistToBnd (:) Distance to boundary from first fluid neighbor in normal direction\nin lattice unit. real(kind=rk), public, allocatable :: unitNormal (:,:) Unit normal for each boundary element.\nSize: (3, nElems) real(kind=rk), public, allocatable :: bndForce (:,:) Force on each boundary element.\nSize: (3, nElems) real(kind=rk), public, allocatable :: bndMoment (:,:) Moment on each boundary element.\nSize: (3, nElems) Functions private pure function newton_method (velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) This routine computes friction velocity from wall model profile\nusing Newton iteration method Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine private pure function fixedPoint_method (velTau_initialGuess, velSW, y, nu, wall_function) result(velTau_new) This routine computes friction velocity from wall model profile\nusing fixed-point iterative method Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: velTau_initialGuess Friction velocity computed from previsous time step real(kind=rk), intent(in) :: velSW Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: nu dynamic viscosity class( mus_wall_function_type ), intent(in) :: wall_function Number of elements in input and output arrays Return Value real(kind=rk) Friction velocity computed in this routine Subroutines public  subroutine mus_load_turb_wallFunc (me, conf, parent) This routine loads wall model and nonlinear solver type for nonlinear\nequation Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle private  subroutine load_iterativeMethod (me, conf, parent) Load the iterativeMethod to use in the turbulent wall model from the user\nconfiguration. Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle private  subroutine load_wall_function (me, conf, parent) Load the iterativeMethod to use in the turbulent wall model from the user\nconfiguration. Arguments Type Intent Optional Attributes Name type( mus_turb_wallFunc_type ), intent(inout) :: me Turbulent wall model type to fill assign wall model type( flu_State ) :: conf lua flu state integer, intent(in) :: parent bc parent handle private pure subroutine fricVel_Schmitt (this, velTau, velSW, distToBnd, viscKine, nElems) This routine computes friction velocity from Schmitt wall model. Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Pass the calling object as an argument real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays private pure subroutine compute_fricVel (this, velTau, velSW, distToBnd, viscKine, nElems) This routine computes friction velocity from wall model profile\nusing Newton iteration method Arguments Type Intent Optional Attributes Name class( mus_turb_wallFunc_type ), intent(in) :: this Pass the calling object as an argument real(kind=rk), intent(inout) :: velTau (:) Friction velocity computed from wall model.\nit is inout to provide velTau from previous timestep as initial velTau\nfor fixed-point or Newton iteration solver real(kind=rk), intent(in) :: velSW (:) Stream-wise velocity component from which friction velocity is computed real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays private pure subroutine computeStreamWiseVel (velSW, velTau, distToBnd, viscKine, nElems, wall_function) This routines computes streamWise velocity component from friction velocity\nand distance to boundary using any wall function profile. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: velSW (:) Stream-wise velocity component from wall model real(kind=rk), intent(in) :: velTau (:) Friction velocity computd from wall model real(kind=rk), intent(in) :: distToBnd (:) Distance to the boundary in the discrete normai direction real(kind=rk), intent(in) :: viscKine (:) Kinematic viscosity integer, intent(in) :: nElems Number of elements in input and output arrays class( mus_wall_function_type ), intent(in) :: wall_function Allocate wall function object","tags":"","loc":"module/mus_turb_wallfunc_module.html"},{"title":"mus_WALE_module – Musubi","text":"This module contains function to compute eddy viscosity for\nWall-Adapting Local Eddy-Viscosity turbulence\nmodel.\nThis implementation follows the LES described by Weickert et al.\nWeickert, M., Teike, G., Schmidt, O., & Sommerfeld, M. (2010).\nInvestigation of the LES WALE turbulence model within the lattice Boltzmann\nframework. Computers and Mathematics with Applications, 59(7), 2200–2214.\nauthor: Kannan Masilamani Uses env_module mus_turbulence_module tem_compileconf_module tem_param_module mus_gradData_module module~~mus_wale_module~~UsesGraph module~mus_wale_module mus_WALE_module env_module env_module module~mus_wale_module->env_module module~mus_turbulence_module mus_turbulence_module module~mus_wale_module->module~mus_turbulence_module mus_gradData_module mus_gradData_module module~mus_wale_module->mus_gradData_module tem_compileconf_module tem_compileconf_module module~mus_wale_module->tem_compileconf_module tem_param_module tem_param_module module~mus_wale_module->tem_param_module module~mus_turbulence_module->env_module module~mus_turbulence_module->mus_gradData_module aot_table_module aot_table_module module~mus_turbulence_module->aot_table_module aotus_module aotus_module module~mus_turbulence_module->aotus_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_turbulence_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_turbulence_module->tem_aux_module tem_comm_module tem_comm_module module~mus_turbulence_module->tem_comm_module tem_construction_module tem_construction_module module~mus_turbulence_module->tem_construction_module tem_logging_module tem_logging_module module~mus_turbulence_module->tem_logging_module tem_tools_module tem_tools_module module~mus_turbulence_module->tem_tools_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->tem_param_module module~mus_scheme_layout_module->aot_table_module module~mus_scheme_layout_module->aotus_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_logging_module module~mus_scheme_layout_module->tem_tools_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_param_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_wale_module~~UsedByGraph module~mus_wale_module mus_WALE_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_wale_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_turbVisc_WALE_3D (turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)\nmodel\n\\todo add reference and formula Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients public  subroutine mus_turbVisc_WALE_2D (turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity)\nmodel\n\\todo add reference and formula Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients","tags":"","loc":"module/mus_wale_module.html"},{"title":"mus_bc_var_module – Musubi","text":"This module provides variable to extract from boundary condition Uses env_module iso_c_binding tem_grow_array_module tem_varSys_module mus_field_module tem_aux_module tem_topology_module tem_variable_module mus_varSys_module tem_time_module treelmesh_module tem_logging_module tem_property_module tem_stencil_module mus_bc_header_module tem_dyn_array_module module~~mus_bc_var_module~~UsesGraph module~mus_bc_var_module mus_bc_var_module env_module env_module module~mus_bc_var_module->env_module iso_c_binding iso_c_binding module~mus_bc_var_module->iso_c_binding module~mus_field_module mus_field_module module~mus_bc_var_module->module~mus_field_module mus_bc_header_module mus_bc_header_module module~mus_bc_var_module->mus_bc_header_module mus_varSys_module mus_varSys_module module~mus_bc_var_module->mus_varSys_module tem_aux_module tem_aux_module module~mus_bc_var_module->tem_aux_module tem_dyn_array_module tem_dyn_array_module module~mus_bc_var_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_bc_var_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_bc_var_module->tem_logging_module tem_property_module tem_property_module module~mus_bc_var_module->tem_property_module tem_stencil_module tem_stencil_module module~mus_bc_var_module->tem_stencil_module tem_time_module tem_time_module module~mus_bc_var_module->tem_time_module tem_topology_module tem_topology_module module~mus_bc_var_module->tem_topology_module tem_varSys_module tem_varSys_module module~mus_bc_var_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_bc_var_module->tem_variable_module treelmesh_module treelmesh_module module~mus_bc_var_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_bc_var_module~~UsedByGraph module~mus_bc_var_module mus_bc_var_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_bc_var_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_variable_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_append_bcVar (varSys, solverData, derVarName, nFields, field, stencil) This routine adds boundary variables for tracking Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( grw_labelarray_type ), intent(inout) :: derVarName array of derive physical variables integer, intent(in) :: nFields number of fields type( mus_field_type ), intent(in) :: field (nFields) Field contains sources and boundary infos type( tem_stencilHeader_type ), intent(in) :: stencil Compute stencil header private recursive subroutine access_bcNormal_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns the boundary normal pointing inside the domain Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more… private recursive subroutine access_qVal_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns the boundary qValues Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more… private recursive subroutine access_bcFricVel_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns friction velocity computed in turbulent_wall bc and\nstored in mus_turb_wallFunc_data_type routine. Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more… private recursive subroutine access_bcNormDistToBnd_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns normal distance to boundary calculated in\nmus_init_turbWallFunc and stored in mus_turb_wallFunc_data_type routine. Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more… private recursive subroutine access_bcTurbVisc_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns turbulent viscosity computed in turbulent_wall bc\naccording to RANS formulation and stored in mus_turb_wallFunc_data_type\nroutine. Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more… private recursive subroutine access_bcYPlus_forElement (fun, varSys, elempos, time, tree, nElems, nDofs, res) This routine returns yPlus = distToBnd * fric_vel / visc Read more… Arguments Type Intent Optional Attributes Name class( tem_varSys_op_type ), intent(in) :: fun Description of the method to obtain the variables, here some preset\nvalues might be stored, like the space time function to use or the\nrequired variables. type( tem_varSys_type ), intent(in) :: varSys The variable system to obtain the variable from. integer, intent(in) :: elempos (:) Position of the TreeID of the element to get the variable for in the\nglobal treeID list. type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( treelmesh_type ), intent(in) :: tree global treelm mesh info integer, intent(in) :: nElems Number of values to obtain for this variable (vectorized access). integer, intent(in) :: nDofs Number of degrees of freedom within an element. real(kind=rk), intent(out) :: res (:) Resulting values for the requested variable. Read more…","tags":"","loc":"module/mus_bc_var_module.html"},{"title":"mus_initFluidIncomp_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for lbm incompressible model. Uses env_module mus_mrt_d3q19_module tem_aux_module mus_scheme_type_module mus_bgk_module mus_d3q27_module mus_mrt_d3q27_module tem_logging_module mus_d2q9_module mus_d3q19_module module~~mus_initfluidincomp_module~~UsesGraph module~mus_initfluidincomp_module mus_initFluidIncomp_module env_module env_module module~mus_initfluidincomp_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initfluidincomp_module->module~mus_scheme_type_module mus_bgk_module mus_bgk_module module~mus_initfluidincomp_module->mus_bgk_module mus_d2q9_module mus_d2q9_module module~mus_initfluidincomp_module->mus_d2q9_module mus_d3q19_module mus_d3q19_module module~mus_initfluidincomp_module->mus_d3q19_module mus_d3q27_module mus_d3q27_module module~mus_initfluidincomp_module->mus_d3q27_module mus_mrt_d3q19_module mus_mrt_d3q19_module module~mus_initfluidincomp_module->mus_mrt_d3q19_module mus_mrt_d3q27_module mus_mrt_d3q27_module module~mus_initfluidincomp_module->mus_mrt_d3q27_module tem_aux_module tem_aux_module module~mus_initfluidincomp_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initfluidincomp_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_fluidIncomp (relaxation, variant, layout, compute) Initialize the relaxation model for lbm incompressible model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute private  subroutine mus_init_advRel_fluidIncomp_bgk (variant, layout, compute) This routine assigns compute routine for bgk relaxation Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute private  subroutine mus_init_advRel_fluidIncomp_mrt (variant, layout, compute) This routine assigns compute routine for mrt relaxation Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initfluidincomp_module.html"},{"title":"mus_dynLoadBal_module – Musubi","text":"Uses env_module mus_tools_module mus_scheme_type_module mus_weights_module mus_transport_var_module mus_varSys_module mus_geom_module tem_varMap_module tem_stencil_module mus_bc_header_module mus_IBM_module mus_bndForce_module tem_dyn_array_module mus_construction_module tem_convergence_module mus_auxField_module tem_topology_module mus_flow_module mus_fluid_module tem_time_module mus_timer_module tem_operation_var_module tem_general_module mus_param_module tem_tools_module tem_element_module mus_tracking_module mus_scheme_module tem_spacetime_fun_module mus_scheme_layout_module treelmesh_module mus_bc_general_module tem_logging_module mus_interpolate_module tem_debug_module tem_restart_module mus_buffer_module mus_time_module mpi tem_bc_prop_module tem_aux_module tem_Sparta_module tem_property_module tem_construction_module mus_gradData_module mus_source_module env_module w mus_dynLoadBal_module w mpi w w mus_auxField_module w w mus_bc_general_module w w mus_bc_header_module w w mus_bndForce_module w w mus_buffer_module w w mus_construction_module w w mus_flow_module w w mus_fluid_module w w mus_geom_module w w mus_gradData_module w w mus_IBM_module w w mus_interpolate_module w w mus_param_module w w mus_scheme_layout_module w w mus_scheme_module w w mus_scheme_type_module w w mus_source_module w w mus_time_module w w mus_timer_module w w mus_tools_module w w mus_tracking_module w w mus_transport_var_module w w mus_varSys_module w w mus_weights_module w w tem_aux_module w w tem_bc_prop_module w w tem_construction_module w w tem_convergence_module w w tem_debug_module w w tem_dyn_array_module w w tem_element_module w w tem_general_module w w tem_logging_module w w tem_operation_var_module w w tem_property_module w w tem_restart_module w w tem_spacetime_fun_module w w tem_Sparta_module w w tem_stencil_module w w tem_time_module w w tem_tools_module w w tem_topology_module w w tem_varMap_module w w treelmesh_module w w Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_perform_dynLoadBal (scheme, params, geometry, solverData) Wrap up the routines required for dynamic load balancing Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_param_type ), intent(inout) :: params Global parameters type( mus_geom_type ), intent(inout) :: geometry Treelmesh data type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types private  subroutine mus_reset_aux (scheme, params, geometry) This subroutine initializes musubi after a dynamic load balancing is\nperformed. Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_param_type ), intent(inout) :: params Global parameters type( mus_geom_type ), intent(inout) :: geometry Treelmesh data private  subroutine mus_balance (tree, minLevel, maxLevel, levelDesc, nBCs, globBC, general, sparta) This routine performs the load balancing for multilevel simulations. The\nweights are calculated on the basis of levelwise run time, which are then\nfed to sparta for calculation of splitting positions. Restart files are\nsaved and the simulation is restarted with the newly distributed mesh Arguments Type Intent Optional Attributes Name type( treelmesh_type ), intent(inout) :: tree geometry infomation integer, intent(in) :: minLevel min level and max level integer, intent(in) :: maxLevel min level and max level type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level descriptor integer, intent(in) :: nBCs global IBM type\nNumber of boundary conditions type(glob_boundary_type), intent(in) :: globBC (nBCs) BC elements information type( tem_general_type ), intent(in) :: general global parameters type( tem_sparta_type ), intent(inout) :: sparta Sparta data type private  subroutine exchange_tree_bc (sparta, geometry, comm, comm_size) Arguments Type Intent Optional Attributes Name type( tem_sparta_type ), intent(in) :: sparta type( mus_geom_type ), intent(inout) :: geometry integer, intent(in) :: comm integer, intent(in) :: comm_size","tags":"","loc":"module/mus_dynloadbal_module.html"},{"title":"mus_scheme_header_module – Musubi","text":"This module contains scheme property type and module related to scheme prop todo move omega_Cum, omega_Lim, DRT_tauN, lambda from mus_fluid_type\nto here Uses env_module tem_aux_module aotus_module tem_logging_module aot_out_module aot_table_module tem_tools_module module~~mus_scheme_header_module~~UsesGraph module~mus_scheme_header_module mus_scheme_header_module aot_out_module aot_out_module module~mus_scheme_header_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_header_module->aot_table_module aotus_module aotus_module module~mus_scheme_header_module->aotus_module env_module env_module module~mus_scheme_header_module->env_module tem_aux_module tem_aux_module module~mus_scheme_header_module->tem_aux_module tem_logging_module tem_logging_module module~mus_scheme_header_module->tem_logging_module tem_tools_module tem_tools_module module~mus_scheme_header_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_scheme_header_module~~UsedByGraph module~mus_scheme_header_module mus_scheme_header_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_scheme_header_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_scheme_header_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_scheme_header_module module~mus_field_prop_module mus_field_prop_module module~mus_field_prop_module->module~mus_scheme_header_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_scheme_header_module module~mus_mixture_module mus_mixture_module module~mus_mixture_module->module~mus_scheme_header_module module~mus_moments_module mus_moments_module module~mus_moments_module->module~mus_scheme_header_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_scheme_header_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_scheme_header_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_source_type_module mus_source_type_module module~mus_source_type_module->module~mus_scheme_header_module module~mus_source_var_module mus_source_var_module module~mus_source_var_module->module~mus_scheme_header_module module~mus_transport_var_module mus_transport_var_module module~mus_transport_var_module->module~mus_scheme_header_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_scheme_header_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_scheme_header_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_relaxation_header_type Datatype containing additional options for the relaxation like variant and\nother variant specific parameters Components Type Visibility Attributes Name Initial character(len=labelLen), public :: variant Varaint name of the relaxation. Set to \"default\" to select default\nrelaxation real(kind=rk), public :: regularization_omega Addtional information to load for regularited bgk like\n\"regularized\", \"recursive_regularited\" and \"hybrid_recursive_regularized\"\nvariant. type, public :: mus_scheme_header_type Datatype containing information to identify the scheme Read more… Components Type Visibility Attributes Name Initial character(len=labelLen), public :: kind scheme kind, Ex: fluid, fluid_incompressible, multispecies_gas,\nmultispecies_liquid, poisson, poisson_boltzmann_linear,\npoisson_boltzmann_nonlinear, nernst_planck, isotherm_acEq character(len=labelLen), public :: layout scheme layout, Ex: d3q19 character(len=labelLen), public :: relaxation scheme relaxation type Ex: BGK, MRT, bgk_pl, bgk_cy, bgk_cs... type( mus_relaxation_header_type ), public :: relaxHeader Variant and additional options for a relaxation Subroutines public  subroutine mus_load_scheme_header (me, conf, parent, scaling) load scheme header info from lua file identify table or from scheme table\n or from config Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_header_type ), intent(out) :: me returns scheme identify information type( flu_State ) :: conf integer, intent(in), optional :: parent parent handle if scheme table is defined character(len=*), intent(in) :: scaling public  subroutine mus_scheme_header_out (me, conf) Dumps scheme header Arguments Type Intent Optional Attributes Name type( mus_scheme_header_type ), intent(in) :: me returns scheme identify information type( aot_out_type ) :: conf private  subroutine load_relaxation_header (me, conf, thandle) Load relaxation options from a table Arguments Type Intent Optional Attributes Name type( mus_relaxation_header_type ), intent(out) :: me type( flu_State ) :: conf integer, intent(in) :: thandle relaxation handle","tags":"","loc":"module/mus_scheme_header_module.html"},{"title":"mus_wall_function_schmitt_module – Musubi","text":"This module contains data types, function and routines for wall function\ncomputations relative to Schmitt profile.\nRef to following paper for Schmitt three layer equations.\nHaussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models\nfor turbulent channel flows at high Reynolds numbers with a lattice\nBoltzmann method — Application to Coriolis mass flowmeter’, Computers &\nMathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302. author: Gregorio Gerardo Spinelli Constant parameters for Schmitt's law Uses env_module mus_wall_function_abstract_module module~~mus_wall_function_schmitt_module~~UsesGraph module~mus_wall_function_schmitt_module mus_wall_function_schmitt_module env_module env_module module~mus_wall_function_schmitt_module->env_module module~mus_wall_function_abstract_module mus_wall_function_abstract_module module~mus_wall_function_schmitt_module->module~mus_wall_function_abstract_module module~mus_wall_function_abstract_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_wall_function_schmitt_module~~UsedByGraph module~mus_wall_function_schmitt_module mus_wall_function_schmitt_module module~mus_turb_wallfunc_module mus_turb_wallFunc_module module~mus_turb_wallfunc_module->module~mus_wall_function_schmitt_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: sc_uLmt = 30._rk real(kind=rk), public, parameter :: sc_lLmt = 5._rk real(kind=rk), private, parameter :: vonKA = 0.4_rk Derived Types type, public, extends( mus_wall_function_type ) :: mus_wall_function_schmitt_type extend the abstract subclass mus_wall_function_type Type-Bound Procedures procedure, public, nopass :: get_uPlus ../../../../../ function to get uPlus procedure, public, nopass :: get_d_uPlus_d_uTau ../../../../../ function to apply the newton method Functions public pure function get_uTau_subVisousLayer (visc_div_dist, velSW) result(uTau) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc_div_dist dynamic viscosity divided by vertical distance from the wall real(kind=rk), intent(in) :: velSW velocity stream-wise parallel to wall Return Value real(kind=rk) friction velocity public pure function get_uTau_logLayer (visc_div_dist, velSW) result(uTau) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc_div_dist dynamic viscosity divided by vertical distance from the wall real(kind=rk), intent(in) :: velSW velocity stream-wise parallel to wall Return Value real(kind=rk) friction velocity private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"module/mus_wall_function_schmitt_module.html"},{"title":"mus_eNRTL_module – Musubi","text":"This module contains an interface for external C++ code to compute\nliquid mixture property like thermodynamic factor and\nMaxwell-Stefan Diffusivity coefficients Uses env_module iso_c_binding module~~mus_enrtl_module~2~~UsesGraph module~mus_enrtl_module~2 mus_eNRTL_module env_module env_module module~mus_enrtl_module~2->env_module iso_c_binding iso_c_binding module~mus_enrtl_module~2->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_enrtl_module~2~~UsedByGraph module~mus_enrtl_module~2 mus_eNRTL_module module~mus_mixture_module mus_mixture_module module~mus_mixture_module->module~mus_enrtl_module~2 module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_mixture_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_mixture_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_mixture_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_mixture_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_scheme_type_module->module~mus_field_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_source_module->module~mus_field_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface mus_calc_thermFactor private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) This routine calculates thermodynamic factor for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix public        interface mus_calc_MS_DiffMatrix private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) This routine calculates Diffusivity coefficients matrix for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix interface This function initialize eNRTL model by loading liquid mixture\nproperty from filename private  function init_enrtl_loc(filename, nSpc) bind(c, name='init_enrtl') Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer(kind=c_int), intent(out) :: nSpc Return Value integer interface This routine calculates thermodynamic factor for given mole_frac\nof all species private  subroutine calc_therm_factor_loc(nSpc, Temp, Press, Mole_frac, Therm_factors) bind(c, name='calc_therm_factor_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_frac real(kind=c_double), intent(out), dimension(*) :: Therm_factors interface This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix\nfor given mole_frac of all species private  subroutine calc_ms_diff_matrix_from_molefrac(nSpc, Temp, Press, Mole_frac, D_ij_out) bind(c, name='calc_ms_diff_matrix_from_molefrac_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_frac real(kind=c_double), intent(out), dimension(*) :: D_ij_out interface This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix\nfor given mole_frac of all species private  subroutine calc_ms_diff_matrix_from_moledens(nSpc, Temp, Press, Mole_dens, D_ij_out) bind(c, name='calc_ms_diff_matrix_from_moledens_C') Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: nSpc real(kind=c_double), intent(in), value :: Temp real(kind=c_double), intent(in), value :: Press real(kind=c_double), intent(in), dimension(*) :: Mole_dens real(kind=c_double), intent(out), dimension(*) :: D_ij_out Functions public  function mus_init_eNRTL (filename, nFields) result(success) This function loads property file using external c-function Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer, intent(out) :: nFields number of fields in mixture Return Value logical Subroutines private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) This routine calculates thermodynamic factor for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) This routine calculates Diffusivity coefficients matrix for given mole_frac\nof all species for single element Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"module/mus_enrtl_module~2.html"},{"title":"mus_initFluid_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for lbm model. Uses mus_test_module env_module mus_mrt_d3q19_module tem_aux_module mus_scheme_type_module mus_bgk_module mus_compute_cumulant_module mus_d3q27_module mus_mrt_d3q27_module tem_logging_module mus_d2q9_module mus_d3q19_module module~~mus_initfluid_module~~UsesGraph module~mus_initfluid_module mus_initFluid_module env_module env_module module~mus_initfluid_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initfluid_module->module~mus_scheme_type_module mus_bgk_module mus_bgk_module module~mus_initfluid_module->mus_bgk_module mus_compute_cumulant_module mus_compute_cumulant_module module~mus_initfluid_module->mus_compute_cumulant_module mus_d2q9_module mus_d2q9_module module~mus_initfluid_module->mus_d2q9_module mus_d3q19_module mus_d3q19_module module~mus_initfluid_module->mus_d3q19_module mus_d3q27_module mus_d3q27_module module~mus_initfluid_module->mus_d3q27_module mus_mrt_d3q19_module mus_mrt_d3q19_module module~mus_initfluid_module->mus_mrt_d3q19_module mus_mrt_d3q27_module mus_mrt_d3q27_module module~mus_initfluid_module->mus_mrt_d3q27_module mus_test_module mus_test_module module~mus_initfluid_module->mus_test_module tem_aux_module tem_aux_module module~mus_initfluid_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initfluid_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_fluid (relaxation, variant, layout, compute) Assigning compute kernel routine by scheme relaxation type for fluid kind. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute private  subroutine mus_init_advRel_fluid_bgk (variant, layout, compute) This routine assigns compute routine for bgk relaxation. Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute private  subroutine mus_init_advRel_fluid_mrt (variant, layout, compute) This routine assigns compute routine for mrt relaxation Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute private  subroutine mus_init_advRel_fluid_trt (variant, layout, compute) This routine assigns compute routine for trt relaxation Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: variant character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initfluid_module.html"},{"title":"mus_source_type_module – Musubi","text":"Module containing subroutines for building MUSUBI specific source\nvariables Uses env_module mus_absorbLayer_module tem_varSys_module tem_aux_module mus_derVarPos_module aotus_module tem_shape_module tem_stringKeyValuePair_module tem_time_module tem_varMap_module treelmesh_module tem_stencil_module tem_logging_module tem_subTree_type_module mus_scheme_header_module mus_physics_module aot_table_module tem_tools_module module~~mus_source_type_module~~UsesGraph module~mus_source_type_module mus_source_type_module aot_table_module aot_table_module module~mus_source_type_module->aot_table_module aotus_module aotus_module module~mus_source_type_module->aotus_module env_module env_module module~mus_source_type_module->env_module module~mus_absorblayer_module mus_absorbLayer_module module~mus_source_type_module->module~mus_absorblayer_module module~mus_dervarpos_module mus_derVarPos_module module~mus_source_type_module->module~mus_dervarpos_module module~mus_physics_module mus_physics_module module~mus_source_type_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_source_type_module->module~mus_scheme_header_module tem_aux_module tem_aux_module module~mus_source_type_module->tem_aux_module tem_logging_module tem_logging_module module~mus_source_type_module->tem_logging_module tem_shape_module tem_shape_module module~mus_source_type_module->tem_shape_module tem_stencil_module tem_stencil_module module~mus_source_type_module->tem_stencil_module tem_stringKeyValuePair_module tem_stringKeyValuePair_module module~mus_source_type_module->tem_stringKeyValuePair_module tem_subTree_type_module tem_subTree_type_module module~mus_source_type_module->tem_subTree_type_module tem_time_module tem_time_module module~mus_source_type_module->tem_time_module tem_tools_module tem_tools_module module~mus_source_type_module->tem_tools_module tem_varMap_module tem_varMap_module module~mus_source_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_source_type_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_source_type_module->treelmesh_module module~mus_absorblayer_module->aot_table_module module~mus_absorblayer_module->aotus_module module~mus_absorblayer_module->env_module module~mus_absorblayer_module->tem_aux_module module~mus_absorblayer_module->tem_logging_module module~mus_absorblayer_module->tem_tools_module module~mus_dervarpos_module->env_module module~mus_dervarpos_module->tem_aux_module module~mus_dervarpos_module->tem_stencil_module module~mus_dervarpos_module->tem_varSys_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_dervarpos_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_dervarpos_module->module~mus_scheme_layout_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module module~mus_physics_module->treelmesh_module aot_out_module aot_out_module module~mus_physics_module->aot_out_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module module~mus_scheme_header_module->aot_table_module module~mus_scheme_header_module->aotus_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module module~mus_scheme_header_module->tem_tools_module module~mus_scheme_header_module->aot_out_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_logging_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module tem_param_module tem_param_module module~mus_scheme_derived_quantities_module->tem_param_module module~mus_scheme_layout_module->aot_table_module module~mus_scheme_layout_module->aotus_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_logging_module module~mus_scheme_layout_module->tem_stencil_module module~mus_scheme_layout_module->tem_tools_module module~mus_scheme_layout_module->aot_out_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module module~mus_scheme_layout_module->tem_param_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_source_type_module~~UsedByGraph module~mus_source_type_module mus_source_type_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_source_type_module module~mus_field_module mus_field_module module~mus_auxfield_module->module~mus_field_module module~mus_field_module->module~mus_source_type_module module~mus_source_var_module mus_source_var_module module~mus_field_module->module~mus_source_var_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_source_type_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_scheme_type_module->module~mus_field_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_source_type_module module~mus_source_module->module~mus_field_module module~mus_source_var_module->module~mus_source_type_module module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_source_var_turbchanforce_module->module~mus_source_type_module module~mus_variable_module->module~mus_source_type_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_source_var_module module~mus_variable_module->module~mus_source_var_turbchanforce_module module~mus_bc_var_module mus_bc_var_module module~mus_variable_module->module~mus_bc_var_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_aux_module->module~mus_source_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_source_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine proc_apply_source(fun, inState, outState, neigh, auxField, nPdfSize, iLevel, varSys, time, phyConvFac, derVarPos) Abstract interface to update state with source terms Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(in) :: fun Description of method to update source real(kind=rk), intent(in) :: inState (:) input  pdf vector\n\\todo KM: instate is passed to compute auxField.\nSince auxField is precomputed from instate and passed to this routine.\ninstate can be removed real(kind=rk), intent(inout) :: outState (:) output pdf vector integer, intent(in) :: neigh (:) connectivity Array corresponding to state vector real(kind=rk), intent(in) :: auxField (:) auxField array integer, intent(in) :: nPdfSize number of elements in state Array integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys abstract interface private  subroutine proc_addSrcToAuxField(fun, auxField, iLevel, time, varSys, phyConvFac, derVarPos) Interface to add source to auxField vars in source_op_type for\nall nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner).\nHalo elements are exchanged Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(inout) :: auxField (:) output auxField array integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys abstract interface private  subroutine proc_updateSourceVar(fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Interface to update source variable which has dependency on auxField.\nApplied on all nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner).\nHalo elements are exchanged\nThis should be called after adding sorce term to state so that both\nauxField and apply_source uses same source value in one multilevel cycle. Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys Derived Types type, public :: mus_HRRCorrectionTerm_type Stores correction term for HRR_bgk Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dens (:) density real(kind=rk), public, allocatable :: vel (:,:) velocity type, public :: mus_turbChannelForce_type Contains information to compute average bulk velocity for dynamic_force.\nIn turb_channel_force, the force term is adapted according to difference\nbetween reference bulk velocity and simulated plane average bulk velocity\nto avoid linear increase in simulated bulk velocits.\nFor more information:\nhttps://www.wias-berlin.de/people/john/ELECTRONIC_PAPERS/JR07.IJNMF.pdf Components Type Visibility Attributes Name Initial type( tem_shape_type ), public :: geom_utau (1) tracking shapes type( tem_shape_type ), public :: geom_umean (1) type( tem_subTree_type ), public :: subTree_utau sub-tree resulting from the elements within the tracking shape\nThe sub-tree also holds the sub-communicator\nThis data needs to be UPDATED after balance type( tem_subTree_type ), public :: subTree_umean real(kind=rk), public :: refVelBulk Reference bulk velocity in physical unit real(kind=rk), public :: refHeight Characteristic height in physical unit integer, public :: flow_direction Stream-wise direction to compute average velocity\nx=1, y=2, z=3 real(kind=rk), public :: forceDyn (3) Dynamic Force term for turbulent channel in physical unit [m/s&#94;2]\nF_dyn = (refVelBulk-avgVelXBulk) * refVelBulk / refHeight integer, public :: nElemsGlobal_utau Global number of elements in defined shape integer, public :: nElemsGlobal_umean type, public :: mus_source_op_type Description contains list of elements on which source is active and\nfunction pointer to update source Components Type Visibility Attributes Name Initial integer, public :: srcTerm_varPos Position of this source term variable in the varSys integer, public :: data_varPos Position of data variable provided in config file in the varSys type( mus_source_elems_type ), public, allocatable :: elemLvl (:) Contains source elements position in state array/total list for\neach level procedure( proc_apply_source ), public, pointer :: applySrc => null() Function to update state with source term character(len=labelLen), public :: varname to use source field array\nname of the source variable procedure( proc_addSrcToAuxField ), public, pointer :: addSrcToAuxField => null() Function pointer to append source field to auxilary variable procedure( proc_updateSourceVar ), public, pointer :: updateSourceVar => null() Function pointer to update source variable which are dependent on\nauxField. integer, public :: order Order of approximation for source like force, electric_field,\ncharge_density.\nOrder = 1, uses force term in BE approximated by forward Euler method\nOrder = 2, uses force term in BE approximated by Trapezoidal method.\nFor order 2, macroscopic source is also added to auxField.\nFor fluid, fluid_incompressible, multispecies_liquid: source is added\nto momentum and for poisson: source is added to potential.\nDefault: order = 2. type( mus_absorbLayer_type ), public :: absLayer Additional config information for absorbLayer type( mus_turbChannelForce_type ), public :: turbChanForce Contains information to compute average bulk velocity for dynamic_force type, public :: mus_source_type Description of musubi source type Components Type Visibility Attributes Name Initial type( mus_source_op_type ), public, allocatable :: method (:) Contains source elements position in tree%treeID and\nfunction pointer to update source\nSize: varDict%nVals type( grw_stringkeyvaluepairarray_type ), public :: varDict Dictionary of source variable with\nvarDict%val()%key is the name of source variable and\nvarDict%val()%value is the name of variable provided for the key type, private :: mus_source_elems_type Contains source elements position in state array and idx to access\ndata variable refered in config file.\nThis type is defined for each level Components Type Visibility Attributes Name Initial integer, public :: nElems Number of source elements on this level.\nnFluids + nGhosts integer, public, allocatable :: posInTotal (:) Position of elements in state array to apply source terms.\nPosition in state array is same as position in total list\nSize: nElems integer, public, allocatable :: idx (:) Index to access point data type to retrieve values from variable\nrefered for source variable type( mus_absorbLayer_dynAvg_type ), public :: dynAvg source field value obtained from ST_fun data variable.\nFilled only for elements where source is active i.e. elements in\nposInTotal.\nsize: nElems*nComponents\n\\todo KM: might be not neccessary\nContains time average values of density and velocity for dynamic\nabsorblayer.\n\\todo KM: 02042021 Introduce method_data c_ptr and point to\ndynAvg for absorbLayer and change intent(inout) to intent(in) in\nproc_addSrcToAuxField. type( mus_HRRCorrectionTerm_type ), public :: HRR_Corr Subroutines public  subroutine mus_create_poss_srcVar (poss_srcVar, schemeHeader) Routine initialize possible source variable depends on scheme kind Arguments Type Intent Optional Attributes Name type( tem_possible_variable_type ), intent(out) :: poss_srcVar possible source variables type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme public  subroutine mus_load_source_var (me, possVars, conf, parent, key, varSys) Routine load musubi source terms for given key.\nkey is glob_source or source Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(out) :: me Source variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible source variables type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined character(len=*), intent(in) :: key key to load source term type( tem_varSys_type ), intent(inout) :: varSys Global variable system public  subroutine mus_source_cleanup (me) This routine act as a destructor for source type.\nThe arrays allocated in mus_init_sourceTerms are destroyed here Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: me public  subroutine mus_applySrc_dummy (fun, inState, outState, neigh, auxField, nPdfSize, iLevel, varSys, time, phyConvFac, derVarPos) Dummy routine for apply source Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(in) :: fun Description of method to update source real(kind=rk), intent(in) :: inState (:) input  pdf vector\n\\todo KM: instate is passed to compute auxField.\nSince auxField is precomputed from instate and passed to this routine.\ninstate can be removed real(kind=rk), intent(inout) :: outState (:) output pdf vector integer, intent(in) :: neigh (:) connectivity Array corresponding to state vector real(kind=rk), intent(in) :: auxField (:) auxField array integer, intent(in) :: nPdfSize number of elements in state Array integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system type( tem_time_type ), intent(in) :: time Point in time at which to evaluate the variable. type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys public  subroutine mus_addSrcToAuxField_dummy (fun, auxField, iLevel, time, varSys, phyConvFac, derVarPos) Dummy routine for add source to auxField Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(inout) :: auxField (:) output auxField array integer, intent(in) :: iLevel current level type( tem_time_type ), intent(in) :: time current timing information type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor for current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys public  subroutine mus_updateSrcVar_dummy (fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Dummy routine for update source variable Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys private  subroutine load_turbChanForce (me, conf, key, parent) Load shape, bulk velocity and height for turbulent channel force Arguments Type Intent Optional Attributes Name type( mus_turbChannelForce_type ), intent(out) :: me Turbulent channel force type( flu_State ) :: conf flu state character(len=*), intent(in) :: key Table name to load target states integer, intent(in) :: parent parent source handle","tags":"","loc":"module/mus_source_type_module.html"},{"title":"mus_directions_module – Musubi","text":"This module contains parameters to address the stencil directions. These\nparameters are valid for all stencils, however, the direction q00 and q000 needs to be set on each use according to QQ . Used by module~~mus_directions_module~~UsedByGraph module~mus_directions_module mus_directions_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_directions_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: qN00 = 1 integer, public, parameter :: q0N0 = 2 integer, public, parameter :: q00N = 3 integer, public, parameter :: q100 = 4 integer, public, parameter :: q010 = 5 integer, public, parameter :: q001 = 6 integer, public, parameter :: q0NN = 7 integer, public, parameter :: q0N1 = 8 integer, public, parameter :: q01N = 9 integer, public, parameter :: q011 = 10 integer, public, parameter :: qN0N = 11 integer, public, parameter :: q10N = 12 integer, public, parameter :: qN01 = 13 integer, public, parameter :: q101 = 14 integer, public, parameter :: qNN0 = 15 integer, public, parameter :: qN10 = 16 integer, public, parameter :: q1N0 = 17 integer, public, parameter :: q110 = 18 integer, public, parameter :: qNNN = 19 integer, public, parameter :: qNN1 = 20 integer, public, parameter :: qN1N = 21 integer, public, parameter :: qN11 = 22 integer, public, parameter :: q1NN = 23 integer, public, parameter :: q1N1 = 24 integer, public, parameter :: q11N = 25 integer, public, parameter :: q111 = 26 integer, public, parameter :: qN0 = 1 integer, public, parameter :: q0N = 2 integer, public, parameter :: q10 = 3 integer, public, parameter :: q01 = 4 integer, public, parameter :: qNN = 5 integer, public, parameter :: qN1 = 6 integer, public, parameter :: q1N = 7 integer, public, parameter :: q11 = 8 integer, public, parameter :: q__W = 1 integer, public, parameter :: q__S = 2 integer, public, parameter :: q__E = 3 integer, public, parameter :: q__N = 4 integer, public, parameter :: q_SW = 5 integer, public, parameter :: q_NW = 6 integer, public, parameter :: q_SE = 7 integer, public, parameter :: q_NE = 8","tags":"","loc":"module/mus_directions_module.html"},{"title":"mus_initNernstPlanck_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for lbm incompressible model. Uses env_module tem_aux_module mus_scheme_type_module tem_logging_module mus_compute_nernstPlanck_module module~~mus_initnernstplanck_module~~UsesGraph module~mus_initnernstplanck_module mus_initNernstPlanck_module env_module env_module module~mus_initnernstplanck_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initnernstplanck_module->module~mus_scheme_type_module mus_compute_nernstPlanck_module mus_compute_nernstPlanck_module module~mus_initnernstplanck_module->mus_compute_nernstPlanck_module tem_aux_module tem_aux_module module~mus_initnernstplanck_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initnernstplanck_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_nernstPlanck (relaxation, layout, compute) Initialize the relaxation model for lbm poisson equation Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initnernstplanck_module.html"},{"title":"mus_auxField_module – Musubi","text":"This module contains routine to retrieve auxiliary field variables for\ngetElement, getPoint, setupIndices and getValOfIndex.\nAuxilary field variables are:\n   * density and velocity for fluid\n   * species desity and velocity for multispecies\n   * potential for poisson Uses env_module tem_general_module mus_pdf_module tem_varSys_module mus_field_module tem_comm_module mus_derVarPos_module treelmesh_module mus_source_type_module tem_stencil_module mus_scheme_header_module tem_construction_module mus_physics_module tem_param_module mus_interpolate_header_module mus_scheme_derived_quantities_module module~~mus_auxfield_module~~UsesGraph module~mus_auxfield_module mus_auxField_module env_module env_module module~mus_auxfield_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_auxfield_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_auxfield_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_pdf_module mus_pdf_module module~mus_auxfield_module->module~mus_pdf_module module~mus_physics_module mus_physics_module module~mus_auxfield_module->module~mus_physics_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_auxfield_module->module~mus_scheme_derived_quantities_module module~mus_scheme_header_module mus_scheme_header_module module~mus_auxfield_module->module~mus_scheme_header_module module~mus_source_type_module mus_source_type_module module~mus_auxfield_module->module~mus_source_type_module tem_comm_module tem_comm_module module~mus_auxfield_module->tem_comm_module tem_construction_module tem_construction_module module~mus_auxfield_module->tem_construction_module tem_general_module tem_general_module module~mus_auxfield_module->tem_general_module tem_param_module tem_param_module module~mus_auxfield_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_auxfield_module->tem_stencil_module tem_varSys_module tem_varSys_module module~mus_auxfield_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_auxfield_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_auxfield_module~~UsedByGraph module~mus_auxfield_module mus_auxField_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_auxfield_module module~mus_scheme_type_module mus_scheme_type_module module~mus_control_module->module~mus_scheme_type_module module~mus_aux_module mus_aux_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_aux_module->module~mus_tools_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  subroutine mus_proc_calcAuxField(auxField, state, neigh, nSize, nSolve, iLevel, stencil, varSys, derVarPos, quantities) Interface to compute auxField vars i.e. conserved macroscopic moments\nfrom pre-collision PDF for fluid and ghostFromCoarser.\nauxField on GhostFromFiner elements are interpolated and\nhalo elements are exchanged\nFor Multicomponent models: in calcAuxField function, the velocity\nis computed on transformed PDF such that force term can be added to it\nin addSrcToAuxField routine. The auxField is updated with correct\nvelocity field in compute kernel\ni.e. velocity of original PDF is obtained by solving\nlinear equation system  in compute kernel Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: auxField (:) output auxField array real(kind=rk), intent(in) :: state (:) input state array integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: nSize number of elements in the state array integer, intent(in) :: nSolve number of fluid elements + ghostFromCoarser integer, intent(in) :: iLevel current level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Derived Types type, public :: mus_auxFieldVar_type Contains auxiliary field variable values per level and communication\nbuffers Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: val (:) auxiliary field variable values computed from pre-collision PDF\nafter PDF exchange\nSize: nSize nScalars\nElement order is same as state array\nAccess: (iElem-1) nScalars + varSys%method%val(iVar)%auxField_varPos\nSee mus_append_auxField for the name of the variable stored in this\narray as it depends on the scheme kind. type( tem_communication_type ), public :: sendBuffer Local Fluids required by remote processes type( tem_communication_type ), public :: sendBufferFromCoarser Local ghostFromCoarser required by remote processes type( tem_communication_type ), public :: sendBufferFromFiner Local ghostFromFiner required by remote processes type( tem_communication_type ), public :: recvBuffer My halos which are fluids on remote processes type( tem_communication_type ), public :: recvBufferFromCoarser My halos which are ghostFromCoarser on remote processes type( tem_communication_type ), public :: recvBufferFromFiner My halos which are ghostFromFiner on remote processes Subroutines public  subroutine mus_init_auxFieldArrays (me, levelDesc, pattern, nSize, nAuxScalars) This routine initialize auxField var val array and communication buffers Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(out) :: me Auxiliary field variable type( tem_levelDesc_type ), intent(in) :: levelDesc levelDesc to access communication buffers of state array type( tem_commPattern_type ), intent(in) :: pattern communication pattern integer, intent(in) :: nSize Number of elements in state array integer, intent(in) :: nAuxScalars Number of scalars in auxiliary variables public  subroutine mus_initAuxFieldFluidAndExchange (auxField, state, neigh, nElems, nSize, nFields, stencil, varSys, derVarPos, iLevel, general, quantities) This routine initializes auxField for fluid elements using SAVE access on\nPDF initialized by IC Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(inout) :: auxField auxilary field array real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) connectivity vector integer, intent(in) :: nElems number of elements to compute auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nFields number of fields type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) contains auxField position of all fields in varSys integer, intent(in) :: iLevel current level type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions public  subroutine mus_calcAuxFieldAndExchange (auxField, calcAuxField, state, pdfData, nFields, field, globSrc, stencil, varSys, derVarPos, phyConvFac, general, iLevel, minLevel, schemeHeader, quantities) This routine compute auxField variable from pre-collision pdf and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_auxFieldVar_type ), intent(inout) :: auxField auxilary field array procedure( mus_proc_calcAuxField ), intent(in), pointer :: calcAuxField function pointer to calculate auxField real(kind=rk), intent(in) :: state (:) state array type( pdf_data_type ), intent(in) :: pdfData contains neigh array and nElems on current level integer, intent(in) :: nFields Number of fields type( mus_field_type ), intent(inout) :: field (nFields) contains sources of all fields type( mus_source_type ), intent(inout) :: globSrc global source type( tem_stencilHeader_type ), intent(in) :: stencil stencil header type( tem_varSys_type ), intent(in) :: varSys variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) contains auxField position of all fields in varSys type( mus_convertFac_type ), intent(in) :: phyConvFac physics conversion factors for this level type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl integer, intent(in) :: iLevel current level integer, intent(in) :: minLevel minlevel type( mus_scheme_header_type ), intent(in) :: schemeHeader scheme header type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions public  subroutine mus_intpAuxFieldCoarserAndExchange (intp, tAuxField, sAuxField, tLevelDesc, stencil, iLevel, nAuxScalars, general) This routine interpolate auxField variable for ghostFromFiner and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: intp Interpolation type type( mus_auxFieldVar_type ), intent(inout) :: tAuxField target auxilary field array type( mus_auxFieldVar_type ), intent(in) :: sAuxField source auxilary field array type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: iLevel current level integer, intent(in) :: nAuxScalars number of scalars to interpolate type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl public  subroutine mus_intpAuxFieldFinerAndExchange (intp, tAuxField, sAuxField, tLevelDesc, stencil, iLevel, nAuxScalars, general) This routine interpolate auxField variable for ghostFromCoarser and exchange\nhalos Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: intp Interpolation type type( mus_auxFieldVar_type ), intent(inout) :: tAuxField target auxilary field array type( mus_auxFieldVar_type ), intent(in) :: sAuxField source auxilary field array type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header integer, intent(in) :: iLevel current level integer, intent(in) :: nAuxScalars number of scalars to interpolate type( tem_general_type ), intent(in) :: general contains commPattern, MPI communicator and simControl","tags":"","loc":"module/mus_auxfield_module.html"},{"title":"mus_derVarPos_module – Musubi","text":"This module contains the type defintion which stores position of all\nderive variables in global varSys. function to compute equilFromAux for single element Uses env_module tem_varSys_module tem_aux_module mus_scheme_layout_module tem_stencil_module mus_scheme_derived_quantities_module module~~mus_dervarpos_module~~UsesGraph module~mus_dervarpos_module mus_derVarPos_module env_module env_module module~mus_dervarpos_module->env_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_dervarpos_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_dervarpos_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_dervarpos_module->tem_aux_module tem_stencil_module tem_stencil_module module~mus_dervarpos_module->tem_stencil_module tem_varSys_module tem_varSys_module module~mus_dervarpos_module->tem_varSys_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module tem_logging_module tem_logging_module module~mus_scheme_derived_quantities_module->tem_logging_module tem_param_module tem_param_module module~mus_scheme_derived_quantities_module->tem_param_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_stencil_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_layout_module->aot_table_module aotus_module aotus_module module~mus_scheme_layout_module->aotus_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module module~mus_scheme_layout_module->tem_logging_module module~mus_scheme_layout_module->tem_param_module tem_tools_module tem_tools_module module~mus_scheme_layout_module->tem_tools_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_dervarpos_module~~UsedByGraph module~mus_dervarpos_module mus_derVarPos_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_dervarpos_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_dervarpos_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_dervarpos_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_dervarpos_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_dervarpos_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_dervarpos_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_dervarpos_module module~mus_source_type_module mus_source_type_module module~mus_source_type_module->module~mus_dervarpos_module module~mus_source_var_module mus_source_var_module module~mus_source_var_module->module~mus_dervarpos_module module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_source_var_turbchanforce_module->module~mus_dervarpos_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_dervarpos_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private pure function derive_equilFromAuxFunc(derVarPos, auxField, iField, varSys, layout) result(res) Derive equilibrium from auxField for single element Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: auxField (:) Array of auxField of single element.\nSingle species: dens_1, vel_1\nmultispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2,\nAccess: (iElem-1)*nFields + iField integer, intent(in) :: iField Current field type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights Return Value real(kind=rk), (layout%fStencil%QQ) Output of this routine\nDimension: QQ of res abstract interface private pure function derive_auxFromStateFunc(derVarPos, state, iField, stencil, varSys) result(res) Derive auxField from state for single element Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of derive variable in variable system real(kind=rk), intent(in) :: state (:) Array of state\nlayout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field type( tem_stencilHeader_type ), intent(in) :: stencil stencil header contains discrete velocity vectors type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr Return Value real(kind=rk), (varSys%nAuxScalars) Output of this routine\nSize: nAuxScalars abstract interface private  subroutine derive_FromMacro(density, velocity, iField, nElems, varSys, layout, res) interface to derive equilibrium from macro.\nMainly used in initial condition and boundary condition routines\nto avoid dublication of routines between different scheme kinds.\nIn this interface, solver definition can be access via\nvarSys%method%val(1)%method_data c_ptr Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: density (:) Array of density.\nSingle species: dens_1, dens_2 .. dens_n\nmultispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ...\n               dens_n_sp1, dens_n_sp2\nAccess: (iElem-1)*nFields + iField real(kind=rk), intent(in) :: velocity (:,:) Array of velocity.\nSize: (3, n nFields)\nAccess: ( iComp, (iElem-1) nFields + iField ) integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*nComponents of res abstract interface private  subroutine derive_FromState(state, iField, nElems, varSys, layout, res) Interface that takes state array as input\ncalculate density, velocity or eq as output\nState should be AOS layout Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp abstract interface private  subroutine derive_FromPreColState(state, neigh, iField, nSize, nElems, varSys, layout, res) Interface that takes state array as input\ncalculate density, velocity or eq as output from FETCH state i.e.\nprecollision state\nState should be AOS layout Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: iField Current field integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp abstract interface private  subroutine derive_equilFromAux(derVarPos, auxField, iField, nElems, varSys, layout, res) Derive equilibrium from auxField for given nelems Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: auxField (:) Array of auxField.\nSingle species: dens_1, vel_1, dens_2, vel_2, .. dens_n, vel_n\nmultispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2,\n               dens_2_sp1, vel_2_spc2, dens_2_sp2, vel_2_spc2 ...\n               dens_n_sp1, vel_n_sp1, dens_n_sp2, vel_n_spc2\nAccess: (iElem-1)*nFields + iField integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*QQ of res abstract interface private  subroutine derive_auxFromState(derVarPos, state, neigh, iField, nElems, nSize, iLevel, stencil, varSys, auxField, quantities) Derive auxField from local state.\n\\todo KM: pass external force to add to auxField Arguments Type Intent Optional Attributes Name class( mus_derVarPos_type ), intent(in) :: derVarPos Position of current field derive variable in variable system real(kind=rk), intent(in) :: state (:) Array of state\nnSize * layout%stencil(1)%QQ * nFields\nuse IDX macro to access this state integer, intent(in) :: neigh (:) connectivity vector integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements to compute integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: iLevel current level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header contains discrete velocity vectors type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr real(kind=rk), intent(inout) :: auxField (:) Output of this routine\nauxField is inout to allow storing auxField for each species\nseperately\nSize: nElems*nAuxScalars type( mus_scheme_derived_quantities_type ), intent(in) :: quantities Class that contains pointers to the proper derived quantities functions Derived Types type, public :: mus_derVarPos_type This type stores the position of each variable in the global sys Components Type Visibility Attributes Name Initial integer, public :: pdf = -1 integer, public :: fetch_pdf = -1 integer, public :: omega = -1 integer, public :: density = -1 integer, public :: moleDensity = -1 integer, public :: pressure = -1 integer, public :: kinePress = -1 integer, public :: velocity = -1 integer, public :: spc_velocities = -1 integer, public :: velMag = -1 integer, public :: momentum = -1 integer, public :: spc_momenta = -1 integer, public :: shearStress = -1 integer, public :: wss = -1 integer, public :: shearMag = -1 integer, public :: strainRate = -1 integer, public :: shearRate = -1 integer, public :: kineticEnergy = -1 integer, public :: temperature = -1 integer, public :: moleFrac = -1 integer, public :: massFrac = -1 integer, public :: moleflux = -1 integer, public :: equilibrium = -1 integer, public :: nonEquilibrium = -1 integer, public :: equilibriumVel = -1 integer, public :: potential = -1 procedure( derive_FromMacro ), public, pointer, nopass :: equilFromMacro => null() procedure( derive_FromState ), public, pointer, nopass :: velFromState => null() procedure( derive_FromState ), public, pointer, nopass :: equilFromState => null() procedure( derive_FromState ), public, pointer, nopass :: momFromState => null() procedure( derive_FromState ), public, pointer, nopass :: velocitiesFromState => null() procedure( derive_FromState ), public, pointer, nopass :: momentaFromState => null() procedure( derive_FromPreColState ), public, pointer, nopass :: velFromPreColState => null() procedure( derive_auxFromState ), public, pointer :: auxFieldFromState => null() return auxField from local pdf state procedure( derive_equilFromAux ), public, pointer, nopass :: equilFromAux => null() return equilibrium from auxilary variable for given nElems Subroutines public  subroutine mus_derive_FromMacro_dummy (density, velocity, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: density (:) Array of density.\nSingle species: dens_1, dens_2 .. dens_n\nmultispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ...\n               dens_n_sp1, dens_n_sp2\nAccess: (iElem-1)*nFields + iField real(kind=rk), intent(in) :: velocity (:,:) Array of velocity.\nSize: (3, n nFields)\nAccess: ( iComp, (iElem-1) nFields + iField ) integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n*nComponents of res public  subroutine mus_derive_FromState_dummy (state, iField, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: iField Current field integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp public  subroutine mus_derive_FromPreColState_dummy (state, neigh, iField, nSize, nElems, varSys, layout, res) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: state (:) Array of state\nn * layout%stencil(1)%QQ * nFields integer, intent(in) :: neigh (:) connectivity array integer, intent(in) :: iField Current field integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nElems number of elements type( tem_varSys_type ), intent(in) :: varSys variable system which is required to access fieldProp\ninformation via variable method data c_ptr type( mus_scheme_layout_type ), intent(in) :: layout scheme layout contains stencil definition and lattice weights real(kind=rk), intent(out) :: res (:) Output of this routine\nDimension: n * nComponents of res\nAccess: (iElem-1) nComp + iComp\nTo derive velocities of all species, dimension: n nFields nComp\nAccess: (iElem-1) nFields nComp + (iField-1) nComp + iComp","tags":"","loc":"module/mus_dervarpos_module.html"},{"title":"mus_poisson_module – Musubi","text":"Uses env_module tem_aux_module aotus_module tem_logging_module aot_out_module aot_table_module mus_physics_module module~~mus_poisson_module~~UsesGraph module~mus_poisson_module mus_poisson_module aot_out_module aot_out_module module~mus_poisson_module->aot_out_module aot_table_module aot_table_module module~mus_poisson_module->aot_table_module aotus_module aotus_module module~mus_poisson_module->aotus_module env_module env_module module~mus_poisson_module->env_module module~mus_physics_module mus_physics_module module~mus_poisson_module->module~mus_physics_module tem_aux_module tem_aux_module module~mus_poisson_module->tem_aux_module tem_logging_module tem_logging_module module~mus_poisson_module->tem_logging_module module~mus_physics_module->aot_out_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module tem_tools_module tem_tools_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_poisson_module~~UsedByGraph module~mus_poisson_module mus_poisson_module module~mus_field_prop_module mus_field_prop_module module~mus_field_prop_module->module~mus_poisson_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_source_module->module~mus_field_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_poisson_type Contains information to solve the poission equation Components Type Visibility Attributes Name Initial real(kind=rk), public :: pot_diff Potential diffusivty to tune omega and stability real(kind=rk), public :: omega relaxation parameter real(kind=rk), public :: permittivity the dielectric constant C&#94;2 J&#94;-1 m&#94;-1 type( mus_poisson_boltzmann_type ), public :: PB information of poisson boltmann equation type, private :: mus_poisson_boltzmann_type Contains information to calculate rhs for poisson boltzmann equation.\nDefinition of linear and non-linear poisson boltzmann equation\ncan be found in\nMasilamani, K. (2010). WaLBerla : Investigation of Electrostatic Effects\nin Particulate and Electro-Osmotic Flows. Master Thesis.\nFRIEDRICH-ALEXANDER-UNIVERSITÄT ERLANGEN-NÜRNBERG. Components Type Visibility Attributes Name Initial logical, public :: active Neccesary if source term is poisson_boltzmann real(kind=rk), public :: temp abosulte temperature in Kelvin integer, public :: nIons Number of ions integer, public, allocatable :: valence (:) valence of the ion\nsize: nions real(kind=rk), public :: moleDens0 Mole density of ions in the bulk real(kind=rk), public :: RHS_coeff RHS coeff for linear poisson boltzmann equation real(kind=rk), public :: gasConst_R_LB Gas constant in lattice unit real(kind=rk), public :: faradayLB Faraday constant in lattice unit Read more… Subroutines public  subroutine mus_load_poisson (me, conf, parent, minLevel, cs_lattice, physics, schemeKind) load input to solve poisson equation Arguments Type Intent Optional Attributes Name type( mus_poisson_type ), intent(out) :: me poisson type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle integer, intent(in) :: minLevel minlevel real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout\nrequired to compute omega from potential diffusivity type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa character(len=*), intent(in) :: schemeKind scheme kind public  subroutine mus_load_poissonBoltzmann (me, conf, parent, physics) Load input to solve poisson boltzmann equation Arguments Type Intent Optional Attributes Name type( mus_poisson_boltzmann_type ), intent(out) :: me poisson bolztmann type type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa","tags":"","loc":"module/mus_poisson_module.html"},{"title":"mus_eNRTL_module – Musubi","text":"This module contains an interface for external C++ code to compute\nliquid mixture property like thermodynamic factor and\nMaxwell-Stefan Diffusivity coefficients Uses env_module iso_c_binding tem_logging_module module~~mus_enrtl_module~~UsesGraph module~mus_enrtl_module mus_eNRTL_module env_module env_module module~mus_enrtl_module->env_module iso_c_binding iso_c_binding module~mus_enrtl_module->iso_c_binding tem_logging_module tem_logging_module module~mus_enrtl_module->tem_logging_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface mus_calc_thermFactor private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) Dummy routine which sets thermodynamic factor matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix public        interface mus_calc_MS_DiffMatrix private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) Dummy routine which sets diffusivity coeff matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix Functions public  function mus_init_eNRTL (filename, nFields) result(success) Dummy function to init_enrtl Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1), dimension(*) :: filename integer, intent(out) :: nFields Number of fields defined in the property file Return Value logical Result, indicating the status of encode Subroutines private  subroutine mus_calc_thermFactor_single (nFields, temp, press, mole_frac, therm_factors) Dummy routine which sets thermodynamic factor matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_frac (nFields) mole fraction of all species of single element real(kind=rk), intent(out) :: therm_factors (nFields,nFields) thermodynamic factor matrix private  subroutine mus_calc_MS_DiffMatrix_single (nFields, temp, press, mole_dens, D_ij_out) Dummy routine which sets diffusivity coeff matrix to diagonal matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields number of fields in mixture real(kind=rk), intent(in) :: temp mixture temperature real(kind=rk), intent(in) :: press mixture pressure real(kind=rk), intent(in) :: mole_dens (nFields) mole density of all species of single element real(kind=rk), intent(out) :: D_ij_out (nFields,nFields) thermodynamic factor matrix","tags":"","loc":"module/mus_enrtl_module.html"},{"title":"mus_source_var_turbChanForce_module – Musubi","text":"Module containing subroutines for building MUSUBI specific source\nvariables for turbulent channel flow. To avoid cyclic inclusions Uses env_module iso_c_binding tem_varSys_module mpi mus_derVarPos_module tem_topology_module mus_varSys_module tem_stringKeyValuePair_module mus_source_type_module tem_varMap_module mus_physics_module tem_param_module module~~mus_source_var_turbchanforce_module~~UsesGraph module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module env_module env_module module~mus_source_var_turbchanforce_module->env_module iso_c_binding iso_c_binding module~mus_source_var_turbchanforce_module->iso_c_binding module~mus_dervarpos_module mus_derVarPos_module module~mus_source_var_turbchanforce_module->module~mus_dervarpos_module module~mus_physics_module mus_physics_module module~mus_source_var_turbchanforce_module->module~mus_physics_module module~mus_source_type_module mus_source_type_module module~mus_source_var_turbchanforce_module->module~mus_source_type_module mpi mpi module~mus_source_var_turbchanforce_module->mpi mus_varSys_module mus_varSys_module module~mus_source_var_turbchanforce_module->mus_varSys_module tem_param_module tem_param_module module~mus_source_var_turbchanforce_module->tem_param_module tem_stringKeyValuePair_module tem_stringKeyValuePair_module module~mus_source_var_turbchanforce_module->tem_stringKeyValuePair_module tem_topology_module tem_topology_module module~mus_source_var_turbchanforce_module->tem_topology_module tem_varMap_module tem_varMap_module module~mus_source_var_turbchanforce_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_source_var_turbchanforce_module->tem_varSys_module module~mus_dervarpos_module->env_module module~mus_dervarpos_module->tem_varSys_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_dervarpos_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_dervarpos_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_dervarpos_module->tem_aux_module tem_stencil_module tem_stencil_module module~mus_dervarpos_module->tem_stencil_module module~mus_physics_module->env_module aot_out_module aot_out_module module~mus_physics_module->aot_out_module aot_table_module aot_table_module module~mus_physics_module->aot_table_module aotus_module aotus_module module~mus_physics_module->aotus_module module~mus_physics_module->tem_aux_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_physics_module->tem_logging_module tem_tools_module tem_tools_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module module~mus_source_type_module->env_module module~mus_source_type_module->module~mus_dervarpos_module module~mus_source_type_module->module~mus_physics_module module~mus_source_type_module->tem_stringKeyValuePair_module module~mus_source_type_module->tem_varMap_module module~mus_source_type_module->tem_varSys_module module~mus_source_type_module->aot_table_module module~mus_source_type_module->aotus_module module~mus_absorblayer_module mus_absorbLayer_module module~mus_source_type_module->module~mus_absorblayer_module module~mus_scheme_header_module mus_scheme_header_module module~mus_source_type_module->module~mus_scheme_header_module module~mus_source_type_module->tem_aux_module module~mus_source_type_module->tem_logging_module tem_shape_module tem_shape_module module~mus_source_type_module->tem_shape_module module~mus_source_type_module->tem_stencil_module tem_subTree_type_module tem_subTree_type_module module~mus_source_type_module->tem_subTree_type_module tem_time_module tem_time_module module~mus_source_type_module->tem_time_module module~mus_source_type_module->tem_tools_module module~mus_source_type_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_source_var_turbchanforce_module~~UsedByGraph module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_source_var_turbchanforce_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_variable_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_updateSrcVar_turbChanForce (fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Compute dynamic force term using auxField for turbulent channel\nforce. Read more… Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys","tags":"","loc":"module/mus_source_var_turbchanforce_module.html"},{"title":"mus_turbulence_module – Musubi","text":"This module contains data types, function and routines for turbulence\nmodel. Especially the routine to compute turbulent eddy viscosity for\ndifferent turbulence model author: Kannan Masilamani Uses env_module mus_gradData_module tem_comm_module tem_aux_module aotus_module mus_scheme_layout_module tem_logging_module tem_construction_module aot_table_module tem_tools_module module~~mus_turbulence_module~~UsesGraph module~mus_turbulence_module mus_turbulence_module aot_table_module aot_table_module module~mus_turbulence_module->aot_table_module aotus_module aotus_module module~mus_turbulence_module->aotus_module env_module env_module module~mus_turbulence_module->env_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_turbulence_module->module~mus_scheme_layout_module mus_gradData_module mus_gradData_module module~mus_turbulence_module->mus_gradData_module tem_aux_module tem_aux_module module~mus_turbulence_module->tem_aux_module tem_comm_module tem_comm_module module~mus_turbulence_module->tem_comm_module tem_construction_module tem_construction_module module~mus_turbulence_module->tem_construction_module tem_logging_module tem_logging_module module~mus_turbulence_module->tem_logging_module tem_tools_module tem_tools_module module~mus_turbulence_module->tem_tools_module module~mus_scheme_layout_module->aot_table_module module~mus_scheme_layout_module->aotus_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_logging_module module~mus_scheme_layout_module->tem_tools_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module tem_param_module tem_param_module module~mus_scheme_layout_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_logging_module module~mus_scheme_derived_quantities_module->tem_param_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_turbulence_module~~UsedByGraph module~mus_turbulence_module mus_turbulence_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_turbulence_module module~mus_fluid_module mus_fluid_module module~mus_aux_module->module~mus_fluid_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_aux_module->module~mus_relaxationparam_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_fluid_module->module~mus_turbulence_module module~mus_fluid_module->module~mus_relaxationparam_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_relaxationparam_module->module~mus_turbulence_module module~mus_turb_viscosity_module->module~mus_turbulence_module module~mus_vreman_module mus_Vreman_module module~mus_turb_viscosity_module->module~mus_vreman_module module~mus_wale_module mus_WALE_module module~mus_turb_viscosity_module->module~mus_wale_module module~mus_vreman_module->module~mus_turbulence_module module~mus_wale_module->module~mus_turbulence_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_tools_module->module~mus_relaxationparam_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_tools_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_tracking_module mus_tracking_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface interface to calculate subgrid scale turbulent eddy viscosity private  subroutine proc_calc_turb_visc_fromGradU(turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) This function computes turbulent viscosity from gradient U Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence config contains oefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL turbulence coefficients\ncurrent level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients abstract interface interface to calculate subgrid scale turbulent eddy viscosity private  subroutine proc_calc_turb_visc_fromPreColPDF(turbVisc, turbConfig, state, neigh, auxField, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine) This function compute turbulent viscosity from pre-collision PDF Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence type is implicitly passed to access turbulence coefficients real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL Derived Types type, public :: mus_turbulence_config_type Contains turbulence information loaded from config file Components Type Visibility Attributes Name Initial character(len=labelLen), public :: model turbulence model type type( les_coeff_type ), public :: coeff les model coefficients logical, public :: compSR_fromPDF = .false. To compute strain-rate from non-equilibrium PDF for Smagorinsky les model.\nIf true then velocity and grad data are not required logical, public :: useKolmogorovScale = .true. Use Kolmogorov scale for interpolation turbulent viscosity for multilevel type, public :: mus_turbulence_data_type Contains velocity and gradient data to compute eddy viscosity Components Type Visibility Attributes Name Initial type( tem_communication_type ), public :: sendBuffer Communication buffers to communicate visoscity field\nLocal Fluids required by remote processes type( tem_communication_type ), public :: recvBuffer My halos which are fluids on remote processes type( tem_communication_type ), public :: sendBufferFromCoarser Local ghostFromCoarser required by remote processes type( tem_communication_type ), public :: sendBufferFromFiner Local ghostFromFiner required by remote processes type( tem_communication_type ), public :: recvBufferFromCoarser My halos which are ghostFromCoarser on remote processes type( tem_communication_type ), public :: recvBufferFromFiner My halos which are ghostFromFiner on remote processes real(kind=rk), public, allocatable :: visc (:) Normalized turbulence viscosity\ni.e. viscosity scaled to current level i.e. visc/dtL\nSize: nSize (nFluids+nGhosts+nHalos)\nUsed gradData to compute viscosity for nFluids and nGhosts.\nThis viscosity is interpolated and scaled for setting nonEq term\ninterpolation routines. The source element of interpolation might be\nhalo so they are communicated. Read more… type, public :: mus_turbulence_type Contains information required to compute eddy viscosity Components Type Visibility Attributes Name Initial logical, public :: active is true if turbulence table is defined type( mus_turbulence_config_type ), public :: config information loaded from config file type( mus_turbulence_data_type ), public, allocatable :: dataOnLvl (:) contains level-wise turbulence data to compute eddy viscosity\nsize: minlevel:maxLevel type( mus_turbulence_visc_proc_type ), public :: calcVisc contains turbulence viscosity function pointers real(kind=rk), public :: fac_c2f Factor to scale normalized turbulent viscosity from coarse to fine\ndepending on whether useKolmogorovScale true or false\nif useKolmogorovScale fac_c2f = 1/2&#94;(1/3) else fac_c2f = 1/2\nHow to use: v&#94;s_f = fac_c2f v&#94;s_c real(kind=rk), public :: fac_f2c Factor to scale normalized turbulent viscosity from fine to coarse\ndepending on whether useKolmogorovScale true or false\nif useKolmogorovScale fac_f2c = 2&#94;(1/3) else fac_f2c = 2\nHow to use: v&#94;s_c = fac_f2c v&#94;s_f type, private :: les_coeff_type Contains large Eddy Turbulence (LES) model coefficients Components Type Visibility Attributes Name Initial real(kind=rk), public :: C_s Smagorinsky constant.\nC_s = sqrt(C_k sqrt(C_k/C_e) ) = 0.16778594 = 0.17 real(kind=rk), public :: C_w Model constant for WALE (Wall-Adapting Local Eddy-Viscosity)\ndefault: 0.5 real(kind=rk), public :: C_v Model constant for Vreman model\nIn literature: C_v = sqrt(2.5) C_s = 0.27 real(kind=rk), public :: C_e Modal constant for turbulent kinetic energy dissipation rate\ndefault: 1.048 real(kind=rk), public :: C_k Model constant for eddy-viscosity coefficient\ndefault: 0.094_rk\nhttps://caefn.com/openfoam/smagorinsky-sgs-model type, private :: mus_turbulence_visc_proc_type Contains function pointers to obtain normalized turbulence viscosity.\nViscosity is normalized to current level i.e. v_s = v/dt Components Type Visibility Attributes Name Initial procedure( proc_calc_turb_visc_fromGradU ), public, pointer, nopass :: fromGradU => null() this procedure compute eddy viscosity from velocity field depending\nturbulence and lbm (compressible/incompressible) models procedure( proc_calc_turb_visc_fromPreColPDF ), public, pointer, nopass :: fromPreColPDF => null() this procedure compute eddy viscosity from preCollision PDF.\nIt is used for Smagorinsky model which depends only on strain rate\nthat can be calculated using local nonEquilibrium.\nIs assigned when compSR_fromPDF is .true. Subroutines public  subroutine mus_load_turbulence (me, conf, parent) load turbulence table Arguments Type Intent Optional Attributes Name type( mus_turbulence_type ), intent(out) :: me fluid type type( flu_State ) :: conf lua state integer, intent(in), optional :: parent parent handle public  subroutine mus_init_turbulenceData (me, levelDesc, pattern, nSize) This initialize turbulence data type which includes velocity array\nand communication buffer Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(out) :: me turbulence data Read more… type( tem_levelDesc_type ), intent(in) :: levelDesc levelDesc to access communication buffers of state array type( tem_commPattern_type ), intent(in) :: pattern communication pattern integer, intent(in) :: nSize Number of elements in state array public  subroutine mus_turb_calcVisc (turbData, turbConfig, calcTurbVisc, state, neigh, auxField, gradData, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine, Grad) This routine compute turbulence viscosity and stores in turbulence data type Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(inout) :: turbData turbulence data type type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence configuration type( mus_turbulence_visc_proc_type ), intent(in) :: calcTurbVisc turbulence function real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array type(mus_gradData_type), intent(in) :: gradData gradient data integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL lattice element size in current level real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients public  subroutine mus_turb_updateViscOfTurbWall (turbData, viscTurbWall, nElems_bnd, elemPos) This routine update turbulent viscosity of boundary elements from RANS\nviscosity computed in turbulent_wall boundary. Arguments Type Intent Optional Attributes Name type( mus_turbulence_data_type ), intent(inout) :: turbData turbulence data type real(kind=rk), intent(in) :: viscTurbWall (:) Turbulent viscosity on turbulent wall boundary computed in set boundary integer, intent(in) :: nElems_bnd Number of elements in turbulent_wall boundary integer, intent(in) :: elemPos (:) Position of boundary element in levelwise total list or state array","tags":"","loc":"module/mus_turbulence_module.html"},{"title":"mus_bc_nernstPlanck_module – Musubi","text":"Boundary condition treatment routines for Nernst-Planck equation A detailed description on the implementation details are given in\nboundary_implementation Uses env_module mus_field_prop_module tem_varSys_module mus_mixture_module mus_derVarPos_module mus_scheme_layout_module tem_param_module treelmesh_module tem_time_module mus_param_module mus_physics_module tem_construction_module mus_bc_header_module tem_debug_module module~~mus_bc_nernstplanck_module~~UsesGraph module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module env_module env_module module~mus_bc_nernstplanck_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_bc_nernstplanck_module->module~mus_dervarpos_module module~mus_field_prop_module mus_field_prop_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_mixture_module mus_mixture_module module~mus_bc_nernstplanck_module->module~mus_mixture_module module~mus_param_module mus_param_module module~mus_bc_nernstplanck_module->module~mus_param_module module~mus_physics_module mus_physics_module module~mus_bc_nernstplanck_module->module~mus_physics_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_bc_nernstplanck_module->module~mus_scheme_layout_module mus_bc_header_module mus_bc_header_module module~mus_bc_nernstplanck_module->mus_bc_header_module tem_construction_module tem_construction_module module~mus_bc_nernstplanck_module->tem_construction_module tem_debug_module tem_debug_module module~mus_bc_nernstplanck_module->tem_debug_module tem_param_module tem_param_module module~mus_bc_nernstplanck_module->tem_param_module tem_time_module tem_time_module module~mus_bc_nernstplanck_module->tem_time_module tem_varSys_module tem_varSys_module module~mus_bc_nernstplanck_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_bc_nernstplanck_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine moleDens_nonEqExpol_curved (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine moleDens_neumann_curved (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine moleDens_nonEqExpol (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine moleDens_neumann (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc Level descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info","tags":"","loc":"module/mus_bc_nernstplanck_module.html"},{"title":"mus_scheme_layout_module – Musubi","text":"scheme_layout module, providing the scheme_layout datatype and the\n functionality to read the lua files and to set the predefined stencils. # Scheme Layout The layout includes all information about the stencil, the inverse\n directions, the prevailing directions and the weights. In MUSUBI one can choose among the following predefined layouts: 'predefined_d3q19':\n    The D3Q19 model. The advection relaxation kernel for this model is highly\n    optimized. 'predefined_d3q7':\n    The more simple D3Q7 model. The advection relaxation kernel for this\n    model is highly optimized. 'Flekkoy':\n    The Flekkoy model consists of a D3Q6 stencil and is used for passive\n    scalar transport. In MUSUBI it is also possible to define a new layout in the lua file. This\n feature is implemented to test new layouts. In case one wants to run\n multiple simulations using this layout, it is highly recommended to\n implement a new kernel (the following files have to be extended: mus_flow_module and related modules in source/compute. Defining a new Layout\n To define a new layout one has to set layout = 'new_stencil' . To define the\n stencil the following information has to be provided: the number of offsets (QQ) the offsets (disc_vel) the weights (weight) the inverse directions (inv_dir) as integers pointing on the belonging\n     offsets the prevailing directions (prev_dir) as reals giving the distance in the\n     different directions The following example shows how to define the standard D3Q19 as a new\n layout: -- Scheme scheme = { label = 'test' , layout = 'new_stencil' , -- Initial condition initial_condition = { density = 1.0 , velocityX = 0.0 , velocityY = 0.0 , velocityZ = 0.0 }, -- Boundary conditions boundary_condition = { { label = 'wall' , kind = 'velocity_bounceback' , velocityX = 0.03 , velocityY = 0.0 , velocityZ = 0.0 }, { label = 'wall' , kind = 'wall' , velocityX = 0.0 , velocityY = 0.0 , velocityZ = 0.0 } }, fluid = { relaxation_scheme = 'BGK' , omega = 1.8 , rho0 = 1.0 }, -- Defining the new Stencil stencil = { QQ = 19 , disc_vel = { { - 1 , 0 , 0 },{ 0 , - 1 , 0 },{ 0 , 0 , - 1 },{ 1 , 0 , 0 },{ 0 , 1 , 0 },{ 0 , 0 , 1 },{ 0 , - 1 , - 1 },{ 0 , - 1 , 1 },{ 0 , 1 , - 1 }, { 0 , 1 , 1 },{ - 1 , 0 , - 1 },{ 1 , 0 , - 1 },{ - 1 , 0 , 1 },{ 1 , 0 , 1 },{ - 1 , - 1 , 0 },{ - 1 , 1 , 0 },{ 1 , - 1 , 0 },{ 1 , 1 , 0 }, { 0 , 0 , 0 } }, weight = { ( 1.0 / 18.0 ),( 1.0 / 18.0 ),( 1.0 / 18.0 ),( 1.0 / 18.0 ),( 1.0 / 18.0 ),( 1.0 / 18.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ), ( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ),( 1.0 / 36.0 ), ( 1.0 / 3.0 ) }, inv_dir = { 4 , 5 , 6 , 1 , 2 , 3 , 10 , 9 , 8 , 7 , 14 , 13 , 12 , 11 , 18 , 17 , 16 , 15 , 19 }, prev_dir = { { 1. , 0. , 0. },{ 0. , 1. , 0. },{ 0. , 0. , 1. },{ 1. , 0. , 0. },{ 0. , 1. , 0. },{ 0. , 0. , 1. }, { 0. , 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. )},{ 0. , 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. )}, { 0. , 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. )},{ 0. , 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. )}, { 0.5 * math.sqrt ( 2. ), 0. , 0.5 * math.sqrt ( 2. )},{ 0.5 * math.sqrt ( 2. ), 0. , 0.5 * math.sqrt ( 2. )}, { 0.5 * math.sqrt ( 2. ), 0. , 0.5 * math.sqrt ( 2. )},{ 0.5 * math.sqrt ( 2. ), 0. , 0.5 * math.sqrt ( 2. )}, { 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. ), 0. },{ 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. ), 0. }, { 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. ), 0. },{ 0.5 * math.sqrt ( 2. ), 0.5 * math.sqrt ( 2. ), 0. } } } } Uses env_module tem_grow_array_module mpi tem_aux_module aotus_module mus_moments_type_module tem_stencil_module tem_logging_module aot_table_module aot_out_module tem_param_module mus_scheme_derived_quantities_module tem_tools_module tem_comm_env_module tem_dyn_array_module module~~mus_scheme_layout_module~~UsesGraph module~mus_scheme_layout_module mus_scheme_layout_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_layout_module->aot_table_module aotus_module aotus_module module~mus_scheme_layout_module->aotus_module env_module env_module module~mus_scheme_layout_module->env_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_aux_module tem_aux_module module~mus_scheme_layout_module->tem_aux_module tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_scheme_layout_module->tem_logging_module tem_param_module tem_param_module module~mus_scheme_layout_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module tem_tools_module tem_tools_module module~mus_scheme_layout_module->tem_tools_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_logging_module module~mus_scheme_derived_quantities_module->tem_param_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_scheme_layout_module~~UsedByGraph module~mus_scheme_layout_module mus_scheme_layout_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_scheme_layout_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_scheme_layout_module module~mus_dervarpos_module mus_derVarPos_module module~mus_dervarpos_module->module~mus_scheme_layout_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_layout_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_scheme_layout_module module~mus_hrrinit_module mus_hrrInit_module module~mus_hrrinit_module->module~mus_scheme_layout_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_layout_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_scheme_layout_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_scheme_layout_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_scheme_layout_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_scheme_layout_module module~mus_turbulence_module mus_turbulence_module module~mus_turbulence_module->module~mus_scheme_layout_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_scheme_layout_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_scheme_layout_type data structure containing all information related to the\ncompute stencil. Several stencils can be defined. mus_moments_module Moments are directly related to the\nstencil layout and are therefore defined here Components Type Visibility Attributes Name Initial type( tem_stencilHeader_type ), public :: fStencil fluid stencil same as stencil(1) integer, public :: nStencils number of stencils used in this scheme type( grw_stencilheaderarray_type ), public :: grwStencil Temporary growing array of stencil\nIt is copied to stencil(:) and destroyed, where this is destroyed? type( tem_stencilHeader_type ), public, allocatable :: stencil (:) The list of stencil types, the stencils for the individual schemes\nis ordered as follows: Read more… type( dyn_labelarray_type ), public :: stencil_labels dynamic array of labels created from stencil directions to create unique\ngrowing array of grwStencil integer, public :: fStencil_pos position of fluid stencil in grwStencil real(kind=rk), public, allocatable :: weight (:) The weights for the different discrete velocities real(kind=rk), public :: cs Lattice speed of sound for fStencil\n$\\sum_i (weight_i cx_i cx_i) = c_s&#94;2 I real(kind=rk), public, allocatable :: prevailDir (:,:) Prevailing directions type( mus_moment_type ), public :: moment Moment space definition logical, public :: new_stencil = .false. New stencil definition loaded from config type( mus_scheme_derived_quantities_type ), public :: quantities derive quantities that depends on the layout such as velocity, pdf_eq, etc.. Functions private  function mus_calculate_speed_of_sound (layout) result(c_sound) Calculate lattice speed of sound for given stencil Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state Return Value real(kind=rk) Subroutines public  subroutine mus_load_newLayout (me, parent_handle, conf) load a new stencil definition from the lua file Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ) :: me integer, intent(in), optional :: parent_handle type( flu_State ) :: conf public  subroutine mus_weights_out (me, conf) Dump the weights in lua format. Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: me (:) weights type( aot_out_type ) :: conf public  subroutine mus_init_layout (layout) Initialize growing array of stencils Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout musubi schemes layout type public  subroutine mus_finalize_layout (layout, nElemsInTree, minLevel, maxLevel, proc) This routine finialize grwStencil by truncating stencil elem arrays and\nset stencil%nElems Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout integer, intent(in) :: nElemsInTree fluid tree from mesh integer, intent(in) :: minLevel min and max level integer, intent(in) :: maxLevel min and max level type( tem_comm_env_type ), intent(in) :: proc mpi communication type public  subroutine mus_destroy_stencil (stencil) Destroy the stencil Arguments Type Intent Optional Attributes Name type( tem_stencilHeader_type ), intent(out), allocatable :: stencil (:) musubi schemes stencil type public  subroutine mus_define_layout (layout, stencilName, nElems) This routine defines layout for predefined stencils Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state character(len=*), intent(in) :: stencilName Name of the stencil to create integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_define_d3q19 (layout, nElems) This subroutine sets the parameters for the predefined d3q19 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d3q19 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (19) public  subroutine mus_define_d3q27 (layout, nElems) This subroutine sets the parameters for the predefined d3q27 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d3q27 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (27) public  subroutine mus_define_d3q7 (layout, nElems) This subroutine sets the parameters for the predefined d3q7 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d3q7 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (7) public  subroutine mus_define_d3q6 (layout, nElems) This subroutine sets the parameters for the predefined d3q6\nlayout%fStencil, used by the Flekkoy model of passive scalar transport. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d3q6 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (6) public  subroutine mus_define_d2q9 (layout, nElems) This subroutine sets the parameters for the predefined d2q9 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d2q9 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (9) public  subroutine mus_define_d1q3 (layout, nElems) This subroutine sets the parameters for the predefined d2q9 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout public  subroutine mus_set_weights_d1q3 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (3) private  subroutine mus_define_d3q13 (layout, nElems) This subroutine sets the parameters for the predefined d3q13 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout private  subroutine mus_set_weights_d3q13 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (13) private  subroutine mus_define_d2q5 (layout, nElems) This subroutine sets the parameters for the predefined d2q5 stencil. Arguments Type Intent Optional Attributes Name type( mus_scheme_layout_type ), intent(inout) :: layout scheme layout for pdf state integer, intent(in) :: nElems number of elements use this layout private  subroutine mus_set_weights_d2q5 (weights) Arguments Type Intent Optional Attributes Name real(kind=rk) :: weights (5)","tags":"","loc":"module/mus_scheme_layout_module.html"},{"title":"mus_transport_var_module – Musubi","text":"Module containing subroutines for building MUSUBI specific transport\nvariables to use in compute kernels and source update Uses tem_dyn_array_module env_module iso_c_binding tem_varSys_module tem_aux_module tem_tools_module aotus_module tem_stringKeyValuePair_module treelmesh_module tem_varMap_module tem_stencil_module tem_logging_module tem_construction_module mus_scheme_header_module aot_out_module tem_geometry_module tem_operation_module module~~mus_transport_var_module~~UsesGraph module~mus_transport_var_module mus_transport_var_module aot_out_module aot_out_module module~mus_transport_var_module->aot_out_module aotus_module aotus_module module~mus_transport_var_module->aotus_module env_module env_module module~mus_transport_var_module->env_module iso_c_binding iso_c_binding module~mus_transport_var_module->iso_c_binding module~mus_scheme_header_module mus_scheme_header_module module~mus_transport_var_module->module~mus_scheme_header_module tem_aux_module tem_aux_module module~mus_transport_var_module->tem_aux_module tem_construction_module tem_construction_module module~mus_transport_var_module->tem_construction_module tem_dyn_array_module tem_dyn_array_module module~mus_transport_var_module->tem_dyn_array_module tem_geometry_module tem_geometry_module module~mus_transport_var_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_transport_var_module->tem_logging_module tem_operation_module tem_operation_module module~mus_transport_var_module->tem_operation_module tem_stencil_module tem_stencil_module module~mus_transport_var_module->tem_stencil_module tem_stringKeyValuePair_module tem_stringKeyValuePair_module module~mus_transport_var_module->tem_stringKeyValuePair_module tem_tools_module tem_tools_module module~mus_transport_var_module->tem_tools_module tem_varMap_module tem_varMap_module module~mus_transport_var_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_transport_var_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_transport_var_module->treelmesh_module module~mus_scheme_header_module->aot_out_module module~mus_scheme_header_module->aotus_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module module~mus_scheme_header_module->tem_tools_module aot_table_module aot_table_module module~mus_scheme_header_module->aot_table_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_transport_var_module~~UsedByGraph module~mus_transport_var_module mus_transport_var_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_transport_var_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_transport_var_module module~mus_scheme_module mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_scheme_module->module~mus_transport_var_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_type_module->module~mus_transport_var_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_scheme_type_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_transport_var_type Description of musubi transport variable type Components Type Visibility Attributes Name Initial type( mus_transport_op_type ), public, allocatable :: method (:) Contains variable pntIndex to setup_index and getValOfIndex\nSize: varDict%nVals type( grw_stringkeyvaluepairarray_type ), public :: varDict Dictionary of transport variable with\nvarDict%val()%key is the name of transport variable and\nvarDict%val()%value is the name of variable provided for the key type, private :: mus_transport_op_type Description contains index to access value using variable function\npointer Components Type Visibility Attributes Name Initial integer, public :: data_varpos Position of data variable provided in config file in the varSys type( tem_indexLvl_type ), public :: pntIndex Indices for points for nElems_solve (nFluids + nGhostsFromCoarser).\nOrder of index matches levelDesc%total list, required for setup_index,\ngetvalof_Index Subroutines public  subroutine mus_create_poss_transVar (poss_transVar, schemeHeader) Routine initialize possible transport variable depends on scheme kind Arguments Type Intent Optional Attributes Name type( tem_possible_variable_type ), intent(out) :: poss_transVar possible transport variables type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme public  subroutine mus_load_transport_var (me, possVars, conf, parent, varSys, schemeHeader) Routine load musubi transport variables Arguments Type Intent Optional Attributes Name type( mus_transport_var_type ), intent(out) :: me transport variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible transport variables type( flu_State ) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined type( tem_varSys_type ), intent(inout) :: varSys Global variable system type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme public  subroutine mus_init_transport_var (me, varSys, tree, nElems_solve, levelDesc) Initialize transport variable by calling setupIndices for every variable\nand store pntIndex Arguments Type Intent Optional Attributes Name type( mus_transport_var_type ), intent(inout) :: me transport variable to fill in type( tem_varSys_type ), intent(in) :: varSys global variable system type( treelmesh_type ), intent(in) :: tree global treelm mesh integer, intent(in) :: nElems_solve (tree%global%minLevel:) Number of elements to solve in all levels\nnFluids + nGhosts type( tem_levelDesc_type ), intent(in) :: levelDesc (tree%global%minLevel:) Level descriptors","tags":"","loc":"module/mus_transport_var_module.html"},{"title":"mus_geom_module – Musubi","text":"This module contains the definition of geometry type and routines to\ngeometry information like mesh, boundary, immersed_boundary and restart Uses env_module tem_timeControl_module tem_global_module tem_bc_prop_module mus_geomIncrHead_module mus_IBM_module tem_tools_module treelmesh_module tem_property_module tem_logging_module tem_solveHead_module tem_simControl_module tem_geometry_module tem_restart_module tem_comm_env_module module~~mus_geom_module~~UsesGraph module~mus_geom_module mus_geom_module env_module env_module module~mus_geom_module->env_module module~mus_geomincrhead_module mus_geomIncrHead_module module~mus_geom_module->module~mus_geomincrhead_module mus_IBM_module mus_IBM_module module~mus_geom_module->mus_IBM_module tem_bc_prop_module tem_bc_prop_module module~mus_geom_module->tem_bc_prop_module tem_comm_env_module tem_comm_env_module module~mus_geom_module->tem_comm_env_module tem_geometry_module tem_geometry_module module~mus_geom_module->tem_geometry_module tem_global_module tem_global_module module~mus_geom_module->tem_global_module tem_logging_module tem_logging_module module~mus_geom_module->tem_logging_module tem_property_module tem_property_module module~mus_geom_module->tem_property_module tem_restart_module tem_restart_module module~mus_geom_module->tem_restart_module tem_simControl_module tem_simControl_module module~mus_geom_module->tem_simControl_module tem_solveHead_module tem_solveHead_module module~mus_geom_module->tem_solveHead_module tem_timeControl_module tem_timeControl_module module~mus_geom_module->tem_timeControl_module tem_tools_module tem_tools_module module~mus_geom_module->tem_tools_module treelmesh_module treelmesh_module module~mus_geom_module->treelmesh_module module~mus_geomincrhead_module->env_module module~mus_geomincrhead_module->tem_logging_module module~mus_geomincrhead_module->tem_timeControl_module module~mus_geomincrhead_module->tem_tools_module aot_table_module aot_table_module module~mus_geomincrhead_module->aot_table_module aot_vector_module aot_vector_module module~mus_geomincrhead_module->aot_vector_module aotus_module aotus_module module~mus_geomincrhead_module->aotus_module module~mus_param_module mus_param_module module~mus_geomincrhead_module->module~mus_param_module tem_depend_module tem_depend_module module~mus_geomincrhead_module->tem_depend_module module~mus_param_module->env_module module~mus_param_module->tem_logging_module module~mus_param_module->tem_tools_module module~mus_param_module->aotus_module aot_out_module aot_out_module module~mus_param_module->aot_out_module module~mus_abortcriteria_module mus_abortCriteria_module module~mus_param_module->module~mus_abortcriteria_module module~mus_physics_module mus_physics_module module~mus_param_module->module~mus_physics_module tem_general_module tem_general_module module~mus_param_module->tem_general_module module~mus_abortcriteria_module->env_module module~mus_abortcriteria_module->aotus_module tem_abortCriteria_module tem_abortCriteria_module module~mus_abortcriteria_module->tem_abortCriteria_module module~mus_physics_module->env_module module~mus_physics_module->tem_geometry_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module module~mus_physics_module->treelmesh_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->aot_out_module tem_aux_module tem_aux_module module~mus_physics_module->tem_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_geom_module~~UsedByGraph module~mus_geom_module mus_geom_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_geom_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_geom_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_geom_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_geom_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_geom_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_geom_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_geom_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_geom_module module~mus_scheme_module->module~mus_geom_module module~mus_tracking_module->module~mus_geom_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_geom_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_geom_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module module~mus_tools_module->module~mus_scheme_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_geom_type Geometric information and definitions Components Type Visibility Attributes Name Initial type( treelmesh_type ), public :: tree tree data type type( tem_BC_prop_type ), public :: boundary boundary information as stored on disk type( mus_geomIncrHead_type ), public, allocatable :: geomIncr (:) The header type containing all the geometry increase information logical, public :: dynamicGeom = .false. Logical to define whether geometry increase is active or not integer, public, allocatable :: posInBndID (:) Tree element position in the boundary_ID( nDir, nElems) in bc_prop_type\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  posInBndID = posInBndID( iElem )\n  ! current element has boundary only if posInBndID>0\n  ! else posInBndID = -1\n  if (posInBnd > 0 )\n    bnd_ID(1:nDir) = bc_prop%boundary_ID( 1:nDir, posInBndID )\n  end if\nend do integer, public, allocatable :: posInQVal (:) Tree element position in the qVal( nDir, nElems) in bc_prop_type\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  posInQVal = posInQVal( iElem )\n  ! current element has qVal if posInQVal>0 else posInQVal = -1\n  if (posInQVal > 0 )\n    qVal(1:nDir) = bc_prop%qVal( 1:nDir, posInQVal )\n  end if\nend do integer, public, allocatable :: levelPointer (:) tree element position in level descriptor total list\nit has a size of tree%nElems\nHow to use:\ndo iElem = 1, tree%nElems\n  treeID = tree%treeID( iElem )\n  level = tem_levelOf( treeID )\n  posInTotal = levelPointer( iElem )\n  treeID = LevelDesc( iLevel )%total( posInTotal )\nend do integer, public, allocatable :: bcLevelPointer (:) Boundary element poisition in the levelwise globBC%elemLvl(:)%elem%val\nIt has a size of geometry%boundary%property%nElems.\nIt is used in tracking to extract value stored in boundary types.\nHot to use this access normal direction of boundary element:\ndo iElem = 1, tree%nElems\n  level = tem_levelOf( treeID )\n  posInBndID = posInBndID(iElem)\n  if (posInBndID > 0) then\n    BCIDs = bc_prop%boundary_ID(:, posInBndID)\n    minBCID = minval(BCIDs, BCIDs > 0)\n    posInBcElem = bcLevelPointer(posInBndID)\n    normal = globBC%elemLvl(iLevel)%normal(posInBcElem)\n  end if\nend do integer, public, allocatable :: minBcID (:) Minimum bcID for each boundary element.\nif a element has more than one boundary then use minBcID which depends\non boundary order in seeder configuration. type(mus_IBM_globType), public :: globIBM immersed boundary data real(kind=rk), public, allocatable :: bndForce (:,:) Contains Forces on boundary elements computed using momentum exchange\nmethod. This will be used to derive_bndForce routine to compute force\nof certain boundaries.\nForces are stored in level-independent fashion as geometry%boundaryID\nloaded from mesh files.\nDim1: geometry%boundaryi%property%nElems\nDim2: 3 real(kind=rk), public, allocatable :: bndMoment (:,:) Contains Moments on boundary elements computed using momentum exchange\nmethod. This will be used to derive_bndMoment routine to compute moment\nof certain boundaries.\nForces are stored in level-independent fashion as geometry%boundaryID\nloaded from mesh files.\nDim1: geometry%boundaryi%property%nElems\nDim2: 3 Subroutines public  subroutine mus_load_geom (me, restart, solverHead, simControl, proc, scaleFactor, initial_balance) This routine load all geometry related datas like mesh, boundary\nand immersed_boundary. Restart is also loaded here because mesh is loaded\nin tem_load_restart if restart read is defined. Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(out) :: me type( tem_restart_type ), intent(out) :: restart contains restart information type( tem_solveHead_type ), intent(inout) :: solverHead contains general description of the solver including flu_state type( tem_simControl_type ), intent(inout) :: simControl contains simulation time control information type( tem_comm_env_type ), intent(in) :: proc contains MPI communication environment integer, intent(in) :: scaleFactor Temporal scaling factor for multilevel mesh logical, intent(in) :: initial_balance If true, do initial balancing using level_weights public  subroutine mus_load_bc_data (geometry, rank, comm) This routine invokes the treelm routines to load the boundary conditions Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: geometry integer, intent(in) :: rank integer, intent(in) :: comm public  subroutine mus_build_posInProp (me) This routine builds mapping between elements in tree to to propery list Arguments Type Intent Optional Attributes Name type( mus_geom_type ), intent(inout) :: me private  subroutine mus_build_minBcID (minBcID, bc_prop, posInBndID) This routine build minBcID for boundary elements, it is required if a\nelement has more than one boundary in its directions.\nif a element has more than one boundary then use minBcID which depends\non boundary order in seeder configuration Arguments Type Intent Optional Attributes Name integer, intent(out), allocatable :: minBcID (:) type( tem_BC_prop_type ), intent(in) :: bc_prop boundary information from mesh integer, intent(in) :: posInBndID (:) tree element position in boundaryID","tags":"","loc":"module/mus_geom_module.html"},{"title":"mus_initIsothermAcEq_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for lbm model for acoustic equations. Uses env_module tem_aux_module mus_isotherm_acEq_module mus_scheme_type_module tem_logging_module module~~mus_initisothermaceq_module~~UsesGraph module~mus_initisothermaceq_module mus_initIsothermAcEq_module env_module env_module module~mus_initisothermaceq_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initisothermaceq_module->module~mus_scheme_type_module mus_isotherm_acEq_module mus_isotherm_acEq_module module~mus_initisothermaceq_module->mus_isotherm_acEq_module tem_aux_module tem_aux_module module~mus_initisothermaceq_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initisothermaceq_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_isotherm_acEq (relaxation, layout, compute) Assigning compute kernel routine by scheme relaxation type for\nisotherm_acEq kind. Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(inout) :: relaxation character(len=labelLen), intent(in) :: layout procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initisothermaceq_module.html"},{"title":"mus_timer_module – Musubi","text":"This module contains data types and routines used to measure time spend on\nmusubi routines.\nauthor: Kannan Masilamani Uses env_module tem_timer_module module~~mus_timer_module~~UsesGraph module~mus_timer_module mus_timer_module env_module env_module module~mus_timer_module->env_module tem_timer_module tem_timer_module module~mus_timer_module->tem_timer_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_timer_module~~UsedByGraph module~mus_timer_module mus_timer_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_timer_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_timer_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_timer_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_timer_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_weights_module mus_weights_module module~mus_dynloadbal_module->module~mus_weights_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_timer_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_timer_module module~mus_source_module->module~mus_timer_module module~mus_tools_module->module~mus_timer_module module~mus_weights_module->module~mus_timer_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_timer_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_timer_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: nStages = 12 type( mus_timer_handle_type ), public, save :: mus_timerHandles Musubi timer type -------------------------------------------------- Interfaces public        interface get_boundaryTime private  function get_boundaryTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_boundaryTime_byID (bcID) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: bcID Return Value real(kind=rk) public        interface get_computeTime private  function get_computeTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_computeTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_computeRatio private  function get_computeRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_computeRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_auxTime private  function get_auxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_auxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_relaxTime private  function get_relaxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_relaxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_intpFromCoarserTime private  function get_intpFromCoarserTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_intpFromCoarserRatio private  function get_intpFromCoarserRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) public        interface get_intpFromFinerTime private  function get_intpFromFinerTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_intpFromFinerRatio private  function get_intpFromFinerRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) public        interface get_bcBufferTime private  function get_bcBufferTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_bcBufferTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) public        interface get_bcBufferRatio private  function get_bcBufferRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_bcBufferRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) Derived Types type, public :: mus_timer_handle_type Musubi timer type -------------------------------------------------- Components Type Visibility Attributes Name Initial integer, public :: mainloop handle for the complete mainloop integer, public :: loadMesh handle for loading / creating the mesh and config integer, public :: initLvlD handle for initialising the levelDescriptor integer, public :: wRestart handle for writing restart integer, public :: balance handle for the dyn_loadBal routine integer, public :: source handle for source terms integer, public :: first = 0 First main handle position in treelm timer object integer, public :: last = -1 Last main handle position in treelm timer object integer, public, allocatable :: compute (:) handle for advection relaxation integer, public, allocatable :: aux (:) handle for auxfield calculation integer, public, allocatable :: relax (:) handle for relax parameter update integer, public, allocatable :: comm (:) handle for communicate integer, public, allocatable :: intpFromCoarser (:) handle for interpolation and communicate integer, public, allocatable :: intpFromFiner (:) integer, public, allocatable :: commFromCoarser (:) integer, public, allocatable :: commFromFiner (:) integer, public, allocatable :: setBnd (:) handle for setboundary integer, public, allocatable :: bcBuffer (:) integer, public, allocatable :: doIBM (:) handle for immersed boundary method integer, public :: stage (nStages) Stage timers for multi level recursive algorithm integer, public :: minLevel min. level in mesh integer, public :: maxLevel max. level in mesh integer, public :: nBCs number of BCs Functions public  function mus_get_timerHandles () result(timerHandles) This function returns musubi modular variable mus_timerHandles to apesmate\nand deallocate mus_timerHandles level timers. Arguments None Return Value type( mus_timer_handle_type ) public  function get_communicateTime () result(time) Arguments None Return Value real(kind=rk) public  function get_communicateRatio () result(ratio) Arguments None Return Value real(kind=rk) public  function get_boundaryRatio () result(ratio) Arguments None Return Value real(kind=rk) public  function get_intpRatio () result(ratio) Arguments None Return Value real(kind=rk) public  function get_mainLoopTime () result(time) Arguments None Return Value real(kind=rk) public  function get_stageTime (ii) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii Return Value real(kind=rk) public  function get_stageRatio (ii) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii Return Value real(kind=rk) private  function get_computeTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_computeTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_computeRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_computeRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_auxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_auxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_relaxTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_relaxTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_intpFromCoarserTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_intpFromCoarserRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromCoarserRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) private  function get_intpFromFinerTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_intpFromFinerRatio_total () result(ratio) Arguments None Return Value real(kind=rk) private  function get_intpFromFinerRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer :: level Return Value real(kind=rk) private  function get_boundaryTime_byID (bcID) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: bcID Return Value real(kind=rk) private  function get_boundaryTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_intpTime () result(time) Arguments None Return Value real(kind=rk) private  function get_bcBufferTime_atLevel (level) result(time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_bcBufferTime_total () result(time) Arguments None Return Value real(kind=rk) private  function get_bcBufferRatio_atLevel (level) result(ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Return Value real(kind=rk) private  function get_bcBufferRatio_total () result(ratio) Arguments None Return Value real(kind=rk) Subroutines public  subroutine mus_init_mainTimer () Timers initialization routine for whatever Arguments None public  subroutine mus_init_levelTimer (minLevel, maxLevel) Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_reset_levelTimer () Arguments None public  subroutine mus_reset_mainTimer () Arguments None public  subroutine mus_set_timerHandles (timerHandles) This routine sets mus_timerHandles passed by apesmate Arguments Type Intent Optional Attributes Name type( mus_timer_handle_type ), intent(in) :: timerHandles public  subroutine mus_init_bcTimer (nBCs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nBCs public  subroutine mus_reset_bcTimer () Arguments None","tags":"","loc":"module/mus_timer_module.html"},{"title":"mus_config_module – Musubi","text":"In this module, all parameter files are read in\nas lua script or a sample configuration is being loaded Possible Parameter configuration General Parameters mus_scheme_layout_module for Scheme Definitions tem_debug_module for Debug Parameters Uses env_module mus_tools_module mus_scheme_type_module aotus_module mus_varSys_module mus_geom_module mus_timer_module tem_general_module mus_param_module tem_tools_module tem_comm_env_module mus_scheme_module tem_logging_module tem_debug_module mpi tem_aux_module tem_adaptation_config_module tem_timer_module mus_physics_module module~~mus_config_module~~UsesGraph module~mus_config_module mus_config_module aotus_module aotus_module module~mus_config_module->aotus_module env_module env_module module~mus_config_module->env_module module~mus_geom_module mus_geom_module module~mus_config_module->module~mus_geom_module module~mus_param_module mus_param_module module~mus_config_module->module~mus_param_module module~mus_physics_module mus_physics_module module~mus_config_module->module~mus_physics_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_scheme_type_module mus_scheme_type_module module~mus_config_module->module~mus_scheme_type_module module~mus_timer_module mus_timer_module module~mus_config_module->module~mus_timer_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module mpi mpi module~mus_config_module->mpi mus_varSys_module mus_varSys_module module~mus_config_module->mus_varSys_module tem_adaptation_config_module tem_adaptation_config_module module~mus_config_module->tem_adaptation_config_module tem_aux_module tem_aux_module module~mus_config_module->tem_aux_module tem_comm_env_module tem_comm_env_module module~mus_config_module->tem_comm_env_module tem_debug_module tem_debug_module module~mus_config_module->tem_debug_module tem_general_module tem_general_module module~mus_config_module->tem_general_module tem_logging_module tem_logging_module module~mus_config_module->tem_logging_module tem_timer_module tem_timer_module module~mus_config_module->tem_timer_module tem_tools_module tem_tools_module module~mus_config_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_config_module~~UsedByGraph module~mus_config_module mus_config_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_config_module program~musubi musubi program~musubi->module~mus_config_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_load_config (scheme, solverData, geometry, params, adapt) Read in LUA parameter file\nSee http://www.lua.org for a reference on how to use\nLua is a scripting language in itself which allows\nmore complex parameter files including comments\nAnd load / create the mesh depending on the configuration Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), target :: scheme scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(out), target :: geometry Treelmesh data type( mus_param_type ), intent(inout), target :: params Global parameters type( tem_adapt_type ), intent(inout) :: adapt mesh adaptation public  subroutine mus_open_config (conf, filename, proc) This routine loads musubi specific lua function from string and musubi\ninput configuration file Arguments Type Intent Optional Attributes Name type( flu_State ), allocatable :: conf (:) lua state to be stored character(len=*), intent(in) :: filename name of the config file to be opened type( tem_comm_env_type ), intent(in) :: proc process description to use","tags":"","loc":"module/mus_config_module.html"},{"title":"mus_mrtInit_module – Musubi","text":"This module provides the definitions of M and Minv for\nMRT advection relaxation scheme for all stencils. The weighted MRT (D3Q27) is based on the following paper\nAbbas Fakhari, Diogo Bolster, Li-Shi Luo\n\"A weighted multiple-relaxation-time lattice Boltzmann method for multiphase\nflows and its application to partial coalescence cascades\"\nJournal of Computational Physics, 2017 The MRT (D3Q19) implementation here is taken from:\\n\nJ. Toelke, S. Freudiger, and M. Krafczyk,\n\"An adaptive scheme using hierarchical grids for lattice Boltzmann\nmulti-phase flow simulations,\" Comput. Fluids, vol. 35, pp. 820–830,\n2006. \\n Uses env_module tem_param_module module~~mus_mrtinit_module~~UsesGraph module~mus_mrtinit_module mus_mrtInit_module env_module env_module module~mus_mrtinit_module->env_module tem_param_module tem_param_module module~mus_mrtinit_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_mrtinit_module~~UsedByGraph module~mus_mrtinit_module mus_mrtInit_module module~mus_moments_module mus_moments_module module~mus_moments_module->module~mus_mrtinit_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_moments_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter,               dimension(19,19) :: MMtrD3Q19 = reshape((/1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, -1._rk, -2._rk, -2._rk, -2._rk, -2._rk, -2._rk, -2._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 2._rk, 0._rk, 0._rk, -2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 2._rk, 0._rk, 0._rk, -2._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, 0._rk, 0._rk, -2._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, -1._rk, -1._rk, 2._rk, -1._rk, -1._rk, -2._rk, -2._rk, -2._rk, -2._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, -2._rk, 1._rk, 1._rk, -2._rk, 1._rk, 1._rk, -2._rk, -2._rk, -2._rk, -2._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 1._rk, -1._rk, 0._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, -1._rk, 1._rk, 0._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk/), (/19, 19/), order=(/2, 1/)) real(kind=rk), public, parameter,               dimension(19,19) :: MMivD3Q19 = reshape((/div1_18, 0._rk, -div1_18, -div1_6, div1_6, 0._rk, 0._rk, 0._rk, 0._rk, div1_12, -div1_12, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, -div1_18, 0._rk, 0._rk, -div1_6, div1_6, 0._rk, 0._rk, -div1_24, div1_24, div1_8, -div1_8, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, -div1_18, 0._rk, 0._rk, 0._rk, 0._rk, -div1_6, div1_6, -div1_24, div1_24, -div1_8, div1_8, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, -div1_18, div1_6, -div1_6, 0._rk, 0._rk, 0._rk, 0._rk, div1_12, -div1_12, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, -div1_18, 0._rk, 0._rk, div1_6, -div1_6, 0._rk, 0._rk, -div1_24, div1_24, div1_8, -div1_8, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, -div1_18, 0._rk, 0._rk, 0._rk, 0._rk, div1_6, -div1_6, -div1_24, div1_24, -div1_8, div1_8, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_36, div1_24, div1_72, 0._rk, 0._rk, -div1_12, -div1_24, -div1_12, -div1_24, -div1_24, -div1_24, 0._rk, 0._rk, 0._rk, div1_4, 0._rk, 0._rk, -div1_8, div1_8, div1_36, div1_24, div1_72, 0._rk, 0._rk, -div1_12, -div1_24, div1_12, div1_24, -div1_24, -div1_24, 0._rk, 0._rk, 0._rk, -div1_4, 0._rk, 0._rk, -div1_8, -div1_8, div1_36, div1_24, div1_72, 0._rk, 0._rk, div1_12, div1_24, -div1_12, -div1_24, -div1_24, -div1_24, 0._rk, 0._rk, 0._rk, -div1_4, 0._rk, 0._rk, div1_8, div1_8, div1_36, div1_24, div1_72, 0._rk, 0._rk, div1_12, div1_24, div1_12, div1_24, -div1_24, -div1_24, 0._rk, 0._rk, 0._rk, div1_4, 0._rk, 0._rk, div1_8, -div1_8, div1_36, div1_24, div1_72, -div1_12, -div1_24, 0._rk, 0._rk, -div1_12, -div1_24, div1_48, div1_48, -div1_16, -div1_16, 0._rk, 0._rk, div1_4, div1_8, 0._rk, -div1_8, div1_36, div1_24, div1_72, div1_12, div1_24, 0._rk, 0._rk, -div1_12, -div1_24, div1_48, div1_48, -div1_16, -div1_16, 0._rk, 0._rk, -div1_4, -div1_8, 0._rk, -div1_8, div1_36, div1_24, div1_72, -div1_12, -div1_24, 0._rk, 0._rk, div1_12, div1_24, div1_48, div1_48, -div1_16, -div1_16, 0._rk, 0._rk, -div1_4, div1_8, 0._rk, div1_8, div1_36, div1_24, div1_72, div1_12, div1_24, 0._rk, 0._rk, div1_12, div1_24, div1_48, div1_48, -div1_16, -div1_16, 0._rk, 0._rk, div1_4, -div1_8, 0._rk, div1_8, div1_36, div1_24, div1_72, -div1_12, -div1_24, -div1_12, -div1_24, 0._rk, 0._rk, div1_48, div1_48, div1_16, div1_16, div1_4, 0._rk, 0._rk, -div1_8, div1_8, 0._rk, div1_36, div1_24, div1_72, -div1_12, -div1_24, div1_12, div1_24, 0._rk, 0._rk, div1_48, div1_48, div1_16, div1_16, -div1_4, 0._rk, 0._rk, -div1_8, -div1_8, 0._rk, div1_36, div1_24, div1_72, div1_12, div1_24, -div1_12, -div1_24, 0._rk, 0._rk, div1_48, div1_48, div1_16, div1_16, -div1_4, 0._rk, 0._rk, div1_8, div1_8, 0._rk, div1_36, div1_24, div1_72, div1_12, div1_24, div1_12, div1_24, 0._rk, 0._rk, div1_48, div1_48, div1_16, div1_16, div1_4, 0._rk, 0._rk, div1_8, -div1_8, 0._rk, div1_3, -div1_2, div1_6, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk/), (/19, 19/), order=(/2, 1/)) real(kind=rk), public, parameter,               dimension(27,27) :: WMMtrD3Q27 = reshape((/1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, -1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 1._rk, -1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, -1._rk, 1._rk, 0._rk, 2._rk, -1._rk, -1._rk, 2._rk, -1._rk, -1._rk, -2._rk, -2._rk, -2._rk, -2._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 0._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 1._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, -1._rk, 2._rk, 0._rk, 0._rk, -2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, -4._rk, -4._rk, -4._rk, -4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 0._rk, 0._rk, 2._rk, 0._rk, 0._rk, -2._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, -1._rk, 1._rk, -4._rk, -4._rk, 4._rk, 4._rk, -4._rk, -4._rk, 4._rk, 4._rk, 0._rk, 0._rk, 0._rk, 2._rk, 0._rk, 0._rk, -2._rk, -1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -4._rk, 4._rk, -4._rk, 4._rk, -4._rk, 4._rk, -4._rk, 4._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, -1._rk, 1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, 1._rk, -1._rk, 1._rk, -1._rk, -1._rk, 1._rk, 0._rk, -1._rk, -1._rk, -1._rk, -1._rk, -1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 1._rk, -2._rk, 1._rk, 1._rk, -2._rk, 1._rk, 1._rk, -4._rk, -4._rk, -4._rk, -4._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, 0._rk, -1._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, -2._rk, -2._rk, -2._rk, -2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, 1._rk, -1._rk, 2._rk, 2._rk, -2._rk, -2._rk, -2._rk, -2._rk, 2._rk, 2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, -2._rk, -2._rk, 2._rk, 2._rk, -2._rk, -2._rk, 2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -1._rk, 1._rk, 1._rk, -1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, -2._rk, 2._rk, -2._rk, -2._rk, 2._rk, -2._rk, 2._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, -2._rk, 2._rk, -2._rk, 2._rk, 2._rk, -2._rk, -2._rk, -4._rk, -4._rk, -4._rk, -4._rk, 4._rk, 4._rk, 4._rk, 4._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, 0._rk, 2._rk, 2._rk, -2._rk, -2._rk, 0._rk, 0._rk, 0._rk, 0._rk, 2._rk, -2._rk, 2._rk, -2._rk, -4._rk, -4._rk, 4._rk, 4._rk, -4._rk, -4._rk, 4._rk, 4._rk, 0._rk, 0._rk, 0._rk, -1._rk, 0._rk, 0._rk, 1._rk, 2._rk, -2._rk, 2._rk, -2._rk, 2._rk, 2._rk, -2._rk, -2._rk, 0._rk, 0._rk, 0._rk, 0._rk, -4._rk, 4._rk, -4._rk, 4._rk, -4._rk, 4._rk, -4._rk, 4._rk, 0._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, 2._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, -4._rk, 8._rk, 8._rk, 8._rk, 8._rk, 8._rk, 8._rk, 8._rk, 8._rk, -1._rk/), (/27, 27/), order=(/2, 1/)) real(kind=rk), public, parameter,               dimension(27,27) :: WMMIvD3Q27 = reshape((/div2_27, -div2_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_9, 0._rk, 0._rk, div1_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, -div1_18, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, 0._rk, 0._rk, div1_54, div2_27, 0._rk, -div2_9, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_6, 0._rk, 0._rk, div1_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_36, -div1_12, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, 0._rk, div1_54, div2_27, 0._rk, 0._rk, -div2_9, 0._rk, 0._rk, 0._rk, -div1_18, -div1_6, 0._rk, 0._rk, 0._rk, div1_9, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_36, div1_12, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_54, div2_27, div2_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_9, 0._rk, 0._rk, -div1_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, -div1_18, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, 0._rk, div1_54, div2_27, 0._rk, div2_9, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_6, 0._rk, 0._rk, -div1_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_36, -div1_12, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, 0._rk, div1_54, div2_27, 0._rk, 0._rk, div2_9, 0._rk, 0._rk, 0._rk, -div1_18, -div1_6, 0._rk, 0._rk, 0._rk, -div1_9, 0._rk, 0._rk, 0._rk, 0._rk, -div1_18, div1_36, div1_12, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div1_18, div1_54, div1_54, 0._rk, -div1_18, -div1_18, 0._rk, div1_6, 0._rk, -div1_36, 0._rk, div1_36, 0._rk, -div1_72, -div1_72, 0._rk, -div1_8, div1_8, 0._rk, 0._rk, -div1_36, 0._rk, 0._rk, -div1_12, 0._rk, 0._rk, div1_36, div1_36, -div1_108, div1_54, 0._rk, -div1_18, div1_18, 0._rk, -div1_6, 0._rk, -div1_36, 0._rk, div1_36, 0._rk, -div1_72, div1_72, 0._rk, -div1_8, -div1_8, 0._rk, 0._rk, -div1_36, 0._rk, 0._rk, div1_12, 0._rk, 0._rk, div1_36, -div1_36, -div1_108, div1_54, 0._rk, div1_18, -div1_18, 0._rk, -div1_6, 0._rk, -div1_36, 0._rk, div1_36, 0._rk, div1_72, -div1_72, 0._rk, div1_8, div1_8, 0._rk, 0._rk, -div1_36, 0._rk, 0._rk, div1_12, 0._rk, 0._rk, -div1_36, div1_36, -div1_108, div1_54, 0._rk, div1_18, div1_18, 0._rk, div1_6, 0._rk, -div1_36, 0._rk, div1_36, 0._rk, div1_72, div1_72, 0._rk, div1_8, -div1_8, 0._rk, 0._rk, -div1_36, 0._rk, 0._rk, -div1_12, 0._rk, 0._rk, -div1_36, -div1_36, -div1_108, div1_54, -div1_18, 0._rk, -div1_18, 0._rk, 0._rk, div1_6, div1_72, -div1_24, div1_36, -div1_72, 0._rk, -div1_72, div1_8, 0._rk, -div1_8, 0._rk, 0._rk, div1_72, -div1_24, 0._rk, 0._rk, -div1_12, div1_36, 0._rk, div1_36, -div1_108, div1_54, div1_18, 0._rk, -div1_18, 0._rk, 0._rk, -div1_6, div1_72, -div1_24, div1_36, div1_72, 0._rk, -div1_72, -div1_8, 0._rk, -div1_8, 0._rk, 0._rk, div1_72, -div1_24, 0._rk, 0._rk, div1_12, -div1_36, 0._rk, div1_36, -div1_108, div1_54, -div1_18, 0._rk, div1_18, 0._rk, 0._rk, -div1_6, div1_72, -div1_24, div1_36, -div1_72, 0._rk, div1_72, div1_8, 0._rk, div1_8, 0._rk, 0._rk, div1_72, -div1_24, 0._rk, 0._rk, div1_12, div1_36, 0._rk, -div1_36, -div1_108, div1_54, div1_18, 0._rk, div1_18, 0._rk, 0._rk, div1_6, div1_72, -div1_24, div1_36, div1_72, 0._rk, div1_72, -div1_8, 0._rk, div1_8, 0._rk, 0._rk, div1_72, -div1_24, 0._rk, 0._rk, -div1_12, -div1_36, 0._rk, -div1_36, -div1_108, div1_54, -div1_18, -div1_18, 0._rk, div1_6, 0._rk, 0._rk, div1_72, div1_24, div1_36, -div1_72, -div1_72, 0._rk, -div1_8, div1_8, 0._rk, 0._rk, 0._rk, div1_72, div1_24, -div1_12, 0._rk, 0._rk, div1_36, div1_36, 0._rk, -div1_108, div1_54, -div1_18, div1_18, 0._rk, -div1_6, 0._rk, 0._rk, div1_72, div1_24, div1_36, -div1_72, div1_72, 0._rk, -div1_8, -div1_8, 0._rk, 0._rk, 0._rk, div1_72, div1_24, div1_12, 0._rk, 0._rk, div1_36, -div1_36, 0._rk, -div1_108, div1_54, div1_18, -div1_18, 0._rk, -div1_6, 0._rk, 0._rk, div1_72, div1_24, div1_36, div1_72, -div1_72, 0._rk, div1_8, div1_8, 0._rk, 0._rk, 0._rk, div1_72, div1_24, div1_12, 0._rk, 0._rk, -div1_36, div1_36, 0._rk, -div1_108, div1_54, div1_18, div1_18, 0._rk, div1_6, 0._rk, 0._rk, div1_72, div1_24, div1_36, div1_72, div1_72, 0._rk, div1_8, -div1_8, 0._rk, 0._rk, 0._rk, div1_72, div1_24, -div1_12, 0._rk, 0._rk, -div1_36, -div1_36, 0._rk, -div1_108, div1_216, -div1_72, -div1_72, -div1_72, div1_24, div1_24, div1_24, 0._rk, 0._rk, div1_72, -div1_72, -div1_72, -div1_72, 0._rk, 0._rk, 0._rk, -div1_8, div1_72, 0._rk, 0._rk, div1_24, div1_24, div1_24, -div1_72, -div1_72, -div1_72, div1_216, div1_216, -div1_72, -div1_72, div1_72, div1_24, -div1_24, -div1_24, 0._rk, 0._rk, div1_72, -div1_72, -div1_72, div1_72, 0._rk, 0._rk, 0._rk, div1_8, div1_72, 0._rk, 0._rk, div1_24, -div1_24, -div1_24, -div1_72, -div1_72, div1_72, div1_216, div1_216, -div1_72, div1_72, -div1_72, -div1_24, -div1_24, div1_24, 0._rk, 0._rk, div1_72, -div1_72, div1_72, -div1_72, 0._rk, 0._rk, 0._rk, div1_8, div1_72, 0._rk, 0._rk, -div1_24, -div1_24, div1_24, -div1_72, div1_72, -div1_72, div1_216, div1_216, -div1_72, div1_72, div1_72, -div1_24, div1_24, -div1_24, 0._rk, 0._rk, div1_72, -div1_72, div1_72, div1_72, 0._rk, 0._rk, 0._rk, -div1_8, div1_72, 0._rk, 0._rk, -div1_24, div1_24, -div1_24, -div1_72, div1_72, div1_72, div1_216, div1_216, div1_72, -div1_72, -div1_72, -div1_24, div1_24, -div1_24, 0._rk, 0._rk, div1_72, div1_72, -div1_72, -div1_72, 0._rk, 0._rk, 0._rk, div1_8, div1_72, 0._rk, 0._rk, -div1_24, div1_24, -div1_24, div1_72, -div1_72, -div1_72, div1_216, div1_216, div1_72, -div1_72, div1_72, -div1_24, -div1_24, div1_24, 0._rk, 0._rk, div1_72, div1_72, -div1_72, div1_72, 0._rk, 0._rk, 0._rk, -div1_8, div1_72, 0._rk, 0._rk, -div1_24, -div1_24, div1_24, div1_72, -div1_72, div1_72, div1_216, div1_216, div1_72, div1_72, -div1_72, div1_24, -div1_24, -div1_24, 0._rk, 0._rk, div1_72, div1_72, div1_72, -div1_72, 0._rk, 0._rk, 0._rk, -div1_8, div1_72, 0._rk, 0._rk, div1_24, -div1_24, -div1_24, div1_72, div1_72, -div1_72, div1_216, div1_216, div1_72, div1_72, div1_72, div1_24, div1_24, div1_24, 0._rk, 0._rk, div1_72, div1_72, div1_72, div1_72, 0._rk, 0._rk, 0._rk, div1_8, div1_72, 0._rk, 0._rk, div1_24, div1_24, div1_24, div1_72, div1_72, div1_72, div1_216, div8_27, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div4_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, div2_9, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, 0._rk, -div1_27/), (/27, 27/), order=(/2, 1/)) Functions public  function check_mrt_matrix_d3q19 () result(test) Unoptimized explicit implementation Read more… Arguments None Return Value logical public  function check_mrt_matrix_d3q27 () result(test) Unoptimized explicit implementation Read more… Arguments None Return Value logical","tags":"","loc":"module/mus_mrtinit_module.html"},{"title":"mus_turb_viscosity_module – Musubi","text":"This module assigns function pointer to calculate turbulent viscosity\naccording to turbulence model and scheme definition Uses env_module mus_WALE_module tem_aux_module mus_turbulence_module mus_scheme_layout_module mus_Vreman_module mus_scheme_header_module mus_gradData_module mus_Smagorinsky_module module~~mus_turb_viscosity_module~~UsesGraph module~mus_turb_viscosity_module mus_turb_viscosity_module env_module env_module module~mus_turb_viscosity_module->env_module module~mus_scheme_header_module mus_scheme_header_module module~mus_turb_viscosity_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_turb_viscosity_module->module~mus_scheme_layout_module module~mus_turbulence_module mus_turbulence_module module~mus_turb_viscosity_module->module~mus_turbulence_module module~mus_vreman_module mus_Vreman_module module~mus_turb_viscosity_module->module~mus_vreman_module module~mus_wale_module mus_WALE_module module~mus_turb_viscosity_module->module~mus_wale_module mus_Smagorinsky_module mus_Smagorinsky_module module~mus_turb_viscosity_module->mus_Smagorinsky_module mus_gradData_module mus_gradData_module module~mus_turb_viscosity_module->mus_gradData_module tem_aux_module tem_aux_module module~mus_turb_viscosity_module->tem_aux_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module aot_out_module aot_out_module module~mus_scheme_header_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_header_module->aot_table_module aotus_module aotus_module module~mus_scheme_header_module->aotus_module tem_logging_module tem_logging_module module~mus_scheme_header_module->tem_logging_module tem_tools_module tem_tools_module module~mus_scheme_header_module->tem_tools_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->aot_out_module module~mus_scheme_layout_module->aot_table_module module~mus_scheme_layout_module->aotus_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module module~mus_scheme_layout_module->tem_logging_module tem_param_module tem_param_module module~mus_scheme_layout_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module module~mus_scheme_layout_module->tem_tools_module module~mus_turbulence_module->env_module module~mus_turbulence_module->module~mus_scheme_layout_module module~mus_turbulence_module->mus_gradData_module module~mus_turbulence_module->tem_aux_module module~mus_turbulence_module->aot_table_module module~mus_turbulence_module->aotus_module tem_comm_module tem_comm_module module~mus_turbulence_module->tem_comm_module tem_construction_module tem_construction_module module~mus_turbulence_module->tem_construction_module module~mus_turbulence_module->tem_logging_module module~mus_turbulence_module->tem_tools_module module~mus_vreman_module->env_module module~mus_vreman_module->module~mus_turbulence_module module~mus_vreman_module->mus_gradData_module tem_compileconf_module tem_compileconf_module module~mus_vreman_module->tem_compileconf_module tem_float_module tem_float_module module~mus_vreman_module->tem_float_module module~mus_wale_module->env_module module~mus_wale_module->module~mus_turbulence_module module~mus_wale_module->mus_gradData_module module~mus_wale_module->tem_compileconf_module module~mus_wale_module->tem_param_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_logging_module module~mus_scheme_derived_quantities_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_turb_viscosity_module~~UsedByGraph module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_assign_turbVisc_ptr (turb, schemeHeader) This routine assigns function pointer to compute turbulence viscosity\nbased on turbulence model and scheme header definition Arguments Type Intent Optional Attributes Name type( mus_turbulence_type ), intent(inout) :: turb turbulence type type( mus_scheme_header_type ), intent(in) :: schemeHeader Scheme header information private  subroutine mus_turbVisc_fromGradU_dummy (turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Dummy function for turbulent viscosity from Gradu procedure Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence config contains oefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL turbulence coefficients\ncurrent level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients private  subroutine mus_turbVisc_fromPreColPDF_dummy (turbVisc, turbConfig, state, neigh, auxField, densPos, velPos, nSize, nSolve, nScalars, nAuxScalars, layout, dxL, dtL, viscKine) Dummy function to compute turbulent viscosity from PDF Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig turbulence type is implicitly passed to access turbulence coefficients real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neigh array to obtain precollision pdf real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: densPos position of density in auxField integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nScalars number of scalars in state array integer, intent(in) :: nAuxScalars number of scalars in auxField array type( mus_scheme_layout_type ), intent(in) :: layout scheme layout real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size real(kind=rk), intent(in) :: viscKine (:) Background kinematic viscosity divided by dtL","tags":"","loc":"module/mus_turb_viscosity_module.html"},{"title":"mus_interpolate_header_module – Musubi","text":"Interpolation header to load confiugration and type definition Uses env_module tem_varSys_module aotus_module tem_stencil_module tem_param_module tem_matrix_module tem_time_module tem_tools_module mus_field_prop_module tem_grow_array_module mus_scheme_layout_module tem_logging_module aot_table_module mus_derVarPos_module tem_debug_module tem_aux_module aot_out_module mus_physics_module tem_construction_module mus_directions_module module~~mus_interpolate_header_module~~UsesGraph module~mus_interpolate_header_module mus_interpolate_header_module aot_out_module aot_out_module module~mus_interpolate_header_module->aot_out_module aot_table_module aot_table_module module~mus_interpolate_header_module->aot_table_module aotus_module aotus_module module~mus_interpolate_header_module->aotus_module env_module env_module module~mus_interpolate_header_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_interpolate_header_module->module~mus_dervarpos_module module~mus_directions_module mus_directions_module module~mus_interpolate_header_module->module~mus_directions_module module~mus_field_prop_module mus_field_prop_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_physics_module mus_physics_module module~mus_interpolate_header_module->module~mus_physics_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_interpolate_header_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_interpolate_header_module->tem_aux_module tem_construction_module tem_construction_module module~mus_interpolate_header_module->tem_construction_module tem_debug_module tem_debug_module module~mus_interpolate_header_module->tem_debug_module tem_grow_array_module tem_grow_array_module module~mus_interpolate_header_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_interpolate_header_module->tem_logging_module tem_matrix_module tem_matrix_module module~mus_interpolate_header_module->tem_matrix_module tem_param_module tem_param_module module~mus_interpolate_header_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_interpolate_header_module->tem_stencil_module tem_time_module tem_time_module module~mus_interpolate_header_module->tem_time_module tem_tools_module tem_tools_module module~mus_interpolate_header_module->tem_tools_module tem_varSys_module tem_varSys_module module~mus_interpolate_header_module->tem_varSys_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_interpolate_header_module~~UsedByGraph module~mus_interpolate_header_module mus_interpolate_header_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: no_intp = -1 Interpolation parameter to choose fillFinerFromMe integer, public, parameter :: weighted_average = 0 integer, public, parameter :: linear = 1 integer, public, parameter :: quadratic = 2 integer, private, parameter :: q00 = 9 Abstract Interfaces abstract interface private  subroutine intpRoutine(method, fieldProp, tLevelDesc, level, sState, sNeigh, snSize, sAuxField, tState, tNeigh, tnSize, layout, nTargets, targetList, physics, time, varSys, derVarPos) This is the interface for all interpolation methods that Arguments Type Intent Optional Attributes Name class( mus_interpolation_method_type ), intent(inout) :: method type( mus_field_prop_type ), intent(in), target :: fieldProp (:) Array of field properties (fluid or species) type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level integer, intent(in) :: level my refinement level real(kind=rk), intent(in) :: sState (:) State vector of SOURCE elements integer, intent(in) :: sNeigh (:) integer, intent(in) :: snSize real(kind=rk), intent(inout) :: sAuxField (:) AuxField variable to read rho and vel from source elements real(kind=rk), intent(inout) :: tState (:) State vector of TARGET GHOST elements integer, intent(in) :: tNeigh (:) integer, intent(in) :: tnSize type( mus_scheme_layout_type ), intent(in) :: layout the layout used integer, intent(in) :: nTargets List of target elements ( their position in depSource list ) integer, intent(in) :: targetList (nTargets) type( mus_physics_type ), intent(in) :: physics physics type to convert lattice to physics SI unit and vice versa type( tem_time_type ), intent(in) :: time time required to compute analytical solution for TGV case type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of all derive variable in varSys abstract interface private  subroutine intpRoutine_arbitraryVal(method, tLevelDesc, level, stencil, sVal, tVal, nTargets, targetList, nScalars) This is the interface for all interpolation methods that Arguments Type Intent Optional Attributes Name class( mus_interpolation_method_type ), intent(inout) :: method type( tem_levelDesc_type ), intent(in) :: tLevelDesc level descriptor on target level integer, intent(in) :: level my refinement level type( tem_stencilHeader_type ), intent(in) :: stencil stencil header real(kind=rk), intent(in) :: sVal (:) array of SOURCE elements real(kind=rk), intent(inout) :: tVal (:) array of TARGET GHOST elements integer, intent(in) :: nTargets List of target elements ( their position in depSource list ) integer, intent(in) :: targetList (nTargets) position in total list - offset integer, intent(in) :: nScalars Number of scalars to interpolate Derived Types type, public :: mus_interpolation_method_type This data types contains intpRoutine function pointer for FillFiner\nand FillCoarser.\nFor fillFiner, it build least square fit matrix for linear\nquadratic interpolations\nFor fillCoarser: currently we do simple average Read more… Components Type Visibility Attributes Name Initial procedure( intpRoutine ), public, pointer :: do_intp => null() Routine to interpolate coarse to fine for ghostFromCoarser elements\nand interpolate fine to coarse for ghostFromFiner elements.\nSets pdf for ghost elements by f_eq + f_neq\nThe moments required to compute equilibrium function are obtained\nfrom auxField array and the auxField of ghost elements are interpolate\nseperately using do_intpArbitraryField procedure( intpRoutine_arbitraryVal ), public, pointer :: do_intpArbiVal => null() Routine to interpolate coarse to fine and fine to coarse for\narbitrary variables type( tem_intpMatrixLSF_type ), public :: intpMat_forLSF Matrix entries for linear/Quadratic interpolation least square fit\n((A&#94;T)A)&#94;-1*(A&#94;T)\nSize: (6,9) for D2Q9 stencil\nSize: (10,QQ)  for D3Q19 and D3Q27 integer, public :: nMinSources how many source elements are required by this interpolation order integer, public :: nMaxSources Max number of sources amoung target ghosts\nComputed in mus_contruction::mus_intp_complete_coarseDep type, public :: mus_interpolation_stencil_type Contains stencil for interpolation Components Type Visibility Attributes Name Initial logical, public :: isActive = .false. Is active only for specific layouts like d2q9, d3q19, d3q27 integer, public, allocatable :: neighDir (:,:) cxDir for interpolation stencil for depFromCoarser type, public :: mus_interpolation_config_type Contains information loaded from config file Components Type Visibility Attributes Name Initial character(len=labelLen), public :: method name of the order of the interpolation method for fillFinerFromMe integer, public :: order Order of the interpolation for fillFinerFromMe character(len=labelLen), public :: weights_method = 'linear_distance' name of used weighting method integer, public :: IDW_powerfac = 6 Power factor for inverse distance weighting logical, public :: useComputeStencil = .false. Stencil for linear interpolation.\nBy default use stencil from weighted average logical, public :: testInterpolation = .false. Interpolation test by comparing against the initial condition logical, public :: testEachElement = .false. logical, public :: testFluids = .false. logical, public :: noIntpFromFiner = .false. logical, public :: noIntpFromCoarser = .false. type, public :: mus_interpolation_type definition of the used interpolation method Components Type Visibility Attributes Name Initial type( mus_interpolation_config_type ), public :: config Information loaded from config file type( mus_interpolation_method_type ), public, allocatable :: fillFinerFromME (:) Interpolation routines to fillFiner\nSize: interpolation order type( mus_interpolation_method_type ), public :: fillMineFromFiner Interpolation routines to fillCoarser type( mus_interpolation_stencil_type ), public :: weightedAvgStencil stencil for weighted average interpolation Functions private  function init_cxDirWeightedAvg (QQ, nSources) result(me) Initialize stencil for weighted average interpolation Arguments Type Intent Optional Attributes Name integer, intent(in) :: QQ integer, intent(in) :: nSources Return Value integer, (nSources,8) Subroutines public  subroutine mus_load_interpolate (me, conf, parent) Read in the type of interpolation scheme Read more… Arguments Type Intent Optional Attributes Name type( mus_interpolation_config_type ), intent(out) :: me interpolation type to load info to type( flu_State ) :: conf lua state to load from integer, intent(in), optional :: parent optional parent table to load from public  subroutine mus_set_nSources (me, nDims, QQ, layout) Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(inout) :: me integer, intent(in) :: nDims integer, intent(in) :: QQ character(len=*), intent(in) :: layout public  subroutine mus_interpolate_out (me, conf) Dump interpolation method to lua Arguments Type Intent Optional Attributes Name type( mus_interpolation_type ), intent(in) :: me interpolation type to dump info to type( aot_out_type ), intent(inout), optional :: conf aotus type handling the output to the file in lua format private  subroutine interpolate_dump (me, outUnit) Dump interpolation method to logUnit Arguments Type Intent Optional Attributes Name type( mus_interpolation_config_type ), intent(in) :: me interpolation type to dump info to integer, intent(in) :: outUnit File unit to write to","tags":"","loc":"module/mus_interpolate_header_module.html"},{"title":"mus_initLBMPS_module – Musubi","text":"This module contains routines which assigns compute kernel for passive scalar\nmodel Uses env_module tem_aux_module mus_scheme_type_module tem_logging_module mus_compute_passiveScalar_module module~~mus_initlbmps_module~~UsesGraph module~mus_initlbmps_module mus_initLBMPS_module env_module env_module module~mus_initlbmps_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initlbmps_module->module~mus_scheme_type_module mus_compute_passiveScalar_module mus_compute_passiveScalar_module module~mus_initlbmps_module->mus_compute_passiveScalar_module tem_aux_module tem_aux_module module~mus_initlbmps_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initlbmps_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_lbm_ps (relaxation, layout, relaxation_variant, compute) Initialize the relaxation model for lbm passive scalar scheme kind Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout character(len=labelLen), intent(in) :: relaxation_variant procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initlbmps_module.html"},{"title":"mus_Vreman_module – Musubi","text":"This module contains function to compute eddy viscosity using\nVreman LES turbulence model.\nVreman, A. W. (2004). An eddy-viscosity subgrid-scale model for turbulent\nshear flow: Algebraic theory and applications. Physics of Fluids, 16(10),\n3670–3681.\nmodel.\nauthor: Kannan Masilamani Uses env_module mus_turbulence_module tem_float_module tem_compileconf_module mus_gradData_module module~~mus_vreman_module~~UsesGraph module~mus_vreman_module mus_Vreman_module env_module env_module module~mus_vreman_module->env_module module~mus_turbulence_module mus_turbulence_module module~mus_vreman_module->module~mus_turbulence_module mus_gradData_module mus_gradData_module module~mus_vreman_module->mus_gradData_module tem_compileconf_module tem_compileconf_module module~mus_vreman_module->tem_compileconf_module tem_float_module tem_float_module module~mus_vreman_module->tem_float_module module~mus_turbulence_module->env_module module~mus_turbulence_module->mus_gradData_module aot_table_module aot_table_module module~mus_turbulence_module->aot_table_module aotus_module aotus_module module~mus_turbulence_module->aotus_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_turbulence_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_turbulence_module->tem_aux_module tem_comm_module tem_comm_module module~mus_turbulence_module->tem_comm_module tem_construction_module tem_construction_module module~mus_turbulence_module->tem_construction_module tem_logging_module tem_logging_module module~mus_turbulence_module->tem_logging_module tem_tools_module tem_tools_module module~mus_turbulence_module->tem_tools_module module~mus_scheme_layout_module->env_module module~mus_scheme_layout_module->aot_table_module module~mus_scheme_layout_module->aotus_module module~mus_scheme_layout_module->tem_aux_module module~mus_scheme_layout_module->tem_logging_module module~mus_scheme_layout_module->tem_tools_module aot_out_module aot_out_module module~mus_scheme_layout_module->aot_out_module module~mus_moments_type_module mus_moments_type_module module~mus_scheme_layout_module->module~mus_moments_type_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module mpi mpi module~mus_scheme_layout_module->mpi tem_comm_env_module tem_comm_env_module module~mus_scheme_layout_module->tem_comm_env_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_layout_module->tem_dyn_array_module tem_grow_array_module tem_grow_array_module module~mus_scheme_layout_module->tem_grow_array_module tem_param_module tem_param_module module~mus_scheme_layout_module->tem_param_module tem_stencil_module tem_stencil_module module~mus_scheme_layout_module->tem_stencil_module module~mus_moments_type_module->env_module tem_matrix_module tem_matrix_module module~mus_moments_type_module->tem_matrix_module module~mus_scheme_derived_quantities_module->env_module module~mus_scheme_derived_quantities_module->tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_aux_module module~mus_scheme_derived_quantities_module->tem_logging_module module~mus_scheme_derived_quantities_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_vreman_module~~UsedByGraph module~mus_vreman_module mus_Vreman_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_vreman_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_fluid_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_turbVisc_Vreman_3D (turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with Vreman model for 3D stencil\nFortran implementation of this model:\nhttp://www.vremanresearch.nl/Vreman_Subgridmodel_Fortran.txt Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients public  subroutine mus_turbVisc_Vreman_2D (turbVisc, turbConfig, gradData, auxField, velPos, nSolve, nAuxScalars, dxL, dtL, Grad) Calculate eddy viscosity with Vreman model for 2D stencil\nmodel\n\\todo add reference and formula Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: turbVisc (:) output: turbulent viscosity type( mus_turbulence_config_type ), intent(in) :: turbConfig Contains turbulenct coefficients type(mus_gradData_type), intent(in) :: gradData gradient data real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array integer, intent(in) :: velPos (3) position of velocity components in auxField integer, intent(in) :: nSolve Number of element to solve in this level integer, intent(in) :: nAuxScalars number of scalars in auxField array real(kind=rk), intent(in) :: dxL current level lattice element size real(kind=rk), intent(in) :: dtL current level lattice time step size type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients","tags":"","loc":"module/mus_vreman_module.html"},{"title":"mus_physics_module – Musubi","text":"This module contains data type and modules related to musubi\n lattice to physical unit convertion and vice versa.\n physics data type is global for all schemes, it is defined\n in the following format: physics = { dt = dt_phy , -- physical time step size rho0 = rho0_phy , -- reference density temp0 = t_phy -- reference temperature } Of these quantities, dt is mandetory for conversion.\n Others can be omitted, thus use default values. To add a new conversion factor, one has to do the following: add this new factor into [mus_convertFac_type] add the defination of factor inside routine [mus_set_convFac] add this new factor into routine [mus_physics_out] Uses env_module tem_aux_module tem_tools_module aotus_module treelmesh_module tem_logging_module aot_out_module aot_table_module tem_geometry_module module~~mus_physics_module~~UsesGraph module~mus_physics_module mus_physics_module aot_out_module aot_out_module module~mus_physics_module->aot_out_module aot_table_module aot_table_module module~mus_physics_module->aot_table_module aotus_module aotus_module module~mus_physics_module->aotus_module env_module env_module module~mus_physics_module->env_module tem_aux_module tem_aux_module module~mus_physics_module->tem_aux_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_physics_module->tem_logging_module tem_tools_module tem_tools_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_physics_module~~UsedByGraph module~mus_physics_module mus_physics_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_physics_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_physics_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_physics_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_physics_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_physics_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_physics_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_physics_module module~mus_field_prop_module mus_field_prop_module module~mus_field_prop_module->module~mus_physics_module module~mus_fluid_module mus_fluid_module module~mus_fluid_module->module~mus_physics_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_physics_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_physics_module module~mus_mixture_module mus_mixture_module module~mus_mixture_module->module~mus_physics_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_nernstplanck_module->module~mus_physics_module module~mus_param_module mus_param_module module~mus_param_module->module~mus_physics_module module~mus_poisson_module mus_poisson_module module~mus_poisson_module->module~mus_physics_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_physics_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_physics_module module~mus_source_type_module mus_source_type_module module~mus_source_type_module->module~mus_physics_module module~mus_source_var_module mus_source_var_module module~mus_source_var_module->module~mus_physics_module module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_source_var_turbchanforce_module->module~mus_physics_module module~mus_species_module mus_species_module module~mus_species_module->module~mus_physics_module module~mus_tools_module mus_tools_module module~mus_tools_module->module~mus_physics_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: coulomb_ref = 1.60217657e-19_rk Reference coulomb is set to fundamental electrical charge real(kind=rk), public, parameter :: mole_ref = 1e-23_rk/6.02214129 Reference mole is set to inverse of Avogadro's constant real(kind=rk), public, parameter :: k_b = 1.38064852e-23_rk the boltzmann constant J K&#94;-1 real(kind=rk), public, parameter :: faraday = 96485.3365_rk Faraday constant C/mol real(kind=rk), public, parameter :: gasConst_R = 8.3144621_rk Ideal gas constant N m / (mol K) Derived Types type, public :: mus_convertFac_type This type contains the converstion factor for derived variables\nfrom lattice to physical. Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public :: length length (m) = dx real(kind=rk), public :: time time (s) = dt real(kind=rk), public :: vel velocity(m/s) = dx/dt real(kind=rk), public :: visc kinematic viscosity(m&#94;2/s) = dx&#94;2/dt real(kind=rk), public :: viscDyna Dynamic viscosity (Pa s) = kg/m/s real(kind=rk), public :: accel acceleration(m/s&#94;2) = dx/dt&#94;2 real(kind=rk), public :: force Force(N)(kg m/s&#94;2) = rho0*dx&#94;4/dt&#94;2 real(kind=rk), public :: body_force Force per unit volume (N/m&#94;3)(kg/s&#94;2/m&#94;2) = rho0*dx/dt&#94;2 real(kind=rk), public :: press Pressure(N/m&#94;2)(kg/m/s&#94;2) = rho0*dx&#94;2/dt&#94;2 real(kind=rk), public :: strainRate Strain Rate (1/s) = 1/dt real(kind=rk), public :: energy Energy (N-m) (kg m&#94;2/s&#94;2) = rho0 dx&#94;5/dt&#94;2 real(kind=rk), public :: chargeDens mole density(mol/m&#94;3) = mole0/dx&#94;3\nCharge density (C/m&#94;3) = Coulomb0/dx&#94;3 real(kind=rk), public :: currentDens Current density (C/s/m&#94;2) = Coulomb0/dt/dx&#94;2 real(kind=rk), public :: moleFlux mole flux(mol/m&#94;2/s) = moleDen0*dx/dt real(kind=rk), public :: flux mass flux(kg/m&#94;2/s) = rho0*dx/dt real(kind=rk), public :: diffusivity diffusivity(m&#94;2/s) = dx&#94;2/dt real(kind=rk), public :: faraday faraday (C/mol) = coulomb0/moleDens0/dx&#94;3 real(kind=rk), public :: gasConst gas constant (J/mol/K) (N m/mol/K) (kg m&#94;2/s&#94;2/mol/K)\n= rho0*dx&#94;5/dt&#94;2/mole0/temp0 real(kind=rk), public :: potential Potential (V) (kg m&#94;2/(C*S&#94;2)) type, public :: mus_physics_type This type contains the reference values as defined in the physics\ntable by the user Read more… Components Type Visibility Attributes Name Initial logical, public :: active = .false. needed to check if physics table is defined real(kind=rk), public :: dx = -1.0_rk reference length - discretization size of the coarsest level\nSI unit - meter real(kind=rk), public, allocatable :: dxLvl (:) real(kind=rk), public :: dt = -1.0_rk reference time - time discretization for discretization size\nof the coarsest level\nSI unit - seconds real(kind=rk), public, allocatable :: dtLvl (:) real(kind=rk), public :: rho0 = -1.0_rk reference physical mass density\nSI unit - kg/m&#94;3 real(kind=rk), public :: moleDens0 = -1.0_rk reference physical mole density\nSI unit - mol/m&#94;3 real(kind=rk), public :: molWeight0 = -1.0_rk reference molecular weight\nSI unit - kg/mol real(kind=rk), public :: temp0 = -1.0_rk reference temperature\nSI unit - Kelvin real(kind=rk), public :: coulomb0 = -1.0_rk reference fundamental electrical charge\nSI unit - Coulomb real(kind=rk), public :: mole0 = -1.0_rk mole is defined by inverse of Avogadro Constant\nAvogadro Constant = 6.02214129e23 [1/mol] real(kind=rk), public :: mass0 = -1.0_rk reference mass in kg derived from density or moleweight\nSI unit :: kg type( mus_convertFac_type ), public, allocatable :: fac (:) Level-wise conversion factor for derived variables\nsize: minLevel:maxLevel\nallocated in mus_load_physics\n\\todo KM: conversion factor should not be level-dependent.\nit should be same for all levels, the lattice dx and dt for each level\nmust be considered to scale variables in multilevel.\nImplemented force, visc, etc using dtL according to formula\nIntroduced lattice speed variable: dx/dt for each level\nit should be same for all level for acoustic scaling and different\nfor diffusive scaling real(kind=rk), public, allocatable :: pFac (:,:) Pressure (strain rate) over level scale factor.\nThis factor is meant to convert pressure in LB unit on source level to\nthe required pressure on target level.\nIt is mainly used in interpolation routine.\nIt is allocated as: allocate(pFac( minLevel:maxLevel, minLevel:maxLevel))\nIt is allocated and initialized in routine: mus_set_scaleFac\nHow to use it in the code:\npTargetLevel = pSourceLevel * pFac( sourceLevel, targetLevel ) real(kind=rk), public, allocatable :: vFac (:,:) Velocity over level scale factor\nIts usage is the same as pressure scale factor real(kind=rk), public, allocatable :: sFac (:,:) Strain rate over level scale factor\nIts usage is the same as pressure scale factor Functions public pure function set_values_by_levels (valMinLevel, minLevel, maxLevel, scaleFac) result(values) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: valMinLevel integer, intent(in) :: minLevel integer, intent(in) :: maxLevel integer, intent(in) :: scaleFac Return Value real(kind=rk), (minLevel:maxLevel) Subroutines public  subroutine mus_load_physics (me, conf, tree, scaleFactor, dtRef, dxRef) This routine loads the physics table from musubi config file Read more… Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(out) :: me physics type type( flu_State ) :: conf flu state type( treelmesh_type ), intent(in) :: tree global treelm mesh integer, intent(in) :: scaleFactor scaling factor: diffusive -> 4; acoustic -> 2 real(kind=rk), intent(in), optional :: dtRef reference time step if none real(kind=rk), intent(in), optional :: dxRef reference spacestep if none public  subroutine mus_set_convFac (me, minLevel, maxLevel) This routine computed conversion factors for lattice to physical units.\ninverse of this factors can be used to convert from physical to lattice\nunits.\\n\nuse reference density to parmeterize kg and reference mole density\nto parmeterize mol.\\n\nMultiply these factors with the LB quantity to get the physical quantity\nDivide the physical quantity by these factors to get the LB units. Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(inout) :: me integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_create_funcStr (fun_str) This routine creates musubi specific lua function to compute dx and dt. Arguments Type Intent Optional Attributes Name character(len=*) :: fun_str This string contains lua functions to compute dt from visocosity or\nvelocity public  subroutine mus_physics_out (me, conf) This routine write reference physics parameters into solver specific\nstring in lua format. Read more… Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me type( aot_out_type ) :: conf public  subroutine mus_physics_out_conv (me, conf, minLevel, maxLevel) This routine write physics convert factor into solver specific string in\nlua format.\nuse reference density to parmeterize kg and reference mole density\nto parmeterize mol. Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me type( aot_out_type ) :: conf integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_physics_dump2outUnit (me, outUnit, minLevel, maxLevel) Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(in) :: me integer, intent(in) :: outUnit integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_set_scaleFac (me, minLevel, maxLevel) Arguments Type Intent Optional Attributes Name type( mus_physics_type ), intent(inout) :: me integer, intent(in) :: minLevel integer, intent(in) :: maxLevel","tags":"","loc":"module/mus_physics_module.html"},{"title":"mus_geomIncrHead_module – Musubi","text":"This module contains the datatypes for the geometry increase table within the\nlua configuration file. It also contains the routines to load various\nvariables, parameters from the lua file which are then used in performing\ngeometry changes Uses env_module tem_timeControl_module tem_depend_module aotus_module aot_vector_module tem_logging_module aot_table_module mus_param_module tem_tools_module module~~mus_geomincrhead_module~~UsesGraph module~mus_geomincrhead_module mus_geomIncrHead_module aot_table_module aot_table_module module~mus_geomincrhead_module->aot_table_module aot_vector_module aot_vector_module module~mus_geomincrhead_module->aot_vector_module aotus_module aotus_module module~mus_geomincrhead_module->aotus_module env_module env_module module~mus_geomincrhead_module->env_module module~mus_param_module mus_param_module module~mus_geomincrhead_module->module~mus_param_module tem_depend_module tem_depend_module module~mus_geomincrhead_module->tem_depend_module tem_logging_module tem_logging_module module~mus_geomincrhead_module->tem_logging_module tem_timeControl_module tem_timeControl_module module~mus_geomincrhead_module->tem_timeControl_module tem_tools_module tem_tools_module module~mus_geomincrhead_module->tem_tools_module module~mus_param_module->aotus_module module~mus_param_module->env_module module~mus_param_module->tem_logging_module module~mus_param_module->tem_tools_module aot_out_module aot_out_module module~mus_param_module->aot_out_module module~mus_abortcriteria_module mus_abortCriteria_module module~mus_param_module->module~mus_abortcriteria_module module~mus_physics_module mus_physics_module module~mus_param_module->module~mus_physics_module tem_general_module tem_general_module module~mus_param_module->tem_general_module module~mus_abortcriteria_module->aotus_module module~mus_abortcriteria_module->env_module tem_abortCriteria_module tem_abortCriteria_module module~mus_abortcriteria_module->tem_abortCriteria_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module module~mus_physics_module->aot_out_module tem_aux_module tem_aux_module module~mus_physics_module->tem_aux_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_geomincrhead_module~~UsedByGraph module~mus_geomincrhead_module mus_geomIncrHead_module module~mus_geom_module mus_geom_module module~mus_geom_module->module~mus_geomincrhead_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_geomincrhead_module module~mus_hvs_config_module->module~mus_geom_module module~mus_config_module mus_config_module module~mus_hvs_config_module->module~mus_config_module module~mus_scheme_module mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_geom_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_config_module->module~mus_geom_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_geom_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_geom_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_geom_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_geom_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_geom_module module~mus_scheme_module->module~mus_geom_module module~mus_tracking_module->module~mus_geom_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_geom_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_geom_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module module~mus_tools_module->module~mus_scheme_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_geomIncrHead_type Components Type Visibility Attributes Name Initial logical, public :: active = .false. logical, public :: solidify = .false. logical, public :: fluidify = .false. logical, public :: proximity = .false. type( tem_timeControl_type ), public :: timeControl character(len=labelLen), public :: cond_varName Name of the variable defined for condition varname in config file.\nVariable refered should return 0 for if condition is false and\nIf there are more than one condition variable required then they must\nbe combined via variable definitions in config file. integer, public :: cond_varPos Position of variable defined for the condition varname in the varSys Subroutines public  subroutine mus_geomIncrHead_load (me, conf, parent, dynamicGeom) Read all the necessary information for the geometry increase from the lua\n config file. This routine basically provides as a wrapper to the routine\n which reads single values Read more… Arguments Type Intent Optional Attributes Name type( mus_geomIncrHead_type ), intent(inout), allocatable :: me (:) type( flu_State ) :: conf integer, intent(in), optional :: parent logical, intent(inout) :: dynamicGeom private  subroutine mus_geomIncrHead_load_single (me, conf, thandle) Reads various parameters from the lua file defined for geometry increase\nThis routine reads single values and is wrapped around in another function\nwhere it is called multiple times as required Arguments Type Intent Optional Attributes Name type( mus_geomIncrHead_type ), intent(inout) :: me type( flu_State ), intent(in) :: conf integer, intent(in) :: thandle","tags":"","loc":"module/mus_geomincrhead_module.html"},{"title":"mus_wall_function_abstract_module – Musubi","text":"This module contains data types, function and routines for wall function\ncomputations. author: Gregorio Gerardo Spinelli Uses env_module module~~mus_wall_function_abstract_module~~UsesGraph module~mus_wall_function_abstract_module mus_wall_function_abstract_module env_module env_module module~mus_wall_function_abstract_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_wall_function_abstract_module~~UsedByGraph module~mus_wall_function_abstract_module mus_wall_function_abstract_module module~mus_turb_wallfunc_module mus_turb_wallFunc_module module~mus_turb_wallfunc_module->module~mus_wall_function_abstract_module module~mus_wall_function_musker_module mus_wall_function_musker_module module~mus_turb_wallfunc_module->module~mus_wall_function_musker_module module~mus_wall_function_reichardt_module mus_wall_function_reichardt_module module~mus_turb_wallfunc_module->module~mus_wall_function_reichardt_module module~mus_wall_function_schmitt_module mus_wall_function_schmitt_module module~mus_turb_wallfunc_module->module~mus_wall_function_schmitt_module module~mus_wall_function_musker_module->module~mus_wall_function_abstract_module module~mus_wall_function_reichardt_module->module~mus_wall_function_abstract_module module~mus_wall_function_schmitt_module->module~mus_wall_function_abstract_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public pure function get_uPlus_interface(yPlus) result(uPlus) function interface to get u_Plus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) interface public pure function get_d_uPlus_d_uTau_interface(y, uTau, nu) result(d_uPlus_d_uTau) function interface to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk) Derived Types type, public, abstract :: mus_wall_function_type collection of properties of the wall function type Type-Bound Procedures procedure( get_uPlus_interface ), public, deferred, nopass :: get_uPlus ../../../../../ function to get uPlus procedure( get_d_uPlus_d_uTau_interface ), public, deferred, nopass :: get_d_uPlus_d_uTau ../../../../../ function to apply the newon method","tags":"","loc":"module/mus_wall_function_abstract_module.html"},{"title":"mus_relaxationParam_module – Musubi","text":"This module contains the data type for MRT. Also provides functions and routines to set relaxation parameters for\nsingle-component and multispecies. Uses env_module tem_varSys_module mus_scheme_header_module tem_param_module tem_temporal_module tem_time_module tem_general_module tem_comm_env_module mus_nonNewtonian_module tem_grow_array_module tem_spacetime_fun_module mus_scheme_layout_module mus_moments_type_module tem_logging_module mus_derVarPos_module tem_status_module mpi tem_aux_module mus_turbulence_module mus_physics_module mus_gradData_module module~~mus_relaxationparam_module~~UsesGraph module~mus_relaxationparam_module mus_relaxationParam_module env_module env_module module~mus_relaxationparam_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_relaxationparam_module->module~mus_dervarpos_module module~mus_moments_type_module mus_moments_type_module module~mus_relaxationparam_module->module~mus_moments_type_module module~mus_physics_module mus_physics_module module~mus_relaxationparam_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_relaxationparam_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_relaxationparam_module->module~mus_scheme_layout_module module~mus_turbulence_module mus_turbulence_module module~mus_relaxationparam_module->module~mus_turbulence_module mpi mpi module~mus_relaxationparam_module->mpi mus_gradData_module mus_gradData_module module~mus_relaxationparam_module->mus_gradData_module mus_nonNewtonian_module mus_nonNewtonian_module module~mus_relaxationparam_module->mus_nonNewtonian_module tem_aux_module tem_aux_module module~mus_relaxationparam_module->tem_aux_module tem_comm_env_module tem_comm_env_module module~mus_relaxationparam_module->tem_comm_env_module tem_general_module tem_general_module module~mus_relaxationparam_module->tem_general_module tem_grow_array_module tem_grow_array_module module~mus_relaxationparam_module->tem_grow_array_module tem_logging_module tem_logging_module module~mus_relaxationparam_module->tem_logging_module tem_param_module tem_param_module module~mus_relaxationparam_module->tem_param_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_relaxationparam_module->tem_spacetime_fun_module tem_status_module tem_status_module module~mus_relaxationparam_module->tem_status_module tem_temporal_module tem_temporal_module module~mus_relaxationparam_module->tem_temporal_module tem_time_module tem_time_module module~mus_relaxationparam_module->tem_time_module tem_varSys_module tem_varSys_module module~mus_relaxationparam_module->tem_varSys_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_relaxationparam_module~~UsedByGraph module~mus_relaxationparam_module mus_relaxationParam_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_relaxationparam_module module~mus_fluid_module mus_fluid_module module~mus_aux_module->module~mus_fluid_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_field_module mus_field_module module~mus_aux_module->module~mus_field_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_fluid_module->module~mus_relaxationparam_module module~mus_tools_module->module~mus_relaxationparam_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_field_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_fluid_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_field_module->module~mus_fluid_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_field_prop_module->module~mus_fluid_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_config_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_field_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_field_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_viscosity_type Contains STfun of viscosity variable and relaxation parameter for each\nlevel Components Type Visibility Attributes Name Initial type( tem_spacetime_fun_type ), public :: STfun space-time function type( grw_realarray_type ), public, allocatable :: dataOnLvl (:) viscosity value evaluated from STfun type( mus_relaxationParam_type ), public, allocatable :: omLvl (:) relaxation paramter omega for each level type, private :: mus_relaxationParam_type Contains relaxation parameter for a level Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: val (:) Relaxation parameter computed from viscosity\nFor kinematic viscosity, if turbulence is active, this omega refers to\neffective omega which is omega_bg + omega_turb\nsize: nElems_solve Functions public elemental function mus_calcOmegaFromVisc (visc) result(omega) This function compute relaxation paramter omega from viscosity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: visc scaled lattice viscosity i.e vL_c/dtL Return Value real(kind=rk) lattice time step size in current level\nreal(kind=rk), intent(in) :: dtL\n output: relaxation parameter omega Subroutines public  subroutine mus_init_relaxParam (omLvl, minLevel, maxLevel, nElems) This routine initialize relaxation parameter Arguments Type Intent Optional Attributes Name type( mus_relaxationParam_type ), intent(out), allocatable :: omLvl (:) relaxation paramter integer, intent(in) :: minLevel minlevel and maxLevel integer, intent(in) :: maxLevel minlevel and maxLevel integer, intent(in) :: nElems (minLevel:maxLevel) number of local elements per level public  subroutine mus_update_viscKine (viscKine, state, neigh, auxField, gradData, layout, baryOfTotal, tNow, nSize, nFluids, nGhostFromCoarser, nGhostFromFiner, nHalo, varSys, iLevel, convFac, dxL, dtL, derVarPos, turb, nNwtn, Grad) Update kinematic viscosity from STfun and calculate turbulent viscosity\nfrom velocity gradient or nonEqPDF\nViscosity obtained from this routine are normalized to the level Read more… Arguments Type Intent Optional Attributes Name type( mus_viscosity_type ), intent(inout) :: viscKine Kinematic viscosity real(kind=rk), intent(in) :: state (:) state array integer, intent(in) :: neigh (:) neighbor connectivity array real(kind=rk), intent(in) :: auxField (:) Auxiliary field variable array type(mus_gradData_type), intent(in) :: gradData gradient data type( mus_scheme_layout_type ), intent(in) :: layout stencil layout real(kind=rk), intent(in) :: baryOfTotal (:,:) bary of treeID in total list type( tem_time_type ), intent(in) :: tNow current simulation time integer, intent(in) :: nSize number of elements in state array integer, intent(in) :: nFluids number of fluid elements in state array integer, intent(in) :: nGhostFromCoarser Number of ghostFromCoarser element in state array integer, intent(in) :: nGhostFromFiner Number of ghostFromFiner element in state array integer, intent(in) :: nHalo Number of halo element in state array type( tem_varSys_type ), intent(in) :: varSys variable system integer, intent(in) :: iLevel current level type( mus_convertFac_type ), intent(in) :: convFac reference physical conversion factors for current level real(kind=rk), intent(in) :: dxL lattice element size in current level real(kind=rk), intent(in) :: dtL lattice time step size in current level type( mus_derVarPos_type ), intent(in) :: derVarPos contains position of in varSys type( mus_turbulence_type ), intent(inout) :: turb turbulence type type(mus_nNwtn_type), intent(in) :: nNwtn non-Newtonian type type(mus_Grad_type), intent(in) :: Grad Object that contains pointers to calculate gradients public  subroutine mus_update_relaxParamKine (viscKine, turb, nSolve, iLevel) Update kinematic relaxation parameter from viscosity and check omega Arguments Type Intent Optional Attributes Name type( mus_viscosity_type ), intent(inout) :: viscKine Kinematic viscosity type( mus_turbulence_type ), intent(in) :: turb turbulence type integer, intent(in) :: nSolve Number of elements to solve in compute kernel integer, intent(in) :: iLevel current level public  subroutine mus_update_relaxParamFromViscSTfun (omega, visc, viscSTfun, nElems, baryOfTotal, tNow, viscRef) This routine is used to initialize relaxation paramter and update\nbulk viscosity at every time step\nBulk visocisty is defined as space-time function to apply\nramping and spatial sponge in bulk viscosity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: omega (:) relaxation parameter real(kind=rk), intent(inout) :: visc (:) Kinematic viscosity type( tem_spacetime_fun_type ), intent(in) :: viscSTfun viscosity space-time function integer, intent(in) :: nElems Number of local elements including halos real(kind=rk), intent(in) :: baryOfTotal (:,:) baryID of total list type( tem_time_type ), intent(in) :: tNow current simulation time real(kind=rk), intent(in) :: viscRef reference physical viscosity on current level i.e. (dxP_l)&#94;2/dtP_l\nDividing physical viscosity with the viscRef gives vL_l/dtL_l public  subroutine mus_check_omegaKine (schemeRelax, omLvlKine, nSolve, minLevel, maxLevel, general) This routine checks whether omega is within the stability limit.\nIf not it will terminate the simulation with error message.\nUsing limits given in\nTölke, J., Freudiger, S., & Krafczyk, M. (2006). An adaptive scheme using\nhierarchical grids for lattice Boltzmann multi-phase flow simulations.\nComputers & Fluids, 35(8–9), 820–830.\nFor BGK: 2/3 < omega < 1.976\nFor MRT: 2/3 < omega < 1.999 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: schemeRelax scheme relaxation type type( mus_relaxationParam_type ), intent(in) :: omLvlKine (minLevel:maxLevel) array of kinematic relaxation parameter on all levels integer, intent(in) :: nSolve (minLevel:maxLevel) Number of elements to solve in compute kernel integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel type( tem_general_type ), intent(inout) :: general Contains proc, simControl, solveHead","tags":"","loc":"module/mus_relaxationparam_module.html"},{"title":"mus_control_module – Musubi","text":"In this module, the control structure for computing each time step is\nestablished. Various different control structures can be defined and set by function\npointers.\nThe current main routine is recursive_multilevel which recursively computes\nthe new time step for all the schemes defined on all levels, starting from\nthe coarsest. Uses env_module tem_varSys_module mus_scheme_type_module mus_geom_module tem_stencil_module mus_scheme_header_module mus_IBM_module mus_field_module mus_auxField_module tem_time_module mus_timer_module tem_general_module mus_pdf_module mus_param_module mus_bc_general_module tem_logging_module tem_debug_module mus_derVarPos_module mus_debug_module mus_aux_module tem_timer_module mus_physics_module mus_source_module module~~mus_control_module~~UsesGraph module~mus_control_module mus_control_module env_module env_module module~mus_control_module->env_module module~mus_aux_module mus_aux_module module~mus_control_module->module~mus_aux_module module~mus_auxfield_module mus_auxField_module module~mus_control_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_control_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_control_module->module~mus_field_module module~mus_geom_module mus_geom_module module~mus_control_module->module~mus_geom_module module~mus_param_module mus_param_module module~mus_control_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_control_module->module~mus_pdf_module module~mus_physics_module mus_physics_module module~mus_control_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_control_module->module~mus_scheme_header_module module~mus_scheme_type_module mus_scheme_type_module module~mus_control_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_control_module->module~mus_source_module module~mus_timer_module mus_timer_module module~mus_control_module->module~mus_timer_module mus_IBM_module mus_IBM_module module~mus_control_module->mus_IBM_module mus_bc_general_module mus_bc_general_module module~mus_control_module->mus_bc_general_module mus_debug_module mus_debug_module module~mus_control_module->mus_debug_module tem_debug_module tem_debug_module module~mus_control_module->tem_debug_module tem_general_module tem_general_module module~mus_control_module->tem_general_module tem_logging_module tem_logging_module module~mus_control_module->tem_logging_module tem_stencil_module tem_stencil_module module~mus_control_module->tem_stencil_module tem_time_module tem_time_module module~mus_control_module->tem_time_module tem_timer_module tem_timer_module module~mus_control_module->tem_timer_module tem_varSys_module tem_varSys_module module~mus_control_module->tem_varSys_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_control_module~~UsedByGraph module~mus_control_module mus_control_module program~musubi musubi program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, save :: iStage = 0 logical, private, save :: running = .false. Abstract Interfaces abstract interface private  subroutine computation(me, scheme, geometry, params, iLevel) Interface describes the main control routine which does computation\nset boundary and check flow status Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable Derived Types type, public :: mus_control_type Datatype containing mapping of control routines to function pointers Components Type Visibility Attributes Name Initial procedure( computation ), public, pointer :: do_computation => null() Subroutines public  subroutine mus_init_control (controlRoutine, me, minLevel, maxLevel) This routines sets the function pointer to main control routine Read more… Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: controlRoutine type( mus_control_type ), intent(out) :: me contains function pointer to point control routine integer, intent(in) :: minLevel integer, intent(in) :: maxLevel private recursive subroutine do_recursive_multiLevel (me, scheme, geometry, params, iLevel) Main control routine: Update the time step for all levels.\nMain steps:\n  * if iLevel < maxLevel do recursive at iLevel+1\n  * do BC at iLevel\n  * do auxField calculation at iLevel\n  * do compute kernel at iLevel\n  * do apply source at iLevel\n  * do do_IntpFinerAndExchange at iLevel if iLevel < maxLevel\n    * intp My Coarser ghost (iLevel) from Finer (iLevel+1)\n    * do exchange bufferFromFiner at iLevel\n  * exchange buffer at iLevel\n  * exchange bufferFromCoarser at iLevel if iLevel > minLevel\n  * do do_intpCoarserAndExchange at iLevel if iLevel < maxLevel\n    * intp Finer Ghost (iLevel+1) from my coarser (iLevel)\n    * exchange bufferFromCoarser at iLevel+1 Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel the current level private  subroutine do_intpFinerAndExchange (scheme, params, iLevel) This routine does:\n1. interpolate my coarse ghost element (iLevel) from finer level (iLevel+1)\n2. exchange the data of my coarse ghost elements between process Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel private  subroutine do_intpCoarserAndExchange (scheme, params, iLevel) This routine utilizes fluid elements on my level (L) to fill finer\nghost elements on next level (L+1).\nThen it exchanges the datas of finer ghost elements (L+1) between process. Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_param_type ), intent(in) :: params global parameters integer, intent(in) :: iLevel Level counter variable private  subroutine do_fast_singleLevel (me, scheme, geometry, params, iLevel) Control routine for an optimized workflow with reduced functionality. Read more… Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type\ndummy variable in this routine, required by interface type( mus_scheme_type ), intent(inout) :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable private  subroutine do_benchmark (me, scheme, geometry, params, iLevel) Arguments Type Intent Optional Attributes Name class( mus_control_type ) :: me self control type\ndummy variable in this routine, required by interface type( mus_scheme_type ), intent(inout) :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters integer, intent(in) :: iLevel Level counter variable private  subroutine start_stageTimer () Arguments None private  subroutine stop_stageTimer () Arguments None","tags":"","loc":"module/mus_control_module.html"},{"title":"mus_scheme_type_module – Musubi","text":"This module contains the type definition(s) required in the scheme routines\nIn addition depend type and condition type for geometry increase routine\nare defined. Compute kernel definition is also defined in this module Uses env_module tem_varSys_module mus_transport_var_module mus_source_type_module tem_varMap_module mus_scheme_header_module mus_bc_header_module mus_field_module mus_auxField_module tem_tracking_module mus_param_module mus_pdf_module mus_field_prop_module mus_mixture_module mus_nernstPlanck_module tem_spacetime_fun_module tem_variable_module mus_scheme_layout_module mus_derVarPos_module mus_interpolate_header_module tem_construction_module mus_gradData_module module~~mus_scheme_type_module~~UsesGraph module~mus_scheme_type_module mus_scheme_type_module env_module env_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_scheme_type_module~~UsedByGraph module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface What does the kernel interface look like?\nEvery kernel's argument list must correspond to this one. Read more… public  subroutine kernel(fieldProp, inState, outState, auxField, neigh, nElems, nSolve, level, layout, params, varSys, derVarPos) The common subroutine interface for compute kernels. All kernels have to\nimplement this interface in order to be callable via\nmus_scheme_type%compute function pointer. Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(in) :: fieldProp (:) Array of field properties (fluid or species) real(kind=rk), intent(in) :: inState (nElems*varSys%nScalars) input  pdf vector real(kind=rk), intent(out) :: outState (nElems*varSys%nScalars) output pdf vector real(kind=rk), intent(inout) :: auxField (nElems*varSys%nAuxScalars) Auxiliary field computed from pre-collision state\nIs updated with correct velocity field for multicomponent models integer, intent(in) :: neigh (nElems*layout%fStencil%QQ) connectivity vector integer, intent(in) :: nElems number of elements in state Array integer, intent(in) :: nSolve number of elements solved in kernel integer, intent(in) :: level current level type( mus_scheme_layout_type ), intent(in) :: layout current layout type( mus_param_type ), intent(in) :: params global parameters type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys for all fields Derived Types type, public :: array2D_type To allow Intel AVX SIMD streaming store instructions,\nthe array must be aligned at 32 bytes Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable, dimension(:,:) :: val type, public :: mus_scheme_type Datatype containing all information on the scheme. Read more… Components Type Visibility Attributes Name Initial type( mus_interpolation_type ), public :: intp Interpolation description for each scheme to do its own interpolation type( mus_mixture_type ), public :: mixture contains mixture information for multispecies type( mus_nernstPlanck_type ), public :: nernstPlanck integer, public :: nFields = 0 number of fields in the current scheme type( mus_field_type ), public, allocatable :: field (:) array of field type for each field type(glob_boundary_type), public, allocatable :: globBC (:) array of boundary types contains elems of each boundary type( mus_source_type ), public :: globSrc global source applied to all fields type( tem_possible_variable_type ), public :: poss_srcVar possible source variables depends on scheme kind type( mus_transport_var_type ), public :: transVar transport variables type( tem_possible_variable_type ), public :: poss_transVar possible transport variables depends on scheme kind\nThis variables might be used in compute kernel type( mus_scheme_header_type ), public :: header identifier of the scheme type( tem_levelDesc_type ), public, allocatable :: levelDesc (:) type( pdf_data_type ), public, allocatable :: pdf (:) pdf_data_types for every level\nsize: minLevel:maxLevel type( array2D_type ), public, allocatable :: state (:) Data vector containing the pdf state\nallocated in routine: mus_construct\nsize: minLevel:maxLevel type( mus_scheme_layout_type ), public :: layout the scheme representation used in this scheme procedure( kernel ), public, pointer, nopass :: compute => null() function pointer to compute kernel type( tem_tracking_type ), public :: track Contains trackingControl, config and instances type( tem_varMap_type ), public :: redTransVarMap Position of reduction transient variable in varSys type( mus_derVarPos_type ), public, allocatable :: derVarPos (:) store position of derived variable each field and total field\nin the global system type( tem_varSys_type ), public :: varSys global variable system definition type( tem_variable_type ), public, allocatable :: luaVar (:) Variables defined in the lua file type( tem_varMap_type ), public :: stateVarMap state variable position in the global varSys type( tem_st_fun_linkedList_type ), public :: st_funList contains spacetime functions defined for lua variables logical, public :: readVarIsPdf Used in mus_harvesting to check whether variables loaded from\nrestart file has pdf variable type( mus_auxFieldVar_type ), public, allocatable :: auxField (:) stores auxField variable values and function pointer to compute\nauxiliary field\nSize: minlevel:maxLevel type(mus_gradData_type), public, allocatable :: gradData (:) Contains direct neighbor position in the state and\nfinite difference coefficients to compute gradient procedure( mus_proc_calcAuxField ), public, pointer, nopass :: calcAuxField => null() Function pointer to evaluate auxilary variable type(mus_Grad_type), public :: Grad Contains the different pointers to calculate the gradients","tags":"","loc":"module/mus_scheme_type_module.html"},{"title":"mus_tracking_module – Musubi","text":"This module provides the MUSUBI subroutines needed for the tracking\nfunctionality. Uses mus_time_module mus_tools_module mus_scheme_type_module hvs_output_module tem_tracking_module mus_geom_module tem_logging_module mus_param_module tem_debug_module module~~mus_tracking_module~~UsesGraph module~mus_tracking_module mus_tracking_module hvs_output_module hvs_output_module module~mus_tracking_module->hvs_output_module module~mus_geom_module mus_geom_module module~mus_tracking_module->module~mus_geom_module module~mus_param_module mus_param_module module~mus_tracking_module->module~mus_param_module module~mus_scheme_type_module mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_time_module mus_time_module module~mus_tracking_module->module~mus_time_module module~mus_tools_module mus_tools_module module~mus_tracking_module->module~mus_tools_module tem_debug_module tem_debug_module module~mus_tracking_module->tem_debug_module tem_logging_module tem_logging_module module~mus_tracking_module->tem_logging_module tem_tracking_module tem_tracking_module module~mus_tracking_module->tem_tracking_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_tracking_module~~UsedByGraph module~mus_tracking_module mus_tracking_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tracking_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_tracker (scheme, geometry, params) This routine initialize tracking subTree to remove empty tracking objects.\nOn active tracking objects: Homogenize time control, write solver speific\ninfo for harvester output format and initialize output using\ntem_init_tracker Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( mus_geom_type ), intent(in) :: geometry Treelmesh data type( mus_param_type ), intent(in) :: params Global parameters","tags":"","loc":"module/mus_tracking_module.html"},{"title":"mus_initMultispecies_module – Musubi","text":"This module contains routines which initiliaze advection relaxation and\nflow field for multispecies lbm gas model and liquid model. Uses env_module mus_MSGas_module tem_aux_module mus_scheme_type_module mus_MSLiquid_module tem_logging_module module~~mus_initmultispecies_module~~UsesGraph module~mus_initmultispecies_module mus_initMultispecies_module env_module env_module module~mus_initmultispecies_module->env_module module~mus_scheme_type_module mus_scheme_type_module module~mus_initmultispecies_module->module~mus_scheme_type_module mus_MSGas_module mus_MSGas_module module~mus_initmultispecies_module->mus_MSGas_module mus_MSLiquid_module mus_MSLiquid_module module~mus_initmultispecies_module->mus_MSLiquid_module tem_aux_module tem_aux_module module~mus_initmultispecies_module->tem_aux_module tem_logging_module tem_logging_module module~mus_initmultispecies_module->tem_logging_module module~mus_scheme_type_module->env_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_dervarpos_module mus_derVarPos_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_field_module mus_field_module module~mus_scheme_type_module->module~mus_field_module module~mus_field_prop_module mus_field_prop_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_type_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_scheme_type_module->module~mus_nernstplanck_module module~mus_param_module mus_param_module module~mus_scheme_type_module->module~mus_param_module module~mus_pdf_module mus_pdf_module module~mus_scheme_type_module->module~mus_pdf_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_type_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_type_module->module~mus_transport_var_module mus_bc_header_module mus_bc_header_module module~mus_scheme_type_module->mus_bc_header_module mus_gradData_module mus_gradData_module module~mus_scheme_type_module->mus_gradData_module tem_construction_module tem_construction_module module~mus_scheme_type_module->tem_construction_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_type_module->tem_spacetime_fun_module tem_tracking_module tem_tracking_module module~mus_scheme_type_module->tem_tracking_module tem_varMap_module tem_varMap_module module~mus_scheme_type_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_scheme_type_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_type_module->tem_variable_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_init_advRel_multispecies_gas (relaxation, layout, nFields, compute) Initialize the relaxation model for multispecies gas model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout integer, intent(in) :: nFields procedure( kernel ), intent(out), pointer :: compute public  subroutine mus_init_advRel_multispecies_liquid (relaxation, layout, nFields, compute) Initialize the relaxation model for multispecies liquid model Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: relaxation character(len=labelLen), intent(in) :: layout integer, intent(in) :: nFields procedure( kernel ), intent(out), pointer :: compute","tags":"","loc":"module/mus_initmultispecies_module.html"},{"title":"mus_variable_module – Musubi","text":"This module provides all possible 'pure variables' (= no prefixes) for a\n given kind of simulation. IMPORTANT NOTE: When you create a new variable, do not forget to add this\nvariable\nname into mus_append_auxField , mus_store_derVarPos and also in mus_store_bcVarPos routine. Uses env_module iso_c_binding tem_varSys_module mus_derQuanPS_module mus_varSys_module mus_source_type_module tem_varMap_module tem_stencil_module mus_scheme_header_module mus_operation_var_module mus_source_var_turbChanForce_module tem_meshInfo_module mus_turbulence_var_module mus_derQuanPoisson_module tem_dyn_array_module mus_auxFieldVar_module mus_field_module mus_material_var_module mus_source_var_module mus_bc_var_module mus_stateVar_module tem_grow_array_module tem_derived_module tem_spacetime_fun_module mus_derQuanMSLiquid_module tem_variable_module mus_scheme_layout_module tem_logging_module tem_debug_module mus_derVarPos_module mus_derQuanPhysics_module mus_derQuanIncomp_module tem_aux_module mus_derQuanMSGas_module mus_derQuanIsothermAcEq_module mus_derQuan_module mus_derQuanNernstPlanck_module env_module w mus_variable_module w iso_c_binding w w mus_auxFieldVar_module w w mus_bc_var_module w w mus_derQuan_module w w mus_derQuanIncomp_module w w mus_derQuanIsothermAcEq_module w w mus_derQuanMSGas_module w w mus_derQuanMSLiquid_module w w mus_derQuanNernstPlanck_module w w mus_derQuanPhysics_module w w mus_derQuanPoisson_module w w mus_derQuanPS_module w w mus_derVarPos_module w w mus_field_module w w mus_material_var_module w w mus_operation_var_module w w mus_scheme_header_module w w mus_scheme_layout_module w w mus_source_type_module w w mus_source_var_module w w mus_source_var_turbChanForce_module w w mus_stateVar_module w w mus_turbulence_var_module w w mus_varSys_module w w tem_aux_module w w tem_debug_module w w tem_derived_module w w tem_dyn_array_module w w tem_grow_array_module w w tem_logging_module w w tem_meshInfo_module w w tem_spacetime_fun_module w w tem_stencil_module w w tem_variable_module w w tem_varMap_module w w tem_varSys_module w w Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_variable_module~~UsedByGraph module~mus_variable_module mus_variable_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_variable_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_aux_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module program~musubi->module~mus_aux_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_build_varSys (varSys, solverData, schemeHeader, stencil, nFields, derVarPos, luaVar, field, globSrc, poss_srcVar, st_funList) Build global variable system for Musubi Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_stencilHeader_type ), intent(in) :: stencil Compute stencil header integer, intent(in) :: nFields number of fields type( mus_derVarPos_type ), intent(out), allocatable :: derVarPos (:) store position of each variable for each field and mixture\nsize: nFields+1 type( tem_variable_type ), intent(in), allocatable :: luaVar (:) additional variable defined in the lua file.\nFunction pointer for this variables depends on its varType. type( mus_field_type ), intent(inout) :: field (:) Field contains sources and boundary infos type( mus_source_type ), intent(inout) :: globSrc global source type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( tem_st_fun_linkedList_type ), intent(out) :: st_funList contains spacetime functions of all variables public  subroutine mus_append_readVarAsStateVar (varSys, readVarIsPdf, read_varSys, stateVarMap, solverData, nFields, fldLabel) Append variable read from restart file as state variables Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system logical, intent(out) :: readVarIsPdf Is true if read_varSys has pdf variable type( tem_varSys_type ), intent(in) :: read_varSys Variable system loaded from restart header file type( tem_varMap_type ), intent(out) :: stateVarMap Store position of state variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields public  subroutine mus_append_stateVar (varSys, stateVarMap, solverData, schemeHeader, stencil, nFields, fldLabel) Append state variable depends on the scheme kind Read more… Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type( tem_varMap_type ), intent(out) :: stateVarMap Store position of state variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_stencilHeader_type ), intent(in) :: stencil compute stencil defintion integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields public  subroutine mus_append_auxField (varSys, solverData, schemeHeader, nFields, fldLabel, derVarName) Append auxiliary variables which are computed from state and stored\nin auxField array using calcAuxField function Arguments Type Intent Optional Attributes Name type( tem_varSys_type ), intent(inout) :: varSys global variable system type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields type( grw_labelarray_type ), intent(inout) :: derVarName array of derive physical variables public  subroutine mus_store_derVarPos (derVarPos, derVarName, varSys, nFields, fldLabel) Store the position of each variable in the global system in the derVarPos\nThis function is also called in Harvester. Arguments Type Intent Optional Attributes Name type( mus_derVarPos_type ), intent(inout) :: derVarPos (:) Position of derived variables type( grw_labelarray_type ), intent(in) :: derVarName array of derive physical variables type( tem_varSys_type ), intent(in) :: varSys global variable system integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields private  subroutine mus_append_sourceVar (me, solverData, schemeHeader, varSys, nFields, stencil, poss_srcVar, fldLabel) Build a variable system of all possible source terms for the given\nschemeKind Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(inout) :: me Contains source function pointer,\nsource variable definition from lua and\nmapping of source variable in global varSys type(mus_varSys_solverData_type), intent(in), target :: solverData Contains pointer to solver data types type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme type( tem_varSys_type ), intent(inout) :: varSys Global variable system integer, intent(in) :: nFields number of fields type( tem_stencilHeader_type ), intent(in) :: stencil compute stencil defintion type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables character(len=*), intent(in), optional :: fldLabel array of field label prefix required only for field source.\nIf not present, it is assumed as global source private  subroutine mus_store_bcVarPos (field, nFields, varSys) Store the position of each boundary variable in the global varSys\nin the field%bc%varPos% .\nThis routine also checks if boundary variable defined in config file\nhas same number of components as expected. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (:) Field containing boundary infos integer, intent(in) :: nFields number of fields type( tem_varSys_type ), intent(in) :: varSys global variable system private  subroutine check_varSys_forPdfVar (readVarIsPdf, varSys, nFields, fldLabel) This function runs over all variable loaded from restart file check if\nvariables loaded are pdf variable or derive variable Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: readVarIsPdf return true if variable read from restart file has pdf type( tem_varSys_type ), intent(in) :: varSys variable system loaded from restart file integer, intent(in) :: nFields number of fields character(len=*), intent(in) :: fldLabel (:) array of field label prefix. Size=nFields","tags":"","loc":"module/mus_variable_module.html"},{"title":"mus_param_module – Musubi","text":"This module provides the definition and methods for\nboundarys. Uses mus_abortCriteria_module env_module aotus_module tem_logging_module mus_physics_module tem_general_module aot_out_module tem_tools_module module~~mus_param_module~~UsesGraph module~mus_param_module mus_param_module aot_out_module aot_out_module module~mus_param_module->aot_out_module aotus_module aotus_module module~mus_param_module->aotus_module env_module env_module module~mus_param_module->env_module module~mus_abortcriteria_module mus_abortCriteria_module module~mus_param_module->module~mus_abortcriteria_module module~mus_physics_module mus_physics_module module~mus_param_module->module~mus_physics_module tem_general_module tem_general_module module~mus_param_module->tem_general_module tem_logging_module tem_logging_module module~mus_param_module->tem_logging_module tem_tools_module tem_tools_module module~mus_param_module->tem_tools_module module~mus_abortcriteria_module->aotus_module module~mus_abortcriteria_module->env_module tem_abortCriteria_module tem_abortCriteria_module module~mus_abortcriteria_module->tem_abortCriteria_module module~mus_physics_module->aot_out_module module~mus_physics_module->aotus_module module~mus_physics_module->env_module module~mus_physics_module->tem_logging_module module~mus_physics_module->tem_tools_module aot_table_module aot_table_module module~mus_physics_module->aot_table_module tem_aux_module tem_aux_module module~mus_physics_module->tem_aux_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_param_module~~UsedByGraph module~mus_param_module mus_param_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_param_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_geom_module mus_geom_module module~mus_aux_module->module~mus_geom_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_param_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_param_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_param_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_config_module->module~mus_geom_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_param_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_geom_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_param_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_dynloadbal_module->module~mus_geom_module module~mus_geomincrhead_module mus_geomIncrHead_module module~mus_geomincrhead_module->module~mus_param_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_param_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_geom_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_param_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_geomincrhead_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_geom_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_param_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_hvs_construction_module->module~mus_geom_module module~mus_scheme_module->module~mus_param_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_geom_module module~mus_scheme_type_module->module~mus_param_module module~mus_tools_module->module~mus_param_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_param_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_tracking_module->module~mus_geom_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_param_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_geom_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_param_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_geom_module module~mus_geom_module->module~mus_geomincrhead_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module->module~mus_geom_module module~mus_restart_module->module~mus_scheme_type_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: block_size = 576 Derived Types type, public :: mus_latticeUnit_type lattice dx and dt on each level Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dtLvl (:) dt in LB unit, dtLvl(minLevel) = 1.0 real(kind=rk), public, allocatable :: dxLvl (:) dx in LB unit, dxLvl(minLevel) = 1.0 type, public :: mus_param_type Global parameter type definition, filled with Components Type Visibility Attributes Name Initial type( tem_general_type ), public :: general Treelm param parameter type type( mus_abortCriteria_type ), public :: mus_Aborts Musubi specific abort criteria type( mus_latticeUnit_type ), public :: lattice Lattice dx and dt on each level type( mus_physics_type ), public :: physics contains basic SI units to convert from lattice to physical and\nvice versa character(len=labelLen), public :: controlRoutine type of the control routine logical, public :: init_allElems = .false. initialize all elements with valid entries?\nThis should only be activated for debugging,\nas it needs to be ensured that all helper elements\nare filled by communication and interpolation instead\nof filling initial values (consider restart!) character(len=labelLen), public :: scaling type of the scaling:\n* acoustic\n* diffusive integer, public :: scaleFactor Temporal scaling factor for the scaling. Acoustic = 2, Diffusive = 4 integer, public :: nNesting = 2 To calculate turbulent viscosity, velocity on buffer ghost elements\nshould be valid to nesting is set to same as scaling Factor integer, public :: reqInterval Required interval, in which the update MUST occur.\nThis is required for the musubi multilevel, where the time step should\nonly be determined active, when the end of the largest cycle is reached. logical, public :: comm_reduced = .true. character(len=labelLen), public :: version = 'v2.0' need to set solver version in  general%solver%version logical, public :: restart_triggered = .false. active when restart is triggered by restart timeControl\ndump restart when simulation reached end only when\nrestart is not triggered by its timeControl before logical, public :: remove_solid = .true. remove solid from BC list integer, public :: block = block_size Block size for compute kernel logical, public :: initial_balance = .false. Initial balance logical, public :: dump_level_timing = .false. scratch file unit contains solver specific info in dump in restart header\nThis file should contain the information in form of a Lua script.\nKM: Not required anymore. Load config file name from restart header\ninteger :: solSpec_unit = -1\nDump level timing logical, public :: dump_linear_partition = .false. Dump linear partition logical, public :: dump_bc_timing = .false. Dump computation and bc timing information for all ranks Subroutines public  subroutine mus_load_param (params, conf) load global parameter from conf Read more… Arguments Type Intent Optional Attributes Name type( mus_param_type ), intent(inout) :: params global parameter info type( flu_State ) :: conf lua state public  subroutine mus_param_out (me, conf) This routine writes global parameter into solver specific string in lua\nformat Arguments Type Intent Optional Attributes Name type( mus_param_type ), intent(in) :: me type( aot_out_type ) :: conf public  subroutine mus_init_latticeUnit (lattice, minLevel, maxLevel, scaleFactor) This routine initialize lattice dx and dt Arguments Type Intent Optional Attributes Name type( mus_latticeUnit_type ), intent(out) :: lattice Lattice unit integer, intent(in) :: minLevel minlevel and maxlevel integer, intent(in) :: maxLevel minlevel and maxlevel integer, intent(in) :: scaleFactor scaleFactor depending on acoustic or diffusive scaling","tags":"","loc":"module/mus_param_module.html"},{"title":"mus_scheme_module – Musubi","text":"Definition of the datatypes for the scheme implementation. For a detailed description see Scheme Implementation . Uses env_module mus_moments_module tem_varSys_module mus_scheme_type_module mus_transport_var_module aotus_module mus_varSys_module mus_source_type_module mus_geom_module tem_stencil_module mus_scheme_header_module tem_dyn_array_module mus_auxFieldVar_module mus_field_module mus_variable_module tem_tracking_module mus_param_module tem_tools_module mus_scheme_derived_quantities_module mus_mixture_module tem_spacetime_fun_module tem_variable_module mus_scheme_layout_module treelmesh_module tem_logging_module aot_table_module tem_debug_module mus_interpolate_header_module tem_aux_module aot_out_module mus_gradData_module module~~mus_scheme_module~~UsesGraph module~mus_scheme_module mus_scheme_module aot_out_module aot_out_module module~mus_scheme_module->aot_out_module aot_table_module aot_table_module module~mus_scheme_module->aot_table_module aotus_module aotus_module module~mus_scheme_module->aotus_module env_module env_module module~mus_scheme_module->env_module module~mus_field_module mus_field_module module~mus_scheme_module->module~mus_field_module module~mus_geom_module mus_geom_module module~mus_scheme_module->module~mus_geom_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_mixture_module mus_mixture_module module~mus_scheme_module->module~mus_mixture_module module~mus_moments_module mus_moments_module module~mus_scheme_module->module~mus_moments_module module~mus_param_module mus_param_module module~mus_scheme_module->module~mus_param_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_scheme_module->module~mus_scheme_derived_quantities_module module~mus_scheme_header_module mus_scheme_header_module module~mus_scheme_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_scheme_module->module~mus_scheme_layout_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_source_type_module mus_source_type_module module~mus_scheme_module->module~mus_source_type_module module~mus_transport_var_module mus_transport_var_module module~mus_scheme_module->module~mus_transport_var_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module mus_auxFieldVar_module mus_auxFieldVar_module module~mus_scheme_module->mus_auxFieldVar_module mus_gradData_module mus_gradData_module module~mus_scheme_module->mus_gradData_module mus_varSys_module mus_varSys_module module~mus_scheme_module->mus_varSys_module tem_aux_module tem_aux_module module~mus_scheme_module->tem_aux_module tem_debug_module tem_debug_module module~mus_scheme_module->tem_debug_module tem_dyn_array_module tem_dyn_array_module module~mus_scheme_module->tem_dyn_array_module tem_logging_module tem_logging_module module~mus_scheme_module->tem_logging_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_scheme_module->tem_spacetime_fun_module tem_stencil_module tem_stencil_module module~mus_scheme_module->tem_stencil_module tem_tools_module tem_tools_module module~mus_scheme_module->tem_tools_module tem_tracking_module tem_tracking_module module~mus_scheme_module->tem_tracking_module tem_varSys_module tem_varSys_module module~mus_scheme_module->tem_varSys_module tem_variable_module tem_variable_module module~mus_scheme_module->tem_variable_module treelmesh_module treelmesh_module module~mus_scheme_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_scheme_module~~UsedByGraph module~mus_scheme_module mus_scheme_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_tools_module mus_tools_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_config_module module~mus_tools_module->module~mus_scheme_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_hvs_config_module module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_aux_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module program~musubi musubi program~musubi->module~mus_config_module program~musubi->module~mus_aux_module module~mus_control_module mus_control_module program~musubi->module~mus_control_module module~mus_control_module->module~mus_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_load_scheme (me, solverData, geometry, conf, params, parent, isMusHvs) load single scheme defined in lua file with or without scheme handle Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: me scheme type type(mus_varSys_solverData_type), target :: solverData contains pointer to scheme, physics types type( mus_geom_type ), intent(in), target :: geometry geometry information like tree and boundary type( flu_State ) :: conf flu state type( mus_param_type ), intent(inout), target :: params global parameter type integer, intent(in), optional :: parent parent handle if scheme table is defined logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False public  subroutine mus_init_scheme (me, tree, solverData) Initialize single scheme stencil and variable system Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: me single scheme to initialize type( treelmesh_type ), intent(in) :: tree global treelm mesh type(mus_varSys_solverData_type), intent(in), target :: solverData contains pointer to scheme, physics types public  subroutine mus_scheme_out (me, conf) Dump single scheme info into restart solver specific conf to dump\nsolver specific information in restart header file Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: me schemes to dump to restart header file type( aot_out_type ), intent(inout), optional :: conf aotus type handling the output to the file in lua format public  subroutine mus_scheme_cleanup (me, minLevel, maxLevel, nBCs) This subroutine acts as a destructor for the construct routine Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: me scheme information including fluid, boundary and flow information integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(in) :: nBCs Number of boundary conditions","tags":"","loc":"module/mus_scheme_module.html"},{"title":"mus_field_module – Musubi","text":"This module contains information about all fields like fluid,\nspecies, temperature etc. This field type will be used for\nmultispecies and passive scalar transport. [mus_field_prop]: @ref mus_field_prop_module \"mus_field_prop_module\" Uses env_module tem_varSys_module aotus_module tem_stringKeyValuePair_module mus_source_type_module tem_varMap_module tem_stencil_module mus_scheme_header_module tem_ini_condition_module mus_bc_header_module tem_param_module mus_source_var_module mus_fluid_module tem_temporal_module tem_time_module tem_tools_module mus_field_prop_module mus_mixture_module mus_nernstPlanck_module mus_scheme_layout_module tem_logging_module aot_table_module tem_debug_module tem_restart_module mus_species_module tem_bc_prop_module tem_math_module tem_aux_module aot_out_module mus_physics_module tem_construction_module module~~mus_field_module~~UsesGraph module~mus_field_module mus_field_module aot_out_module aot_out_module module~mus_field_module->aot_out_module aot_table_module aot_table_module module~mus_field_module->aot_table_module aotus_module aotus_module module~mus_field_module->aotus_module env_module env_module module~mus_field_module->env_module module~mus_field_prop_module mus_field_prop_module module~mus_field_module->module~mus_field_prop_module module~mus_fluid_module mus_fluid_module module~mus_field_module->module~mus_fluid_module module~mus_mixture_module mus_mixture_module module~mus_field_module->module~mus_mixture_module module~mus_nernstplanck_module mus_nernstPlanck_module module~mus_field_module->module~mus_nernstplanck_module module~mus_physics_module mus_physics_module module~mus_field_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_field_module->module~mus_scheme_header_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_field_module->module~mus_scheme_layout_module module~mus_source_type_module mus_source_type_module module~mus_field_module->module~mus_source_type_module module~mus_source_var_module mus_source_var_module module~mus_field_module->module~mus_source_var_module module~mus_species_module mus_species_module module~mus_field_module->module~mus_species_module mus_bc_header_module mus_bc_header_module module~mus_field_module->mus_bc_header_module tem_aux_module tem_aux_module module~mus_field_module->tem_aux_module tem_bc_prop_module tem_bc_prop_module module~mus_field_module->tem_bc_prop_module tem_construction_module tem_construction_module module~mus_field_module->tem_construction_module tem_debug_module tem_debug_module module~mus_field_module->tem_debug_module tem_ini_condition_module tem_ini_condition_module module~mus_field_module->tem_ini_condition_module tem_logging_module tem_logging_module module~mus_field_module->tem_logging_module tem_math_module tem_math_module module~mus_field_module->tem_math_module tem_param_module tem_param_module module~mus_field_module->tem_param_module tem_restart_module tem_restart_module module~mus_field_module->tem_restart_module tem_stencil_module tem_stencil_module module~mus_field_module->tem_stencil_module tem_stringKeyValuePair_module tem_stringKeyValuePair_module module~mus_field_module->tem_stringKeyValuePair_module tem_temporal_module tem_temporal_module module~mus_field_module->tem_temporal_module tem_time_module tem_time_module module~mus_field_module->tem_time_module tem_tools_module tem_tools_module module~mus_field_module->tem_tools_module tem_varMap_module tem_varMap_module module~mus_field_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_field_module->tem_varSys_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_field_module~~UsedByGraph module~mus_field_module mus_field_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_source_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_source_module->module~mus_field_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface mus_fields_out Interface for dumping a single field or a set of fields in a file in lua\nformat. private  subroutine mus_fields_out_vec (me, conf, schemeHeader) write array of fields into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me (:) array of field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme private  subroutine mus_field_out_scal (me, conf, schemeHeader, level) write single field into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in), optional :: level To dump field with or without key Derived Types type, public :: mus_field_type This type contains all information on fields with ic and bc\nExample fields: fluid, species etc.\nEach field contains one initial condition and array of\nboundary conditions Components Type Visibility Attributes Name Initial character(len=labelLen), public :: label field label. Should be unique for each field type( mus_field_prop_type ), public :: fieldProp physics parameters (fluid and species) for field type(boundary_type), public, allocatable :: bc (:) array of field boundary types for each field\nsize: #BCs in the boundary_condition table\nallocated in mus_load_bc type( tem_ini_condition_type ), public :: ic initialization case, one initial condition for each field type( mus_source_type ), public :: source field source applied only to current field type( mus_source_type ), public :: internalSource field internal source applied only to current field\nnot needed input from musubi.lua\nused only for HRR correction at the moment type( tem_restart_type ), public :: restart An instance of restart type Functions public pure function mus_check_allWall (nFields, fields, iBC) result(allWall) Check if a BC is wall or symmetry for all fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: nFields type( mus_field_type ), intent(in) :: fields (nFields) integer, intent(in) :: iBC Return Value logical Subroutines public  subroutine mus_load_fields (me, varSys, nFields, mixture, nernstPlanck, bc_prop, conf, parent, minLevel, maxLevel, schemeHeader, poss_srcVar, physics, scaling, layout, isMusHvs) Subroutine to load the field table from the lua configuration file. Read more… Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me (:) array of field type type( tem_varSys_type ), intent(inout) :: varSys Global variable system required to append annoymous source and\nboundary variables integer, intent(in) :: nFields type( mus_mixture_type ), intent(out) :: mixture contains mixture information type( mus_nernstPlanck_type ), intent(out) :: nernstPlanck contains solvent information type( tem_BC_prop_type ), intent(in) :: bc_prop boundary data from mesh type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined integer, intent(in) :: minLevel global pdf info integer, intent(in) :: maxLevel global pdf info type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa character(len=labelLen), intent(in) :: scaling scaling type type( mus_scheme_layout_type ), intent(in) :: layout fluid stencil info logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False public  subroutine mus_load_fieldBaseInfos (me, nFields, parent, conf) This routine returns nFields and field labels from config file.\nIt is required to initialize variable system.\nlabels are loaded only if field table is present else default\nis set to empty string. Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(out), allocatable :: me (:) array of field type integer, intent(out) :: nFields number of fields defined in lua file integer, intent(in), optional :: parent parent handle if scheme table is defined type( flu_State ), intent(inout) :: conf flu state public  subroutine setParameters_multispecies (field, nFields, mixture, header, layout, iLevel, tNow) Set parameters for multispecies Read more… Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: field (nFields) integer, intent(in) :: nFields type( mus_mixture_type ), intent(inout) :: mixture type( mus_scheme_header_type ), intent(in) :: header type( mus_scheme_layout_type ), intent(in) :: layout integer, intent(in) :: iLevel type( tem_time_type ), intent(in) :: tNow solver general info public  subroutine remove_solid_in_bc (minLevel, maxLevel, nBCs, nFields, levelPointer, levelDesc, globBC, fields) First check count number of valid elements (non-solid) in each BC.\nThen rearrange BC elements list so it contains only valid elements.\nUpdate fields%bc%elemLvl%stencilPos fields%bc%elemLvl%posInNghElems\naccordingly. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel integer, intent(in) :: nBCs integer, intent(in) :: nFields integer, intent(in) :: levelPointer (:) Level pointer type( tem_levelDesc_type ), intent(in) :: levelDesc (minLevel:maxLevel) Level Descriptor type(glob_boundary_type) :: globBC (nBCs) type( mus_field_type ) :: fields (nFields) public  subroutine mus_field_getSymmetricBCs (symmetricBCs, nSymBCs, nBCs, nFields, field) This routine checks for the existence of symmetric boundaries and\nreturns the boundary IDs which are defined as symmetry Arguments Type Intent Optional Attributes Name integer, intent(out) :: symmetricBCs (nBCs) Symmetric boundary ids integer, intent(out) :: nSymBCs Number of symmetric boundary conditions integer, intent(in) :: nBCs number of boundary conditions integer, intent(in) :: nFields number of fields type( mus_field_type ), intent(in) :: field (nFields) all fields to access their boundary definitions public  subroutine mus_field_cleanup (me, schemeHeader, minLevel, maxLevel, nBCs, nFields) This routines act as a destructor for field type.\nOnly allocatable arrays which are allocated in mus_construct routine\nare deallocated.\nKM: DO NOT DESTROY FIELD ARRAY AS IT CONTAINS ALL CONFIG INFO Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me (:) single field type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: minLevel minlevel integer, intent(in) :: maxLevel maxlevel integer, intent(in) :: nBCs Number of boundary conditions integer, intent(in) :: nFields Number of fields private  subroutine mus_load_field_single (me, varSys, nFields, bc_prop, conf, parent, minLevel, maxLevel, poss_srcVar, physics, schemeHeader, scaling, layout, isMusHvs) load a single field table\nIn includes:\n  load field property\n  load source variables\n  load boundary defination\n  load immersed boundary method\n  load initial condition defination and its property Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(inout) :: me field type type( tem_varSys_type ), intent(inout) :: varSys Global variable system required to append annoymous source and\nboundary variables integer, intent(in) :: nFields number of fields defined in lua file type( tem_BC_prop_type ), intent(in) :: bc_prop boundary data from mesh type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent handle if scheme table is defined integer, intent(in) :: minLevel global pdf info integer, intent(in) :: maxLevel global pdf info type( tem_possible_variable_type ), intent(in) :: poss_srcVar possible source variables type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme character(len=labelLen), intent(in) :: scaling scaling type type( mus_scheme_layout_type ), intent(in) :: layout fluid stencil info logical, intent(in), optional :: isMusHvs Logic to not to load tracking and variable table if this routine\nis called from mus_hvs_config_load.\nDefault is False private  subroutine mus_fields_out_vec (me, conf, schemeHeader) write array of fields into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me (:) array of field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme private  subroutine mus_field_out_scal (me, conf, schemeHeader, level) write single field into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in), optional :: level To dump field with or without key private  subroutine mus_set_ic_states (scheme_kind, ic_states, IC_nVars) Set ic states labels by scheme kind Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: scheme_kind character(len=labelLen), allocatable :: ic_states (:) integer, intent(out) :: IC_nVars Number of initial condition variables required to initialize state","tags":"","loc":"module/mus_field_module.html"},{"title":"mus_source_var_module – Musubi","text":"Module containing subroutines for building MUSUBI specific source\nvariables Uses env_module tem_varSys_module mpi mus_derVarPos_module tem_spacetime_fun_module tem_spacetime_var_module tem_stringKeyValuePair_module tem_time_module tem_varMap_module mus_source_type_module mus_physics_module mus_scheme_header_module tem_param_module tem_dyn_array_module module~~mus_source_var_module~~UsesGraph module~mus_source_var_module mus_source_var_module env_module env_module module~mus_source_var_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_source_var_module->module~mus_dervarpos_module module~mus_physics_module mus_physics_module module~mus_source_var_module->module~mus_physics_module module~mus_scheme_header_module mus_scheme_header_module module~mus_source_var_module->module~mus_scheme_header_module module~mus_source_type_module mus_source_type_module module~mus_source_var_module->module~mus_source_type_module mpi mpi module~mus_source_var_module->mpi tem_dyn_array_module tem_dyn_array_module module~mus_source_var_module->tem_dyn_array_module tem_param_module tem_param_module module~mus_source_var_module->tem_param_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_source_var_module->tem_spacetime_fun_module tem_spacetime_var_module tem_spacetime_var_module module~mus_source_var_module->tem_spacetime_var_module tem_stringKeyValuePair_module tem_stringKeyValuePair_module module~mus_source_var_module->tem_stringKeyValuePair_module tem_time_module tem_time_module module~mus_source_var_module->tem_time_module tem_varMap_module tem_varMap_module module~mus_source_var_module->tem_varMap_module tem_varSys_module tem_varSys_module module~mus_source_var_module->tem_varSys_module module~mus_dervarpos_module->env_module module~mus_dervarpos_module->tem_varSys_module module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_dervarpos_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_dervarpos_module->module~mus_scheme_layout_module tem_aux_module tem_aux_module module~mus_dervarpos_module->tem_aux_module tem_stencil_module tem_stencil_module module~mus_dervarpos_module->tem_stencil_module module~mus_physics_module->env_module aot_out_module aot_out_module module~mus_physics_module->aot_out_module aot_table_module aot_table_module module~mus_physics_module->aot_table_module aotus_module aotus_module module~mus_physics_module->aotus_module module~mus_physics_module->tem_aux_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module tem_logging_module tem_logging_module module~mus_physics_module->tem_logging_module tem_tools_module tem_tools_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->aot_out_module module~mus_scheme_header_module->aot_table_module module~mus_scheme_header_module->aotus_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module module~mus_scheme_header_module->tem_tools_module module~mus_source_type_module->env_module module~mus_source_type_module->module~mus_dervarpos_module module~mus_source_type_module->module~mus_physics_module module~mus_source_type_module->module~mus_scheme_header_module module~mus_source_type_module->tem_stringKeyValuePair_module module~mus_source_type_module->tem_time_module module~mus_source_type_module->tem_varMap_module module~mus_source_type_module->tem_varSys_module module~mus_source_type_module->aot_table_module module~mus_source_type_module->aotus_module module~mus_absorblayer_module mus_absorbLayer_module module~mus_source_type_module->module~mus_absorblayer_module module~mus_source_type_module->tem_aux_module module~mus_source_type_module->tem_logging_module tem_shape_module tem_shape_module module~mus_source_type_module->tem_shape_module module~mus_source_type_module->tem_stencil_module tem_subTree_type_module tem_subTree_type_module module~mus_source_type_module->tem_subTree_type_module module~mus_source_type_module->tem_tools_module module~mus_source_type_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_source_var_module~~UsedByGraph module~mus_source_var_module mus_source_var_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_source_var_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_source_var_module module~mus_variable_module->module~mus_field_module module~mus_bc_var_module mus_bc_var_module module~mus_variable_module->module~mus_bc_var_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_field_module module~mus_bc_var_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_source_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_source_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_updateSrcVar_dynSponFld (fun, auxField, iLevel, varSys, phyConvFac, derVarPos) Compute density and velocity in sponge layer for dynamic sponge Arguments Type Intent Optional Attributes Name class( mus_source_op_type ), intent(inout) :: fun Description of method to update source real(kind=rk), intent(in) :: auxField (:) input auxField array on current level integer, intent(in) :: iLevel current level type( tem_varSys_type ), intent(in) :: varSys variable system definition type( mus_convertFac_type ), intent(in) :: phyConvFac Physics conversion factor on current level type( mus_derVarPos_type ), intent(in) :: derVarPos (:) position of derived quantities in varsys public  subroutine mus_add_internal_source_var (me, possVars, varSys, schemeHeader) Routine load musubi source terms for given key.\nkey is glob_source or source Arguments Type Intent Optional Attributes Name type( mus_source_type ), intent(out) :: me Source variable type to initialize type( tem_possible_variable_type ), intent(in) :: possVars possible source variables type( tem_varSys_type ), intent(inout) :: varSys Global variable system type( mus_scheme_header_type ), intent(in) :: schemeHeader Identifier of the scheme","tags":"","loc":"module/mus_source_var_module.html"},{"title":"mus_scheme_derived_quantities_module – Musubi","text":"This module contains data types, function and routines for gradient\ncomputation. author: Gregorio Gerardo Spinelli Uses env_module tem_aux_module tem_compileconf_module tem_logging_module tem_param_module module~~mus_scheme_derived_quantities_module~~UsesGraph module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module env_module env_module module~mus_scheme_derived_quantities_module->env_module tem_aux_module tem_aux_module module~mus_scheme_derived_quantities_module->tem_aux_module tem_compileconf_module tem_compileconf_module module~mus_scheme_derived_quantities_module->tem_compileconf_module tem_logging_module tem_logging_module module~mus_scheme_derived_quantities_module->tem_logging_module tem_param_module tem_param_module module~mus_scheme_derived_quantities_module->tem_param_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_scheme_derived_quantities_module~~UsedByGraph module~mus_scheme_derived_quantities_module mus_scheme_derived_quantities_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_scheme_derived_quantities_module module~mus_dervarpos_module mus_derVarPos_module module~mus_auxfield_module->module~mus_dervarpos_module module~mus_dervarpos_module->module~mus_scheme_derived_quantities_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_dervarpos_module->module~mus_scheme_layout_module module~mus_scheme_layout_module->module~mus_scheme_derived_quantities_module module~mus_scheme_module mus_scheme_module module~mus_scheme_module->module~mus_scheme_derived_quantities_module module~mus_scheme_module->module~mus_scheme_layout_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_dervarpos_module module~mus_bc_nernstplanck_module->module~mus_scheme_layout_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_dervarpos_module module~mus_bc_poisson_module->module~mus_scheme_layout_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_dervarpos_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_layout_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_scheme_layout_module module~mus_hrrinit_module mus_hrrInit_module module~mus_hrrinit_module->module~mus_scheme_layout_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_layout_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_dervarpos_module module~mus_interpolate_header_module->module~mus_scheme_layout_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_relaxationparam_module->module~mus_dervarpos_module module~mus_relaxationparam_module->module~mus_scheme_layout_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_scheme_type_module->module~mus_dervarpos_module module~mus_scheme_type_module->module~mus_scheme_layout_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_dervarpos_module module~mus_source_type_module mus_source_type_module module~mus_source_type_module->module~mus_dervarpos_module module~mus_source_var_module mus_source_var_module module~mus_source_var_module->module~mus_dervarpos_module module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_source_var_turbchanforce_module->module~mus_dervarpos_module module~mus_tools_module mus_tools_module module~mus_tools_module->module~mus_scheme_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_turb_viscosity_module->module~mus_scheme_layout_module module~mus_turbulence_module mus_turbulence_module module~mus_turbulence_module->module~mus_scheme_layout_module module~mus_variable_module mus_variable_module module~mus_variable_module->module~mus_dervarpos_module module~mus_variable_module->module~mus_scheme_layout_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private pure function get_pdfEq(rho, vel, QQ, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the stencil real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) abstract interface private pure function get_pdfEq_iDir(rho, vel, iDir, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk) abstract interface private pure function get_vel_from_pdf(pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity abstract interface private pure function get_vel_from_pdf_vectorized(pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density VECTORIZED Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity abstract interface private pure function get_vector_from_vel_dens(vel, dens) result(vector) function pointer to get pdf equilibrium from vel and density Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk), (3) momentum abstract interface private pure function get_scalar_from_vel_dens(vel, dens) result(scalar) function pointer to get pdf equilibrium from vel and density Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) momentum abstract interface private pure function get_rho0Inv(dens) result(inv_rho0) function pointer to get 1/rho as a mask regardless incompressibility Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) inverse of density regardless compressibility Derived Types type, public :: mus_scheme_derived_quantities_type collection of properties of the scheme derived quantities type Components Type Visibility Attributes Name Initial procedure( get_pdfEq ), public, nopass, pointer :: pdfEq_ptr => null() function pointer to get pdf equilibrium from vel and density procedure( get_pdfEq_iDir ), public, nopass, pointer :: pdfEq_iDir_ptr => null() function pointer to get pdf equilibrium in a specific direction procedure( get_vel_from_pdf ), public, nopass, pointer :: vel_from_pdf_ptr => null() function pointer to get velocities from pdf procedure( get_vel_from_pdf_vectorized ), public, nopass, pointer :: vel_from_pdf_vectorized_ptr => null() function pointer to get velocities from pdf VECTORIZED procedure( get_vector_from_vel_dens ), public, nopass, pointer :: momentum_from_vel_dens_ptr => null() function pointer to get momentum procedure( get_scalar_from_vel_dens ), public, nopass, pointer :: kineticEnergy_from_vel_dens_ptr => null() function pointer to get kinetic energy procedure( get_rho0Inv ), public, nopass, pointer :: rho0Inv_ptr => null() function pointer to get 1/rho as a mask regardless incompressibility Functions public  function mus_assign_derived_functions_ptr (label_stencil, label_fluid) result(getQuantities) This function assigns the pointers for the respective derived function in Arguments Type Intent Optional Attributes Name character(len=labelLen), intent(in) :: label_stencil Scheme header information character(len=labelLen), intent(in) :: label_fluid Fluid label information Return Value type( mus_scheme_derived_quantities_type ) getQuantities function private pure function get_pdfEq_incompressible_iDir (rho, vel, iDir, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk) private pure function get_pdfEq_compressible_iDir (rho, vel, iDir, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: iDir direction of the pdf real(kind=rk), intent(in) :: cxDirRK (3) velocity streaming normal along iDir real(kind=rk), intent(in) :: weight weight along iDir Return Value real(kind=rk) private pure function get_pdfEq_incompressible (rho, vel, QQ, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_pdfEq_compressible (rho, vel, QQ, cxDirRK, weight) result(fEq) function pointer to get pdf equilibrium from vel and density along a Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_sigma_d2q9 (vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (9) private pure function get_pdfEq_d2q9 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_pdfEq_incomp_d2q9 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_sigma_d3q19 (vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (22) private pure function get_pdfEq_d3q19 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_pdfEq_incomp_d3q19 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_sigma_d3q27 (vel) result(sigma) This function computes the sigma vector necessary to get the Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (3) velocity Return Value real(kind=rk), (34) private pure function get_pdfEq_d3q27 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_pdfEq_incomp_d3q27 (rho, vel, QQ, cxDirRK, weight) result(fEq) This function computes the incompressible equilibrium pdf from velocity Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: rho density real(kind=rk), intent(in) :: vel (3) velocity integer, intent(in) :: QQ size of the pdf real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir real(kind=rk), intent(in), optional :: weight (:) weight along iDir Return Value real(kind=rk), (QQ) private pure function get_vel_from_pdf_compressible (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_compressible_vectorized (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_incompressible (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_incompressible_vectorized (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d2q9 (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d2q9 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d2q9_vectorized (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d2q9_incompressible (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d2q9 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d2q9_vectorized_incompressible (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d3q19 (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q19 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d3q19_vectorized (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d3q19_incompressible (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q19 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d3q19_vectorized_incompressible (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d3q27 (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q27 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d3q27_vectorized (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_vel_from_pdf_d3q27_incompressible (pdf, dens, cxDirRK) result(vel) function pointer to get pdf equilibrium from vel and density for d3q27 stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:) pdf real(kind=rk), intent(in) :: dens density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir Return Value real(kind=rk), (3) velocity private pure function get_vel_from_pdf_d3q27_vectorized_incompressible (pdf, dens, cxDirRK, nSolve) result(vel) function pointer to get pdf equilibrium from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: pdf (:,:) pdf real(kind=rk), intent(in) :: dens (:) density real(kind=rk), intent(in), optional :: cxDirRK (:,:) velocity streaming normal along iDir integer, intent(in) :: nSolve number of element to compute Return Value real(kind=rk), (3,vlen) velocity private pure function get_momentum_from_vel_dens_compressible (vel, dens) result(vector) function pointer to get momentum from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk), (3) momentum private pure function get_momentum_from_vel_dens_incompressible (vel, dens) result(vector) function pointer to get momentum from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk), (3) momentum private pure function get_kineticEnergy_from_vel_dens_compressible (vel, dens) result(scalar) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy private pure function get_kineticEnergy_from_vel_dens_incompressible (vel, dens) result(scalar) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: vel (:) velocity real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy private pure function get_rho0Inv_compressible (dens) result(inv_rho0) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy private pure function get_rho0Inv_incompressible (dens) result(inv_rho0) function pointer to get kineticEnergy from vel and density for any stencil Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: dens density Return Value real(kind=rk) kineticEnergy","tags":"","loc":"module/mus_scheme_derived_quantities_module.html"},{"title":"mus_abortCriteria_module – Musubi","text":"Musubi specific criteria to abort the simulation. This module provies the mus_abortCriteria_type that holds parameters for\n simulation aborts.\n The configuration parameters are read from the abort_criteria table in sim_control , see also tem_simControl_module . Additional parameters for Musubi in the abort_criteria table: velocity_lat_max: The maximal lattice velocity that may appear in the\n                     domain. Defaults to 0.15.\n                     Lattice velocities larger than 0.1 are considered to\n                     produce large errors. A simple complete example for the Musubi abort_criteria table within the sim_control table is: abort_criteria = { stop_file = 'stop' , velocity_lat_max = 0.15 -- Maximum lattice velocity for Musubi } Uses env_module tem_abortCriteria_module aotus_module module~~mus_abortcriteria_module~~UsesGraph module~mus_abortcriteria_module mus_abortCriteria_module aotus_module aotus_module module~mus_abortcriteria_module->aotus_module env_module env_module module~mus_abortcriteria_module->env_module tem_abortCriteria_module tem_abortCriteria_module module~mus_abortcriteria_module->tem_abortCriteria_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_abortcriteria_module~~UsedByGraph module~mus_abortcriteria_module mus_abortCriteria_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_abortcriteria_module module~mus_param_module mus_param_module module~mus_aux_module->module~mus_param_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_geom_module mus_geom_module module~mus_aux_module->module~mus_geom_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_param_module->module~mus_abortcriteria_module module~mus_tools_module->module~mus_abortcriteria_module module~mus_tools_module->module~mus_param_module module~mus_scheme_module mus_scheme_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_param_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_param_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_param_module module~mus_config_module->module~mus_tools_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_geom_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_param_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_geom_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_param_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_dynloadbal_module->module~mus_geom_module module~mus_geomincrhead_module mus_geomIncrHead_module module~mus_geomincrhead_module->module~mus_param_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_param_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_aux_module->module~mus_geom_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_param_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_geomincrhead_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_geom_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_param_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_hvs_construction_module->module~mus_geom_module module~mus_scheme_module->module~mus_param_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_geom_module module~mus_scheme_type_module->module~mus_param_module module~mus_tracking_module->module~mus_param_module module~mus_tracking_module->module~mus_tools_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_geom_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_param_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_geom_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_param_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_geom_module module~mus_geom_module->module~mus_geomincrhead_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module->module~mus_geom_module module~mus_restart_module->module~mus_scheme_type_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( tem_solverAborts_type ) :: mus_abortCriteria_type Musubi specific abort criteria. Components Type Visibility Attributes Name Initial real(kind=rk), public :: velLat_max = 0.15_rk Maximal lattice velocity that will be tolerated in the simulation.\nThe lattice velocity should usually be smaller than 0.1. Type-Bound Procedures procedure, public :: load => mus_abortCriteria_load Subroutines private  subroutine mus_abortCriteria_load (me, conf, abort_table) Loading Musubi specific abort criteria from the abort_criteria table. Read more… Arguments Type Intent Optional Attributes Name class( mus_abortCriteria_type ), intent(inout) :: me Object to hold the solver specific configuration parameters. type( flu_State ), intent(in) :: conf Handle to the Lua script with the configuration. integer, intent(in) :: abort_table Handle to the opened abort_criteria table that holds the\nabort parameters to load.","tags":"","loc":"module/mus_abortcriteria_module.html"},{"title":"mus_bc_poisson_module – Musubi","text":"Boundary condition treatment routines for Poisson equation A detailed description on the implementation details are given in\nboundary_implementation Uses env_module mus_field_prop_module tem_varSys_module mus_mixture_module mus_derVarPos_module mus_scheme_layout_module treelmesh_module tem_time_module mus_param_module mus_physics_module tem_construction_module mus_bc_header_module tem_debug_module module~~mus_bc_poisson_module~~UsesGraph module~mus_bc_poisson_module mus_bc_poisson_module env_module env_module module~mus_bc_poisson_module->env_module module~mus_dervarpos_module mus_derVarPos_module module~mus_bc_poisson_module->module~mus_dervarpos_module module~mus_field_prop_module mus_field_prop_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_mixture_module mus_mixture_module module~mus_bc_poisson_module->module~mus_mixture_module module~mus_param_module mus_param_module module~mus_bc_poisson_module->module~mus_param_module module~mus_physics_module mus_physics_module module~mus_bc_poisson_module->module~mus_physics_module module~mus_scheme_layout_module mus_scheme_layout_module module~mus_bc_poisson_module->module~mus_scheme_layout_module mus_bc_header_module mus_bc_header_module module~mus_bc_poisson_module->mus_bc_header_module tem_construction_module tem_construction_module module~mus_bc_poisson_module->tem_construction_module tem_debug_module tem_debug_module module~mus_bc_poisson_module->tem_debug_module tem_time_module tem_time_module module~mus_bc_poisson_module->tem_time_module tem_varSys_module tem_varSys_module module~mus_bc_poisson_module->tem_varSys_module treelmesh_module treelmesh_module module~mus_bc_poisson_module->treelmesh_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine potential_nonEqExpol (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise Dirichlet potential non-equilibrium boundary condition for curved\n and straight walls. For straight wall, physical boundary overlaps with\n boundary node i.e. qVal=0.0. Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine potential_nonEqExpol_curved (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise Dirichlet potential non-equilibrium boundary condition for curved\n wall Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine potential_neumann (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) Linkwise neumann potential non-equilibrium boundary condition for curved\n and straight walls (zero gradient).\n For straight wall, values are extrapolated along\n boundary normal instead of along the link. The accuracy of straight wall\n depends on the qVal defined in config file and default is set to 0.5 Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info public  subroutine potential_neumann_curved (me, state, bcBuffer, globBC, levelDesc, tree, nSize, iLevel, sim_time, neigh, layout, fieldProp, varPos, nScalars, varSys, derVarPos, physics, iField, mixture) No comment yet! Read more… Arguments Type Intent Optional Attributes Name class(boundary_type) :: me global boundary type real(kind=rk), intent(inout) :: state (:) Current state vector of iLevel real(kind=rk), intent(in) :: bcBuffer (:) state values of boundary elements of all fields of iLevel type(glob_boundary_type), intent(in) :: globBC scheme global boundary type type( tem_levelDesc_type ), intent(in) :: levelDesc iLevel descriptor type( treelmesh_type ), intent(in) :: tree Treelm Mesh integer, intent(in) :: nSize size of state array ( in terms of elements ) integer, intent(in) :: iLevel the level On which this boundary was invoked type( tem_time_type ), intent(in) :: sim_time global time information integer, intent(in) :: neigh (:) connectivity array corresponding to state vector type( mus_scheme_layout_type ), intent(in) :: layout stencil layout information type( mus_field_prop_type ), intent(in) :: fieldProp fluid parameters and properties integer, intent(in) :: varPos (:) pointer to field variable in the state vector integer, intent(in) :: nScalars number of Scalars in the scheme var system type( tem_varSys_type ), intent(in) :: varSys scheme variable system type( mus_derVarPos_type ), intent(in) :: derVarPos position of derived quantities in varsys type( mus_physics_type ), intent(in) :: physics scheme global boundary type integer, intent(in) :: iField current field type( mus_mixture_type ), intent(in) :: mixture mixture info","tags":"","loc":"module/mus_bc_poisson_module.html"},{"title":"mus_absorbLayer_module – Musubi","text":"Module containing subroutines for building MUSUBI specific absorbLayer source\nvariables Make target_pressure and target_velocity as stFun. Uses env_module tem_aux_module aotus_module tem_logging_module aot_table_module tem_tools_module module~~mus_absorblayer_module~~UsesGraph module~mus_absorblayer_module mus_absorbLayer_module aot_table_module aot_table_module module~mus_absorblayer_module->aot_table_module aotus_module aotus_module module~mus_absorblayer_module->aotus_module env_module env_module module~mus_absorblayer_module->env_module tem_aux_module tem_aux_module module~mus_absorblayer_module->tem_aux_module tem_logging_module tem_logging_module module~mus_absorblayer_module->tem_logging_module tem_tools_module tem_tools_module module~mus_absorblayer_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_absorblayer_module~~UsedByGraph module~mus_absorblayer_module mus_absorbLayer_module module~mus_source_module mus_source_module module~mus_source_module->module~mus_absorblayer_module module~mus_source_type_module mus_source_type_module module~mus_source_module->module~mus_source_type_module module~mus_field_module mus_field_module module~mus_source_module->module~mus_field_module module~mus_source_type_module->module~mus_absorblayer_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_source_module module~mus_aux_module->module~mus_field_module module~mus_scheme_type_module mus_scheme_type_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module mus_auxField_module module~mus_auxfield_module->module~mus_source_type_module module~mus_auxfield_module->module~mus_field_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_source_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_scheme_module mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_field_module->module~mus_source_type_module module~mus_source_var_module mus_source_var_module module~mus_field_module->module~mus_source_var_module module~mus_scheme_module->module~mus_source_type_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_scheme_type_module->module~mus_source_type_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_scheme_type_module->module~mus_field_module module~mus_source_var_module->module~mus_source_type_module module~mus_source_var_turbchanforce_module mus_source_var_turbChanForce_module module~mus_source_var_turbchanforce_module->module~mus_source_type_module module~mus_variable_module->module~mus_source_type_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_source_var_module module~mus_variable_module->module~mus_source_var_turbchanforce_module module~mus_bc_var_module mus_bc_var_module module~mus_variable_module->module~mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_scheme_type_module module~mus_config_module->module~mus_tools_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_module program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module program~musubi->module~mus_scheme_type_module program~musubi->module~mus_config_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_absorbLayer_dynAvg_type Stores time average values of density and velocity for dynamic absorbLayer Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: dens (:) density time average in lattice unit real(kind=rk), public, allocatable :: velX (:) velocity time average in lattice unit real(kind=rk), public, allocatable :: velY (:) real(kind=rk), public, allocatable :: velZ (:) logical, public :: isInitDens = .true. It is used to initialiye dynamic average density with initial condition logical, public :: isInitVel = .true. It is used to initialiye dynamic average velocity with initial condition type, public :: mus_absorbLayer_type Contains information for absorblayer Components Type Visibility Attributes Name Initial type( absorbLayer_config_type ), public :: config Information loaded from configuration file real(kind=rk), public :: smoothFac Smoothing factor for expoential moving average\n= 2 / (nRecord+1) type, private :: absorbLayer_config_type Contains additional information for absorblayer source Components Type Visibility Attributes Name Initial real(kind=rk), public :: target_pressure target pressure real(kind=rk), public :: target_velocity (3) target velocityX, velocityY and velocityZ logical, public :: isPressDyn = .false. Use time average for pressure. Default: false. logical, public :: isVelDyn = .false. Use time average for Velocity. Default: false. integer, public :: nRecord = 100 Number of iterations to record for time-averaging Subroutines public  subroutine mus_load_absorbLayer (me, conf, key, parent, loadPres, loadVel) This routine load additional information for absorblayer Arguments Type Intent Optional Attributes Name type( absorbLayer_config_type ), intent(out) :: me Absorb layer type( flu_State ) :: conf flu state character(len=*), intent(in) :: key Table name to load target states integer, intent(in) :: parent parent source handle logical, intent(in) :: loadPres Load pressure if true else set to dynamic logical, intent(in) :: loadVel Load velocity if true else set to dynamic public  subroutine mus_init_absorbLayer (absLayer, dynAvg, nElems) Initialize arrays to store time average density and velocity for\ndynamic absorbing layer.\n\\todo KM: 20210301 Allocate only pressure or velocity depending on\nabsorb_layer_inlet or absorb_layer_outlet Arguments Type Intent Optional Attributes Name type( mus_absorbLayer_type ), intent(inout) :: absLayer Absorblayer type type( mus_absorbLayer_dynAvg_type ), intent(inout) :: dynAvg Contains dynamic average density and velocity for absorblayer integer, intent(in) :: nElems Number of source elements","tags":"","loc":"module/mus_absorblayer_module.html"},{"title":"mus_aux_module – Musubi","text":"Uses env_module mus_tools_module tem_global_module mus_scheme_type_module mus_transport_var_module mus_geom_module mus_IBM_module mus_ppInfo_module mus_bndForce_module mus_relaxationParam_module tem_simControl_module tem_dyn_array_module tem_convergence_module tem_timeControl_module mus_field_module mus_fluid_module mus_timer_module tem_tracking_module tem_time_module tem_operation_var_module tem_general_module mus_param_module tem_solveHead_module tem_tools_module mus_tracking_module mus_geomIncr_module tem_spacetime_fun_module treelmesh_module mus_interpolate_tools_module mus_restart_module tem_logging_module mus_interpolate_module tem_debug_module tem_restart_module mus_abortCriteria_module mus_time_module tem_aux_module mus_turbulence_module tem_depend_module tem_timer_module mus_physics_module mus_gradData_module mus_source_module env_module w mus_aux_module w mus_abortCriteria_module w w mus_bndForce_module w w mus_field_module w w mus_fluid_module w w mus_geom_module w w mus_geomIncr_module w w mus_gradData_module w w mus_IBM_module w w mus_interpolate_module w w mus_interpolate_tools_module w w mus_param_module w w mus_physics_module w w mus_ppInfo_module w w mus_relaxationParam_module w w mus_restart_module w w mus_scheme_type_module w w mus_source_module w w mus_time_module w w mus_timer_module w w mus_tools_module w w mus_tracking_module w w mus_transport_var_module w w mus_turbulence_module w w tem_aux_module w w tem_convergence_module w w tem_debug_module w w tem_depend_module w w tem_dyn_array_module w w tem_general_module w w tem_global_module w w tem_logging_module w w tem_operation_var_module w w tem_restart_module w w tem_simControl_module w w tem_solveHead_module w w tem_spacetime_fun_module w w tem_time_module w w tem_timeControl_module w w tem_timer_module w w tem_tools_module w w tem_tracking_module w w treelmesh_module w w Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_aux_module~~UsedByGraph module~mus_aux_module mus_aux_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine check_flow_status (scheme, geometry, general, physics, mus_aborts, restart_triggered) This routine performs several tasks: geometry increment, time updating,\ntracking, density checking, restart Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( tem_general_type ), intent(inout) :: general Global parameters type( mus_physics_type ), intent(in) :: physics physics conversion tyoe type( mus_abortCriteria_type ), intent(in) :: mus_aborts logical, intent(inout) :: restart_triggered Indication whether a restart output was triggered public  subroutine mus_banner (solver) Initialize musubi solverHead and print musubi banner to screen Arguments Type Intent Optional Attributes Name type( tem_solveHead_type ), intent(in) :: solver solver definition public  subroutine mus_init_aux (scheme, geometry, params) Init auxiliary features such as interpolation boundaries, restart and\nthe tracker Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme containers for the different schemes type( mus_geom_type ), intent(inout) :: geometry geometry information type( mus_param_type ), intent(inout) :: params global parameters public  subroutine mus_update_relaxParams (scheme, iLevel, tNow, physics, lattice, nBCs) Set relaxation parameters for MRT Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type integer, intent(in) :: iLevel level type( tem_time_type ), intent(in) :: tNow global parameters type( mus_physics_type ), intent(in) :: physics contains factors to convert physical to lattice unit and vice versa type( mus_latticeUnit_type ), intent(in) :: lattice contains lattice dx and dt integer, intent(in) :: nBCs Number of boundaries public  subroutine mus_dumpData (scheme, tree, levelPointer, general, restart_triggered) This routine dumps tracking and restart when timeControl is active Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout) :: scheme scheme type type( treelmesh_type ), intent(in) :: tree Treelmesh data integer, intent(in) :: levelPointer (:) Level Pointer type( tem_general_type ), intent(inout) :: general Global parameters logical, intent(inout) :: restart_triggered","tags":"","loc":"module/mus_aux_module.html"},{"title":"mus_field_prop_module – Musubi","text":"This module contains mus_field_prop_type and modules related\nto fiels properties. \\author Kannan Masilamani, Simon Zimny Uses env_module mus_poisson_module tem_aux_module mus_fluid_module flu_binding aot_out_module tem_logging_module mus_scheme_header_module mus_physics_module mus_species_module module~~mus_field_prop_module~~UsesGraph module~mus_field_prop_module mus_field_prop_module aot_out_module aot_out_module module~mus_field_prop_module->aot_out_module env_module env_module module~mus_field_prop_module->env_module flu_binding flu_binding module~mus_field_prop_module->flu_binding module~mus_fluid_module mus_fluid_module module~mus_field_prop_module->module~mus_fluid_module module~mus_physics_module mus_physics_module module~mus_field_prop_module->module~mus_physics_module module~mus_poisson_module mus_poisson_module module~mus_field_prop_module->module~mus_poisson_module module~mus_scheme_header_module mus_scheme_header_module module~mus_field_prop_module->module~mus_scheme_header_module module~mus_species_module mus_species_module module~mus_field_prop_module->module~mus_species_module tem_aux_module tem_aux_module module~mus_field_prop_module->tem_aux_module tem_logging_module tem_logging_module module~mus_field_prop_module->tem_logging_module module~mus_fluid_module->aot_out_module module~mus_fluid_module->env_module module~mus_fluid_module->module~mus_physics_module module~mus_fluid_module->module~mus_scheme_header_module module~mus_fluid_module->tem_aux_module module~mus_fluid_module->tem_logging_module aot_table_module aot_table_module module~mus_fluid_module->aot_table_module aotus_module aotus_module module~mus_fluid_module->aotus_module module~mus_cumulantinit_module mus_cumulantInit_module module~mus_fluid_module->module~mus_cumulantinit_module module~mus_pdf_module mus_pdf_module module~mus_fluid_module->module~mus_pdf_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_fluid_module->module~mus_relaxationparam_module module~mus_turb_viscosity_module mus_turb_viscosity_module module~mus_fluid_module->module~mus_turb_viscosity_module module~mus_turbulence_module mus_turbulence_module module~mus_fluid_module->module~mus_turbulence_module mpi mpi module~mus_fluid_module->mpi mus_mrtRelaxation_module mus_mrtRelaxation_module module~mus_fluid_module->mus_mrtRelaxation_module mus_nonNewtonian_module mus_nonNewtonian_module module~mus_fluid_module->mus_nonNewtonian_module tem_construction_module tem_construction_module module~mus_fluid_module->tem_construction_module tem_general_module tem_general_module module~mus_fluid_module->tem_general_module tem_grow_array_module tem_grow_array_module module~mus_fluid_module->tem_grow_array_module tem_param_module tem_param_module module~mus_fluid_module->tem_param_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_fluid_module->tem_spacetime_fun_module tem_stencil_module tem_stencil_module module~mus_fluid_module->tem_stencil_module tem_time_module tem_time_module module~mus_fluid_module->tem_time_module tem_tools_module tem_tools_module module~mus_fluid_module->tem_tools_module module~mus_physics_module->aot_out_module module~mus_physics_module->env_module module~mus_physics_module->tem_aux_module module~mus_physics_module->tem_logging_module module~mus_physics_module->aot_table_module module~mus_physics_module->aotus_module tem_geometry_module tem_geometry_module module~mus_physics_module->tem_geometry_module module~mus_physics_module->tem_tools_module treelmesh_module treelmesh_module module~mus_physics_module->treelmesh_module module~mus_poisson_module->aot_out_module module~mus_poisson_module->env_module module~mus_poisson_module->module~mus_physics_module module~mus_poisson_module->tem_aux_module module~mus_poisson_module->tem_logging_module module~mus_poisson_module->aot_table_module module~mus_poisson_module->aotus_module module~mus_scheme_header_module->aot_out_module module~mus_scheme_header_module->env_module module~mus_scheme_header_module->tem_aux_module module~mus_scheme_header_module->tem_logging_module module~mus_scheme_header_module->aot_table_module module~mus_scheme_header_module->aotus_module module~mus_scheme_header_module->tem_tools_module module~mus_species_module->aot_out_module module~mus_species_module->env_module module~mus_species_module->module~mus_physics_module module~mus_species_module->tem_aux_module module~mus_species_module->tem_logging_module module~mus_species_module->aot_table_module module~mus_species_module->aotus_module module~mus_species_module->tem_param_module module~mus_species_module->tem_tools_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_field_prop_module~~UsedByGraph module~mus_field_prop_module mus_field_prop_module module~mus_bc_nernstplanck_module mus_bc_nernstPlanck_module module~mus_bc_nernstplanck_module->module~mus_field_prop_module module~mus_bc_poisson_module mus_bc_poisson_module module~mus_bc_poisson_module->module~mus_field_prop_module module~mus_field_module mus_field_module module~mus_field_module->module~mus_field_prop_module module~mus_interpolate_header_module mus_interpolate_header_module module~mus_interpolate_header_module->module~mus_field_prop_module module~mus_scheme_type_module mus_scheme_type_module module~mus_scheme_type_module->module~mus_field_prop_module module~mus_scheme_type_module->module~mus_field_module module~mus_scheme_type_module->module~mus_interpolate_header_module module~mus_auxfield_module mus_auxField_module module~mus_scheme_type_module->module~mus_auxfield_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_field_module module~mus_aux_module->module~mus_scheme_type_module module~mus_restart_module mus_restart_module module~mus_aux_module->module~mus_restart_module module~mus_source_module mus_source_module module~mus_aux_module->module~mus_source_module module~mus_tools_module mus_tools_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_auxfield_module->module~mus_field_module module~mus_auxfield_module->module~mus_interpolate_header_module module~mus_bc_var_module mus_bc_var_module module~mus_bc_var_module->module~mus_field_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_scheme_type_module module~mus_scheme_module mus_scheme_module module~mus_config_module->module~mus_scheme_module module~mus_config_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_field_module module~mus_control_module->module~mus_scheme_type_module module~mus_control_module->module~mus_aux_module module~mus_control_module->module~mus_auxfield_module module~mus_control_module->module~mus_source_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_scheme_type_module module~mus_dynloadbal_module->module~mus_auxfield_module module~mus_dynloadbal_module->module~mus_scheme_module module~mus_dynloadbal_module->module~mus_source_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_scheme_type_module module~mus_hvs_config_module->module~mus_config_module module~mus_hvs_config_module->module~mus_scheme_module module~mus_hvs_construction_module mus_hvs_construction_module module~mus_hvs_construction_module->module~mus_scheme_type_module module~mus_initfluid_module mus_initFluid_module module~mus_initfluid_module->module~mus_scheme_type_module module~mus_initfluidincomp_module mus_initFluidIncomp_module module~mus_initfluidincomp_module->module~mus_scheme_type_module module~mus_initisothermaceq_module mus_initIsothermAcEq_module module~mus_initisothermaceq_module->module~mus_scheme_type_module module~mus_initlbmps_module mus_initLBMPS_module module~mus_initlbmps_module->module~mus_scheme_type_module module~mus_initmultispecies_module mus_initMultispecies_module module~mus_initmultispecies_module->module~mus_scheme_type_module module~mus_initnernstplanck_module mus_initNernstPlanck_module module~mus_initnernstplanck_module->module~mus_scheme_type_module module~mus_initpoisson_module mus_initPoisson_module module~mus_initpoisson_module->module~mus_scheme_type_module module~mus_mesh_adaptation_module mus_mesh_adaptation_module module~mus_mesh_adaptation_module->module~mus_scheme_type_module module~mus_restart_module->module~mus_scheme_type_module module~mus_scheme_module->module~mus_field_module module~mus_scheme_module->module~mus_interpolate_header_module module~mus_scheme_module->module~mus_scheme_type_module module~mus_variable_module mus_variable_module module~mus_scheme_module->module~mus_variable_module module~mus_source_module->module~mus_field_module module~mus_tools_module->module~mus_scheme_type_module module~mus_tools_module->module~mus_scheme_module module~mus_tracking_module->module~mus_scheme_type_module module~mus_tracking_module->module~mus_tools_module module~mus_variable_module->module~mus_field_module module~mus_variable_module->module~mus_bc_var_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_scheme_type_module program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~mus_harvesting->module~mus_hvs_construction_module program~mus_harvesting->module~mus_restart_module program~mus_harvesting->module~mus_scheme_module program~musubi musubi program~musubi->module~mus_scheme_type_module program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: mus_field_prop_type This type contains parameter needed for field Components Type Visibility Attributes Name Initial type( mus_fluid_type ), public :: fluid contains fluid information type( mus_species_type ), public :: species contains species information type( mus_poisson_type ), public :: poisson Contains information for poisson equation Subroutines public  subroutine mus_load_field_prop (me, conf, parent, minLevel, schemeHeader, nFields, physics, cs_lattice) load fluid properties like fluid and species table from\nlua file based on the scheme kind Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(out) :: me field property type type( flu_State ), intent(inout) :: conf flu state integer, intent(in), optional :: parent parent lua handle integer, intent(in) :: minLevel type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme integer, intent(in) :: nFields number of fields defined in lua file type( mus_physics_type ), intent(in) :: physics physics type to convert physics to lattice unit or vice versa real(kind=rk), intent(in) :: cs_lattice lattice speed of sound calculated for defined stencil layout public  subroutine mus_field_prop_out (me, conf, schemeHeader) write field prop into a lua file Arguments Type Intent Optional Attributes Name type( mus_field_prop_type ), intent(in) :: me single field type type( aot_out_type ), intent(inout) :: conf aotus out type type( mus_scheme_header_type ), intent(in) :: schemeHeader identifier of the scheme","tags":"","loc":"module/mus_field_prop_module.html"},{"title":"mus_hvs_aux_module – Musubi","text":"Auxiliary functionality for musubi harvesting Uses tem_debug_module mus_time_module mus_tracking_module mus_tools_module tem_aux_module mus_scheme_type_module tem_spacetime_fun_module mus_fluid_module tem_tools_module mus_geom_module tem_tracking_module mus_interpolate_tools_module tem_logging_module mus_interpolate_module mus_param_module mus_gradData_module mus_bndForce_module tem_restart_module module~~mus_hvs_aux_module~~UsesGraph module~mus_hvs_aux_module mus_hvs_aux_module module~mus_fluid_module mus_fluid_module module~mus_hvs_aux_module->module~mus_fluid_module module~mus_geom_module mus_geom_module module~mus_hvs_aux_module->module~mus_geom_module module~mus_param_module mus_param_module module~mus_hvs_aux_module->module~mus_param_module module~mus_scheme_type_module mus_scheme_type_module module~mus_hvs_aux_module->module~mus_scheme_type_module module~mus_time_module mus_time_module module~mus_hvs_aux_module->module~mus_time_module module~mus_tools_module mus_tools_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_hvs_aux_module->module~mus_tracking_module mus_bndForce_module mus_bndForce_module module~mus_hvs_aux_module->mus_bndForce_module mus_gradData_module mus_gradData_module module~mus_hvs_aux_module->mus_gradData_module mus_interpolate_module mus_interpolate_module module~mus_hvs_aux_module->mus_interpolate_module mus_interpolate_tools_module mus_interpolate_tools_module module~mus_hvs_aux_module->mus_interpolate_tools_module tem_aux_module tem_aux_module module~mus_hvs_aux_module->tem_aux_module tem_debug_module tem_debug_module module~mus_hvs_aux_module->tem_debug_module tem_logging_module tem_logging_module module~mus_hvs_aux_module->tem_logging_module tem_restart_module tem_restart_module module~mus_hvs_aux_module->tem_restart_module tem_spacetime_fun_module tem_spacetime_fun_module module~mus_hvs_aux_module->tem_spacetime_fun_module tem_tools_module tem_tools_module module~mus_hvs_aux_module->tem_tools_module tem_tracking_module tem_tracking_module module~mus_hvs_aux_module->tem_tracking_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_hvs_aux_module~~UsedByGraph module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine mus_hvs_init_aux (scheme, geometry, params) Init auxiliary features such as interpolation boundaries, restart and\nthe tracker Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(inout), target :: scheme container for the scheme type( mus_geom_type ), intent(inout) :: geometry geometry infomation type( mus_param_type ), intent(inout) :: params global parameters","tags":"","loc":"module/mus_hvs_aux_module.html"},{"title":"mus_wall_function_musker_module – Musubi","text":"This module contains data types, function and routines for wall function\ncomputations relative to Musker profile.\nHaussmann, Marc; BARRETO, Alejandro CLARO; KOUYI, Gislain LIPEME;\nRivière, Nicolas; Nirschl, Hermann; Krause, Mathias J. (2019):\nLarge-eddy simulation coupled with wall models for turbulent channel\nflows at high Reynolds numbers with a lattice Boltzmann method\n— Application to Coriolis mass flowmeter. In Computers & Mathematics\nwith Applications 78 (10), pp. 3285–3302. DOI: 10.1016/j.camwa.2019.04.033. author: Gregorio Gerardo Spinelli Uses env_module mus_wall_function_abstract_module module~~mus_wall_function_musker_module~~UsesGraph module~mus_wall_function_musker_module mus_wall_function_musker_module env_module env_module module~mus_wall_function_musker_module->env_module module~mus_wall_function_abstract_module mus_wall_function_abstract_module module~mus_wall_function_musker_module->module~mus_wall_function_abstract_module module~mus_wall_function_abstract_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_wall_function_musker_module~~UsedByGraph module~mus_wall_function_musker_module mus_wall_function_musker_module module~mus_turb_wallfunc_module mus_turb_wallFunc_module module~mus_turb_wallfunc_module->module~mus_wall_function_musker_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( mus_wall_function_type ) :: mus_wall_function_musker_type extend the abstract subclass mus_wall_function_type Type-Bound Procedures procedure, public, nopass :: get_uPlus ../../../../../ function to get uPlus procedure, public, nopass :: get_d_uPlus_d_uTau ../../../../../ function to apply the newon method Functions private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"module/mus_wall_function_musker_module.html"},{"title":"mus_tools_module – Musubi","text":"Some generic handy check routines to check the properties of the flow field\nand the current run Performance estimation, check of the total density, check for NaNs Uses env_module tem_comm_module mus_scheme_type_module aotus_module tem_param_module mus_IBM_module mus_relaxationParam_module tem_timeControl_module tem_isNaN_module tem_topology_module tem_time_module mus_timer_module tem_general_module mus_param_module tem_tools_module tem_comm_env_module tem_balance_module mus_scheme_module tem_logging_module tem_debug_module tem_status_module mus_abortCriteria_module mpi tem_aux_module tem_timer_module mus_physics_module aot_out_module module~~mus_tools_module~~UsesGraph module~mus_tools_module mus_tools_module aot_out_module aot_out_module module~mus_tools_module->aot_out_module aotus_module aotus_module module~mus_tools_module->aotus_module env_module env_module module~mus_tools_module->env_module module~mus_abortcriteria_module mus_abortCriteria_module module~mus_tools_module->module~mus_abortcriteria_module module~mus_param_module mus_param_module module~mus_tools_module->module~mus_param_module module~mus_physics_module mus_physics_module module~mus_tools_module->module~mus_physics_module module~mus_relaxationparam_module mus_relaxationParam_module module~mus_tools_module->module~mus_relaxationparam_module module~mus_scheme_module mus_scheme_module module~mus_tools_module->module~mus_scheme_module module~mus_scheme_type_module mus_scheme_type_module module~mus_tools_module->module~mus_scheme_type_module module~mus_timer_module mus_timer_module module~mus_tools_module->module~mus_timer_module mpi mpi module~mus_tools_module->mpi mus_IBM_module mus_IBM_module module~mus_tools_module->mus_IBM_module tem_aux_module tem_aux_module module~mus_tools_module->tem_aux_module tem_balance_module tem_balance_module module~mus_tools_module->tem_balance_module tem_comm_env_module tem_comm_env_module module~mus_tools_module->tem_comm_env_module tem_comm_module tem_comm_module module~mus_tools_module->tem_comm_module tem_debug_module tem_debug_module module~mus_tools_module->tem_debug_module tem_general_module tem_general_module module~mus_tools_module->tem_general_module tem_isNaN_module tem_isNaN_module module~mus_tools_module->tem_isNaN_module tem_logging_module tem_logging_module module~mus_tools_module->tem_logging_module tem_param_module tem_param_module module~mus_tools_module->tem_param_module tem_status_module tem_status_module module~mus_tools_module->tem_status_module tem_timeControl_module tem_timeControl_module module~mus_tools_module->tem_timeControl_module tem_time_module tem_time_module module~mus_tools_module->tem_time_module tem_timer_module tem_timer_module module~mus_tools_module->tem_timer_module tem_tools_module tem_tools_module module~mus_tools_module->tem_tools_module tem_topology_module tem_topology_module module~mus_tools_module->tem_topology_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_tools_module~~UsedByGraph module~mus_tools_module mus_tools_module module~mus_aux_module mus_aux_module module~mus_aux_module->module~mus_tools_module module~mus_tracking_module mus_tracking_module module~mus_aux_module->module~mus_tracking_module module~mus_config_module mus_config_module module~mus_config_module->module~mus_tools_module module~mus_dynloadbal_module mus_dynLoadBal_module module~mus_dynloadbal_module->module~mus_tools_module module~mus_dynloadbal_module->module~mus_tracking_module module~mus_hvs_aux_module mus_hvs_aux_module module~mus_hvs_aux_module->module~mus_tools_module module~mus_hvs_aux_module->module~mus_tracking_module module~mus_tracking_module->module~mus_tools_module module~mus_control_module mus_control_module module~mus_control_module->module~mus_aux_module module~mus_hvs_config_module mus_hvs_config_module module~mus_hvs_config_module->module~mus_config_module program~mus_harvesting mus_harvesting program~mus_harvesting->module~mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_config_module program~musubi musubi program~musubi->module~mus_aux_module program~musubi->module~mus_config_module program~musubi->module~mus_control_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions private pure function calc_MLUPS (minLevel, maxLevel, scaleFactor, nElems, iter, time) result(mlups) Calculate the MLUPS or MFLUPS for the simulation Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel level range integer, intent(in) :: maxLevel level range integer, intent(in) :: scaleFactor global parameter integer(kind=long_k), intent(in) :: nElems (minLevel:maxLevel) array of nElems levelwise integer, intent(in) :: iter number of iterations on maxLevel\nnumber of iteration on iLevel = iter / scaleFactor**(maxLevel-iLevel) real(kind=rk), intent(in) :: time time consumed for running iter iterations Return Value real(kind=rk) resulting mlups Subroutines public  subroutine perform_checks (scheme, minLevel, maxLevel, general, mus_aborts, initCheck) Perform run-time checks if interval is active Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme integer, intent(in) :: minLevel integer, intent(in) :: maxLevel type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts logical, intent(in) :: initCheck True for initial check before main time toop public  subroutine check_potential (scheme, minLevel, maxLevel, general, total_potential) Check the total potential for poisson scheme Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general real(kind=rk), intent(out), optional :: total_potential public  subroutine check_density (scheme, minLevel, maxLevel, general, total_density) Check the total density for a selected scheme and write to unit Read more… Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general real(kind=rk), intent(out), optional :: total_density public  subroutine mus_perf_measure (totalDens, DomSize, minLevel, maxLevel, nElems, scaleFactor, general) This routine measures performance imbalance, MLUPS and dumps timings\nto disk Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: totalDens Total density from check_density integer(kind=long_k), intent(in) :: DomSize Total number of elements in tree integer, intent(in) :: minLevel level range integer, intent(in) :: maxLevel level range integer, intent(in) :: nElems (minLevel:maxLevel) array of nElems levelwise integer, intent(in) :: scaleFactor global parameter type( tem_general_type ), intent(in) :: general Contains proc, simControl, solveHead public  subroutine check_streaming_layout (minLevel, maxLevel) Check for the streaming layout. Arguments Type Intent Optional Attributes Name integer, intent(in) :: minLevel integer, intent(in) :: maxLevel public  subroutine mus_writeSolverSpecInfo (scheme, params, rank, outUnit) Write solver specific info to scratch file Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type type( mus_param_type ), intent(in) :: params Contains physical convertion info and scaling type integer, intent(in) :: rank Rank of the process either from\nglobal communicator or tracking output communicator integer, intent(inout) :: outUnit unit to output solver info in lua format public  subroutine dump_linear_partition (treeID, nElems, offset, myRank, iter) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: treeID (1:nElems) integer, intent(in) :: nElems integer(kind=long_k), intent(in) :: offset integer, intent(in) :: myRank integer, intent(in) :: iter public  subroutine mus_BC_timing (nBCs, bc_labels, comm) Output the min and max time across all ranks,\nwhich are spent on each boundary condition. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nBCs character(len=labelLen), intent(in) :: bc_labels (nBCs) integer, intent(in) :: comm public  subroutine dump_bc_timing (proc, nFluids, nBCElems, DomSize, iter, send) This routine dump compute and BC timing for all ranks\nrank    nFluids     tCompute     nBCElems     tBC    tCPU    tMainLoop Arguments Type Intent Optional Attributes Name type( tem_comm_env_type ), intent(in) :: proc integer, intent(in) :: nFluids integer, intent(in) :: nBCElems integer(kind=long_k), intent(in) :: DomSize integer, intent(in) :: iter type( tem_communication_type ), intent(in) :: send private  subroutine check_velocityFluid (scheme, minLevel, maxLevel, general, mus_aborts) Check the maximum velocity whether it is above Ma>0.1 Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts private  subroutine check_velocityMS (scheme, minLevel, maxLevel, general, mus_aborts) Check the maximum velocity whether it is above Ma>0.1 Arguments Type Intent Optional Attributes Name type( mus_scheme_type ), intent(in) :: scheme scheme type integer, intent(in) :: minLevel global scheme independent information integer, intent(in) :: maxLevel global scheme independent information type( tem_general_type ), intent(inout) :: general type( mus_abortCriteria_type ), intent(in) :: mus_aborts private  subroutine dump_timing (totalDens, DomSize, MLUPS, MLUPS_kernel, timerVal, imbalance, general) Performance results (MLUPs) are written to a file for statistical review\nThe file-format is simple can be evaluated with gnuplot Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: totalDens integer(kind=long_k), intent(in) :: DomSize real(kind=rk), intent(in) :: MLUPS real(kind=rk), intent(in) :: MLUPS_kernel real(kind=rk), intent(in) :: timerVal (:) Max. timers of all process real(kind=rk), intent(in) :: imbalance type( tem_general_type ), intent(in) :: general","tags":"","loc":"module/mus_tools_module.html"},{"title":"mus_wall_function_reichardt_module – Musubi","text":"This module contains data types, function and routines for wall function\ncomputations relative to Reichardt profile.\nHaussmann, Marc; BARRETO, Alejandro CLARO; KOUYI, Gislain LIPEME;\nRivière, Nicolas; Nirschl, Hermann; Krause, Mathias J. (2019):\nLarge-eddy simulation coupled with wall models for turbulent channel\nflows at high Reynolds numbers with a lattice Boltzmann method\n— Application to Coriolis mass flowmeter. In Computers & Mathematics\nwith Applications 78 (10), pp. 3285–3302. DOI: 10.1016/j.camwa.2019.04.033. The explicit power-law in terms of friction velocity given in Eq. 33 in\nS. Wilhelm, J. Jacob, and P. Sagaut, \"An explicit power-law-based wall\nmodel for lattice Boltzmann method–Reynolds-averaged numerical simulations\nof the flow around airfoils\", Physics of Fluids 30, 065111 (2018)\nhttps://doi.org/10.1063/1.5031764 The model constants are chosen according to Werner and Wengle:\nWengle, H. and Werner, H. (1993) ‘Large-eddy Simulation of Turbulent Flow\nOver Sharp-edged Obstacles in a Plate Channel’, (1985), pp. 192–199. author: Gregorio Gerardo Spinelli Constant parameters for Reichardt's law Uses env_module mus_wall_function_abstract_module module~~mus_wall_function_reichardt_module~~UsesGraph module~mus_wall_function_reichardt_module mus_wall_function_reichardt_module env_module env_module module~mus_wall_function_reichardt_module->env_module module~mus_wall_function_abstract_module mus_wall_function_abstract_module module~mus_wall_function_reichardt_module->module~mus_wall_function_abstract_module module~mus_wall_function_abstract_module->env_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mus_wall_function_reichardt_module~~UsedByGraph module~mus_wall_function_reichardt_module mus_wall_function_reichardt_module module~mus_turb_wallfunc_module mus_turb_wallFunc_module module~mus_turb_wallfunc_module->module~mus_wall_function_reichardt_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=rk), private, parameter :: vonKA = 0.4_rk real(kind=rk), private, parameter :: oneOvervonKA = 1.0_rk/vonKA Derived Types type, public, extends( mus_wall_function_type ) :: mus_wall_function_reichardt_type extend the abstract subclass mus_wall_function_type Type-Bound Procedures procedure, public, nopass :: get_uPlus ../../../../../ function to get uPlus procedure, public, nopass :: get_d_uPlus_d_uTau ../../../../../ function to apply the newon method Functions private pure function get_uPlus (yPlus) result(uPlus) function to get uPlus Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: yPlus yPlus Return Value real(kind=rk) private pure function get_d_uPlus_d_uTau (y, uTau, nu) result(d_uPlus_d_uTau) function to get the derivative of uPlus with respect to uTau Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: y vertical distance from the wall real(kind=rk), intent(in) :: uTau uTau at iteration n real(kind=rk), intent(in) :: nu dynamic viscosity Return Value real(kind=rk)","tags":"","loc":"module/mus_wall_function_reichardt_module.html"},{"title":"mus_harvesting – Musubi","text":"Uses env_module iso_c_binding mus_scheme_type_module aotus_module mus_varSys_module mus_geom_module mus_hvs_config_module mus_hvs_aux_module mus_hvs_construction_module mus_bndForce_module mus_construction_module tem_timeControl_module mus_flow_module tem_tracking_module mus_timer_module tem_general_module mus_param_module hvs_aux_module mus_scheme_module mus_restart_module tem_logging_module mpi tem_aux_module hvs_output_module program~~mus_harvesting~~UsesGraph program~mus_harvesting mus_harvesting aotus_module aotus_module program~mus_harvesting->aotus_module env_module env_module program~mus_harvesting->env_module hvs_aux_module hvs_aux_module program~mus_harvesting->hvs_aux_module hvs_output_module hvs_output_module program~mus_harvesting->hvs_output_module iso_c_binding iso_c_binding program~mus_harvesting->iso_c_binding module~mus_geom_module mus_geom_module program~mus_harvesting->module~mus_geom_module module~mus_hvs_aux_module mus_hvs_aux_module program~mus_harvesting->module~mus_hvs_aux_module module~mus_hvs_config_module mus_hvs_config_module program~mus_harvesting->module~mus_hvs_config_module module~mus_hvs_construction_module mus_hvs_construction_module program~mus_harvesting->module~mus_hvs_construction_module module~mus_param_module mus_param_module program~mus_harvesting->module~mus_param_module module~mus_restart_module mus_restart_module program~mus_harvesting->module~mus_restart_module module~mus_scheme_module mus_scheme_module program~mus_harvesting->module~mus_scheme_module module~mus_scheme_type_module mus_scheme_type_module program~mus_harvesting->module~mus_scheme_type_module module~mus_timer_module mus_timer_module program~mus_harvesting->module~mus_timer_module mpi mpi program~mus_harvesting->mpi mus_bndForce_module mus_bndForce_module program~mus_harvesting->mus_bndForce_module mus_construction_module mus_construction_module program~mus_harvesting->mus_construction_module mus_flow_module mus_flow_module program~mus_harvesting->mus_flow_module mus_varSys_module mus_varSys_module program~mus_harvesting->mus_varSys_module tem_aux_module tem_aux_module program~mus_harvesting->tem_aux_module tem_general_module tem_general_module program~mus_harvesting->tem_general_module tem_logging_module tem_logging_module program~mus_harvesting->tem_logging_module tem_timeControl_module tem_timeControl_module program~mus_harvesting->tem_timeControl_module tem_tracking_module tem_tracking_module program~mus_harvesting->tem_tracking_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Musubi Harvesting Tool\nVisualization of restart file or tracking harvester formar, generated by\nmusubi\n(c) 2015 University of Siegen For a documentation, run ./waf gendoxy and find the documentation at\n./Documentation/html/index.html\nIf restart read variable is not pdf then set interpolation\nmethod to none to deactivate interpolation for\nderived variable Calls program~~mus_harvesting~~CallsGraph program~mus_harvesting mus_harvesting config config program~mus_harvesting->config fillhelperelementscoarsetofine fillhelperelementscoarsetofine program~mus_harvesting->fillhelperelementscoarsetofine fillhelperelementsfinetocoarse fillhelperelementsfinetocoarse program~mus_harvesting->fillhelperelementsfinetocoarse hvs_banner hvs_banner program~mus_harvesting->hvs_banner hvs_output_close hvs_output_close program~mus_harvesting->hvs_output_close hvs_output_finalize hvs_output_finalize program~mus_harvesting->hvs_output_finalize hvs_output_init hvs_output_init program~mus_harvesting->hvs_output_init hvs_output_open hvs_output_open program~mus_harvesting->hvs_output_open hvs_output_write hvs_output_write program~mus_harvesting->hvs_output_write instance instance program~mus_harvesting->instance mpi_barrier mpi_barrier program~mus_harvesting->mpi_barrier mus_calcbndforce mus_calcbndforce program~mus_harvesting->mus_calcbndforce mus_construct mus_construct program~mus_harvesting->mus_construct mus_initauxfield mus_initauxfield program~mus_harvesting->mus_initauxfield proc~mus_hvs_config_load mus_hvs_config_load program~mus_harvesting->proc~mus_hvs_config_load proc~mus_hvs_construct mus_hvs_construct program~mus_harvesting->proc~mus_hvs_construct proc~mus_hvs_init_aux mus_hvs_init_aux program~mus_harvesting->proc~mus_hvs_init_aux proc~mus_init_leveltimer mus_init_levelTimer program~mus_harvesting->proc~mus_init_leveltimer proc~mus_init_maintimer mus_init_mainTimer program~mus_harvesting->proc~mus_init_maintimer proc~mus_init_scheme mus_init_scheme program~mus_harvesting->proc~mus_init_scheme proc~mus_readrestart mus_readRestart program~mus_harvesting->proc~mus_readrestart tem_finalize tem_finalize program~mus_harvesting->tem_finalize tem_start tem_start program~mus_harvesting->tem_start tem_tracking_finalize tem_tracking_finalize program~mus_harvesting->tem_tracking_finalize val val program~mus_harvesting->val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( mus_scheme_type ), target :: scheme type( mus_geom_type ), target :: geometry type( mus_param_type ), target :: params type(mus_varSys_solverData_type), target :: solverData type( mus_hvs_config_type ) :: config type( hvs_output_file_type ) :: out_file integer :: ierr integer :: iTrack integer :: iConfig integer :: nVars integer :: minLevel integer :: maxLevel character(len=pathLen) :: basename","tags":"","loc":"program/mus_harvesting.html"},{"title":"musubi – Musubi","text":"Uses mus_config_module mus_aux_module mpi mus_scheme_type_module tem_adaptation_config_module mus_varSys_module mus_timer_module mus_geom_module mus_control_module mus_program_module tem_general_module mus_param_module program~~musubi~~UsesGraph program~musubi musubi module~mus_aux_module mus_aux_module program~musubi->module~mus_aux_module module~mus_config_module mus_config_module program~musubi->module~mus_config_module module~mus_control_module mus_control_module program~musubi->module~mus_control_module module~mus_geom_module mus_geom_module program~musubi->module~mus_geom_module module~mus_param_module mus_param_module program~musubi->module~mus_param_module module~mus_scheme_type_module mus_scheme_type_module program~musubi->module~mus_scheme_type_module module~mus_timer_module mus_timer_module program~musubi->module~mus_timer_module mpi mpi program~musubi->mpi mus_program_module mus_program_module program~musubi->mus_program_module mus_varSys_module mus_varSys_module program~musubi->mus_varSys_module tem_adaptation_config_module tem_adaptation_config_module program~musubi->tem_adaptation_config_module tem_general_module tem_general_module program~musubi->tem_general_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. M U S U B I\nThe lattice Boltzmann solver within the APES suite\n(c) 2012 German Research School for Simulation Sciences GmbH\n(c) 2013 University of Siegen. For a documentation, run ./waf gendoxy and find the documentation at\n./Documentation/html/index.html Calls program~~musubi~~CallsGraph program~musubi musubi mpi_barrier mpi_barrier program~musubi->mpi_barrier mus_finalize mus_finalize program~musubi->mus_finalize mus_initialize mus_initialize program~musubi->mus_initialize mus_solve mus_solve program~musubi->mus_solve proc~mus_banner mus_banner program~musubi->proc~mus_banner proc~mus_init_bctimer mus_init_bcTimer program~musubi->proc~mus_init_bctimer proc~mus_init_leveltimer mus_init_levelTimer program~musubi->proc~mus_init_leveltimer proc~mus_init_maintimer mus_init_mainTimer program~musubi->proc~mus_init_maintimer proc~mus_load_config mus_load_config program~musubi->proc~mus_load_config tem_finalize tem_finalize program~musubi->tem_finalize tem_start tem_start program~musubi->tem_start mus_print_ppinfo mus_print_ppinfo proc~mus_banner->mus_print_ppinfo tem_print_execInfo tem_print_execInfo proc~mus_banner->tem_print_execInfo utc_date_string utc_date_string proc~mus_banner->utc_date_string tem_addTimer tem_addTimer proc~mus_init_bctimer->tem_addTimer proc~mus_init_leveltimer->tem_addTimer proc~mus_init_maintimer->tem_addTimer tem_getNTimers tem_getNTimers proc~mus_init_maintimer->tem_getNTimers conf conf proc~mus_load_config->conf proc~dump_linear_partition dump_linear_partition proc~mus_load_config->proc~dump_linear_partition proc~mus_init_latticeunit mus_init_latticeUnit proc~mus_load_config->proc~mus_init_latticeunit proc~mus_load_geom mus_load_geom proc~mus_load_config->proc~mus_load_geom proc~mus_load_param mus_load_param proc~mus_load_config->proc~mus_load_param proc~mus_load_physics mus_load_physics proc~mus_load_config->proc~mus_load_physics proc~mus_load_scheme mus_load_scheme proc~mus_load_config->proc~mus_load_scheme proc~mus_open_config mus_open_config proc~mus_load_config->proc~mus_open_config tem_debug_load_main tem_debug_load_main proc~mus_load_config->tem_debug_load_main tem_horizontalSpacer tem_horizontalSpacer proc~mus_load_config->tem_horizontalSpacer tem_load_adapt tem_load_adapt proc~mus_load_config->tem_load_adapt tem_load_general tem_load_general proc~mus_load_config->tem_load_general tem_logging_load_primary tem_logging_load_primary proc~mus_load_config->tem_logging_load_primary tem_startTimer tem_startTimer proc~mus_load_config->tem_startTimer tem_stopTimer tem_stopTimer proc~mus_load_config->tem_stopTimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( mus_scheme_type ), target :: scheme scheme types type( mus_geom_type ), target :: geometry type( mus_param_type ), target :: params type(mus_varSys_solverData_type), target :: solverData type( mus_control_type ) :: control type( tem_adapt_type ) :: adapt integer :: ierr","tags":"","loc":"program/musubi.html"},{"title":"mus_restart_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_restart_module.f90~~EfferentGraph sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_restart_module.f90~~AfferentGraph sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011 Konstantin Kleinheinz <k.kleinheinz@grs-sim.de> ! Copyright (c) 2011-2012, 2016, 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012, 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2015 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Simon Zimny !! This module provides the MUSUBI subroutines needed for the restart !! functionality. !! !! This module makes the restart IO functionality available for MUSUBI. When !! using the write functionality the workflow is as follows !! - open the file and write the 'normal header' !! - run over the chunks and !!   + serialize the data !!   + write them to file !! - close the file and write the 'last header' !! For reading the restart files the workflow is as follows: !! - open the file !! - read the solver specific character !! - loop over the chunks and !!   + read the data from disc !!   + unserialize the data and store it in the state vector !! - close the file !! !! Further information on the treelm functions and the usage can be found in !! the [[tem_restart_module]] and inside the Restart Usage section itself. !! module mus_restart_module ! include treelm modules use mpi use env_module , only : rk , io_buffer_size use treelmesh_module , only : treelmesh_type use tem_time_module , only : tem_time_type use tem_timer_module , only : tem_timer_type , tem_startTimer , tem_stopTimer use tem_restart_module , only : tem_restart_type , tem_restart_openRead , & & tem_restart_closeRead , tem_restart_readData ,& & tem_restart_openWrite , & & tem_restart_closeWrite , & & tem_restart_writeData use tem_debug_module , only : dbgUnit , main_debug use tem_logging_module , only : logUnit ! include musubi modules use mus_scheme_type_module , only : mus_scheme_type use mus_buffer_module , only : mus_pdf_unserialize , mus_pdf_serialize implicit none private public :: mus_writeRestart public :: mus_readRestart contains ! **************************************************************************** ! !> Write the serialized buffer assembled in mus_serializeData to disk !! subroutine mus_writeRestart ( levelPointer , restart , scheme , tree , timing , & & timerHandle , suffix ) ! -------------------------------------------------------------------------- !> global pdf info integer , intent ( in ) :: levelPointer (:) !> restart information type ( tem_restart_type ), intent ( inout ) :: restart !> array of schemes including the data to be serialized and dumped type ( mus_scheme_type ), intent ( inout ) :: scheme !> mesh, provided in treelm format type ( treelmesh_type ), intent ( in ) :: tree !> current simulation time information type ( tem_time_type ), intent ( inout ) :: timing !> Timer handle integer , intent ( in ) :: timerHandle !> optional suffix (if present NO timestamp will be added!!!!) character ( len =* ), optional , intent ( in ) :: suffix ! -------------------------------------------------------------------------- ! array for chunkwise memory bounded output real ( kind = rk ), allocatable :: buffer (:) ! counter variables integer :: elemOff ! -------------------------------------------------------------------------- allocate ( buffer ( io_buffer_size )) ! open the file, write header and prepare buffering call tem_restart_openWrite ( me = restart , & & tree = tree , & & timing = timing , & & varSys = scheme % varSys , & & suffix = suffix ) ! debug output if ( main_debug % debugRestart ) then write ( dbgUnit ( 1 ), * ) 'DEBUG: WRITE RESTART' write ( dbgUnit ( 1 ), * ) 'minLevel ' , tree % global % minLevel , & & ' PDF state array size ' , & & size ( scheme % state ( tree % global % minLevel )% val , 1 ) write ( dbgUnit ( 1 ), * ) 'maxLevel ' , tree % global % maxLevel , & & ' PDF state array size ' , & & size ( scheme % state ( tree % global % maxLevel )% val , 1 ) end if elemOff = 0 ! loop over the chunks do while ( elemOff < tree % nElems ) ! set the number of elements that are on the stack restart % nChunkElems = min ( restart % write_file % chunkSize , & & tree % nElems - elemOff ) ! prepare the data call mus_pdf_serialize ( & & scheme , & & tree % treeID ( elemOff + 1 : elemOff + restart % nChunkElems ), & & levelPointer ( elemOff + 1 : elemOff + restart % nChunkElems ), & & restart % varMap , & & restart % nChunkElems , & & buffer , & & tree % global % minLevel , & & tree % global % maxLevel ) call tem_startTimer ( timerHandle = timerHandle ) ! write the data to file call tem_restart_writeData ( restart , buffer ) call tem_stopTimer ( timerHandle = timerHandle ) ! set elements offset for next chunk elemOff = elemOff + restart % nChunkElems end do ! close the file and write last header call tem_restart_closeWrite ( me = restart , & & timing = timing , & & tree = tree , & & varSys = scheme % varSys ) deallocate ( buffer ) ! debug output if ( main_debug % debugRestart ) then write ( dbgUnit ( 1 ), * ) 'END DEBUG: WRITE RESTART' end if end subroutine mus_writeRestart ! **************************************************************************** ! ! **************************************************************************** ! !> Read the serialized restart file into the state vectors !! subroutine mus_readRestart ( levelPointer , restart , scheme , tree ) ! ------------------------------------------------------------------------- !> restart information type ( tem_restart_type ), intent ( inout ) :: restart !> mesh, provided in treelm format type ( treelmesh_type ), intent ( in ) :: tree !> Level pointer, from tree mesh to level descriptor integer , intent ( in ) :: levelPointer ( tree % nElems ) !> array of schemes including the data to be serialized and dumped type ( mus_scheme_type ), intent ( inout ) :: scheme ! ------------------------------------------------------------------------- ! local variables real ( kind = rk ), allocatable :: buffer (:) ! integer :: iChunk integer :: elemOff ! Offset in the overall number of elements ! ------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Reading restart...' allocate ( buffer ( io_buffer_size )) if ( main_debug % debugRestart ) then write ( dbgUnit ( 1 ), * ) 'DEBUG: READ RESTART' end if ! open the file, read header and prepare buffering call tem_restart_openRead ( me = restart ) elemOff = 0 ! loop over the chunks do while ( elemOff < tree % nElems ) ! set the number of elements that are on the stack restart % nChunkElems = min ( restart % read_file % chunkSize , & & tree % nElems - elemOff ) ! fill buffer from restart file call tem_restart_readData ( restart , buffer ) ! transfer buffer to level-wise PDF array call mus_pdf_unserialize ( & & scheme , & & tree % treeID ( elemOff + 1 : elemOff + restart % nChunkElems ), & & levelPointer ( elemOff + 1 : elemOff + restart % nChunkElems ), & & restart % varMap , & & restart % nChunkElems , & & buffer , & & tree % global % minLevel , & & tree % global % maxLevel ) ! Set treeID offset for next buffer elemOff = elemOff + restart % nChunkElems end do ! close the file call tem_restart_closeRead ( me = restart ) deallocate ( buffer ) ! debug output if ( main_debug % debugRestart ) then write ( dbgUnit ( 1 ), * ) 'END DEBUG: READ RESTART' end if write ( logUnit ( 1 ), * ) 'Done reading restart.' end subroutine mus_readRestart ! **************************************************************************** ! end module mus_restart_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_restart_module.f90.html"},{"title":"mus_species_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_species_module.f90~~EfferentGraph sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_species_module.f90~~AfferentGraph sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016, 2018, 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012-2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilmani !! This module contains mus_species_type and routines to load species table !! from config file. !! module mus_species_module ! include treelm modules use env_module , only : rk , globalMaxLevels use tem_aux_module , only : tem_abort use tem_tools_module , only : tem_horizontalSpacer use tem_param_module , only : cs2 use tem_logging_module , only : logUnit ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_NonExistent , & & aoterr_Fatal , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , aot_table_length use aot_out_module , only : aot_out_type , aot_out_val , aot_out_open_table , & & aot_out_close_table ! include musubi modules use mus_physics_module , only : mus_physics_type implicit none private public :: mus_species_type public :: mus_load_species , compute_molWeightRatio , compute_bulkViscOmega public :: mus_species_out !> MRT species type type mrt_species_type !> relaxation matrix for mrt !! size of this matrix is (layout%QQ, layout%QQ) real ( kind = rk ), allocatable :: s_mrt (:,:) !> transformed relaxation matrix-moments factor !! omegaMoments = (Moments&#94;-1.s_mrt.Moments) !!               .(I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1 real ( kind = rk ), allocatable :: omegaMoments (:,:) !> Omega factor for 2nd order force term !! omegaMomForce = (I+(Moments&#94;-1.s_mrt.Moments)/2.0)&#94;-1 real ( kind = rk ), allocatable :: omegaMomForce (:,:) end type mrt_species_type !> this type contains species parameters !! @todo KM: extent level dependent parameter for multilevel type mus_species_type !> molecular weight of the species real ( kind = rk ) :: molWeight !> Inverse of molecular weight of the species. !! This parameter is required to convert mass density to mole density real ( kind = rk ) :: molWeightInv !> ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma i \\f$ real ( kind = rk ) :: molWeigRatio !> coefficient of diffusivity  of the species (size of nspecies) real ( kind = rk ), allocatable :: diff_coeff (:) !> coefficient of resisivity of species which is !! reciprocal of diffusivity of the species real ( kind = rk ), allocatable :: resi_coeff (:) !! KM:@todo set diffusivity and resistivity for multilevel !> molar fraction of this species in the mixture !    real(kind=rk) :: molarFrac !> Volume fraction of is species in the mixture !    real(kind=rk) :: volFrac !> mrt relaxation for each level type ( mrt_species_type ) :: mrt ( globalMaxLevels ) !> bulk relaxation parameter !! omBulk_k = (2-phi_k)/3*bulkViscosity real ( kind = rk ) :: omBulk !> bulk relaxation parameter for each level real ( kind = rk ) :: ombulkLvl ( globalMaxLevels ) !> relaxation parameter for Nernst-Planck equation real ( kind = rk ) :: omega !> relaxation parameter for trt scheme real ( kind = rk ) :: lambda !> charge number of the species real ( kind = rk ) :: chargeNr end type mus_species_type contains ! **************************************************************************** ! !> this routines load species table from config file !! !!``` !! species = { molweight = 1.0, diff_coeff = { 0.5,0.3,0.1 } } !!``` subroutine mus_load_species ( me , conf , parent , minLevel , nFields , physics , & & cs_lattice ) ! -------------------------------------------------------------------------- type ( mus_species_type ), intent ( out ) :: me !< contains species information type ( flu_State ) :: conf !< flu state integer , intent ( in ), optional :: parent !< parent lua handle integer , intent ( in ) :: minLevel integer , intent ( in ) :: nFields !< number of fields defined in lua file !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> lattice speed of sound calculated for defined stencil layout !! required to compute omega from potential diffusivity real ( kind = rk ), intent ( in ) :: cs_lattice ! -------------------------------------------------------------------------- !local variables integer :: spc_handle , sub_handle integer :: iError integer , allocatable :: vError (:), errFatal (:) integer :: nCoeff ! -------------------------------------------------------------------------- call aot_table_open ( L = conf , & & parent = parent , & & thandle = spc_handle , & & key = 'species' ) !> if species handle is not defined if ( spc_handle == 0 ) then write ( logUnit ( 1 ), * ) ' No species table defined' call tem_abort () endif call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) ' Loading species information' !get molecular weight call aot_get_val ( L = conf , & & thandle = spc_handle , & & key = 'molweight' , & & val = me % molWeight , & & ErrCode = iError , & & default = 1.0_rk ) me % molWeight = me % molWeight / physics % molWeight0 me % molWeightInv = 1.0_rk / me % molWeight if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving molecular ' // & & 'weight of species :' if ( btest ( iError , aotErr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' end if !get trt relaxation parameter call aot_get_val ( L = conf , & & thandle = spc_handle , & & key = 'lambda' , & & val = me % lambda , & & ErrCode = iError , & & default = 0.25_rk ) !get specific charge call aot_get_val ( L = conf , thandle = spc_handle , key = 'charge_nr' , & & val = me % chargeNr , ErrCode = iError , & & default = 0.0_rk ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving charge_nr ' // & & 'of species :' if ( btest ( iError , aotErr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' end if !get diffusivities call aot_table_open ( L = conf , & & parent = spc_handle , & & thandle = sub_handle , & & key = 'diff_coeff' ) if ( sub_handle == 0 ) then nCoeff = 1 !check whether resistivity table is defined call aot_table_open ( L = conf , parent = spc_handle , thandle = sub_handle ,& & key = 'resi_coeff' ) if ( sub_handle == 0 ) then ! coefficients are not defined as a table. try to load single constant ! value allocate ( me % diff_coeff ( nCoeff )) allocate ( me % resi_coeff ( nCoeff )) ! diff_coeff may be single constant value call aot_get_val ( L = conf , thandle = spc_handle , key = 'diff_coeff' , & & val = me % diff_coeff ( 1 ), ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then ! check whether resi_coeff is defined call aot_get_val ( L = conf , thandle = spc_handle , key = 'resi_coeff' , & & val = me % resi_coeff ( 1 ), ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'diff_coeff/resi_coeff of species :' if ( btest ( iError , aotErr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' call tem_abort () endif me % diff_coeff = 1._rk / me % resi_coeff endif me % resi_coeff = 1._rk / me % diff_coeff else ! resisivity coeff is defined as table nCoeff = aot_table_length ( L = conf , thandle = sub_handle ) allocate ( errFatal ( nCoeff ) ) errFatal = aotErr_Fatal call aot_get_val ( L = conf , & & thandle = spc_handle , & & key = 'resi_coeff' , & & val = me % resi_coeff , & & maxlength = nCoeff , & & ErrCode = vError ) if ( any ( btest ( vError , errFatal )) ) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'resi_coeff table' call tem_abort () endif allocate ( me % diff_coeff ( nCoeff )) me % diff_coeff = 1._rk / me % resi_coeff endif call aot_table_close ( L = conf , thandle = sub_handle ) else ! diff_coeff is defined as a table nCoeff = aot_table_length ( L = conf , thandle = sub_handle ) allocate ( errFatal ( nCoeff ) ) errFatal = aotErr_Fatal call aot_get_val ( L = conf , & & thandle = spc_handle , & & key = 'diff_coeff' , & & val = me % diff_coeff , & & maxlength = nCoeff , & & ErrCode = vError ) if ( any ( btest ( vError , errFatal )) ) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'diff_coeff table' call tem_abort () endif allocate ( me % resi_coeff ( nCoeff )) me % resi_coeff = 1._rk / me % diff_coeff endif call aot_table_close ( L = conf , thandle = sub_handle ) if ( nCoeff /= nFields ) then write ( logUnit ( 1 ), * ) 'ERROR: In loading diff_coeff or resi_coeff' write ( logUnit ( 1 ), * ) '       nCoeff does not match nFields' call tem_abort () endif !> convert physics to lattice unit me % diff_coeff = me % diff_coeff / physics % fac ( minLevel )% diffusivity me % resi_coeff = 1.0_rk / me % diff_coeff ! Relaxation parameter omega is compted from diffusivity coefficient. ! Used for Nernst-Planck equation !> \\todo KM: Compute omega for each level me % omega = 1.0_rk / ( me % diff_coeff ( 1 ) / cs_lattice ** 2 + 0.5_rk ) write ( logUnit ( 1 ), * ) ' Species properties          ' write ( logUnit ( 1 ), * ) '   Molecular weight:         ' , real ( me % molWeight ) write ( logUnit ( 1 ), * ) '   Inverse molecular weight: ' , real ( me % molWeightInv ) write ( logUnit ( 1 ), * ) '   Charge number:            ' , real ( me % chargeNr ) write ( logUnit ( 1 ), * ) '   Diffusivity coefficients: ' , real ( me % diff_coeff ) write ( logUnit ( 1 ), * ) '   Resitivity coefficients:  ' , real ( me % resi_coeff ) write ( logUnit ( 1 ), * ) '   Relaxation parameter:  ' , real ( me % omega ) call aot_table_close ( L = conf , thandle = spc_handle ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_species ! **************************************************************************** ! ! **************************************************************************** ! !> This routine computes the molecular weight ratio for all species !! based asinari model !! !! \"Lattice Boltzmann scheme for mixture modeling: Analysis of the continuum !! diffusion regimes recovering Maxwell-Stefan model and incompressible !! Navier-Stokes equations. Pietro Asinari(2009)\" !! \\f$ m_\\sigma = \\frac{min_\\varsigma(m_\\varsigma)}{m_\\sigma} \\le 1 \\f$ subroutine compute_molWeightRatio ( molWeights , molWeigRatios ) ! -------------------------------------------------------------------------- !> molecular weight of the species real ( kind = rk ), intent ( in ) :: molWeights (:) !> ratio of molecular weight  \\f$ \\phi_\\sigma = min(M)/M_\\sigma \\f$ real ( kind = rk ), intent ( out ) :: molWeigRatios (:) ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) ' Compute species molecular weight ratio' molWeigRatios (:) = minval ( MolWeights ) / molWeights (:) write ( logUnit ( 1 ), * ) '  Molecular weight ratio:' , real ( molWeigRatios (:)) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine compute_molWeightRatio ! **************************************************************************** ! ! **************************************************************************** ! !> This routine compute bulk viscosity omega for species for all levels !! omega_bulk = (2-molWeigRatio_k)/(3*bulk_visc) subroutine compute_bulkViscOmega ( species , bulkVisc , bulkViscLvl , & & minLevel , maxLevel ) ! -------------------------------------------------------------------------- !> contains species information type ( mus_species_type ), intent ( inout ) :: species !> bulk viscosity of the mixture real ( kind = rk ), intent ( in ) :: bulkvisc real ( kind = rk ), intent ( in ) :: bulkviscLvl ( globalMaxLevels ) integer , intent ( in ) :: minLevel , maxLevel ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- species % omBulk = ( 2.0_rk - species % molWeigRatio ) * cs2 / bulkvisc write ( logUnit ( 1 ), * ) '   Bulk omega: ' , real ( species % omBulk ) do iLevel = minLevel , maxLevel write ( logUnit ( 1 ), * ) '    level ' , iLevel species % omBulkLvl ( iLevel ) = ( 2.0_rk - species % molWeigRatio ) * cs2 & & / bulkViscLvl ( iLevel ) write ( logUnit ( 1 ), * ) '   Bulk omega ' , real ( species % omBulkLvl ( iLevel )) end do end subroutine compute_bulkViscOmega ! **************************************************************************** ! !> writes species propertries into a lua file !! subroutine mus_species_out ( me , conf ) ! -------------------------------------------------------------------------- type ( mus_species_type ), intent ( in ) :: me type ( aot_out_type ) :: conf ! -------------------------------------------------------------------------- call aot_out_open_table ( put_conf = conf , tname = 'species' ) call aot_out_val ( put_conf = conf , & & vname = 'molweight' , & & val = me % molWeight ) call aot_out_val ( put_conf = conf , & & vname = 'diff_coeff' , & & val = me % diff_coeff ) call aot_out_val ( put_conf = conf , & & vname = 'resi_coeff' , & & val = me % resi_coeff ) call aot_out_val ( put_conf = conf , & & vname = 'charge_nr' , & & val = me % chargeNr ) call aot_out_close_table ( put_conf = conf ) end subroutine mus_species_out ! **************************************************************************** ! end module mus_species_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_species_module.f90.html"},{"title":"mus_hvs_config_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_hvs_config_module.f90~~EfferentGraph sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_hvs_config_module.f90~~AfferentGraph sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016, 2018, 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** ! !> In this module, all parameter files are read in !! as lua script or a sample configuration is being loaded !! !! Possible Parameter configuration !! - General Parameters !! - [[mus_scheme_layout_module]] \"Scheme Definitions\" !! - [[tem_debug_module]] \"Debug Parameters\" !! module mus_hvs_config_module ! include musubi modules use mpi use mus_param_module , only : mus_param_type , mus_load_param use mus_geom_module , only : mus_geom_type , mus_load_bc_data use mus_scheme_type_module , only : mus_scheme_type use mus_scheme_module , only : mus_load_scheme use mus_geomIncrHead_module , only : mus_geomIncrHead_load use mus_physics_module , only : mus_load_physics use mus_varSys_module , only : mus_varSys_solverData_type use mus_config_module , only : mus_open_config use mus_timer_module , only : mus_timerHandles ! include treelm modules use env_module , only : pathLen , rk , long_k , rk_mpi use tem_property_module , only : prp_hasBnd , prp_hasQVal use tem_bc_prop_module , only : init_tem_bc_prop , load_tem_BC_prop , & & load_tem_bc_qVal use tem_restart_module , only : tem_load_restart use tem_timer_module , only : tem_startTimer , & & tem_stopTimer use tem_tools_module , only : tem_horizontalSpacer use tem_geometry_module , only : tem_setEffBoundingBox use tem_general_module , only : tem_load_general use tem_logging_module , only : logUnit , tem_logging_load_primary use tem_timeControl_module , only : tem_timeControl_start_at_sim use tem_debug_module , only : dbgUnit , tem_debug_load_main use tem_aux_module , only : tem_abort , tem_open_distconf use tem_tracking_module , only : tem_load_tracking use hvs_output_module , only : hvs_output_config_type , hvs_output_load ! include aotus modules use aotus_module , only : flu_State , open_config_chunk , close_config , & & aot_get_val implicit none private public :: mus_hvs_config_load public :: mus_hvs_config_type !> This datatype describes the various settings to load from the configuration !! file. type mus_hvs_config_type !> Location on disk to load the mesh data from. !! !! This prefix will be put before the various filenames of the individual !! mesh data files. character ( len = pathLen ) :: prefix !> Description of how the visualization output should be done. type ( hvs_output_config_type ) :: output end type mus_hvs_config_type contains ! ****************************************************************************** ! !> Read in LUA parameter file !! See http://www.lua.org for a reference on how to use !! Lua is a scripting language in itself which allows !! more complex parameter files including comments !! And load / create the mesh depending on the configuration subroutine mus_hvs_config_load ( me , scheme , solverData , geometry , params ) ! --------------------------------------------------------------------------- !> Musubi harvesting configuration to load when no tracking table is defined type ( mus_hvs_config_type ), intent ( out ) :: me !> scheme type type ( mus_scheme_type ), target :: scheme !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target :: solverData !> Treelmesh data type ( mus_geom_type ), intent ( inout ), target :: geometry !> Global parameters type ( mus_param_type ), target , intent ( inout ) :: params ! --------------------------------------------------------------------------- character ( len = PathLen ) :: filename integer :: minLevel , maxLevel integer :: iError ! --------------------------------------------------------------------------- call tem_startTimer ( timerHandle = mus_timerHandles % loadMesh ) ! Load configuration data according to command line arguments. filename = '' ! Get filename from command line argument call get_command_argument ( 1 , filename ) if ( trim ( filename ) == '' ) then ! Default to harvester.lua, if no filename is provided on the command ! line. filename = 'harvester.lua' end if if ( params % general % proc % rank == 0 ) then write ( logUnit ( 1 ), * ) \"Loading configuration file: \" // trim ( filename ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end if ! open musubi config file and solver specific lua functions as chunk call mus_open_config ( conf = params % general % solver % conf , & & filename = filename , & & proc = params % general % proc ) ! load and initialize logUnit call tem_logging_load_primary ( conf = params % general % solver % conf ( 1 ), & & rank = params % general % proc % rank ) ! load and initialize debug unit call tem_debug_load_main ( conf = params % general % solver % conf ( 1 ), & & rank = params % general % proc % rank ) ! load general information call tem_load_general ( me = params % general , & & conf = params % general % solver % conf ( 1 )) ! ------------------------------------------------------------------------- ! First check, if we are starting from a restart call tem_load_restart ( me = params % general % restart , & & conf = params % general % solver % conf ( 1 ), & & tree = geometry % tree , & & timing = params % general % simControl % now , & & globProc = params % general % proc ) if ( . not . params % general % restart % controller % readRestart ) then write ( logUnit ( 1 ), * ) 'ERROR: No read restart given.' write ( logUnit ( 1 ), * ) 'Solution: Provide restart file in: ' write ( logUnit ( 1 ), * ) '          restart = { read = <filename> }' call tem_abort () end if minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel ! If there is a restart, the timings in the params type have to be ! updated to those read from the restart call tem_timeControl_start_at_sim ( & & me = params % general % simControl % timeControl , & & now = params % general % simControl % now ) ! Load boundary and qval call mus_load_bc_data ( geometry , params % general % proc % rank , & & params % general % proc % comm ) ! load params, physics and solver specific info call mus_hvs_load_solverData ( scheme = scheme , & & solverData = solverData , & & geometry = geometry , & & params = params ) ! Initialize requiredInterval for multilevel to determine one complete cycle minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel params % reqInterval = params % scaleFactor ** ( maxLevel - minLevel ) ! If tracking table is not defined, load output_folder key ! to dump restart input or mesh to disk if ( . not . scheme % track % control % active ) then ! load output format and other config for output from output table call hvs_output_load ( me = me % output , & & conf = params % general % solver % conf ( 1 ),& & isReduce = . false . ) ! Load output folder call aot_get_val ( L = params % general % solver % conf ( 1 ), & & key = 'output_folder' , & & val = me % prefix , & & default = './' , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) 'Output folder: ' // trim ( me % prefix ) end if call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) call tem_stopTimer ( timerHandle = mus_timerHandles % loadMesh ) end subroutine mus_hvs_config_load ! ****************************************************************************** ! ! ****************************************************************************** ! !> This routines load solver data from config file except tracking subroutine mus_hvs_load_solverData ( scheme , solverData , geometry , params ) ! --------------------------------------------------------------------------- !> scheme type type ( mus_scheme_type ), target :: scheme !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target :: solverData !> Treelmesh data type ( mus_geom_type ), intent ( inout ), target :: geometry !> Global parameters type ( mus_param_type ), target , intent ( inout ) :: params ! --------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) ! load global musubi params call mus_load_param ( params = params , & & conf = params % general % solver % conf ( 1 ) ) ! load physics table for unit converstion call mus_load_physics ( me = params % physics , & & conf = params % general % solver % conf ( 1 ), & & tree = geometry % tree , & & scaleFactor = params % scaleFactor ) ! Load basic scheme information from the restart file call mus_load_scheme ( me = scheme , & & solverData = solverData , & & geometry = geometry , & & conf = params % general % solver % conf ( 1 ), & & params = params , & & isMusHvs = . true . ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_hvs_load_solverData ! ****************************************************************************** ! end module mus_hvs_config_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_hvs_config_module.f90.html"},{"title":"mus_moments_type_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_moments_type_module.f90~~AfferentGraph sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_hrrinit_module.f90 mus_hrrInit_module.f90 sourcefile~mus_hrrinit_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2014, 2018-2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module provides a data type for moment definition !! module mus_moments_type_module ! include treelm modules use env_module , only : labelLen use tem_matrix_module , only : tem_matrix_type implicit none private public :: mus_moment_type !> moment space definition type mus_moment_type !> is true if this type is already filled and no need !! to fill again after load balancing logical :: mom_ready = . false . !> transformation matrix from pdf space to moments type ( tem_matrix_type ) :: toMoments !> transformation matrix from moment space to pdf type ( tem_matrix_type ) :: toPDF !> Labels of the moments character ( len = labelLen ), allocatable :: momLabel (:) ! the followings are used by moment BCs !> position of first order moments in moments vector integer , allocatable :: first_moments (:) !> position of second order moments in moments vector integer , allocatable :: second_moments (:) !> position of third order moments in moments vector integer , allocatable :: third_moments (:) !> position of fourth order moments in moments vector integer , allocatable :: fourth_moments (:) end type mus_moment_type end module mus_moments_type_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_moments_type_module.f90.html"},{"title":"mus_comm_module.f90 – Musubi","text":"Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011, 2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2015-2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012-2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module provides the definition and methods for musubi-specific !! communication. !! It includes the wrapper functions for the actual communication, which is !! defined in [[tem_comm_module]]. !! module mus_comm_module ! include treelm modules use mpi use env_module , only : rk use tem_comm_module , only : tem_communication_type , tem_commpattern_type use tem_comm_env_module , only : tem_comm_env_type implicit none private ! public :: mus_exchange public :: mus_init_longBuffers contains ! **************************************************************************** ! !> Wrapper around the actual communication, to avoid copy-in, copy-out by the !! Intel compiler. (At least the intel compiler on pigeon (v12.0) seems to do !! copying here, if a sub-array is passed to an assumed size dummy argument. !! Therefore we use this wrapping with an assumed shape dummy argument, so we !! can pass a complete field to the actual exchange which has an assumed size !! argument, without copying complete state field around, just for !! communication. Ugly, but it doesn't seem to have an impact on performance, !! and right it seems to be the most suitable solution. !! ! subroutine mus_exchange(send, recv, state, pattern, level, comm) !   ! ------------------------------------------------------------------------ !   !> !   type(tem_communication_type), intent(inout) :: send !   !> !   type(tem_communication_type), intent(inout) :: recv !   !> !   real(kind=rk), intent(inout) :: state(:) !   !> !   type(tem_commPattern_type), intent(in) :: pattern !   !> !   integer :: level !   !> MPI communicator !   integer, intent(in) :: comm !   ! ------------------------------------------------------------------------ !   call pattern%exchange_real( send = send, recv = recv, state = state, & !     &                         message_flag = level, comm = comm        ) ! end subroutine mus_exchange ! **************************************************************************** ! ! **************************************************************************** ! !> Copy the element position in send and recv buffer to pos array !! in long type buffer !! subroutine mus_init_longBuffers ( comm , pattern ) ! -------------------------------------------------------------------------- !> type ( tem_communication_type ), intent ( inout ) :: comm !> type ( tem_commPattern_type ), intent ( in ) :: pattern ! -------------------------------------------------------------------------- integer :: iProc ! -------------------------------------------------------------------------- ! Allocate long buffers and initialize comm buffer if ( allocated ( comm % buf_long )) deallocate ( comm % buf_long ) allocate ( comm % buf_long ( comm % nProcs ) ) do iProc = 1 , comm % nProcs call pattern % initBuf_long ( me = comm % buf_long ( iProc ), & & pos = comm % elemPos ( iProc )% val , & & nVals = comm % nElemsProc ( iProc )) end do end subroutine mus_init_longBuffers ! **************************************************************************** ! end module mus_comm_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_comm_module.f90.html"},{"title":"mus_cumulantInit_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_cumulantinit_module.f90~~AfferentGraph sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2021 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module contains functions for initializing Cumulant relaxation paramaters !! author: Gregorio Gerardo Spinelli module mus_cumulantInit_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit implicit none private public :: cumulant_omega_check integer , parameter :: QQ = 27 !< number of pdf directions integer , parameter :: q000 = 27 contains ! ****************************************************************************** ! !> Checking the stability regions of omegas for the parametrized Cumulant !! Just omega(2) is given in input. omega(2)=-1 means omega2=omegaBulk. !! Limiters read from input. lim(N)=10&#94;10 means unlimited. !! lim(N) is for omega(N+2). Just omega(3:5) are limited as in the paper. !! omega(6:10) = 1._rk subroutine cumulant_omega_check ( omegaVisc , omegaBulk , omegaIn , nSolve , level ) ! -------------------------------------------------------------------- ! !> vector of omegas in the level real ( kind = rk ), intent ( in ) :: omegaVisc (:) !> omega bulk value in the level real ( kind = rk ), intent ( in ) :: omegaBulk !> vector of omegas as given in musubi.lua real ( kind = rk ), intent ( in ) :: omegaIn (:) !> number of elements solved in kernel integer , intent ( in ) :: nSolve !> current level integer , intent ( in ) :: level ! -------------------------------------------------------------------- ! real ( kind = rk ) :: omega ( 10 ), omegaPrev integer :: iElem ! tests to print WARNING just once for omega 1, 3, 4, 5 logical :: test ( 5 ) ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Level: ' , level test = . true . omega = omegaIn if ( omega ( 2 ) < 0._rk ) then ! this is omegabulk omega ( 2 ) = omegaBulk endif if ( omega ( 2 ) <= 0._rk . or . omega ( 2 ) >= 2._rk ) then write ( logUnit ( 1 ), * ) 'ERROR: Omega_2 is not in the admissible range: ' , omega ( 2 ) write ( logUnit ( 1 ), * ) 'Change bulk_viscosity value or give omega_2 = 1_rk as input' call tem_abort ( 'Please check omega_2 value' ) endif omegaPrev = - 100_rk nodeloop : do iElem = 1 , nSolve ! this is kinetic omega omega ( 1 ) = omegaVisc ( iElem ) if ( omega ( 1 ) == omegaPrev ) then CYCLE else omegaPrev = omega ( 1 ) endif if ( omega ( 1 ) <= 0._rk . or . omega ( 1 ) >= 2._rk ) then write ( logUnit ( 1 ), * ) 'ERROR: Omega_1 is not in the admissible range: ' , omega ( 1 ) call tem_abort ( 'Please check omega_1 value' ) endif if ( omega ( 1 ) == omega ( 2 ) ) then call tem_Abort ( 'omega(1) should not be equal to omega(2), please increase bulk_viscosity value' ) endif if ( omega ( 1 ) > 1.9995_rk . and . test ( 1 ) ) then test ( 1 ) = . false . write ( logUnit ( 1 ), * ) 'WARNING: Omega_1 is really close to the stability limit of 2' , omega ( 1 ) endif ! eq. 111 - 113 omega ( 3 ) = ( 8._rk * ( omega ( 1 ) - 2._rk ) * ( omega ( 2 ) * ( 3._rk * omega ( 1 ) - 1._rk ) & & - 5._rk * omega ( 1 ) ) ) / ( 8._rk * ( 5._rk - 2._rk * omega ( 1 )) * omega ( 1 ) & & + omega ( 2 ) * ( 8._rk + omega ( 1 ) * ( 9._rk * omega ( 1 ) - 2 6._rk ) ) ) if ( ( omega ( 3 ) <= 0._rk . or . omega ( 3 ) >= 2._rk ) . and . test ( 3 ) ) then test ( 3 ) = . false . write ( logUnit ( 1 ), * ) 'WARNING: Omega_3 is not in the admissible range: ' , omega ( 3 ) write ( logUnit ( 1 ), * ) 'A solution is to run \"cumulant\" as relaxation or try to set omega(2) = 1._rk' write ( logUnit ( 1 ), * ) 'or to increase the bulk_viscosity value' write ( logUnit ( 1 ), * ) 'The code internally switches to relaxation = \"cumulant\" for the troublesome element' !call tem_abort('Please check omega_3 value.') endif omega ( 4 ) = ( 8._rk * ( omega ( 1 ) - 2._rk ) * ( omega ( 1 ) + omega ( 2 ) * ( 3._rk * omega ( 1 ) & & - 7._rk ) ) ) / ( omega ( 2 ) * ( 5 6._rk - 4 2._rk * omega ( 1 ) + 9._rk * omega ( 1 ) ** 2 ) & & - 8._rk + omega ( 1 ) ) if ( ( omega ( 4 ) <= 0._rk . or . omega ( 4 ) >= 2._rk ) . and . test ( 4 ) ) then test ( 4 ) = . false . write ( logUnit ( 1 ), * ) 'WARNING: Omega_4 is not in the admissible range: ' , omega ( 4 ) write ( logUnit ( 1 ), * ) 'A solution is to run \"cumulant\" as relaxation or try to set omega(2) = 1._rk' write ( logUnit ( 1 ), * ) 'or to increase the bulk_viscosity value' write ( logUnit ( 1 ), * ) 'The code internally switches to relaxation = \"cumulant\" for the troublesome element' !call tem_abort('Please check omega_4 value.') endif omega ( 5 ) = ( 2 4._rk * ( omega ( 1 ) - 2._rk ) * ( 4._rk * omega ( 1 ) ** 2 + omega ( 1 ) & & * omega ( 2 ) * ( 1 8._rk - 1 3._rk * omega ( 1 ) ) + omega ( 2 ) ** 2 * ( 2._rk + omega ( 1 ) & & * ( 6._rk * omega ( 1 ) - 1 1._rk ) ) ) ) / ( 1 6._rk * omega ( 1 ) ** 2 * ( omega ( 1 ) - 6._rk ) & & - 2._rk * omega ( 1 ) * omega ( 2 ) * ( 21 6._rk + 5._rk * omega ( 1 ) * ( 9._rk * omega ( 1 ) & & - 4 6._rk ) ) + omega ( 2 ) ** 2 * ( omega ( 1 ) * ( 3._rk * omega ( 1 ) - 1 0._rk ) * ( 1 5._rk & & * omega ( 1 ) - 2 8._rk ) - 4 8._rk ) ) if ( ( omega ( 5 ) <= 0._rk . or . omega ( 5 ) >= 2._rk ) . and . test ( 5 ) ) then test ( 5 ) = . false . write ( logUnit ( 1 ), * ) 'WARNING: Omega_5 is not in the admissible range: ' , omega ( 5 ) write ( logUnit ( 1 ), * ) 'A solution is to run \"cumulant\" as relaxation or try to set omega(2) = 1._rk' write ( logUnit ( 1 ), * ) 'or to increase the bulk_viscosity value' write ( logUnit ( 1 ), * ) 'The code internally switches to relaxation = \"cumulant\" for the troublesome element' !call tem_abort('Please check omega_5 value.') endif end do nodeloop end subroutine cumulant_omega_check ! ****************************************************************************** ! end module mus_cumulantInit_module","tags":"","loc":"sourcefile/mus_cumulantinit_module.f90.html"},{"title":"mus_statistics_module.f90 – Musubi","text":"Source Code ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> In this module we collect routines  and type definitions related to !! statistics for the runtime of the code. !! !! module mus_statistics_module ! include treelm modules use mpi use tem_logging_module , only : logUnit implicit none private public :: mus_statistics_type public :: mus_calc_commAmount !> runtime statistics !! this includes memory consumption, amount of data to communciate, !! runtimes etc. type mus_statistics_type !> number of links to communicate !! Subset of nLinks_total integer :: nLinks_comm = 0 !> number of total links available which theoretically can be communciated integer :: nLinks_total = 0 !> Mean number of neighbor processes to which one process needs to send integer :: nProcs_send = 0 end type mus_statistics_type contains ! **************************************************************************** ! !> Calculate the number of links to be communicated !! subroutine mus_calc_commAmount ( stat , comm , nProcs ) ! -------------------------------------------------------------------------- !> runtime statistic type ( mus_statistics_type ), intent ( inout ) :: stat !> integer , intent ( in ) :: comm , nProcs ! -------------------------------------------------------------------------- integer :: iErr integer :: nLinks_comm , nLinks_total ! -------------------------------------------------------------------------- if ( nProcs > 1 ) then call mpi_reduce ( stat % nLinks_comm , nLinks_comm , 1 , mpi_integer , & & mpi_sum , 0 , comm , iErr ) call mpi_reduce ( stat % nLinks_total , nLinks_total , 1 , mpi_integer , & & mpi_sum , 0 , comm , iErr ) stat % nLinks_comm = nLinks_comm stat % nLinks_total = nLinks_total if ( nLinks_total > 0 ) then write ( logUnit ( 3 ), \"(A,I0)\" ) \"Amount of message per proc: \" , nLinks_comm & & / nProcs write ( logUnit ( 1 ), \"(A,F6.2)\" ) 'Communication amount compressed to [%]:' ,& & real ( nLinks_comm ) / real ( nLinks_total ) * 10 0.0 endif endif end subroutine mus_calc_commAmount ! **************************************************************************** ! end module mus_statistics_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_statistics_module.f90.html"},{"title":"mus_nernstPlanck_module.f90 – Musubi","text":"In this module the nernst_planck equation is considered.\nThe file type contains all relevant information.\nIt is a one dimensional case. This file depends on sourcefile~~mus_nernstplanck_module.f90~~EfferentGraph sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_nernstplanck_module.f90~~AfferentGraph sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **********************************************************************! !! In this module the nernst_planck equation is considered. !! The file type contains all relevant information. !! It is a one dimensional case. !> author: seyfettin bilgi module mus_nernstPlanck_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit , tem_toStr use aotus_module , only : flu_State , aot_get_val , aoterr_Fatal , & & aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use aot_out_module , only : aot_out_type , aot_out_val , & & aot_out_open_table , & & aot_out_close_table use mus_physics_module , only : mus_physics_type , faraday , gasConst_R implicit none private public :: mus_nernstPlanck_type public :: mus_load_nernstPlanck !> Contains configuration to calculate nernst_planck equation. !! More information can be found in !! A Coupled Lattice Boltzmann Method to Solve Nernst_Planck Model for !! simulating Electro-Osmatic Flows by Yang x., Shi B., Chai Z., Guo Z. type mus_nernstPlanck_type !> abosulte temperature in Kelvin real ( kind = rk ) :: temp !> Molar density of ions real ( kind = rk ) :: moleDens end type mus_nernstPlanck_type contains ! **************************************************************************** !> load input to solve nernst_planck equation subroutine mus_load_nernstPlanck ( me , conf , parent , physics ) !------------------------------------------------------------------------- !> nernst_planck type type ( mus_nernstPlanck_type ), intent ( out ) :: me !> flu state type ( flu_state ) :: conf !> parent handle integer , intent ( in ), optional :: parent !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !------------------------------------------------------------------------- integer :: NP_handle integer :: iError !------------------------------------------------------------------------- ! if nernst planck informations in scheme table parentHandle /= 0 if ( present ( parent ) ) then call aot_table_open ( L = conf , & & parent = parent , & & thandle = NP_handle , & & key = 'nernst_planck' ) else call aot_table_open ( L = conf , thandle = NP_handle , & & key = 'nernst_planck' ) end if if ( NP_handle == 0 ) then write ( logUnit ( 1 ), * ) 'No nernst_planck table defined' call tem_abort () end if write ( logUnit ( 1 ), * ) 'Loading nernst planck informations' ! load absolute temperature call aot_get_val ( L = conf , & & thandle = NP_handle , & & key = 'mole_density' , & & val = me % moleDens , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'WARNING: FATAL Error occured, while retrieving ' // & & 'mole_density:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if me % moleDens = me % moleDens / physics % moleDens0 ! load absolute temperature call aot_get_val ( L = conf , & & thandle = NP_handle , & & key = 'temp' , & & val = me % temp , & & default = 27 3._rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'WARNING: FATAL Error occured, while retrieving ' // & & 'temp:' write ( logUnit ( 3 ), * ) 'WARNING: Using default value 273 K' end if me % temp = me % temp / physics % temp0 call aot_table_close ( L = conf , thandle = NP_handle ) write ( logUnit ( 1 ), \"(A)\" ) 'Nernst_Planck properties:' write ( logUnit ( 1 ), \"(A)\" ) '  mole_density of solvent: ' & & // trim ( tem_toStr ( me % moleDens )) write ( logUnit ( 1 ), \"(A)\" ) '  temp: ' // trim ( tem_toStr ( me % temp )) end subroutine mus_load_nernstPlanck ! **************************************************************************** end module mus_nernstPlanck_module","tags":"","loc":"sourcefile/mus_nernstplanck_module.f90.html"},{"title":"mus_solSpecHelpers_module.f90 – Musubi","text":"Source Code ! Copyright (c) 2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013-2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Simon Zimny !! author: Kannan Masilmani !! author: Khaled Ibrahim !! This module provides MUSUBI specific helper functions for extracting !! information from the solver specific character. !! module mus_solSpecHelpers_module ! include treelm modules use env_module , only : rk , long_k , PathLen , labelLen use tem_variable_module , only : tem_variable_type use tem_stencil_module , only : tem_stencilHeader_type use tem_aux_module , only : tem_abort use tem_time_module , only : tem_time_type use tem_logging_module , only : logUnit ! include aotus modules use aotus_module , only : flu_State , aot_get_val use aot_table_module , only : aot_table_open , aot_table_close , aot_get_val implicit none private public :: getIdentifyChar public :: getNFields public :: getFieldPrefixes public :: getWeights public :: getFieldVariable public :: getConversionFac public :: getVariable_FromTable interface getFieldVariable module procedure getFieldVariable_scalar module procedure getFieldVariable_array end interface getFieldVariable contains ! ****************************************************************************** ! !             Helper Functions For The Solver Specific Character               ! ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get a character from the identify table using a given solver specific !! character handle and a given key word. !! function getIdentifyChar ( conf , key ) & & result ( resChar ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> key to search for character ( len =* ), intent ( in ) :: key !> scheme kind to be returned character ( len = labelLen ) resChar ! --------------------------------------------------------------------------- ! aotus handle and error variable integer :: identifyHandle integer :: iError ! --------------------------------------------------------------------------- call aot_table_open ( L = conf , thandle = identifyHandle , key = 'identify' ) call aot_get_val ( val = resChar , & & ErrCode = iError , & & L = conf , & & key = trim ( key ), & & thandle = identifyHandle , & & default = '' ) call aot_table_close ( L = conf , thandle = identifyHandle ) end function getIdentifyChar ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the value of variable inside the table name 'key' in scheme !! KM: @todo extent it for vectors function getVariable_FromTable ( conf , varLabel , table ) result ( val ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> complete variable label character ( len =* ), intent ( in ) :: varLabel !> table name character ( len =* ), intent ( in ) :: table !> val to be returned real ( kind = rk ) :: val ! --------------------------------------------------------------------------- ! aotus handles and error variables integer :: iError integer :: varHandle ! --------------------------------------------------------------------------- call aot_table_open ( L = conf , & & thandle = varHandle , & & key = trim ( table ) ) call aot_get_val ( val = val , & & ErrCode = iError , & & L = conf , & & key = trim ( varLabel ), & & thandle = varHandle , & & default = 0._rk ) ! close the table again call aot_table_close ( L = conf , thandle = varHandle ) end function getVariable_FromTable ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the number of fields from a given solver specific character handle. !! function getNFields ( conf ) & & result ( nFields ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> number of fields to be returned integer :: nFields ! --------------------------------------------------------------------------- ! aotus error variable integer :: iError ! --------------------------------------------------------------------------- ! read in nFields call aot_get_val ( val = nFields , & & ErrCode = iError , & & L = conf , & & key = 'nFields' ) end function getNFields ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the right field prefixes from a given solver specific character handle. !! function getFieldPrefixes ( conf , nFields ) & & result ( prefix ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf ! total number of fields defined integer , intent ( in ) :: nFields !> field prefixes to be returned character ( len = labelLen ) :: prefix ( nFields ) ! --------------------------------------------------------------------------- ! counter for field loop integer :: iField ! aotus handles and error variables integer :: prefixHandle integer :: iError ! --------------------------------------------------------------------------- ! open the fieldPrefix table call aot_table_open ( L = conf , & & thandle = prefixHandle , & & key = 'fieldPrefixes' ) do iField = 1 , nFields ! read the prefixes from the fieldPrefix table call aot_get_val ( val = prefix ( iField ), & & ErrCode = iError , & & L = conf , & & pos = iField , & & thandle = prefixHandle , & & default = '' ) end do call aot_table_close ( L = conf , thandle = prefixHandle ) end function getFieldPrefixes ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the field variable name for given field type from a given solver !! specific character handle. !! function getFieldVariable_scalar ( conf , varLabel , varName , fieldVar , & & fieldProp ) result ( val ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> complete variable label (prefix + pure variable name) character ( len =* ), intent ( in ) :: varLabel !> pure variable name (e.g. density) character ( len =* ), intent ( in ) :: varName !> required name of the field variable character ( len =* ), intent ( in ) :: fieldVar !> Which field type does the field variable belong to. !! Example: 'fluid'/'species' character ( len =* ), intent ( in ) :: fieldProp !> val to be returned real ( kind = rk ) :: val ! --------------------------------------------------------------------------- ! aotus handles and error variables integer :: iError integer :: fieldHandle , subHandle ! starting position of the pure variable name in varLabel integer :: pos ! prefix of the belonging field character ( len = labelLen ) :: prefix ! --------------------------------------------------------------------------- ! extract the prefix from the varLabel and open the belonging field table pos = INDEX ( trim ( varLabel ), trim ( varName )) prefix = trim ( varLabel ( 1 : pos - 1 )) call aot_table_open ( L = conf , & & thandle = fieldHandle , & & key = trim ( prefix ) // 'field' ) ! open the species table and extract omega call aot_table_open ( L = conf , & & thandle = subHandle , & & key = trim ( fieldProp ), & & parent = fieldHandle ) call aot_get_val ( val = val , & & ErrCode = iError , & & L = conf , & & key = trim ( fieldVar ), & & thandle = subHandle , & & default = 0._rk ) ! close the tables again call aot_table_close ( L = conf , thandle = subHandle ) call aot_table_close ( L = conf , thandle = fieldHandle ) end function getFieldVariable_scalar ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the field variable name for given field type from a given solver !! specific character handle. !! function getFieldVariable_array ( conf , varLabel , varName , fieldVar , & & fieldProp , nVals ) result ( val ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> complete variable label (prefix + pure variable name) character ( len =* ), intent ( in ) :: varLabel !> pure variable name (e.g. density) character ( len =* ), intent ( in ) :: varName !> required name of the field variable character ( len =* ), intent ( in ) :: fieldVar !> Which field type does the field variable belong to. !! Example: 'fluid'/'species' character ( len =* ), intent ( in ) :: fieldProp !> number of entries in the array to read out integer , intent ( in ) :: nVals !> val to be returned real ( kind = rk ) :: val ( nVals ) ! --------------------------------------------------------------------------- ! aotus handles and error variables integer :: iError ( nVals ) integer :: fieldHandle , subHandle ! starting position of the pure variable name in varLabel integer :: pos ! prefix of the belonging field character ( len = labelLen ) :: prefix real ( kind = rk ) :: def0 ( nVals ) ! --------------------------------------------------------------------------- ! extract the prefix from the varLabel and open the belonging field table def0 = 0.0_rk pos = INDEX ( trim ( varLabel ), trim ( varName )) prefix = trim ( varLabel ( 1 : pos - 1 )) call aot_table_open ( L = conf , & & thandle = fieldHandle , & & key = trim ( prefix ) // 'field' ) ! open the species table and extract omega call aot_table_open ( L = conf , & & thandle = subHandle , & & key = trim ( fieldProp ), & & parent = fieldHandle ) call aot_get_val ( val = val , & & ErrCode = iError , & & L = conf , & & default = def0 , & & key = trim ( fieldVar ), & & thandle = subHandle ) ! close the tables again call aot_table_close ( L = conf , thandle = subHandle ) call aot_table_close ( L = conf , thandle = fieldHandle ) end function getFieldVariable_array ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the the weights of a used stencil from a given solver specific !! character handle. !! function getWeights ( conf , stencil ) & & result ( weights ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> stencil information type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> weights to be returned real ( kind = rk ) :: weights ( stencil % QQ ) ! --------------------------------------------------------------------------- ! aotus error variable integer :: errCode ( stencil % QQ ) ! --------------------------------------------------------------------------- call aot_get_val ( val = weights , & & ErrCode = errCode , & & L = conf , & & key = 'weight' ) end function getWeights ! ****************************************************************************** ! ! ****************************************************************************** ! !> Get the conversion factor variable from physics table from a given solver !! specific character handle. !! function getConversionFac ( conf , facName , nLevels ) & & result ( val ) ! --------------------------------------------------------------------------- !> handle of the solver specific character type ( flu_state ), intent ( in ) :: conf !> conversion factor variable label character ( len =* ), intent ( in ) :: facName integer , intent ( in ) :: nLevels !> val to be returned real ( kind = rk ) :: val ( nLevels ) ! --------------------------------------------------------------------------- ! aotus handles and error variables integer :: iError integer :: phy_Handle , sub_Handle !> position of the phyiscs subtable for each level integer :: iLevel ! --------------------------------------------------------------------------- call aot_table_open ( L = conf , & & thandle = phy_Handle , & & key = 'physics' ) do iLevel = 1 , nLevels call aot_table_open ( L = conf , & & thandle = sub_Handle , & & parent = phy_Handle , & & pos = iLevel ) call aot_get_val ( val = val ( iLevel ), & & ErrCode = iError , & & L = conf , & & key = trim ( facName ), & & thandle = sub_Handle ) ! close the tables again call aot_table_close ( L = conf , thandle = sub_Handle ) end do call aot_table_close ( L = conf , thandle = phy_Handle ) if ( minval ( val ) < 0.0_rk ) then write ( logUnit ( 1 ), * ) 'Requested conversion factor variable name: ' // & & trim ( facName ) write ( logUnit ( 1 ), * ) 'by tracking is not well defined' call tem_abort () end if end function getConversionFac ! ****************************************************************************** ! end module mus_solSpecHelpers_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_solspechelpers_module.f90.html"},{"title":"mus_moments_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_moments_module.f90~~EfferentGraph sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_mrtinit_module.f90 mus_mrtInit_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_mrtinit_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_scheme_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_moments_module.f90~~AfferentGraph sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2013-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2013-2015, 2017-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! *************************************************************************** ! !> This module deals with the calculation of moments from pdfs !! module mus_moments_module ! include treelm modules use env_module , only : rk , labelLen use tem_aux_module , only : tem_abort use tem_math_module , only : invert_matrix use tem_logging_module , only : logUnit use tem_debug_module , only : dbgUnit use tem_matrix_module , only : tem_matrix_dump ! include musubi modules use mus_moments_type_module , only : mus_moment_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_mrtInit_module , only : MMtrD3Q19 , MMivD3Q19 , WMMIvD3Q27 , & & WMMtrD3Q27 implicit none private public :: get_moment public :: get_momentVector public :: mus_init_moments public :: set_momentIndices public :: mus_dump_moments contains ! **************************************************************************** ! !> Initialize the moment space !! subroutine mus_init_moments ( me , QQ , cxDir , label , schemeHeader ) ! -------------------------------------------------------------------------- type ( mus_moment_type ), intent ( inout ) :: me !> integer , intent ( in ) :: QQ integer , intent ( in ) :: cxDir ( 3 , QQ ) character ( len = labelLen ) :: label !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! -------------------------------------------------------------------------- logical :: momDefined ! -------------------------------------------------------------------------- ! if moments are already defined then do nothing if ( me % mom_ready ) return me % mom_ready = . true . write ( logUnit ( 1 ), \"(A)\" ) 'Initializing the moment matrix by stencil: ' & & // trim ( label ) ! Set both entries for the matrix to the stencil size (quadratic matrix) write ( logUnit ( 10 ), \"(A,I0)\" ) 'Set nEntries: ' , QQ me % toMoments % nEntries = QQ me % toPdf % nEntries = QQ write ( logUnit ( 10 ), \"(A,2I4)\" ) 'allocate toMoment: ' , & & me % toPdf % nEntries ( 1 ), me % toPdf % nEntries ( 2 ) if ( allocated ( me % toMoments % A ) ) deallocate ( me % toMoments % A ) if ( allocated ( me % toPdf % A ) ) deallocate ( me % toPdf % A ) allocate ( me % toMoments % A ( me % toMoments % nEntries ( 1 ), & & me % toMoments % nEntries ( 2 ) )) allocate ( me % toPdf % A ( me % toPdf % nEntries ( 1 ), me % toPdf % nEntries ( 2 ) )) ! Allocate and reset the moment labels write ( logUnit ( 10 ), \"(A,I0)\" ) 'allocate momLabel: ' , QQ if ( allocated ( me % momLabel )) deallocate ( me % momLabel ) allocate ( me % momLabel ( QQ )) me % momLabel = '' momDefined = . true . select case ( trim ( schemeHeader % kind )) case ( 'fluid' , 'fluid_incompressible' ) call init_transformation_matrix_fluid ( QQ , cxDir , label , me , & & me % toMoments % A , me % toPdf % A ) case ( 'multispecies_gas' , 'multispecies_liquid' ) call init_transformation_matrix_MS ( QQ , cxDir , label , me , me % toMoments % A ,& & me % toPdf % A ) case default write ( logUnit ( 1 ), * ) 'WARNING: Moments matrix is not defined for scheme ' & & // 'kind: ' // trim ( schemeHeader % kind ) momDefined = . false . end select ! Dump moments transformation matrix if ( momDefined ) call mus_dump_moments ( me , dbgUnit ( 10 )) end subroutine mus_init_moments ! **************************************************************************** ! ! **************************************************************************** ! !> Initialize Moments transformation matrix for LBM compressible and !! incompressible fluid model. This matrix must be consistent with the !! relaxation matrix used in compute kernel and interpolation routines subroutine init_transformation_matrix_fluid ( QQ , cxDir , label , me , toMoment , & & toPdf ) ! -------------------------------------------------------------------------- !> integer , intent ( in ) :: QQ integer , intent ( in ) :: cxDir ( 3 , QQ ) character ( len = labelLen ) :: label type ( mus_moment_type ), intent ( inout ) :: me real ( kind = rk ), intent ( inout ) :: toMoment ( me % toMoments % nEntries ( 1 ),& & me % toMoments % nEntries ( 2 ) ) real ( kind = rk ), intent ( inout ) :: toPdf ( me % toPDF % nEntries ( 1 ), & & me % toPDF % nEntries ( 2 ) ) ! -------------------------------------------------------------------------- real ( kind = rk ), dimension ( QQ ) :: uV , cx , cy , cz , cxsqr , cysqr , czsqr , csqr real ( kind = rk ) :: invMat ( me % toPDF % nEntries ( 1 ), me % toPDF % nEntries ( 2 ) ) real ( kind = rk ) :: transMat ( me % toPDF % nEntries ( 1 ), me % toPDF % nEntries ( 2 ) ) ! -------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'init transformation matrix' uV = 1.0_rk ! unit vector cx = get_momentVector ( QQ , cxDir , ( / 1 , 0 , 0 / )) cy = get_momentVector ( QQ , cxDir , ( / 0 , 1 , 0 / )) cz = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 1 / )) ! cx&#94;2 is cx.*cx element wise multiplication cxsqr = get_momentVector ( QQ , cxDir , ( / 2 , 0 , 0 / )) cysqr = get_momentVector ( QQ , cxDir , ( / 0 , 2 , 0 / )) czsqr = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 2 / )) ! Set the moments one after another on the matrix. ! The moment description might come from some place else. ! Lua? -> check mus_scheme_type_module the type(mus_momentSpace_type) select case ( trim ( label ) ) case ( 'd2q9' ) ! This moments are according to the paper ! Chen, S., Peng, C., Teng, Y., Wang, L. P., & Zhang, K. (2016). ! Improving lattice Boltzmann simulation of moving particles in a ! viscous flow using local grid refinement. Computers and Fluids, ! 136, 228–246. http://doi.org/10.1016/j.compfluid.2016.06.009 ! ! lattice velocity square csqr = cxsqr + cysqr me % momLabel ( 1 ) = 'density      ' ! rho = uV toMoment ( 1 ,:) = uV me % momLabel ( 2 ) = 'energy       ' ! e = -4 + 3(cx&#94;2+ cy&#94;2) toMoment ( 2 ,:) = - 4._rk * uV + 3._rk * csqr me % momLabel ( 3 ) = 'energy_square' ! e&#94;2 = 4 - 21/2 (cx&#94;2+cy&#94;2) !         +  9/2 (cx&#94;2+cy&#94;2)&#94;2 toMoment ( 3 ,:) = 4._rk * uV - 1 0.5_rk * csqr + 4.5_rk * csqr ** 2 me % momLabel ( 4 ) = 'momX         ' ! j_x = cx toMoment ( 4 ,:) = cx me % momLabel ( 5 ) = 'energy_fluxX ' ! q_x = (-5+3*(cx&#94;2+cy&#94;2))*cx toMoment ( 5 ,:) = ( - 5._rk * uV + 3._rk * csqr ) * cx me % momLabel ( 6 ) = 'momY         ' ! j_y = cy toMoment ( 6 ,:) = cy me % momLabel ( 7 ) = 'energy_fluxY ' ! q_y = (-5+3*(cx&#94;2+cy&#94;2))*cy toMoment ( 7 ,:) = ( - 5._rk * uV + 3._rk * csqr ) * cy me % momLabel ( 8 ) = 'normal_stress' ! p_xx = cx&#94;2-cy&#94;2 toMoment ( 8 ,:) = cxsqr - cysqr me % momLabel ( 9 ) = 'shear_stress ' ! p_xy = cx*cy toMoment ( 9 ,:) = cx * cy ! p_xy ! set moments positions !position of each moments pos in D2Q9, QQ,cxDir allocate ( me % first_moments ( 2 )) me % first_moments = ( / 4 , 6 / ) allocate ( me % second_moments ( 4 )) me % second_moments = ( / 2 , 3 , 8 , 9 / ) allocate ( me % third_moments ( 2 )) me % third_moments = ( / 5 , 7 / ) allocate ( me % fourth_moments ( 0 )) transMat = transpose ( toMoment ) invMat = invert_matrix ( matmul ( toMoment , transMat ) ) toPDF = matmul ( transMat , invMat ) case ( 'd3q15' ) ! D’Humières, D., Ginzburg, I., Krafczyk, M., Lallemand, P., & Luo, L.-S. ! (2002). Multiple-relaxation-time lattice Boltzmann models in three ! dimensions. Philosophical Transactions. Series A, Mathematical, ! Physical, and Engineering Sciences, 360(1792), 437–51. ! lattice velocity square csqr = cxsqr + cysqr + czsqr me % momLabel ( 1 ) = 'density        ' ! rho = 1.0_rk toMoment ( 1 ,:) = uV me % momLabel ( 2 ) = 'energy         ' toMoment ( 2 ,:) = csqr - 2.0_rk * uV me % momLabel ( 3 ) = 'enegry_square  ' toMoment ( 3 ,:) = ( 1 5._rk * csqr ** 2 - 5 5._rk * csqr + 3 2._rk * uV ) * 0.5_rk me % momLabel ( 4 ) = 'momX           ' toMoment ( 4 ,:) = cx me % momLabel ( 5 ) = 'energy_fluxX   ' toMoment ( 5 ,:) = ( 5._rk * csqr - 1 3._rk * uV ) * cx * 0.5_rk me % momLabel ( 6 ) = 'momY           ' toMoment ( 6 ,:) = cy me % momLabel ( 7 ) = 'energy_fluxY   ' toMoment ( 7 ,:) = ( 5._rk * csqr - 1 3._rk ) * cy * 0.5_rk me % momLabel ( 8 ) = 'momZ           ' toMoment ( 8 ,:) = cz me % momLabel ( 9 ) = 'energy_fluxZ' toMoment ( 9 ,:) = ( 5._rk * csqr - 1 3._rk ) * cz * 0.5_rk me % momLabel ( 10 ) = 'normal_stress_1' toMoment ( 10 ,:) = 3._rk * cxsqr - csqr me % momLabel ( 11 ) = 'normal_stress_2' toMoment ( 11 ,:) = cysqr - czsqr me % momLabel ( 12 ) = 'shear_stress_XY' toMoment ( 12 ,:) = cx * cy me % momLabel ( 13 ) = 'shear_stress_YZ' toMoment ( 13 ,:) = cy * cz me % momLabel ( 14 ) = 'shear_stress_XZ' toMoment ( 14 ,:) = cx * cz me % momLabel ( 15 ) = 'mXYZ' toMoment ( 15 ,:) = cx * cy * cz ! set moments positions !position of each moments pos in D3Q15 layout allocate ( me % first_moments ( 3 )) me % first_moments = ( / 4 , 6 , 8 / ) allocate ( me % second_moments ( 5 )) me % second_moments = ( / 10 , 11 , 12 , 13 , 14 / ) allocate ( me % third_moments ( 5 )) me % third_moments = ( / 2 , 3 , 5 , 7 , 9 / ) allocate ( me % fourth_moments ( 1 )) me % fourth_moments = ( / 15 / ) transMat = transpose ( toMoment ) invMat = invert_matrix ( matmul ( toMoment , transMat ) ) toPDF = matmul ( transMat , invMat ) case ( 'd3q19' ) ! This moments are according to the paper ! Tölke, J., Freudiger, S., & Krafczyk, M. (2006). ! An adaptive scheme using hierarchical grids for lattice Boltzmann ! multi-phase flow simulations. Computers & Fluids, 35(8–9), 820–830. toMoment = MMtrD3Q19 toPDF = MMIvD3Q19 ! c2 = cx&#94;2+cy&#94;2+cz&#94;2 me % momLabel ( 1 ) = 'density        ' ! rho = uV me % momLabel ( 2 ) = 'energy         ' ! csqr - 1 me % momLabel ( 3 ) = 'enegry_square  ' ! 3*c2&#94;2 - 6*c2 + 1 me % momLabel ( 4 ) = 'momX           ' ! cx me % momLabel ( 5 ) = 'energy_fluxX   ' ! (3*c2 - 5)*cx me % momLabel ( 6 ) = 'momY           ' ! cy me % momLabel ( 7 ) = 'energy_fluxY   ' ! (3*c2 - 5)*cy me % momLabel ( 8 ) = 'momZ           ' ! cz me % momLabel ( 9 ) = 'energy_fluxZ' ! (3*c2 - 5)*cz me % momLabel ( 10 ) = 'normal_stress_1' ! 3*cx&#94;2 - c2 me % momLabel ( 11 ) = '2ndOrd_energy_1' ! (2*c2 - 3*uV)*(3*cx&#94;2-c2) me % momLabel ( 12 ) = 'normal_stress_2' ! cy&#94;2 - cz&#94;2 me % momLabel ( 13 ) = '2ndOrd_energy_2' ! (2*c2 - 3*uV)*(cy&#94;2-cz&#94;2) me % momLabel ( 14 ) = 'shear_stress_XY' ! cx * cy me % momLabel ( 15 ) = 'shear_stress_YZ' ! cy * cz me % momLabel ( 16 ) = 'shear_stress_XZ' ! cx * cz me % momLabel ( 17 ) = '3rdOrd_tensor_1' ! (cy&#94;2 - cz&#94;2)*cx me % momLabel ( 18 ) = '3rdOrd_tensor_2' ! (cz&#94;2 - cx&#94;2)*cy me % momLabel ( 19 ) = '3rdOrd_tensor_3' ! (cx&#94;2 - cy&#94;2)*cz ! set moments positions !position of each moments pos in D3Q19 layout allocate ( me % first_moments ( 3 )) me % first_moments = ( / 4 , 6 , 8 / ) allocate ( me % second_moments ( 7 )) me % second_moments = ( / 2 , 3 , 10 , 12 , 14 , 15 , 16 / ) allocate ( me % third_moments ( 6 )) me % third_moments = ( / 5 , 7 , 9 , 17 , 18 , 19 / ) allocate ( me % fourth_moments ( 2 )) me % fourth_moments = ( / 11 , 13 / ) case ( 'd3q27' ) toMoment = WMMtrD3Q27 toPDF = WMMIvD3Q27 ! c2 = cx&#94;2+cy&#94;2+cz&#94;2 ! density me % momLabel ( 1 ) = 'density        ' ! rho = uV ! momentum me % momLabel ( 2 ) = 'momX           ' ! j_x = cx me % momLabel ( 3 ) = 'momY           ' ! j_y = cy me % momLabel ( 4 ) = 'momZ           ' ! j_z = cz ! second order tensor me % momLabel ( 5 ) = 'shear_stress_XY' ! p_xy = cx*cy me % momLabel ( 6 ) = 'shear_stress_YZ' ! p_yz = cy*cz me % momLabel ( 7 ) = 'shear_stress_XZ' ! p_xz = cx*cz me % momLabel ( 8 ) = 'normal_stress_1' ! p_xx = 3*cx&#94;2-c2 me % momLabel ( 9 ) = 'normal_stress_2' ! p_ww = cy&#94;2-cz&#94;2 ! kinetic energy me % momLabel ( 10 ) = 'kinetic_energy ' ! e = c2-1 ! fluxes of energy me % momLabel ( 11 ) = 'energy_flux_X  ' ! q_x = (3*c2-5)*cx me % momLabel ( 12 ) = 'energy_flux_Y  ' ! q_y = (3*c2-5)*cy me % momLabel ( 13 ) = 'energy_flux_Z  ' ! q_z = (3*c2-5)*cz ! third order pseudo-vector me % momLabel ( 14 ) = '3rdOrd_tensor_1' ! tau_x = (cy&#94;2-cz&#94;2)*cx me % momLabel ( 15 ) = '3rdOrd_tensor_2' ! tau_y = (cz&#94;2-cx&#94;2)*cy me % momLabel ( 16 ) = '3rdOrd_tensor_3' ! tau_z = (cx&#94;2-cy&#94;2)*cz ! antisymmetric tensor me % momLabel ( 17 ) = 'mXYZ' ! XYZ = cx*cy*cz ! square energy me % momLabel ( 18 ) = 'square_energy  ' ! eps = 0.5*(3*c2&#94;2-7*c2+2) ! product of the second order tensor and the energy me % momLabel ( 19 ) = '2ndOrd_tensor_1' ! XXe = (3*c2-4)*(3*cx&#94;2-c2) me % momLabel ( 20 ) = '2ndOrd_tensor_2' ! WWe = (3*c2-4)*(cy&#94;2-cz) me % momLabel ( 21 ) = '2ndOrd_tensor_3' ! XYe = (cx*cy)*(3*c2-7) me % momLabel ( 22 ) = '2ndOrd_tensor_4' ! YZe = (cy*cz)*(3*c2-7) me % momLabel ( 23 ) = '2ndOrd_tensor_5' ! XZe = (cz*cx)*(3*c2-7) ! fluxes of square of energy me % momLabel ( 24 ) = '2ndOrd_energy_X' ! qsqr_x = 0.5*cx*(9*c2&#94;2-33*c2+26) me % momLabel ( 25 ) = '2ndOrd_energy_Y' ! qsqr_y = 0.5*cy*(9*c2&#94;2-33*c2+26) me % momLabel ( 26 ) = '2ndOrd_energy_Z' ! qsqr_z = 0.5*cz*(9*c2&#94;2-33*c2+26) ! cube energy me % momLabel ( 27 ) = 'cube_energy    ' ! e3 = 0.5*(9*c2&#94;3-36*c2&#94;2+33*c2-2) ! set moments positions !position of each moments pos in D3Q19 layout allocate ( me % first_moments ( 3 )) me % first_moments = ( / 2 , 3 , 4 / ) allocate ( me % second_moments ( 6 )) me % second_moments = ( / 5 , 6 , 7 , 8 , 9 , 10 / ) allocate ( me % third_moments ( 6 )) me % third_moments = ( / 11 , 12 , 13 , 24 , 25 , 26 / ) allocate ( me % fourth_moments ( 11 )) me % fourth_moments = ( / 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 27 / ) end select end subroutine init_transformation_matrix_fluid ! **************************************************************************** ! ! **************************************************************************** ! !> Intialize the moment transformation matrix for multispecies. !! This matrix must be consistent with relaxation matrix used for !! multispecies MRT collision routines subroutine init_transformation_matrix_MS ( QQ , cxDir , label , me , toMoment , & & toPdf ) ! -------------------------------------------------------------------------- !> integer , intent ( in ) :: QQ integer , intent ( in ) :: cxDir ( 3 , QQ ) character ( len = labelLen ) :: label type ( mus_moment_type ), intent ( inout ) :: me real ( kind = rk ), intent ( inout ) :: toMoment ( me % toMoments % nEntries ( 1 ),& & me % toMoments % nEntries ( 2 ) ) real ( kind = rk ), intent ( inout ) :: toPdf ( me % toPDF % nEntries ( 1 ), & & me % toPDF % nEntries ( 2 ) ) ! -------------------------------------------------------------------------- logical :: requireMom ! -------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'init transformation matrix' ! require moments for stencil requireMom = . true . ! Set the moments one after another on the matrix. ! The moment description might come from some place else. ! Lua? -> check mus_scheme_type_module the type(mus_momentSpace_type) select case ( trim ( label ) ) case ( 'd2q9' ) me % momLabel ( 1 ) = 'density' toMoment ( 1 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 0 / )) ! m0 me % momLabel ( 2 ) = 'momX' toMoment ( 2 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 0 , 0 / )) ! mx me % momLabel ( 3 ) = 'momY' toMoment ( 3 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 1 , 0 / )) ! my me % momLabel ( 4 ) = 'momXX' toMoment ( 4 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 0 , 0 / )) ! mxx me % momLabel ( 5 ) = 'momYY' toMoment ( 5 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 2 , 0 / )) ! myy me % momLabel ( 6 ) = 'momXY' toMoment ( 6 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 1 , 0 / )) ! mxy me % momLabel ( 7 ) = 'momXXY' toMoment ( 7 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 1 , 0 / )) ! mxxy me % momLabel ( 8 ) = 'momXYY' toMoment ( 8 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 2 , 0 / )) ! mxyy me % momLabel ( 9 ) = 'momXXYY' toMoment ( 9 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 2 , 0 / )) ! mxxyy ! set moments positions !position of each moments pos in D3Q19 QQ,cxDir allocate ( me % first_moments ( 2 )) me % first_moments = ( / 1 , 2 / ) allocate ( me % second_moments ( 3 )) me % second_moments = ( / 1 , 2 , 4 / ) allocate ( me % third_moments ( 2 )) me % third_moments = ( / 1 , 3 / ) allocate ( me % fourth_moments ( 1 )) me % fourth_moments = ( / 1 / ) case ( 'd2q9_reference' ) toMoment ( 1 ,:) = ( / 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk / ) toMoment ( 2 ,:) = ( /- 1._rk , 0._rk , 1._rk , 0._rk , - 1._rk , & & - 1._rk , 1._rk , 1._rk , 0._rk / ) toMoment ( 3 ,:) = ( / 0._rk , - 1._rk , 0._rk , 1._rk , - 1._rk , & & 1._rk , - 1._rk , 1._rk , 0._rk / ) toMoment ( 4 ,:) = ( / 1._rk , 0._rk , 1._rk , 0._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 0._rk / ) toMoment ( 5 ,:) = ( / 0._rk , 1._rk , 0._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 0._rk / ) toMoment ( 6 ,:) = ( / 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , & & - 1._rk , - 1._rk , 1._rk , 0._rk / ) toMoment ( 7 ,:) = ( / 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & 1._rk , - 1._rk , 1._rk , 0._rk / ) toMoment ( 8 ,:) = ( / 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & - 1._rk , 1._rk , 1._rk , 0._rk / ) toMoment ( 9 ,:) = ( / 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 0._rk / ) ! set moments positions !position of each moments pos in D3Q19 QQ,cxDir allocate ( me % first_moments ( 2 )) allocate ( me % second_moments ( 3 )) allocate ( me % third_moments ( 2 )) allocate ( me % fourth_moments ( 1 )) me % first_moments = ( / 1 , 2 / ) me % second_moments = ( / 1 , 2 , 4 / ) me % third_moments = ( / 1 , 3 / ) me % fourth_moments = ( / 1 / ) case ( 'd3q19' ) me % momLabel ( 1 ) = 'density' toMoment ( 1 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 0 / )) ! m0 me % momLabel ( 2 ) = 'momX   ' toMoment ( 2 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 0 , 0 / )) ! mx me % momLabel ( 3 ) = 'momY   ' toMoment ( 3 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 1 , 0 / )) ! my me % momLabel ( 4 ) = 'momZ   ' toMoment ( 4 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 1 / )) ! mz me % momLabel ( 5 ) = 'momXX  ' toMoment ( 5 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 0 , 0 / )) ! mxx me % momLabel ( 6 ) = 'momYY  ' toMoment ( 6 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 2 , 0 / )) ! myy me % momLabel ( 7 ) = 'momZZ  ' toMoment ( 7 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 0 , 2 / )) ! mzz me % momLabel ( 8 ) = 'momXY  ' toMoment ( 8 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 1 , 0 / )) ! mxy me % momLabel ( 9 ) = 'momYZ  ' toMoment ( 9 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 1 , 1 / )) ! myz me % momLabel ( 10 ) = 'momXZ' toMoment ( 10 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 0 , 1 / )) ! mzx me % momLabel ( 11 ) = 'momXXY ' toMoment ( 11 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 1 , 0 / )) ! mxxy me % momLabel ( 12 ) = 'momXXZ ' toMoment ( 12 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 0 , 1 / )) ! mxxz me % momLabel ( 13 ) = 'momYYX ' toMoment ( 13 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 2 , 0 / )) ! myyx me % momLabel ( 14 ) = 'momYYZ ' toMoment ( 14 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 2 , 1 / )) ! myyz me % momLabel ( 15 ) = 'momZZX ' toMoment ( 15 ,:) = get_momentVector ( QQ , cxDir , ( / 1 , 0 , 2 / )) ! mzzx me % momLabel ( 16 ) = 'momZZY ' toMoment ( 16 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 1 , 2 / )) ! mzzy me % momLabel ( 17 ) = 'momXXYY' toMoment ( 17 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 2 , 0 / )) ! mxxyy me % momLabel ( 18 ) = 'momYYZZ' toMoment ( 18 ,:) = get_momentVector ( QQ , cxDir , ( / 0 , 2 , 2 / )) ! myyzz me % momLabel ( 19 ) = 'momZZXX' toMoment ( 19 ,:) = get_momentVector ( QQ , cxDir , ( / 2 , 0 , 2 / )) ! mzzxx ! set moments positions !position of each moments pos in D3Q19 layout allocate ( me % first_moments ( 3 )) me % first_moments = ( / 1 , 2 , 3 / ) allocate ( me % second_moments ( 6 )) me % second_moments = ( / 1 , 2 , 3 , 4 , 5 , 6 / ) allocate ( me % third_moments ( 6 )) me % third_moments = ( / 1 , 2 , 3 , 4 , 5 , 6 / ) allocate ( me % fourth_moments ( 3 )) me % fourth_moments = ( / 1 , 2 , 3 / ) case ( 'd3q27' ) me % momLabel ( 1 ) = 'density' toMoment ( 1 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 0 , 0 ]) ! m0 me % momLabel ( 2 ) = 'momX   ' toMoment ( 2 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 0 , 0 ]) ! mx me % momLabel ( 3 ) = 'momY   ' toMoment ( 3 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 1 , 0 ]) ! my me % momLabel ( 4 ) = 'momZ   ' toMoment ( 4 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 0 , 1 ]) ! mz me % momLabel ( 5 ) = 'momXX  ' toMoment ( 5 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 0 , 0 ]) ! mxx me % momLabel ( 6 ) = 'momYY  ' toMoment ( 6 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 2 , 0 ]) ! myy me % momLabel ( 7 ) = 'momZZ  ' toMoment ( 7 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 0 , 2 ]) ! mzz me % momLabel ( 8 ) = 'momXY  ' toMoment ( 8 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 1 , 0 ]) ! mxy me % momLabel ( 9 ) = 'momYZ  ' toMoment ( 9 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 1 , 1 ]) ! myz me % momLabel ( 10 ) = 'momXZ' toMoment ( 10 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 0 , 1 ]) ! mzx toMoment ( 11 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 1 , 0 ]) ! mxxy toMoment ( 12 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 0 , 1 ]) ! mxxz toMoment ( 13 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 2 , 0 ]) ! mxyy toMoment ( 14 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 2 , 1 ]) ! myyz toMoment ( 15 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 0 , 2 ]) ! mxzz toMoment ( 16 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 1 , 2 ]) ! myzz toMoment ( 17 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 1 , 1 ]) ! mxyz toMoment ( 18 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 2 , 0 ]) ! mxxyy toMoment ( 19 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 0 , 2 ]) ! mxxzz toMoment ( 20 ,:) = get_momentVector ( QQ , cxDir , [ 0 , 2 , 2 ]) ! myyzz toMoment ( 21 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 1 , 1 ]) ! mxxyz toMoment ( 22 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 2 , 1 ]) ! mxyyz toMoment ( 23 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 1 , 2 ]) ! mxyzz toMoment ( 24 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 2 , 1 ]) ! mxxyyz toMoment ( 25 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 1 , 2 ]) ! mxxyzz toMoment ( 26 ,:) = get_momentVector ( QQ , cxDir , [ 1 , 2 , 2 ]) ! mxyyzz toMoment ( 27 ,:) = get_momentVector ( QQ , cxDir , [ 2 , 2 , 2 ]) ! mxxyyzz case default requireMom = . false . end select if ( requireMom ) then toPdf = invert_matrix ( toMoment ) end if end subroutine init_transformation_matrix_MS ! **************************************************************************** ! ! **************************************************************************** ! !> The integer moment vector for a given cxDir and order. !! !! Assuming 0**0 = 1 here. !! pure function mus_iMomVector ( cxDir , expX , QQ ) result ( iMom ) ! -------------------------------------------------------------------------- !> number of velocity channels (include rest) integer , intent ( in ) :: QQ !> discrete velocity integer , intent ( in ) :: cxDir (:,:) !> order in each direction integer , intent ( in ) :: expX ( 3 ) !> integer :: iMom ( QQ ) ! -------------------------------------------------------------------------- integer :: nIndices integer :: iVal integer :: iX integer :: X_idx ( 3 ) integer :: xx ( 3 ) ! -------------------------------------------------------------------------- nIndices = 0 do iX = 1 , 3 if ( expX ( iX ) > 0 ) then nIndices = nIndices + 1 X_idx ( nIndices ) = iX xx ( nIndices ) = expX ( iX ) end if end do select case ( nIndices ) case ( 0 ) imom = 1 case ( 1 ) do iVal = 1 , QQ imom ( iVal ) = cxDir ( X_idx ( 1 ), iVal ) ** xx ( 1 ) end do case ( 2 ) do iVal = 1 , QQ imom ( iVal ) = cxDir ( X_idx ( 1 ), iVal ) ** xx ( 1 ) & & * cxDir ( X_idx ( 2 ), iVal ) ** xx ( 2 ) end do case ( 3 ) do iVal = 1 , QQ imom ( iVal ) = cxDir ( 1 , iVal ) ** xx ( 1 ) & & * cxDir ( 2 , iVal ) ** xx ( 2 ) & & * cxDir ( 3 , iVal ) ** xx ( 3 ) end do end select end function mus_iMomVector ! **************************************************************************** ! ! **************************************************************************** ! !> Calculate the moment of a centain order !! The moment of a distribution  f_i  is defined as:\\n !!  !!    m_{x&#94;{p}y&#94;{q}z&#94;{r}} = \\sum_{i}&#94;{Q} c&#94;{p}_{xi} c&#94;{q}_{yi} c&#94;{r}_{zi} f_i !!  !! The fucntion argument `expX` is array of size 3, !! which contains the values of \\f$p, q, r\\f$ !! pure function get_moment ( QQ , cxDir , expX , pdf ) result ( mom ) ! -------------------------------------------------------------------------- integer , intent ( in ) :: QQ !> distribution value real ( kind = rk ), intent ( in ) :: pdf ( QQ ) !> integer , intent ( in ) :: cxDir ( 3 , QQ ) integer , intent ( in ) :: expX ( 3 ) !< exponents of the moments real ( kind = rk ) :: mom !< moment ! -------------------------------------------------------------------------- !HK: assuming 0**0 should be 1 here mom = sum ( pdf * get_momentVector ( QQ , cxDir , expX ) ) end function get_moment ! **************************************************************************** ! ! **************************************************************************** ! !> get the moment vector to calculate the moment from the pdf !! pure function get_momentVector ( QQ , cxDir , expX ) result ( mom ) ! -------------------------------------------------------------------------- !> integer , intent ( in ) :: QQ integer , intent ( in ) :: cxDir ( 3 , QQ ) !> exponents of the moments integer , intent ( in ) :: expX ( 3 ) !> moment vector real ( kind = rk ) :: mom ( QQ ) ! -------------------------------------------------------------------------- !HK: assuming 0**0 should be 1 here Mom = real ( mus_iMomVector ( cxDir = cxDir , & & expX = expX , & & QQ = QQ ), kind = rk ) end function get_momentVector ! **************************************************************************** ! ! **************************************************************************** ! !> set indices for accessing the pressure, velocity and the shear from a 1d !! vector !! subroutine set_momentIndices ( nDims , iPress , iVelMin , iVelMax , iSMin , iSMax ) ! -------------------------------------------------------------------------- !> number of dimensions integer , intent ( in ) :: nDims !> index for the pressure / density integer , intent ( out ) :: iPress !> starting index for velocity integer , intent ( out ) :: iVelMin !> ending index for velocity integer , intent ( out ) :: iVelMax !> starting index for shear integer , intent ( out ) :: iSMin !> ending index for shear integer , intent ( out ) :: iSMax ! -------------------------------------------------------------------------- ! Pressure / density is always first entry iPress = 1 ! Indices from where / to where to read / store the velocity quantities iVelMin = 2 iVelMax = nDims + 1 ! Indices from where / to where to read / store the stress   quantities iSMin = iVelMax + 1 iSMax = iSMin + max ( 3 * ( nDims - 1 ) - 1 , 0 ) end subroutine set_momentIndices ! **************************************************************************** ! ! **************************************************************************** ! !> Dump moments matrix: toPDF and toMoment subroutine mus_dump_moments ( me , outUnit ) ! -------------------------------------------------------------------------- type ( mus_moment_type ), intent ( in ) :: me integer , intent ( in ) :: outUnit ! -------------------------------------------------------------------------- write ( outUnit , \"(A)\" ) ' toMoment: ' call tem_matrix_dump ( me % toMoments , outUnit ) write ( outUnit , * ) write ( outUnit , \"(A)\" ) ' toPDF: ' call tem_matrix_dump ( me % toPDF , outUnit ) end subroutine mus_dump_moments ! **************************************************************************** ! end module mus_moments_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_moments_module.f90.html"},{"title":"mus_hrrInit_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_hrrinit_module.f90~~EfferentGraph sourcefile~mus_hrrinit_module.f90 mus_hrrInit_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_hrrinit_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Gregorio Gerardo Spinelli !! This module provides the definitions of M and Minv for !! MRT advection relaxation scheme for all stencils. !! !! The weighted MRT (D3Q27) is based on the following paper !! Abbas Fakhari, Diogo Bolster, Li-Shi Luo !! \"A weighted multiple-relaxation-time lattice Boltzmann method for multiphase !! flows and its application to partial coalescence cascades\" !! Journal of Computational Physics, 2017 !! !! The MRT (D3Q19) implementation here is taken from:\\n !! J. Toelke, S. Freudiger, and M. Krafczyk, !! \"An adaptive scheme using hierarchical grids for lattice Boltzmann !! multi-phase flow simulations,\" Comput. Fluids, vol. 35, pp. 820–830, !! 2006. \\n module mus_hrrInit_module ! include treelm modules use env_module , only : rk use tem_param_module , only : div1_6 , div1_3 , div1_2 , cs4inv , cs2 use tem_debug_module , only : dbgUnit use tem_aux_module , only : tem_abort use mus_scheme_layout_module , only : mus_scheme_layout_type implicit none private public :: HRR_Correction_d2q9 public :: HRR_Correction_d3q19 public :: HRR_Correction_d3q27 public :: getHermitepolynomials public :: getHermitepolynomials_D3Q19 contains ! ****************************************************************************** ! ! based on Lattice Boltzmann Method with regularized non-equilibrium distribution ! functions, Jonas Latt and Bastien Chopard 2005 pure subroutine HRR_Correction_d2q9 ( QQ , weight , gradRHOU3 , phi , & & dens , vel ) ! -------------------------------------------------------------------- ! !> stencil size integer , intent ( in ) :: QQ !> weights of the stencil real ( kind = rk ), intent ( in ) :: weight (:) !> gradient rho V&#94;3 real ( kind = rk ), intent ( in ) :: gradRHOU3 (:) !> correction term phi real ( kind = rk ), intent ( out ) :: phi (:) !> correction term phi, rho, vel real ( kind = rk ), intent ( out ) :: dens , vel (:) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: phi_temp ! -------------------------------------------------------------------- ! dens = 0._rk vel (:) = 0._rk !iDir = 1 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 1 ) & & + gradRHOU3 ( 2 ) ) phi ( 1 ) = weight ( 1 ) * phi_temp dens = dens + phi ( 1 ) vel ( 1 ) = vel ( 1 ) - phi ( 1 ) !vel(2) = vel(2) + 0._rk !iDir = 3 phi ( 3 ) = weight ( 3 ) * phi_temp dens = dens + phi ( 3 ) vel ( 1 ) = vel ( 1 ) + phi ( 3 ) !vel(2) = vel(2) + 0._rk !iDir = 2 phi_temp = div1_6 * cs4inv * ( gradRHOU3 ( 1 ) & & - 2._rk * gradRHOU3 ( 2 ) ) phi ( 2 ) = weight ( 2 ) * phi_temp dens = dens + phi ( 2 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 2 ) !iDir = 4 phi ( 4 ) = weight ( 4 ) * phi_temp dens = dens + phi ( 4 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 4 ) !iDir = 5 phi_temp = div1_3 * cs4inv * ( - gradRHOU3 ( 1 ) & & - gradRHOU3 ( 2 ) ) phi ( 5 ) = weight ( 5 ) * phi_temp dens = dens + phi ( 5 ) vel ( 1 ) = vel ( 1 ) - phi ( 5 ) vel ( 2 ) = vel ( 2 ) - phi ( 5 ) !iDir = 8 phi ( 8 ) = weight ( 8 ) * phi_temp dens = dens + phi ( 8 ) vel ( 1 ) = vel ( 1 ) + phi ( 8 ) vel ( 2 ) = vel ( 2 ) + phi ( 8 ) !iDir = 6 phi ( 6 ) = weight ( 6 ) * phi_temp dens = dens + phi ( 6 ) vel ( 1 ) = vel ( 1 ) - phi ( 6 ) vel ( 2 ) = vel ( 2 ) + phi ( 6 ) !iDir = 7 phi ( 7 ) = weight ( 7 ) * phi_temp dens = dens + phi ( 7 ) vel ( 1 ) = vel ( 1 ) + phi ( 7 ) vel ( 2 ) = vel ( 2 ) - phi ( 7 ) !iDir = 9 phi_temp = - div1_2 * phi_temp phi ( 9 ) = weight ( 9 ) * phi_temp dens = dens + phi ( 9 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk end subroutine HRR_Correction_d2q9 ! ****************************************************************************** ! ! ****************************************************************************** ! ! based on Lattice Boltzmann Method with regularized non-equilibrium distribution ! functions, Jonas Latt and Bastien Chopard 2005 pure subroutine HRR_Correction_d3q19 ( QQ , weight , gradRHOU3 , & & gradRHOUVZ , phi , dens , vel ) ! -------------------------------------------------------------------- ! !> stencil size integer , intent ( in ) :: QQ !> weights of the stencil real ( kind = rk ), intent ( in ) :: weight (:) !> gradient rho u&#94;3, rho u v w real ( kind = rk ), intent ( in ) :: gradRHOU3 (:) real ( kind = rk ), intent ( in ) :: gradRHOUVZ (:) !> correction term phi, rho, vel real ( kind = rk ), intent ( out ) :: phi (:), dens , vel (:) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: phi_temp ! -------------------------------------------------------------------- ! dens = 0._rk vel (:) = 0._rk !iDir = 1 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 1 ) & & + gradRHOU3 ( 2 ) + gradRHOU3 ( 3 ) ) phi ( 1 ) = weight ( 1 ) * phi_temp dens = dens + phi ( 1 ) vel ( 1 ) = vel ( 1 ) - phi ( 1 ) !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk !iDir = 4 phi ( 4 ) = weight ( 4 ) * phi_temp dens = dens + phi ( 4 ) vel ( 1 ) = vel ( 1 ) + phi ( 4 ) !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk !iDir = 2 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 2 ) & & + gradRHOU3 ( 1 ) + gradRHOU3 ( 3 ) ) phi ( 2 ) = weight ( 2 ) * phi_temp dens = dens + phi ( 2 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 2 ) !vel(3) = vel(3) + 0._rk !iDir = 5 phi ( 5 ) = weight ( 5 ) * phi_temp dens = dens + phi ( 5 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 5 ) !vel(3) = vel(3) + 0._rk !iDir = 3 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 3 ) & & + gradRHOU3 ( 1 ) + gradRHOU3 ( 2 ) ) phi ( 3 ) = weight ( 3 ) * phi_temp dens = dens + phi ( 3 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 3 ) !iDir = 6 phi ( 6 ) = weight ( 6 ) * phi_temp dens = dens + phi ( 6 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 6 ) !iDir = 7 phi_temp = phi_temp + div1_2 * cs4inv * ( - gradRHOU3 ( 2 ) - gradRHOUVZ ( 1 ) ) phi ( 7 ) = weight ( 7 ) * phi_temp dens = dens + phi ( 7 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 7 ) vel ( 3 ) = vel ( 3 ) - phi ( 7 ) !iDir = 10 phi ( 10 ) = weight ( 10 ) * phi_temp dens = dens + phi ( 10 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 10 ) vel ( 3 ) = vel ( 3 ) + phi ( 10 ) !iDir = 8 phi_temp = phi_temp + cs4inv * ( gradRHOUVZ ( 1 ) ) phi ( 8 ) = weight ( 8 ) * phi_temp dens = dens + phi ( 8 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 8 ) vel ( 3 ) = vel ( 3 ) + phi ( 8 ) !iDir = 9 phi ( 9 ) = weight ( 9 ) * phi_temp dens = dens + phi ( 9 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 9 ) vel ( 3 ) = vel ( 3 ) - phi ( 9 ) !iDir = 11 phi_temp = div1_6 * cs4inv * ( - 2._rk * ( gradRHOU3 ( 1 ) + gradRHOU3 ( 3 ) ) & & + gradRHOU3 ( 2 ) - 3._rk * gradRHOUVZ ( 2 ) ) phi ( 11 ) = weight ( 11 ) * phi_temp dens = dens + phi ( 11 ) vel ( 1 ) = vel ( 1 ) - phi ( 11 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 11 ) !iDir = 14 phi ( 14 ) = weight ( 14 ) * phi_temp dens = dens + phi ( 14 ) vel ( 1 ) = vel ( 1 ) + phi ( 14 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 14 ) !iDir = 12 phi_temp = phi_temp + cs4inv * ( gradRHOUVZ ( 2 ) ) phi ( 12 ) = weight ( 12 ) * phi_temp dens = dens + phi ( 12 ) vel ( 1 ) = vel ( 1 ) + phi ( 12 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 12 ) !iDir = 13 phi ( 13 ) = weight ( 13 ) * phi_temp dens = dens + phi ( 13 ) vel ( 1 ) = vel ( 1 ) - phi ( 13 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 13 ) !iDir = 15 phi_temp = div1_6 * cs4inv * ( - 2._rk * ( gradRHOU3 ( 1 ) + gradRHOU3 ( 2 ) ) & & + gradRHOU3 ( 3 ) - 3._rk * gradRHOUVZ ( 3 ) ) phi ( 15 ) = weight ( 15 ) * phi_temp dens = dens + phi ( 15 ) vel ( 1 ) = vel ( 1 ) - phi ( 15 ) vel ( 2 ) = vel ( 2 ) - phi ( 15 ) !vel(3) = vel(3) + 0._rk !iDir = 18 phi ( 18 ) = weight ( 18 ) * phi_temp dens = dens + phi ( 18 ) vel ( 1 ) = vel ( 1 ) + phi ( 18 ) vel ( 2 ) = vel ( 2 ) + phi ( 18 ) !vel(3) = vel(3) + 0._rk !iDir = 16 phi_temp = phi_temp + cs4inv * ( gradRHOUVZ ( 3 ) ) phi ( 16 ) = weight ( 16 ) * phi_temp dens = dens + phi ( 16 ) vel ( 1 ) = vel ( 1 ) - phi ( 16 ) vel ( 2 ) = vel ( 2 ) + phi ( 16 ) !vel(3) = vel(3) + 0._rk !iDir = 17 phi ( 17 ) = weight ( 17 ) * phi_temp dens = dens + phi ( 17 ) vel ( 1 ) = vel ( 1 ) + phi ( 17 ) vel ( 2 ) = vel ( 2 ) - phi ( 17 ) !vel(3) = vel(3) + 0._rk !iDir = 19 phi_temp = div1_6 * cs4inv * ( gradRHOU3 ( 1 ) + gradRHOU3 ( 2 ) + gradRHOU3 ( 3 ) ) phi ( 19 ) = weight ( 19 ) * phi_temp dens = dens + phi ( 19 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk end subroutine HRR_Correction_d3q19 ! ****************************************************************************** ! ! ****************************************************************************** ! ! based on Lattice Boltzmann Method with regularized non-equilibrium distribution ! functions, Jonas Latt and Bastien Chopard 2005 pure subroutine HRR_Correction_d3q27 ( QQ , weight , gradRHOU3 , phi , & & dens , vel ) ! -------------------------------------------------------------------- ! !> stencil size integer , intent ( in ) :: QQ !> weights of the stencil real ( kind = rk ), intent ( in ) :: weight (:) !> gradient rho V&#94;3 real ( kind = rk ), intent ( in ) :: gradRHOU3 (:) !> correction term phi real ( kind = rk ), intent ( out ) :: phi (:), dens , vel (:) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: phi_temp ! -------------------------------------------------------------------- ! dens = 0._rk vel (:) = 0._rk !iDir = 1 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 1 ) & & + gradRHOU3 ( 2 ) + gradRHOU3 ( 3 ) ) phi ( 1 ) = weight ( 1 ) * phi_temp dens = dens + phi ( 1 ) vel ( 1 ) = vel ( 1 ) - phi ( 1 ) !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk !iDir = 4 phi ( 4 ) = weight ( 4 ) * phi_temp dens = dens + phi ( 4 ) vel ( 1 ) = vel ( 1 ) + phi ( 4 ) !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk !iDir = 2 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 2 ) & & + gradRHOU3 ( 1 ) + gradRHOU3 ( 3 ) ) phi ( 2 ) = weight ( 2 ) * phi_temp dens = dens + phi ( 2 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 2 ) !vel(3) = vel(3) + 0._rk !iDir = 5 phi ( 5 ) = weight ( 5 ) * phi_temp dens = dens + phi ( 5 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 5 ) !vel(3) = vel(3) + 0._rk !iDir = 3 phi_temp = div1_6 * cs4inv * ( - 2._rk * gradRHOU3 ( 3 ) & & + gradRHOU3 ( 1 ) + gradRHOU3 ( 2 ) ) phi ( 3 ) = weight ( 3 ) * phi_temp dens = dens + phi ( 3 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 3 ) !iDir = 6 phi ( 6 ) = weight ( 6 ) * phi_temp dens = dens + phi ( 6 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 6 ) !iDir = 7 phi_temp = div1_6 * cs4inv * ( gradRHOU3 ( 1 ) & & - 2._rk * ( gradRHOU3 ( 2 ) & & + gradRHOU3 ( 3 ) ) ) phi ( 7 ) = weight ( 7 ) * phi_temp dens = dens + phi ( 7 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 7 ) vel ( 3 ) = vel ( 3 ) - phi ( 7 ) !iDir = 10 phi ( 10 ) = weight ( 10 ) * phi_temp dens = dens + phi ( 10 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 10 ) vel ( 3 ) = vel ( 3 ) + phi ( 10 ) !iDir = 8 phi ( 8 ) = weight ( 8 ) * phi_temp dens = dens + phi ( 8 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) - phi ( 8 ) vel ( 3 ) = vel ( 3 ) + phi ( 8 ) !iDir = 9 phi ( 9 ) = weight ( 9 ) * phi_temp dens = dens + phi ( 9 ) !vel(1) = vel(1) + 0._rk vel ( 2 ) = vel ( 2 ) + phi ( 9 ) vel ( 3 ) = vel ( 3 ) - phi ( 9 ) !iDir = 11 phi_temp = div1_6 * cs4inv * ( gradRHOU3 ( 2 ) & & - 2._rk * ( gradRHOU3 ( 1 ) & & + gradRHOU3 ( 3 ) ) ) phi ( 11 ) = weight ( 11 ) * phi_temp dens = dens + phi ( 11 ) vel ( 1 ) = vel ( 1 ) - phi ( 11 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 11 ) !iDir = 14 phi ( 14 ) = weight ( 14 ) * phi_temp dens = dens + phi ( 14 ) vel ( 1 ) = vel ( 1 ) + phi ( 14 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 14 ) !iDir = 12 phi ( 12 ) = weight ( 12 ) * phi_temp dens = dens + phi ( 12 ) vel ( 1 ) = vel ( 1 ) + phi ( 12 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) - phi ( 12 ) !iDir = 13 phi ( 13 ) = weight ( 13 ) * phi_temp dens = dens + phi ( 13 ) vel ( 1 ) = vel ( 1 ) - phi ( 13 ) !vel(2) = vel(2) + 0._rk vel ( 3 ) = vel ( 3 ) + phi ( 13 ) !iDir = 15 phi_temp = div1_6 * cs4inv * ( gradRHOU3 ( 3 ) & & - 2._rk * ( gradRHOU3 ( 1 ) & & + gradRHOU3 ( 2 ) ) ) phi ( 15 ) = weight ( 15 ) * phi_temp dens = dens + phi ( 15 ) vel ( 1 ) = vel ( 1 ) - phi ( 15 ) vel ( 2 ) = vel ( 2 ) - phi ( 15 ) !vel(3) = vel(3) + 0._rk !iDir = 18 phi ( 18 ) = weight ( 18 ) * phi_temp dens = dens + phi ( 18 ) vel ( 1 ) = vel ( 1 ) + phi ( 18 ) vel ( 2 ) = vel ( 2 ) + phi ( 18 ) !vel(3) = vel(3) + 0._rk !iDir = 16 phi ( 16 ) = weight ( 16 ) * phi_temp dens = dens + phi ( 16 ) vel ( 1 ) = vel ( 1 ) - phi ( 16 ) vel ( 2 ) = vel ( 2 ) + phi ( 16 ) !vel(3) = vel(3) + 0._rk !iDir = 17 phi ( 17 ) = weight ( 17 ) * phi_temp dens = dens + phi ( 17 ) vel ( 1 ) = vel ( 1 ) + phi ( 17 ) vel ( 2 ) = vel ( 2 ) - phi ( 17 ) !vel(3) = vel(3) + 0._rk !iDir = 19 phi_temp = div1_3 * cs4inv * ( - ( gradRHOU3 ( 1 ) + gradRHOU3 ( 2 ) & & + gradRHOU3 ( 3 ) ) ) phi ( 19 ) = weight ( 19 ) * phi_temp dens = dens + phi ( 19 ) vel ( 1 ) = vel ( 1 ) - phi ( 19 ) vel ( 2 ) = vel ( 2 ) - phi ( 19 ) vel ( 3 ) = vel ( 3 ) - phi ( 19 ) !iDir = 26 phi ( 26 ) = weight ( 26 ) * phi_temp dens = dens + phi ( 26 ) vel ( 1 ) = vel ( 1 ) + phi ( 26 ) vel ( 2 ) = vel ( 2 ) + phi ( 26 ) vel ( 3 ) = vel ( 3 ) + phi ( 26 ) !iDir = 22 phi ( 22 ) = weight ( 22 ) * phi_temp dens = dens + phi ( 22 ) vel ( 1 ) = vel ( 1 ) - phi ( 22 ) vel ( 2 ) = vel ( 2 ) + phi ( 22 ) vel ( 3 ) = vel ( 3 ) + phi ( 22 ) !iDir = 23 phi ( 23 ) = weight ( 23 ) * phi_temp dens = dens + phi ( 23 ) vel ( 1 ) = vel ( 1 ) + phi ( 23 ) vel ( 2 ) = vel ( 2 ) - phi ( 23 ) vel ( 3 ) = vel ( 3 ) - phi ( 23 ) !iDir = 25 phi ( 25 ) = weight ( 25 ) * phi_temp dens = dens + phi ( 25 ) vel ( 1 ) = vel ( 1 ) + phi ( 25 ) vel ( 2 ) = vel ( 2 ) + phi ( 25 ) vel ( 3 ) = vel ( 3 ) - phi ( 25 ) !iDir = 20 phi ( 20 ) = weight ( 20 ) * phi_temp dens = dens + phi ( 20 ) vel ( 1 ) = vel ( 1 ) - phi ( 20 ) vel ( 2 ) = vel ( 2 ) - phi ( 20 ) vel ( 3 ) = vel ( 3 ) + phi ( 20 ) !iDir = 24 phi ( 24 ) = weight ( 24 ) * phi_temp dens = dens + phi ( 24 ) vel ( 1 ) = vel ( 1 ) + phi ( 24 ) vel ( 2 ) = vel ( 2 ) - phi ( 24 ) vel ( 3 ) = vel ( 3 ) + phi ( 24 ) !iDir = 21 phi ( 21 ) = weight ( 21 ) * phi_temp dens = dens + phi ( 21 ) vel ( 1 ) = vel ( 1 ) - phi ( 21 ) vel ( 2 ) = vel ( 2 ) + phi ( 21 ) vel ( 3 ) = vel ( 3 ) - phi ( 21 ) !iDir = 27 phi_temp = - div1_2 * phi_temp phi ( 27 ) = weight ( 27 ) * phi_temp dens = dens + phi ( 27 ) !vel(1) = vel(1) + 0._rk !vel(2) = vel(2) + 0._rk !vel(3) = vel(3) + 0._rk end subroutine HRR_Correction_d3q27 ! ****************************************************************************** ! ! ************************************************************************** ! !> This function computes Hermite polinomial. It gives in output minimum !  up to 2nd-order polynomials. It is coded for up to 6th-order polynomials ! deprecated, used only to check the optimized R, RR, HRR, PRR, DRT functions subroutine getHermitepolynomials ( nDims , QQ , layout , H_order ) !, H ) ! -------------------------------------------------------------------------- !> number of physical dimensions integer , intent ( in ) :: nDims !> number of stencil streaming directions integer , intent ( in ) :: QQ !> current layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> maximum order of the Hermite polynomials integer , intent ( in ) :: H_order !> Hermite polynomials matrix !real(kind=rk), intent(inout) :: H(:,:) ! -------------------------------------------------------------------------- integer :: iDir real ( kind = rk ) :: c_x , c_y , c_z real ( kind = rk ) :: H ( QQ , QQ ) ! -------------------------------------------------------------------------- if ( nDims == 3 ) then ! Hermite polynomials: 1=H1x, 2=H1y, 3=H1z, 4=H2xx, 5=H2yy, 6=H2zz, 7=H2xy, !                      8=H2xz, 9=H2yz, 10=H3xxy, 11=H3xxz, 12=H3xyy, !                      13=H3xzz, 14=H3yzz, 15=H3yyz, !    (only for D3Q27)  16=H3xyz, 17=H4xxyy, 18=H4xxzz, 19=H4yyzz, 20=H4xyzz, !    (only for D3Q27)  21=H4xyyz, 22=H4xxyz, 23=H5xxyzz, 24=H5xxyyz, 25=H5xyyzz, !    (only for D3Q27)  26=H6xxyyzz !                      QQ=H0 do iDir = 1 , QQ c_x = layout % fStencil % cxDirRK ( 1 , iDir ) c_y = layout % fStencil % cxDirRK ( 2 , iDir ) c_z = layout % fStencil % cxDirRK ( 3 , iDir ) ! 0th order H0 = 1 H ( iDir , QQ ) = 1._rk ! 1st order H1n = c_n H ( iDir , 1 ) = c_x H ( iDir , 2 ) = c_y H ( iDir , 3 ) = c_z ! 2nd order H ( iDir , 4 ) = c_x ** 2 - cs2 H ( iDir , 5 ) = c_y ** 2 - cs2 H ( iDir , 6 ) = c_z ** 2 - cs2 H ( iDir , 7 ) = c_x * c_y H ( iDir , 8 ) = c_x * c_z H ( iDir , 9 ) = c_y * c_z ! 3d order if ( H_order < 3 ) CYCLE ! recursive formula valide from 3rd order on ! H (n+m+l) x_n y_m z_l = H(n)x_n H(m)y_m H(l)z_l H ( iDir , 10 ) = H ( iDir , 4 ) * c_y ! H1y = c_y H ( iDir , 11 ) = H ( iDir , 4 ) * c_z H ( iDir , 12 ) = c_x * H ( iDir , 5 ) H ( iDir , 13 ) = c_x * H ( iDir , 6 ) H ( iDir , 14 ) = c_y * H ( iDir , 6 ) H ( iDir , 15 ) = H ( iDir , 5 ) * c_z ! Hermite polynomials: 1=H1x, 2=H1y, 3=H1z, 4=H2xx, 5=H2yy, 6=H2zz, 7=H2xy, !                      8=H2xz, 9=H2yz, 10=H3xxy, 11=H3xxz, 12=H3xyy, 13=H3xzz, !                      14=H3yzz, 15=H3yyz write ( dbgUnit ( 1 ), * ) \"iDir = \" , iDir write ( dbgUnit ( 1 ), * ) \"  H0 = \" , H ( iDir , QQ ) write ( dbgUnit ( 1 ), * ) \"  H1x_1 = \" , H ( iDir , 1 ) write ( dbgUnit ( 1 ), * ) \"  H1y_2 = \" , H ( iDir , 2 ) write ( dbgUnit ( 1 ), * ) \"  H1z_3 = \" , H ( iDir , 3 ) write ( dbgUnit ( 1 ), * ) \"  H2xx_4 = \" , H ( iDir , 4 ) write ( dbgUnit ( 1 ), * ) \"  H2yy_5 = \" , H ( iDir , 5 ) write ( dbgUnit ( 1 ), * ) \"  H2zz_6 = \" , H ( iDir , 6 ) write ( dbgUnit ( 1 ), * ) \"  H2xy_7 = \" , H ( iDir , 7 ) write ( dbgUnit ( 1 ), * ) \"  H2xz_8 = \" , H ( iDir , 8 ) write ( dbgUnit ( 1 ), * ) \"  H2yz_9 = \" , H ( iDir , 9 ) write ( dbgUnit ( 1 ), * ) \"  H3xxy_10 = \" , H ( iDir , 10 ) write ( dbgUnit ( 1 ), * ) \"  H3xxz_11 = \" , H ( iDir , 11 ) write ( dbgUnit ( 1 ), * ) \"  H3xyy_12 = \" , H ( iDir , 12 ) write ( dbgUnit ( 1 ), * ) \"  H3xzz_13 = \" , H ( iDir , 13 ) write ( dbgUnit ( 1 ), * ) \"  H3yzz_14 = \" , H ( iDir , 14 ) write ( dbgUnit ( 1 ), * ) \"  H3yyz_15 = \" , H ( iDir , 15 ) ! only for D3Q27 ! 16=H3xyz, 17=H4xxyy, 18=H4xxzz, 19=H4yyzz, 20=H4xyzz, 21=H4xyyz, ! 22=H4xxyz, 23=H5xxyzz, 24=H5xxyyz, 25=H5xyyzz, 26=H6xxyyzz if ( QQ == 27 ) then H ( iDir , 16 ) = c_x * c_y * c_z write ( dbgUnit ( 1 ), * ) \"  H3xyz_16 = \" , H ( iDir , 16 ) ! 4th order if ( H_order < 4 ) CYCLE H ( iDir , 17 ) = H ( iDir , 4 ) * H ( iDir , 5 ) H ( iDir , 18 ) = H ( iDir , 4 ) * H ( iDir , 6 ) H ( iDir , 19 ) = H ( iDir , 5 ) * H ( iDir , 6 ) H ( iDir , 20 ) = c_x * H ( iDir , 14 ) H ( iDir , 21 ) = c_x * H ( iDir , 15 ) H ( iDir , 22 ) = H ( iDir , 10 ) * c_z write ( dbgUnit ( 1 ), * ) \"  H4xxyy_17 = \" , H ( iDir , 17 ) write ( dbgUnit ( 1 ), * ) \"  H4xxzz_18 = \" , H ( iDir , 18 ) write ( dbgUnit ( 1 ), * ) \"  H4yyzz_19 = \" , H ( iDir , 19 ) write ( dbgUnit ( 1 ), * ) \"  H4xyzz_20 = \" , H ( iDir , 20 ) write ( dbgUnit ( 1 ), * ) \"  H4xyyz_21 = \" , H ( iDir , 21 ) write ( dbgUnit ( 1 ), * ) \"  H4xxyz_22 = \" , H ( iDir , 22 ) ! 5th order if ( H_order < 5 ) CYCLE H ( iDir , 23 ) = H ( iDir , 18 ) * c_y H ( iDir , 24 ) = H ( iDir , 17 ) * c_z H ( iDir , 25 ) = c_x * H ( iDir , 19 ) write ( dbgUnit ( 1 ), * ) \"  H5xxyzz_23 = \" , H ( iDir , 23 ) write ( dbgUnit ( 1 ), * ) \"  H5xxyyz_24 = \" , H ( iDir , 24 ) write ( dbgUnit ( 1 ), * ) \"  H5xyyzz_25 = \" , H ( iDir , 25 ) ! 6th order if ( H_order < 6 ) CYCLE H ( iDir , 26 ) = H ( iDir , 17 ) * H ( iDir , 6 ) write ( dbgUnit ( 1 ), * ) \"  H6xxyyzz_26 = \" , H ( iDir , 26 ) endif enddo flush ( dbgUnit ( 1 )) call tem_abort ( 'done' ) else !nDims == 2 ! Hermite polynomials: 1=H1x, 2=H1y, 3=H2xx, 4=H2yy, 5=H2xy, !                      6=H3xxy, 7=H3xyy, 8=H4xxyy, QQ=H0 do iDir = 1 , QQ c_x = layout % fStencil % cxDirRK ( 1 , iDir ) c_y = layout % fStencil % cxDirRK ( 2 , iDir ) ! 0th order H0 = 1 H ( iDir , QQ ) = 1._rk ! 1st order H1n = c_n H ( iDir , 1 ) = c_x H ( iDir , 2 ) = c_y ! 2nd order H ( iDir , 3 ) = c_x ** 2 - cs2 H ( iDir , 4 ) = c_y ** 2 - cs2 H ( iDir , 5 ) = c_x * c_y ! 3d order if ( H_order < 3 ) CYCLE ! recursive formula valide from 3rd order on ! H (n+m+l) x_n y_m z_l = H(n)x_n H(m)y_m H(l)z_l H ( iDir , 6 ) = H ( iDir , 3 ) * c_y ! H1y = c_y H ( iDir , 7 ) = c_x * H ( iDir , 4 ) ! 4th order if ( H_order < 4 ) CYCLE H ( iDir , 8 ) = H ( iDir , 3 ) * H ( iDir , 4 ) enddo ! Hermite polynomials: 1=H1x, 2=H1y, 3=H2xx, 4=H2yy, 5=H2xy, !                      6=H3xxy, 7=H3xyy, 8=H4xxyy do iDir = 1 , QQ write ( dbgUnit ( 1 ), * ) \"iDir = \" , iDir write ( dbgUnit ( 1 ), * ) \"  H0 = \" , H ( iDir , QQ ) write ( dbgUnit ( 1 ), * ) \"  H1x = \" , H ( iDir , 1 ) write ( dbgUnit ( 1 ), * ) \"  H1y = \" , H ( iDir , 2 ) write ( dbgUnit ( 1 ), * ) \"  H2xx = \" , H ( iDir , 3 ) write ( dbgUnit ( 1 ), * ) \"  H2yy = \" , H ( iDir , 4 ) write ( dbgUnit ( 1 ), * ) \"  H2xy = \" , H ( iDir , 5 ) write ( dbgUnit ( 1 ), * ) \"  H3xxy = \" , H ( iDir , 6 ) write ( dbgUnit ( 1 ), * ) \"  H3xyy = \" , H ( iDir , 7 ) write ( dbgUnit ( 1 ), * ) \"  H4xxyy = \" , H ( iDir , 8 ) enddo flush ( dbgUnit ( 1 )) call tem_abort ( 'done' ) endif end subroutine getHermitepolynomials ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes Hermite polinomial. It gives in output minimum !  up to 2nd-order polynomials. It is coded for up to 6th-order polynomials ! deprecated, used only to check the optimized R, RR, HRR, PRR, DRT functions subroutine getHermitepolynomials_D3Q19 ( layout ) ! -------------------------------------------------------------------------- !> current layout type ( mus_scheme_layout_type ), intent ( in ) :: layout ! -------------------------------------------------------------------------- integer :: iDir , QQ real ( kind = rk ) :: c_x , c_y , c_z real ( kind = rk ) :: H ( 19 , 19 ) ! -------------------------------------------------------------------------- QQ = 19 ! Hermite polynomials: 1=H1x, 2=H1y, 3=H1z, 4=H2xx, 5=H2yy, 6=H2zz, 7=H2xy, !                      8=H2xz, 9=H2yz, 10=H3xxy, 11=H3xxz, 12=H3xyy, !                      13=H3xzz, 14=H3yzz, 15=H3yyz, do iDir = 1 , QQ c_x = layout % fStencil % cxDirRK ( 1 , iDir ) c_y = layout % fStencil % cxDirRK ( 2 , iDir ) c_z = layout % fStencil % cxDirRK ( 3 , iDir ) ! 0th order H0 = 1 H ( iDir , QQ ) = 1._rk ! 1st order H1n = c_n H ( iDir , 1 ) = c_x H ( iDir , 2 ) = c_y H ( iDir , 3 ) = c_z ! 2nd order H ( iDir , 4 ) = c_x ** 2 - cs2 H ( iDir , 5 ) = c_y ** 2 - cs2 H ( iDir , 6 ) = c_z ** 2 - cs2 H ( iDir , 7 ) = c_x * c_y H ( iDir , 8 ) = c_x * c_z H ( iDir , 9 ) = c_y * c_z ! 3d order ! recursive formula valide from 3rd order on ! H (n+m+l) x_n y_m z_l = H(n)x_n H(m)y_m H(l)z_l H ( iDir , 10 ) = H ( iDir , 4 ) * c_y ! H1y = c_y H ( iDir , 11 ) = H ( iDir , 4 ) * c_z H ( iDir , 12 ) = c_x * H ( iDir , 5 ) H ( iDir , 13 ) = c_x * H ( iDir , 6 ) H ( iDir , 14 ) = c_y * H ( iDir , 6 ) H ( iDir , 15 ) = H ( iDir , 5 ) * c_z ! Hermite polynomials: 1=H1x, 2=H1y, 3=H1z, 4=H2xx, 5=H2yy, 6=H2zz, 7=H2xy, !                      8=H2xz, 9=H2yz, 10=H3xxy, 11=H3xxz, 12=H3xyy, 13=H3xzz, !                      14=H3yzz, 15=H3yyz write ( dbgUnit ( 1 ), * ) \"iDir = \" , iDir write ( dbgUnit ( 1 ), * ) \"  H0 = \" , H ( iDir , QQ ) write ( dbgUnit ( 1 ), * ) \"  H1x_1 = \" , H ( iDir , 1 ) write ( dbgUnit ( 1 ), * ) \"  H1y_2 = \" , H ( iDir , 2 ) write ( dbgUnit ( 1 ), * ) \"  H1z_3 = \" , H ( iDir , 3 ) write ( dbgUnit ( 1 ), * ) \"  H2xx_4 = \" , H ( iDir , 4 ) write ( dbgUnit ( 1 ), * ) \"  H2yy_5 = \" , H ( iDir , 5 ) write ( dbgUnit ( 1 ), * ) \"  H2zz_6 = \" , H ( iDir , 6 ) write ( dbgUnit ( 1 ), * ) \"  H2xy_7 = \" , H ( iDir , 7 ) write ( dbgUnit ( 1 ), * ) \"  H2xz_8 = \" , H ( iDir , 8 ) write ( dbgUnit ( 1 ), * ) \"  H2yz_9 = \" , H ( iDir , 9 ) write ( dbgUnit ( 1 ), * ) \"  3(H3xxy_10 + H3yzz_14) = \" , 3._rk * ( H ( iDir , 10 ) + H ( iDir , 14 ) ) write ( dbgUnit ( 1 ), * ) \"  (H3xxy_10 - H3yzz_14) = \" , ( H ( iDir , 10 ) - H ( iDir , 14 ) ) write ( dbgUnit ( 1 ), * ) \"  3(H3xzz_13 + H3xyy_12) = \" , 3._rk * ( H ( iDir , 13 ) + H ( iDir , 12 ) ) write ( dbgUnit ( 1 ), * ) \"  (H3xzz_13 - H3xyy_12) = \" , ( H ( iDir , 13 ) - H ( iDir , 12 ) ) write ( dbgUnit ( 1 ), * ) \"  3(H3yyz_15 + H3xxz_11) = \" , 3._rk * ( H ( iDir , 15 ) + H ( iDir , 11 ) ) write ( dbgUnit ( 1 ), * ) \"  (H3yyz_15 - H3xxz_11) = \" , ( H ( iDir , 15 ) - H ( iDir , 11 ) ) enddo flush ( dbgUnit ( 1 )) call tem_abort ( 'done' ) end subroutine getHermitepolynomials_D3Q19 ! ************************************************************************** ! end module mus_hrrInit_module","tags":"","loc":"sourcefile/mus_hrrinit_module.f90.html"},{"title":"mus_fluid_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_fluid_module.f90~~EfferentGraph sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_fluid_module.f90~~AfferentGraph sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012-2014, 2016-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012, 2021 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Philipp Otte <otte@mathcces.rwth-aachen.de> ! Copyright (c) 2018 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2019, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module keeps all information about the fluid !! !! In this module, all infos about the fluid is collected. !! The file type [[mus_fluid_type]] contains all relevant information. !! This includes physical parameters such as the viscosity and reference !! density. Also, LBM-specific parameters such as the relaxation rates are !! defined. !! module mus_fluid_module use mpi ! include treelm modules use env_module , only : rk use tem_tools_module , only : tem_horizontalSpacer use tem_aux_module , only : tem_abort use tem_param_module , only : cs2 , cs2inv , rho0 , div2_3 use tem_logging_module , only : logUnit use tem_time_module , only : tem_time_type use tem_stencil_module , only : tem_stencilHeader_type use tem_general_module , only : tem_general_type use tem_spacetime_fun_module , only : tem_load_spacetime use tem_construction_module , only : tem_levelDesc_type use tem_grow_array_module , only : init ! include aotus modules use aotus_module , only : flu_State , & & aot_get_val , & & aoterr_NonExistent , & & aoterr_Fatal use aot_table_module , only : aot_table_open , aot_table_close use aot_out_module , only : aot_out_type , aot_out_val , aot_out_open_table , & & aot_out_close_table ! include musubi modules use mus_physics_module , only : mus_physics_type use mus_nonNewtonian_module , only : mus_nNwtn_type , mus_nNwtn_load , & & mus_assign_nNwtnVisc_ptr , & & mus_nNwtn_dump2outUnit , mus_nNwtn_save2lua use mus_pdf_module , only : pdf_data_type use mus_turbulence_module , only : mus_turbulence_type , & & mus_load_turbulence , & & mus_init_turbulenceData use mus_turb_viscosity_module , only : mus_assign_turbVisc_ptr use mus_scheme_header_module , only : mus_scheme_header_type use mus_relaxationParam_module , only : mus_viscosity_type , & & mus_init_relaxParam , & & mus_calcOmegaFromVisc , & & mus_update_relaxParamFromViscSTfun use mus_mrtRelaxation_module , only : mus_proc_mrt , & & mus_assign_mrt_ptr use mus_cumulantInit_module , only : cumulant_omega_check implicit none private public :: mus_fluid_type public :: mus_load_fluid public :: mus_fluid_save2lua public :: mus_init_fluid public :: mus_fluid_cleanup !> collection of properties of the fluid type mus_fluid_type logical :: active = . false . !< is this object a fluid? !> Magic value for TRT collision model !! Lambda = ( 1/omega_+ - 0.5 ) * ( 1/omega_- - 0.5 ) real ( kind = rk ) :: lambda = 0.25_rk !> level-wise bulk omegas, used as relaxation in mrt model !! allocated in mus_init_fluid real ( kind = rk ), allocatable :: omegaBulkLvl (:) !> Level wise bulk viscosity in lattice real ( kind = rk ), allocatable :: viscBulkLvl (:) !> Contains information for turbulence model type ( mus_turbulence_type ) :: turbulence !> nonNewtonian fluid parameter type ( mus_nNwtn_type ) :: nNwtn !> function pointer to get MRT diagonal relaxation matrix procedure ( mus_proc_mrt ), nopass , pointer :: mrtPtr => null () !> kinematic viscosity !! \\todo KM: implement interpolation routine for constant viscosity type ( mus_viscosity_type ) :: viscKine real ( kind = rk ) :: viscBulk_phy !< physical bulk viscosity real ( kind = rk ) :: force ( 3 ) !< forcing term ! also works around ICE in Intel 19.1 ! HRR real ( kind = rk ) :: HRR_sigma = 0.98_rk ! DRT real ( kind = rk ) :: DRT_tauN = 0.70_rk ! Cumulant extended real ( kind = rk ) :: omega_Cum ( 10 ) real ( kind = rk ) :: omega_Lim ( 3 ) end type mus_fluid_type contains ! **************************************************************************** ! !> Read in the fluid property from the LUA parameter file subroutine mus_load_fluid ( me , conf , parent , minLevel , physics , schemeHeader ) !-------------------------------------------------------------------------- !> fluid type type ( mus_fluid_type ), intent ( out ) :: me !> lua state type ( flu_state ) :: conf !> parent handle integer , intent ( in ), optional :: parent !> global pdf info integer , intent ( in ) :: minLevel !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! -------------------------------------------------------------------------- integer :: fluid_table , ii integer :: iError integer :: vecError ( 3 ) real ( kind = rk ) :: omegaBulk_def ! default omegaBulk for incompressible model character ( len = 6 ) :: omega_name = \"omega_\" character ( len = 8 ) :: omega_string character ( len = 10 ) :: omega_lim_name = \"omega_lim_\" character ( len = 11 ) :: omega_lim_string real ( kind = rk ) :: omegaCum_def ! -------------------------------------------------------------------------- ! if fluid informations in scheme table parentHandle /= 0 if ( present ( parent ) ) then call aot_table_open ( L = conf , & & parent = parent , & & thandle = fluid_table , & & key = 'fluid' ) else call aot_table_open ( L = conf , thandle = fluid_table , key = 'fluid' ) end if if ( fluid_table == 0 ) then write ( logUnit ( 1 ), * ) 'No fluid table defined' call tem_abort () endif write ( logUnit ( 1 ), * ) 'Loading fluid informations' ! Activating the current fluid object me % active = . true . ! load kinematic viscosity as spacetime function call tem_load_spacetime ( me = me % viscKine % STfun , & & conf = conf , & & parent = fluid_table , & & key = 'kinematic_viscosity' , & & errCode = iError ) if ( iError /= 0 ) then call tem_abort ( 'ERROR: Unable to load \"kinematic_viscosity\"' & & // 'from fluid table' ) end if ! Load bulk viscosity as scalar and convert it to LB call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'bulk_viscosity' , & & val = me % viscBulk_phy , & & ErrCode = iError ) ! If not provided, use default value only for incompressible model if ( btest ( iError , aoterr_NonExistent )) then if ( trim ( schemeHeader % kind ) == 'fluid' ) then if ( trim ( schemeHeader % layout ) == 'd2q9' ) then omegaBulk_def = 1.63_rk write ( logUnit ( 1 ), * ) 'Warning: Using default omegaBulk=1.63' else if ( trim ( schemeHeader % layout ) == 'd3q27' ) then omegaBulk_def = 1.54_rk write ( logUnit ( 1 ), * ) 'Warning: Using default omegaBulk=1.54' else call tem_abort ( 'ERROR: \"bulk_viscosity\" is not provided in ' // & & 'fluid table' ) end if else ! using default value from ! D’Humières, D., Ginzburg, I., Krafczyk, M., Lallemand, P., ! & Luo, L.-S. (2002). ! Multiple-relaxation-time lattice Boltzmann models in three ! dimensions. Philosophical Transactions. Series A, Mathematical, ! Physical, and Engineering Sciences, 360(1792), 437–51. select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) ! default value for d2q9 is from ! Chen, S., Peng, C., Teng, Y., Wang, L. P., & Zhang, K. (2016). ! Improving lattice Boltzmann simulation of moving particles in a ! viscous flow using local grid refinement. Computers and Fluids, omegaBulk_def = 1.63_rk case ( 'd3q15' ) omegaBulk_def = 1.60_rk case ( 'd3q27' ) omegaBulk_def = 1.54_rk case default omegaBulk_def = 1.19_rk end select write ( logUnit ( 1 ), * ) 'Warning: Using default omegaBulk:' , omegaBulk_def end if if ( trim ( schemeHeader % layout ) == 'd2q9' ) then !! \"Theory of the lattice Boltzmann method: Dispersion, dissipation, !! isotropy, Galilean invariance, and stability\", Pierre Lallemand and !! Li-Shi Luo, Phys. Rev. E 61, 2000. me % viscBulk_phy = (( 8._rk - 1 2._rk * cs2 ) / 2 4._rk ) & & * ( 1.0_rk / omegaBulk_def - 0.5_rk ) & & * physics % fac ( minLevel )% visc else me % viscBulk_phy = (( 5._rk - 9._rk * cs2 ) / 9._rk ) & & * ( 1.0_rk / omegaBulk_def - 0.5_rk ) & & * physics % fac ( minLevel )% visc endif endif ! load forces call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'force' , & & val = me % force , & & default = [ 0._rk , 0._rk , 0._rk ], & & ErrCode = vecError ) ! convert force to lattice me % force = me % force / physics % fac ( minLevel )% force select case ( trim ( schemeHeader % relaxation )) case ( 'trt' ) ! load lambda (magic value for trt model) call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'lambda' , & & val = me % lambda , & & default = 0.25_rk , & & ErrCode = iError ) case ( 'hrr_bgk' , 'hrr_bgk_corrected' ) ! load sigma for HRR_bgk call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'hrr_sigma' , & & val = me % HRR_sigma ,& & default = 0.98_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_fatal )) then call tem_abort ( 'ERROR: wrong data type for sigma_HRR ' & & // 'fluid table' ) end if case ( 'prr_bgk_corrected' ) me % HRR_sigma = 0._rk case ( 'rr_bgk_corrected' ) me % HRR_sigma = 1._rk case ( 'drt_bgk' ) ! load tauN for DRT_bgk call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'drt_taun' , & & val = me % DRT_tauN ,& & default = 0.70_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_fatal )) then call tem_abort ( 'ERROR: wrong data type for DRT tauN ' & & // 'fluid table' ) end if case ( 'cumulant_extended' , 'cumulant_extended_generic' ) ! load omega vec for cumulant and limiter me % omega_Cum = - 1._rk call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = 'omega_2' , & & val = me % omega_Cum ( 2 ), & & default = - 1._rk , & & ErrCode = iError ) if ( me % omega_Cum ( 2 ) < 0._rk ) then write ( logUnit ( 1 ), * ) 'Cumulant_extended is active' write ( logUnit ( 1 ), * ) '  Warning: Using omega_2 = omegaBulk' end if if ( btest ( iError , aoterr_fatal )) then call tem_abort ( 'ERROR: wrong data type for omega_2 ' // & & 'fluid table' ) end if do ii = 3 , 10 if ( ii < 10 ) then write ( omega_string , \"(A6,I1)\" ) omega_name , ii else write ( omega_string , \"(A6,I2)\" ) omega_name , ii endif if ( ii < 6 ) then omegaCum_def = - 1._rk else omegaCum_def = 1._rk endif call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = trim ( omega_string ), & & val = me % omega_Cum ( ii ), & & default = omegaCum_def , & & ErrCode = iError ) if ( btest ( iError , aoterr_fatal )) then call tem_abort ( 'ERROR: wrong data type for ' // trim ( omega_string ) & & // ' cumulant fluid table' ) end if enddo do ii = 1 , 3 write ( omega_lim_string , \"(A10,I1)\" ) omega_lim_name , ii call aot_get_val ( L = conf , & & thandle = fluid_table , & & key = trim ( omega_lim_string ), & & val = me % omega_Lim ( ii ), & & default = 1.e-2_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_fatal )) then call tem_abort ( 'ERROR: wrong data type for ' & & // trim ( omega_lim_string ) & & // ' cumulant fluid table' ) end if enddo end select ! load nonNewtonian fluid feature call mus_nNwtn_load ( me = me % nNwtn , & & conf = conf , & & parent = fluid_table ) ! load turbulence call mus_load_turbulence ( me = me % turbulence , & & conf = conf , & & parent = fluid_table ) call aot_table_close ( L = conf , thandle = fluid_table ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_fluid ! ************************************************************************** ! ! ************************************************************************** ! !> This routine initilizes fluid visocity and relaxation paramters for each !! level subroutine mus_init_fluid ( me , physics , schemeHeader , minLevel , maxLevel , & & levelDesc , pdf , stencil , general , tNow ) ! -------------------------------------------------------------------------- !> fluid type type ( mus_fluid_type ), intent ( inout ) :: me !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> scheme header type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> min and max level integer , intent ( in ) :: minLevel , maxLevel !> level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( minLevel : maxLevel ) !> pdf info with neigh array for all levels type ( pdf_data_type ), intent ( in ) :: pdf ( minLevel : maxLevel ) !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> general type contains communication pattern and proc info type ( tem_general_type ), intent ( in ) :: general !> current simulation time type ( tem_time_type ), intent ( in ) :: tNow ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- write ( logUnit ( 1 ), '(A)' ) 'Initialize fluid' ! allocate array to store kinematic viscosity and bulk viscosity allocate ( me % viscKine % dataOnLvl ( minLevel : maxLevel )) do iLevel = minLevel , maxLevel call init ( me % viscKine % dataOnLvl ( iLevel ), pdf ( iLevel )% nElems_local ) me % viscKine % dataOnLvl ( iLevel )% val = - 10 0.0_rk end do allocate ( me % viscBulkLvl ( minLevel : maxLevel )) allocate ( me % omegaBulkLvl ( minLevel : maxLevel )) ! New initialization ! allocate relaxation parameter array to size nSolve call mus_init_relaxParam ( omLvl = me % viscKine % omLvl , & & minLevel = minLevel , & & maxLevel = maxLevel , & & nElems = pdf (:)% nElems_local ) ! assign function pointer call mus_assign_mrt_ptr ( me % mrtPtr , schemeHeader ) ! intialize kinematic omega write ( logUnit ( 3 ), '(A)' ) '  Set relaxation parameter from kinematic ' & & // 'viscosity' do iLevel = minLevel , maxLevel call mus_update_relaxParamFromViscSTfun ( & & omega = me % viscKine % omLvl ( iLevel )% val , & & visc = me % viscKine % dataOnLvl ( iLevel )% val , & & viscSTfun = me % viscKine % STfun , & & viscRef = physics % fac ( iLevel )% visc , & & nElems = pdf ( iLevel )% nElems_local , & & baryOfTotal = levelDesc ( iLevel )% baryOfTotal , & & tNow = tNow ) ! Initialize bulk omega me % viscBulkLvl ( iLevel ) = me % viscBulk_phy / physics % fac ( iLevel )% visc ! for 2D the formula is different!!!!!! !write(logUnit(3),'(A,I0)') '   nDims: ', stencil%nDims if ( stencil % nDims == 2 ) then ! for 2d the formula of omega from bulk is different! ! see ref: \"Theory of the Lattice Boltzmann Method: Dispersion, ! Dissipation, Isotropy, Galilean Invariance, and Stability\" ! Luo 2000, PHYSICAL REVIEW E me % omegaBulkLvl ( iLevel ) = 1.0_rk / ( 2 4.0_rk * me % viscBulkLvl ( iLevel ) & & / ( 8._rk - 1 2._rk * cs2 ) + 0.5_rk ) else ! see ref: \"A D3Q27 multiple-relaxation-time lattice Boltzmann method ! for turbulent flows\", Suga 2015, Computers&Fluids !me%omegaBulkLvl(iLevel) = 2.0_rk                                    & !  &                     / (9.0_rk * me%viscBulkLvl(iLevel) + 1.0_rk ) me % omegaBulkLvl ( iLevel ) = 1.0_rk / ( 9.0_rk * me % viscBulkLvl ( iLevel ) & & / ( 5._rk - 9._rk * cs2 ) + 0.5_rk ) endif end do ! Assign function pointer for nonNewtonian model if ( me % nNwtn % active ) then write ( logUnit ( 3 ), '(A)' ) '  Assign function to compute viscosity ' & & // 'for non-Newtonian model' call mus_assign_nNwtnVisc_ptr ( me % nNwtn , schemeHeader ) end if if ( me % turbulence % active ) then write ( logUnit ( 3 ), '(A)' ) '  Assign function to compute viscosity ' & & // 'for turbulence model' ! assign function pointer to compute turbulence viscosity call mus_assign_turbVisc_ptr ( me % turbulence , schemeHeader ) ! Initialize communication buffer for viscosity to compute ! velocity gradient for turbulence model ! This step must be done after construct_connectivity and ! init_levelBuffers allocate ( me % turbulence % dataOnLvl ( minLevel : maxLevel ) ) do iLevel = minLevel , maxLevel call mus_init_turbulenceData ( & & me = me % turbulence % dataOnLvl ( iLevel ), & !& turbConfig = me%turbulence%config,            & & levelDesc = levelDesc ( iLevel ), & & pattern = general % commPattern , & & nSize = pdf ( iLevel )% nSize ) end do !iLevel end if ! Dump fluid information call mus_fluid_dump ( me , minLevel , maxLevel , physics , pdf (:)% nElems_solve , & & general , logUnit ( 1 ), schemeHeader ) end subroutine mus_init_fluid ! ************************************************************************** ! ! ************************************************************************** ! subroutine mus_fluid_dump ( me , minLevel , maxLevel , physics , nSolve , general , & & outUnit , schemeHeader ) ! -------------------------------------------------------------------------- type ( mus_fluid_type ), intent ( inout ) :: me !< fluid type !> minlevel and maxlevel integer , intent ( in ) :: minLevel , maxLevel !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> number of elements to solve per level (fluid+ghost) integer , intent ( in ) :: nSolve ( minLevel : maxLevel ) !> general type type ( tem_general_type ), intent ( in ) :: general integer , intent ( in ) :: outUnit !> scheme header type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! -------------------------------------------------------------------------- integer :: iLevel , iError real ( kind = rk ) :: visc_min , visc_max , viscRef , om_min , om_max real ( kind = rk ) :: glob_visc_min , glob_visc_max ! -------------------------------------------------------------------------- write ( outUnit , \"(A)\" ) 'Fluid properties:' write ( outUnit , \"(A,F10.7)\" ) '  Reference density rho0: ' , rho0 write ( outUnit , \"(A)\" ) '  Kinematic viscosity STfun kind: ' // & & trim ( me % viscKine % STfun % fun_kind ) do iLevel = minLevel , maxLevel ! get global min and max viscosity visc_min = minval ( me % viscKine % dataOnLvl ( iLevel )% val ( 1 : nSolve ( iLevel ))) visc_max = maxval ( me % viscKine % dataOnLvl ( iLevel )% val ( 1 : nSolve ( iLevel ))) call mpi_reduce ( visc_min , glob_visc_min , 1 , mpi_double_precision , & mpi_min , 0 , general % proc % comm , ierror ) call mpi_reduce ( visc_max , glob_visc_max , 1 , mpi_double_precision , & mpi_max , 0 , general % proc % comm , ierror ) viscRef = physics % fac ( iLevel )% visc om_min = mus_calcOmegaFromVisc ( glob_visc_min ) om_max = mus_calcOmegaFromVisc ( glob_visc_max ) write ( outUnit , '(A,I0)' ) 'Kinematic viscosity, (min, max) on level: ' , & & iLevel write ( outUnit , '(A,F10.7,A,F10.7,A)' ) '  Physical: (' , & & glob_visc_min * viscRef , ',' , glob_visc_max * viscRef , ')' write ( outUnit , '(A,F10.7,A,F10.7,A)' ) '  Lattice: (' , glob_visc_min , & & ',' , glob_visc_max , ')' write ( outUnit , '(A,F10.7,A,F10.7,A)' ) '  Kinematic omega (min,max):(' , & & om_min , ',' , om_max , ')' write ( outUnit , \"(A)\" ) ' viscBulk lattice and omega: ' write ( outUnit , \"(A,F10.7)\" ) '  viscBulk:  ' , me % viscBulkLvl ( iLevel ) write ( outUnit , \"(A,F10.7)\" ) '  omegaBulk: ' , me % omegaBulkLvl ( iLevel ) end do write ( outUnit , \"(A,F10.7)\" ) 'Magic lambda for TRT: ' , me % lambda write ( outUnit , \"(A,F10.7)\" ) 'HRR sigma: ' , me % HRR_sigma write ( outUnit , \"(A,F10.7)\" ) 'DRT tauN: ' , me % DRT_tauN if ( trim ( schemeHeader % relaxation ) == 'cumulant_extended' . or . & & trim ( schemeHeader % relaxation ) == 'cumulant_extended_generic' ) then write ( outUnit , \"(A)\" ) 'omega Cumulant: -1.000 means adjust during runtime' do iLevel = 1 , 10 write ( outUnit , \"(A,I2,A,F10.7)\" ) '  ' , iLevel , ' = ' , me % omega_Cum ( iLevel ) enddo write ( outUnit , \"(A)\" ) 'omega limiter Cumulant: 1.e10 means unlimited' do iLevel = 1 , 3 write ( outUnit , \"(A,I2,A,F10.7)\" ) '  ' , iLevel , ' = ' , me % omega_Lim ( iLevel ) enddo ! check Cumulant_extended range of admissibility for omegas write ( logUnit ( 1 ), * ) 'Checking admissibility of omegas for parametrized Cumulant scheme' do iLevel = minLevel , maxLevel call cumulant_omega_check ( omegaVisc = me % viscKine % omLvl ( iLevel )% val (:), & & omegaBulk = me % omegaBulkLvl ( iLevel ), & & omegaIn = me % omega_Cum (:), & & nSolve = nSolve ( iLevel ), & & level = iLevel ) enddo end if if ( maxval ( abs ( me % force )) > 0._rk ) & & write ( outUnit , * ) ' Forcing:             ' , real ( me % force ) ! Dump nonNewtonian parameters to outUnit call mus_nNwtn_dump2outUnit ( me % nNwtn , outUnit ) end subroutine mus_fluid_dump ! ************************************************************************** ! ! ************************************************************************** ! !> write fluid prop into a lua file !! subroutine mus_fluid_save2lua ( me , conf ) ! --------------------------------------------------------------------------- !> single fluid type type ( mus_fluid_type ), intent ( in ) :: me type ( aot_out_type ) :: conf ! --------------------------------------------------------------------------- call aot_out_open_table ( put_conf = conf , tname = 'fluid' ) call aot_out_val ( put_conf = conf , & & vname = 'bulk_viscosity' , & & val = me % viscBulk_phy ) if ( trim ( me % viscKine % STfun % fun_kind ) == 'const' ) then call aot_out_val ( put_conf = conf , & & vname = 'kine_viscosity' , & & val = me % viscKine % STfun % const ( 1 ) ) end if if ( me % nNwtn % active ) call mus_nNwtn_save2lua ( me % nNwtn , conf ) call aot_out_close_table ( put_conf = conf ) end subroutine mus_fluid_save2lua ! **************************************************************************** ! ! ************************************************************************** ! !> This routines act as a destructor for fluid type subroutine mus_fluid_cleanup ( me ) ! --------------------------------------------------------------------------- !> single fluid type type ( mus_fluid_type ), intent ( inout ) :: me ! --------------------------------------------------------------------------- if ( allocated ( me % viscKine % dataOnLvl )) then deallocate ( me % viscKine % dataOnLvl ) end if if ( allocated ( me % viscKine % omLvl )) then deallocate ( me % viscKine % omLvl ) end if if ( allocated ( me % viscBulkLvl )) then deallocate ( me % viscBulkLvl ) end if if ( allocated ( me % omegaBulkLvl )) then deallocate ( me % omegaBulkLvl ) end if if ( me % turbulence % active ) then if ( allocated ( me % turbulence % dataOnLvl )) then deallocate ( me % turbulence % dataOnLvl ) end if end if end subroutine mus_fluid_cleanup ! ************************************************************************** ! end module mus_fluid_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_fluid_module.f90.html"},{"title":"mus_time_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_time_module.f90~~AfferentGraph sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2014 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2020 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains time definition needed for musubi module mus_time_module ! include treelm modules use env_module , only : rk use tem_time_module , only : tem_time_type , tem_time_dump use tem_timeControl_module , only : tem_timeControl_type , tem_timeControl_dump ,& & tem_timeControl_update , & & tem_timeControl_globalTriggered use tem_logging_module , only : logUnit implicit none private public :: mus_time_homogenize public :: mus_timeControl_homogenize public :: mus_time_modulo contains ! **************************************************************************** ! !> Convert itime from restart to real time !! subroutine mus_time_homogenize ( me , dt , readRestart ) ! ------------------------------------------------------------------------- type ( tem_time_type ), intent ( inout ) :: me real ( kind = rk ), intent ( in ) :: dt logical , intent ( in ) :: readRestart ! ------------------------------------------------------------------------- ! if readRestart is active, set sim real time from iTime if ( readRestart ) then me % sim = real ( me % iter , kind = rk ) * dt end if ! debug time output write ( logUnit ( 1 ), * ) 'Simulation time homogenize:' call tem_time_dump ( me , logUnit ( 1 ) ) end subroutine mus_time_homogenize ! **************************************************************************** ! ! **************************************************************************** ! !> Converts sim time to iter and vice versa depends on which one is defined !! in the configuration file subroutine mus_timeControl_homogenize ( me , dt , reqInt ) ! ------------------------------------------------------------------------- !> simulation time control type ( tem_timeControl_type ), intent ( inout ) :: me !> dt of maxlevel or smallest dt real ( kind = rk ), intent ( in ) :: dt !> Required interval, in which the update MUST occur. !! This is required for the musubi multilevel, where the time step should !! only be determined active, when the end of the largest cycle is reached. integer , intent ( in ) :: reqInt ! ------------------------------------------------------------------------- ! if sim time is defined set itime if ( me % min % sim < huge ( me % min % sim ) . and . & & me % min % iter == huge ( me % min % iter )) then me % min % iter = ceiling ( me % min % sim / dt ) ! if ( mod(me%min%iter, reqInt) /= 0 ) & !   & me%min%iter = me%min%iter + (reqInt - mod(me%min%iter, reqInt) me % min % iter = me % min % iter + mod (( reqInt - mod ( me % min % iter , reqInt )), & & reqInt ) end if if ( me % max % sim < huge ( me % max % sim ) . and . & & me % max % iter == huge ( me % max % iter )) then me % max % iter = ceiling ( me % max % sim / dt ) ! if ( mod(me%max%iter, reqInt) /= 0 ) & !   & me%max%iter = me%max%iter + reqInt - mod(me%max%iter, reqInt) me % max % iter = me % max % iter + mod (( reqInt - mod ( me % max % iter , reqInt )), & & reqInt ) end if if ( me % interval % sim < huge ( me % interval % sim ) . and . & & me % interval % iter == huge ( me % interval % iter )) then me % interval % iter = int ( me % interval % sim / dt ) ! update trigger if suppose min is defined by simulation time me % trigger % iter = ceiling ( me % trigger % sim / dt ) end if ! set simulation time to never thus timeControl trigger is only ! based on iterations and not on simulation time me % min % sim = huge ( me % min % sim ) me % max % sim = huge ( me % max % sim ) me % interval % sim = huge ( me % interval % sim ) ! if iTime is defined set sim time !if(me%min%iter < huge(me%min%iter)) then !  me%min%sim = real(me%min%iter, kind=rk)*dt !endif !if(me%max%iter < huge(me%max%iter)) then !  me%max%sim = real(me%max%iter, kind=rk)*dt !endif write ( logUnit ( 1 ), * ) 'Time control homogenize:' call tem_timeControl_dump ( me , logUnit ( 1 )) end subroutine mus_timeControl_homogenize ! **************************************************************************** ! ! **************************************************************************** ! !> Check for multilevel cycle complete by modulo of nIters by scaleFactor !! depends on acoustic or diffusive scaling. !! Acoustic scaling: scale factor = 2 !! Diffusive scaling: scale factor = 4 pure function mus_time_modulo ( now , reqInt ) result ( triggered ) ! ------------------------------------------------------------------------- !> current simulation time type ( tem_time_type ), intent ( in ) :: now !> Required interval, in which the update MUST occur. !! This is required for the musubi multilevel, where the time step should !! only be determined active, when the end of the largest cycle is reached. integer , intent ( in ) :: reqInt ! ------------------------------------------------------------------------- logical :: triggered ! ------------------------------------------------------------------------- triggered = ( mod ( now % iter , reqInt ) == 0 ) end function ! **************************************************************************** ! end module mus_time_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_time_module.f90.html"},{"title":"mus_mixture_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_mixture_module.f90~~EfferentGraph sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_mixture_module.f90~~AfferentGraph sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2017, 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Verena Krupp <verena.krupp@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains all information about fluid mixture module mus_mixture_module use env_module , only : rk , globalMaxLevels , single_k , & & eps_single_k , labelLen use tem_tools_module , only : tem_horizontalSpacer use tem_aux_module , only : tem_abort use tem_param_module , only : cs2 , cs2inv use tem_ini_condition_module , only : tem_ini_condition_type , tem_load_ic use tem_spatial_module , only : tem_spatial_type , tem_load_spatial use tem_temporal_module , only : tem_temporal_type , tem_load_temporal use tem_spacetime_fun_module , only : tem_spacetime_fun_type use tem_logging_module , only : logUnit use aot_table_module , only : aot_table_open , aot_table_close use aotus_module , only : flu_State , aot_get_val , & & aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType , flu_State use aot_out_module , only : aot_out_type , aot_out_val , aot_out_open_table , & & aot_out_close_table use mus_physics_module , only : mus_physics_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_eNRTL_module , only : mus_init_eNRTL use , intrinsic :: iso_c_binding , only : c_int , c_char , c_null_char implicit none private public :: mus_mixture_type public :: mus_load_mixture public :: mus_mixture_out !> relaxation paraemters multispecies required for each level type mixRelaxation_type !> lattice shear viscosity of the mixture for different level real ( kind = rk ) :: visc !> lattice free parameter B for different level real ( kind = rk ) :: paramB !> lattice bulk viscosity for different level real ( kind = rk ) :: bulkVisc !> relaxation parameter, !!  \\omega = K*B/\\rho , B - free parameter unit same as resistivity real ( kind = rk ) :: omega_diff real ( kind = rk ) :: omega_kine !< kinematic viscosity relaxation parameter end type mixRelaxation_type !> This type contains mixture information !! @todo KM: implement parameters which depend on dx and dt for all levels type mus_mixture_type !> initialization case, initial condition of the mixture type ( tem_ini_condition_type ) :: ic !> mass density of the mixture !! SI unit: kg/m&#94;3. !! Physics to lattice conversion: rho0/physics%rho0 real ( kind = rk ) :: rho0 !> lattice mass density of the mixture real ( kind = rk ) :: rho0LB !> number density of the mixture or total mixture molar density !! SI unit: mol/m&#94;3. !! physics to lattice conversion: !! nT0/physics%mol*physics%fac(minlevel)%length&#94;3. !! mixture molar density is required if initial condition !! are defined by molar fraction. !! set only if initial molefraction is space independent real ( kind = rk ) :: moleDens0 !> lattice number density of the mixture or total mixture molar density !! physics to lattice conversion: !! moleDens0/physics%mol*physics%fac(minlevel)%length&#94;3. real ( kind = rk ) :: moleDens0LB !> lattice kinematic shear viscosity of the mixture real ( kind = rk ) :: kine_viscosityLB !> physical kinematic shear viscosity of the mixture real ( kind = rk ) :: kine_viscosity !> lattice bulk viscosity real ( kind = rk ) :: bulk_viscosityLB !> physical bulk viscosity real ( kind = rk ) :: bulk_viscosity !> lattice bulk modulus of the liquid mixture !!  K = c_s&#94;2*\\rho , !!  c_s  - speed of sound (in lattice unit: \\f$ 1/\\sqrt{3} \\f$ real ( kind = rk ) :: bulk_modulusLB !> relaxation parameter, !!  \\omega = K*B/\\rho , B - free parameter unit same as resistivity real ( kind = rk ) :: omega_diff real ( kind = rk ) :: omega_kine !< kinematic viscosity relaxation parameter !> omega for higher order moments real ( kind = rk ) :: omega_hom !> relaxation parameters for each level type ( mixRelaxation_type ) :: relaxLvl ( globalMaxLevels ) !> temporal omega for ramping etc. type ( tem_temporal_type ) :: omega_ramping !> free parameter !! \\f$ B = \\omega*\\rho/K \\f$ real ( kind = rk ) :: paramB !> temperature real ( kind = rk ) :: temp0 !> temperature real ( kind = rk ) :: temp0LB !> equilibrium theta to choose between mixture velocity !! and equilibrium species velocity in the quadratic term !! equilibrium function. !! theta = 0 -> mixture velocity !! theta = 1 -> equilibrium species velocity !! \\todo KM: remove theta_eq and use !! mixture velocity in quadratic term of equilibrium function real ( kind = rk ) :: theta_eq !> spatial omega definition, e.g. for sponge layers type ( tem_spatial_type ) :: viscSpatial !> external electrical force !@todo use source term to define external force real ( kind = rk ) :: electricField ( 3 ) !> gravitational force real ( kind = rk ) :: gravityField ( 3 ) !> faraday constant(C/mol) real ( kind = rk ) :: faraday !> faraday constant in lattice real ( kind = rk ) :: faradayLB !> gas constant R (Nm/(mol *K)) real ( kind = rk ) :: gasConst_R !> gas constant R in lattice real ( kind = rk ) :: gasConst_R_LB !> eNRTL file with species properties character ( kind = c_char , len = labelLen ) :: prop_file !> atmospheric pressure real ( kind = rk ) :: atm_press !> atmospheric pressure real ( kind = rk ) :: atm_pressLB end type mus_mixture_type contains ! **************************************************************************** ! !> This routine load mixture table from scheme table. !! Define either mass density or number density. !! If mass density is specified, number density can be computed at runtime !! or vice versa. !! KM: @todo Currently, the simulation is initialized by density, extend !! it to initialize from mixture number density/volume fraction !! and mole fraction !! \\verbatim !! mixture = { rho0 = 1.0, omega } !! \\endverbatim subroutine mus_load_mixture ( me , conf , parent , minLevel , maxLevel , physics , & & schemeHeader , nFields ) ! -------------------------------------------------------------------------- !> contains mixture information type ( mus_mixture_type ), intent ( out ) :: me type ( flu_State ) :: conf !< flu state integer , intent ( in ), optional :: parent !< parent lua handle !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader integer , intent ( in ) :: minLevel , maxLevel !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> number of fields defined in lua file integer , intent ( in ) :: nFields ! -------------------------------------------------------------------------- !local variables integer :: mix_handle integer :: iError ( 1 ) integer :: vError ( 3 ), errFatal ( 3 ) logical :: prop_read integer :: nFields_loc ! -------------------------------------------------------------------------- errFatal = aotErr_Fatal call aot_table_open ( L = conf , parent = parent , thandle = mix_handle , & & key = 'mixture' ) ! if mixture handle is not defined if ( mix_handle == 0 ) then write ( logUnit ( 1 ), * ) ' ERROR: No mixture table defined' write ( logUnit ( 1 ), * ) '        Mixture properties are neccessary for' write ( logUnit ( 1 ), * ) '        multispecies scheme' call tem_abort () endif call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) ' Loading mixture information' ! load initial condition for mixture call tem_load_ic ( me = me % ic , & & conf = conf , & & parent = mix_handle , & & key = 'initial_condition' , & & errCode = iError , & & StateName = [ 'pressure' ] ) ! load species property file for thermodynamic factor only if ! relaxation kind is bgk_withthermodynfac if ( trim ( schemeHeader % relaxation ) == 'bgk_withthermodynfac' . or . & & trim ( schemeHeader % relaxation ) == 'mrt_withthermodynfac' ) then ! load species property from eNRTL file call aot_get_val ( L = conf , thandle = mix_handle , key = 'prop_file' , & & val = me % prop_file , default = '' , ErrCode = iError ( 1 ) ) ! if property file is defined, initialize eNRTL parameters using ! c-code if ( trim ( me % prop_file ) /= '' ) then me % prop_file = trim ( me % prop_file ) // C_NULL_CHAR write ( logUnit ( 1 ), * ) 'Thermodynamic property file name ' & & // trim ( me % prop_file ) prop_read = mus_init_eNRTL ( me % prop_file , nFields_loc ) if (. not . prop_read ) then write ( logUnit ( 1 ), * ) 'ERROR: loading prop_file need to compute ' & & // 'thermodynamic factors' write ( logUnit ( 1 ), * ) 'Solution: Compile musubi with \"--with_ext_tdf\"' & & // 'to compile musubi with external c-code which' write ( logUnit ( 1 ), * ) '          computes thermodynamic factor' call tem_abort () else if ( nFields_loc /= nFields ) then write ( logUnit ( 1 ), * ) 'nFields in config file: ' , nFields write ( logUnit ( 1 ), * ) 'nFields in property file: ' , nFields_loc call tem_abort ( \"Error: nFields in config file /= \" & & // \"nFields in thermodynamic property file\" ) end if endif endif endif !get mixture density call aot_get_val ( L = conf , thandle = mix_handle , key = 'rho0' , & & val = me % rho0 , default = 1.0_rk , ErrCode = iError ( 1 ) ) if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) ' FATAL Error occured, while retrieving mixture ' // & & 'density :' if ( btest ( iError ( 1 ), aoterr_WrongType )) then write ( logUnit ( 1 ), * ) ' Variable has wrong type!' call tem_abort () end if end if !convert to lattice me % rho0LB = me % rho0 / physics % rho0 !bulk modulus K = cs2 * rho me % bulk_modulusLB = cs2 * me % rho0 !get mixture number density call aot_get_val ( L = conf , thandle = mix_handle , key = 'moleDens0' , & & val = me % moleDens0 , default = 1.0_rk , ErrCode = iError ( 1 ) ) !KM: @todo check whether we need moleDens for different level me % moleDens0LB = me % moleDens0 / physics % moleDens0 if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) ' FATAL Error occured, while retrieving mixture ' // & & 'density :' if ( btest ( iError ( 1 ), aoterr_WrongType )) then write ( logUnit ( 1 ), * ) ' Variable has wrong type!' call tem_abort () end if end if !get equilibrium theta call aot_get_val ( L = conf , thandle = mix_handle , key = 'theta_eq' , & & val = me % theta_eq , ErrCode = iError ( 1 ) ) if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) ' FATAL Error occured, while retrieving theta_eq ' if ( btest ( iError ( 1 ), aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) ' ATTENTION: Setting theta_eq=1.0 i.e using mass ' write ( logUnit ( 1 ), * ) 'averaged mixture velocity in quadratic part of ' write ( logUnit ( 1 ), * ) 'equilibrium function' me % theta_eq = 1.0_rk end if if ( btest ( iError ( 1 ), aoterr_WrongType )) then write ( logUnit ( 1 ), * ) ' Variable has wrong type!' call tem_abort () end if end if ! Omega ramping call tem_load_temporal ( me = me % omega_ramping , & & conf = conf , & & parent = mix_handle , & & key = 'omega_ramping' ) me % viscSpatial % isStored = . false . call tem_load_spatial ( me = me % viscSpatial , & & conf = conf , & & parent = mix_handle , & & key = 'visc_spatial' ) !get diffusivity relaxation parameter call aot_get_val ( L = conf , thandle = mix_handle , key = 'omega_diff' , & & val = me % omega_diff , default = 2.0_rk , ErrCode = iError ( 1 )) if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) ' FATAL Error occured, while retrieving relaxation ' & & // 'parameter omega_diff :' if ( btest ( iError ( 1 ), aoterr_WrongType )) then write ( logUnit ( 1 ), * ) ' Variable has wrong type!' call tem_abort () end if end if ! if omega is not provided. load free parameter B and compute omega ! from paramB if ( btest ( iError ( 1 ), aotErr_NonExistent )) then write ( logUnit ( 1 ), * ) 'omega_diff not defined. Load paramB ' call aot_get_val ( L = conf , thandle = mix_handle , key = 'paramB' , & & val = me % paramB , ErrCode = iError ( 1 )) if ( btest ( iError ( 1 ), aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'ATTENTION: neither omega_diff nor paramB' write ( logUnit ( 1 ), * ) '           Setting default value to     ' write ( logUnit ( 1 ), * ) '           omega_diff = 2.0' me % omega_diff = 2.0 me % paramB = me % omega_diff / cs2 else !compute omega from paramB ! omega_diff = cs2 * B ! cs2 = p/rho for multispecies gas ! cs2 = K/rho for multispecies liquid me % omega_diff = me % paramB * cs2 end if else me % paramB = me % omega_diff / cs2 endif !get kinematic shear viscosity relaxation parameter call aot_get_val ( L = conf , thandle = mix_handle , key = 'omega_kine' , & & val = me % omega_kine , ErrCode = iError ( 1 )) if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving relaxation ' // & & 'parameter omega_kine:' if ( btest ( iError ( 1 ), aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' call tem_abort () end if end if ! if omega_kine is not provided. load kinematic viscosity in physical unit ! if physics table is active ! from paramB if ( btest ( iError ( 1 ), aotErr_NonExistent )) then write ( logUnit ( 1 ), * ) 'omega_kine is not defined.' // & & 'Load kinematic shear viscosity' call aot_get_val ( L = conf , thandle = mix_handle , & & key = 'kinematic_viscosity' , & & val = me % kine_viscosity , ErrCode = iError ( 1 )) if ( btest ( iError ( 1 ), aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'ATTENTION: neither omega_kine nor' // & & 'kine_shear_viscosity is defined' write ( logUnit ( 1 ), * ) '           Setting default value to lattice' // & & 'kine_shear_vis c= 1/(3*omega_diff)' me % kine_viscosityLB = cs2 / me % omega_diff me % kine_viscosity = me % kine_viscosityLB & & * physics % fac ( minLevel )% visc me % omega_kine = me % omega_diff else ! convert physical visc to lattice me % kine_viscosityLB = me % kine_viscosity & & / physics % fac ( minLevel )% visc !compute omega_kine from kinematic shear viscosity ! omega_kine = cs2 / viscosity me % omega_kine = cs2 / me % kine_viscosityLB end if else ! omega = cs&#94;2/nu -> nu = cs&#94;2/omega me % kine_viscosityLB = cs2 / me % omega_kine !physical me % kine_viscosity = me % kine_viscosityLB * physics % fac ( minLevel )% visc endif call aot_get_val ( L = conf , thandle = mix_handle , key = 'bulk_viscosity' , & & val = me % bulk_viscosity , & & ErrCode = iError ( 1 )) !convert to lattice me % bulk_viscosityLB = me % bulk_viscosity / physics % fac ( minLevel )% visc if ( btest ( iError ( 1 ), aoterr_NonExistent )) then ! formula for bulk viscosity. ! http://scienceworld.wolfram.com/physics/BulkViscosity.html ! require second viscosity coeff which is missing here write ( logUnit ( 1 ), * ) ' ATTENTION: Bulk viscosity is not provided.' write ( logUnit ( 1 ), * ) '            It is computed from shear viscosity as ' & & // 'bulk_visc = 2*nu/3' me % bulk_viscosityLB = 2._rk / 3._rk * me % kine_viscosityLB !me%bulk_viscosityLB = me%kine_viscosityLB me % bulk_viscosity = me % bulk_viscosityLB & & * physics % fac ( minLevel )% visc endif !get relaxation parameter for higher order moments call aot_get_val ( L = conf , thandle = mix_handle , key = 'omega_hom' , & & val = me % omega_hom , default = 2.0_rk , ErrCode = iError ( 1 )) !! load paramters for forces !electric field call aot_get_val ( L = conf , thandle = mix_handle , key = 'electricField' , & & val = me % electricField , default = ( / 0.0_rk , 0.0_rk , 0.0_rk / ),& & ErrCode = vError ) if ( any ( btest ( vError , errFatal ))) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving electricField ' call tem_abort () end if ! convert electricfield into lattice unit (N/C) me % electricField = me % electricField * physics % coulomb0 & & / physics % fac ( minLevel )% force !gravity field call aot_get_val ( L = conf , thandle = mix_handle , key = 'gravityField' , & & val = me % gravityField , default = ( / 0.0_rk , 0.0_rk , 0.0_rk / ), & & ErrCode = vError ) if ( any ( btest ( vError , errFatal ))) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving gravityField ' call tem_abort () end if ! convert gravityfield into lattice unit (m/s&#94;2) me % gravityField = me % gravityField & & * physics % dtLvl ( minLevel ) ** 2 & & / physics % dxLvl ( minLevel ) !temperature call aot_get_val ( L = conf , thandle = mix_handle , key = 'temp' , & & val = me % temp0 , default = 27 3._rk , ErrCode = iError ( 1 ) ) if ( btest ( iError ( 1 ), aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'temp (temperature)' call tem_abort () end if me % temp0LB = me % temp0 / physics % temp0 ! atmospheric pressure call aot_get_val ( L = conf , thandle = mix_handle , key = 'atm_press' , & & val = me % atm_press , default = 1.01325e5_rk , & & ErrCode = iError ( 1 ) ) me % atm_pressLB = me % atm_press / physics % fac ( minLevel )% press !set constant parameter faraday and gasconstant in lattice units me % faraday = 9648 5.3365 ![C/mol] me % faradayLB = me % faraday / physics % fac ( minLevel )% faraday !gas constant me % gasConst_R = 8.3144621 ![N m /(mol * K)] me % gasConst_R_LB = me % gasConst_R / physics % fac ( minLevel )% gasConst call aot_table_close ( L = conf , thandle = mix_handle ) write ( logUnit ( 1 ), * ) ' Mixture properties ' write ( logUnit ( 1 ), * ) '   theta_eq:                        ' , & & real ( me % theta_eq ) write ( logUnit ( 1 ), * ) '   Phy.reference mass density:      ' , real ( me % rho0 ) write ( logUnit ( 1 ), * ) '   Lat.reference mass density:      ' , real ( me % rho0LB ) write ( logUnit ( 1 ), * ) '   Phy.reference mole density:      ' , & & real ( me % moleDens0 ) write ( logUnit ( 1 ), * ) '   Lat.reference mole density:      ' , & & real ( me % moleDens0LB ) write ( logUnit ( 1 ), * ) '   Bulk modulus lattice B:          ' , & & real ( me % bulk_modulusLB ) write ( logUnit ( 1 ), * ) '   Diffusivity relaxation parameter:' , & & real ( me % omega_diff ) write ( logUnit ( 1 ), * ) '   Free parameter:                  ' , real ( me % paramB ) write ( logUnit ( 1 ), * ) '   Shear viscosity Physical:        ' , & & real ( me % kine_viscosity ) write ( logUnit ( 1 ), * ) '   Shear viscosityLB:               ' , & & real ( me % kine_viscosityLB ) write ( logUnit ( 1 ), * ) '   Kinematic shear viscosity omega: ' , & & real ( me % omega_kine ) write ( logUnit ( 1 ), * ) '   Bulk viscosity Physical:         ' , & & real ( me % bulk_viscosity ) write ( logUnit ( 1 ), * ) '   Bulk viscosityLB:                ' , & & real ( me % bulk_viscosityLB ) write ( logUnit ( 1 ), * ) '   Omega of Higher order moments: ' , real ( me % omega_hom ) write ( logUnit ( 1 ), * )( '   Setting omegas' ) call set_omegasLvl ( mixture = me , & & minLevel = minLevel , & & maxLevel = maxLevel , & & physics = physics ) write ( logUnit ( 1 ), * ) ' Forcing parameters' write ( logUnit ( 1 ), * ) '   ElectricField:               ' , & & real ( me % electricField ) write ( logUnit ( 1 ), * ) '   GravityField:                ' , & & real ( me % gravityField ) write ( logUnit ( 1 ), * ) '   Physical Temperature:        ' , real ( me % temp0 ) write ( logUnit ( 1 ), * ) '   Lattice Temperature:         ' , real ( me % temp0LB ) write ( logUnit ( 1 ), * ) '   Atmospheric pressure:        ' , real ( me % atm_press ) write ( logUnit ( 1 ), * ) '   Atm pressure lattice:        ' , real ( me % atm_pressLB ) write ( logUnit ( 1 ), * ) '   Faraday constant:            ' , real ( me % faraday ) write ( logUnit ( 1 ), * ) '   Faraday constant lattice:    ' , real ( me % faradayLB ) write ( logUnit ( 1 ), * ) '   Ideal Gas constant:          ' , real ( me % gasconst_R ) write ( logUnit ( 1 ), * ) '   Ideal Gas constant lattice:  ' , & & real ( me % gasconst_R_LB ) end subroutine mus_load_mixture ! **************************************************************************** ! ! **************************************************************************** ! !> Set the omegas according to the time step setting subroutine set_omegasLvl ( mixture , minLevel , maxLevel , physics ) ! -------------------------------------------------------------------------- type ( mus_mixture_type ), intent ( inout ) :: mixture !< mixture type integer , intent ( in ) :: minLevel , maxLevel !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics ! -------------------------------------------------------------------------- integer :: iLevel real ( kind = rk ) :: viscPhy_loc , error_rel ! -------------------------------------------------------------------------- mixture % relaxLvl (:)% paramB = 0._rk mixture % relaxLvl (:)% omega_diff = 0._rk mixture % relaxLvl (:)% visc = 0._rk mixture % relaxLvl (:)% omega_kine = 0._rk mixture % relaxLvl (:)% bulkvisc = 0._rk do iLevel = minLevel , maxLevel write ( logUnit ( 5 ), * ) '    level: ' , iLevel ! paramB is inverse of resistivity unit [s/m&#94;2] mixture % relaxLvl ( iLevel )% paramB = mixture % paramB & & * physics % fac ( iLevel )% visc & & / physics % fac ( minLevel )% visc mixture % relaxLvl ( iLevel )% omega_diff = mixture % relaxLvl ( iLevel )% paramB & & * cs2 write ( logUnit ( 5 ), * ) '    omega_diff ' , & & real ( mixture % relaxLvl ( iLevel )% omega_diff ) ! kinematic viscosity mixture % relaxLvl ( iLevel )% visc = mixture % kine_viscosityLB & & * physics % fac ( minLevel )% visc & & / physics % fac ( iLevel )% visc mixture % relaxLvl ( iLevel )% omega_kine = cs2 / mixture % relaxLvl ( iLevel )% visc write ( logUnit ( 5 ), * ) '    omega_kine ' , & & real ( mixture % relaxLvl ( iLevel )% omega_kine ) !bulk omega mixture % relaxLvl ( iLevel )% bulkVisc = mixture % bulk_viscosityLB & & * physics % fac ( minLevel )% visc & & / physics % fac ( iLevel )% visc end do !> cross check whether omega at each level is set correctly !! by computing physical viscosity from omega and check it with !! specified physical kinematic viscosity !!  \\nu = (1/ \\omega - 0.5)*cs2  do iLevel = minLevel , maxLevel viscPhy_loc = ( 1.0_rk / mixture % relaxLvl ( iLevel )% omega_kine ) * cs2 & & * physics % fac ( iLevel )% visc error_rel = ( mixture % kine_viscosity - viscPhy_loc ) / mixture % kine_viscosity write ( logUnit ( 3 ), * ) ' ATTENTION: Relative error between defined ' // & & 'physical viscosity to' write ( logUnit ( 3 ), * ) ' computed physical viscosity on level: ' , ilevel write ( logUnit ( 3 ), * ) '                                  is : ' , error_rel if ( abs ( real ( error_rel , kind = single_k )) > eps_single_k ) then write ( logUnit ( 1 ), * ) 'Error: Physical kinematic viscosity computed ' // & & 'from omega' write ( logUnit ( 1 ), * ) '       does not match with specified physical ' // & & 'kinematic viscosity' write ( logUnit ( 1 ), * ) ' Physical kinematic shear viscosity: ' , & & real ( mixture % kine_viscosity ) write ( logUnit ( 1 ), * ) ' Calculated phy kinematic shear viscosity: ' , & & real ( viscPhy_loc ) write ( logUnit ( 1 ), * ) ' Defined omega: ' , & & real ( mixture % relaxLvl ( iLevel )% omega_kine ) call tem_abort () end if end do end subroutine set_omegasLvl ! **************************************************************************** ! ! **************************************************************************** ! !> This routine write mixture properties into lua file subroutine mus_mixture_out ( me , conf , schemeHeader ) ! -------------------------------------------------------------------------- !> mixture info type ( mus_mixture_type ), intent ( in ) :: me type ( aot_out_type ) :: conf !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! -------------------------------------------------------------------------- select case ( trim ( schemeHeader % kind ) ) case ( 'multispecies_gas' , 'multispecies_liquid' ) call aot_out_open_table ( put_conf = conf , tname = 'mixture' ) call aot_out_val ( put_conf = conf , vname = 'rho0' , val = me % rho0 ) call aot_out_val ( put_conf = conf , vname = 'omega_diff' , & & val = me % omega_diff ) call aot_out_val ( put_conf = conf , vname = 'omega_kine' , & & val = me % omega_kine ) call aot_out_val ( put_conf = conf , vname = 'omega_hom' , & & val = me % omega_hom ) call aot_out_val ( put_conf = conf , vname = 'bulk_viscosity' , & & val = me % bulk_viscosity ) call aot_out_val ( put_conf = conf , vname = 'paramB' , val = me % paramB ) call aot_out_val ( put_conf = conf , vname = 'theta_eq' , & & val = me % theta_eq ) call aot_out_val ( put_conf = conf , vname = 'moleDens0' , & & val = me % moleDens0 ) call aot_out_val ( put_conf = conf , vname = 'temp' , val = me % temp0 ) call aot_out_val ( put_conf = conf , vname = 'atm_press' , & & val = me % atm_pressLB ) call aot_out_close_table ( put_conf = conf ) end select end subroutine mus_mixture_out end module mus_mixture_module","tags":"","loc":"sourcefile/mus_mixture_module.f90.html"},{"title":"mus_hvs_construction_module.f90 – Musubi","text":"* * * * * * * * * * * * ! This file depends on sourcefile~~mus_hvs_construction_module.f90~~EfferentGraph sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_hvs_construction_module.f90~~AfferentGraph sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! See copyright notice in the COPYRIGHT file. !! ****************************************************************************** ! !> author: Kannan Masilamani !! [[mus_hvs_construct]] \"Creation of the data structures\" !! from the information in the configuration and !! from the mesh read from disk for the musubi harvesting !! module mus_hvs_construction_module ! include treelm modules use mpi use env_module , only : rk , long_k , eps , labelLen , my_status_int use treelmesh_module , only : treelmesh_type use tem_comm_module , only : tem_communication_type , & & tem_commpattern_type use tem_tools_module , only : tem_horizontalSpacer use tem_grow_array_module , only : grw_intArray_type , init , append , destroy , & & empty , truncate use tem_dyn_array_module , only : dyn_intArray_type , init , append , expand , & & destroy , empty , PositionOfVal , truncate , & & dyn_labelArray_type use tem_construction_module , only : tem_init_elemLevels , tem_find_allElements ,& & tem_build_horizontalDependencies , & & tem_debug_horizontalDependencies , & & tem_levelDesc_type , & & tem_dumpTreeIDLists use tem_element_module , only : eT_fluid , eT_halo , eT_ghostFromCoarser , & & eT_ghostFromFiner , destroy use tem_timer_module , only : tem_startTimer , tem_stopTimer , & & tem_getTimerVal use tem_debug_module , only : main_debug , dbgUnit use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_param_module , only : mus_param_type use mus_geom_module , only : mus_geom_type use mus_scheme_layout_module , only : mus_scheme_layout_type , & & mus_finalize_layout use mus_scheme_type_module , only : mus_scheme_type use mus_pdf_module , only : mus_calc_nElems , & & mus_pdf_allocate use mus_construction_module , only : calculate_nElems use mus_timer_module , only : mus_timerHandles implicit none private public :: mus_hvs_construct contains ! ****************************************************************************** ! !> Initialize Musubi data strucutres based on data provided by Treelm !! !! Load the mesh and boundary conditions for this process from disk. !! Get the level-wise treeID lists and create the required ghost and halo !! elements. !! !! This is achieved by a two-folded identification of elements. !! !! -# the theoretically required elements are collected based on !! [[mus_scheme_layout_module:mus_scheme_layout_type]] \"stencil information\" !! The [[tem_construction_module:tem_findneighbor]] \"find neighbor routine\" !! performs this task for compute fluid elements. !! For boundaries which require information from neighbor elements, these !! required [[tem_topology_module]] \"treeIDs\" are collected into the !! [[mus_bc_header_module]] !! \"boundary element type\" !! -# All required elements are created in the !! [[tem_construction_module:tem_createleveldescriptor]] !! \"Level Descriptor creation routine\" !! !! # Additional Tasks !! !! - receive [[tem_construction_module:tem_buildhorizontaldependencies]] !! \"horizontal\" !! (within a level for the element updates) !! - and [[tem_construction:tem_buildverticaldependencies]] \"vertical\" !! dependencies (between levels for ghost-interpolations). !! - The main state vector and the neighbor lists on which the kernel then !!    acts is created !! - The MPI buffers are created. !! - For each [[mus_scheme_module]] \"Scheme\", the !! [[tem_construction_module:tem_levelDesc_type]] \"Level Descriptor\" !! is created !! !! # Result !! !! After this routine, all data structures for starting the main loop of the !! solver are allocated and ready. !! !! Only difference between this routine and mus_construct is then !! creating of boundary elements and its stencil are omitted for harvesting !! subroutine mus_hvs_construct ( scheme , geometry , params ) ! --------------------------------------------------------------------------- !> run-time Parameters type ( mus_param_type ), intent ( inout ) :: params !> geometric information type ( mus_geom_type ), intent ( inout ) :: geometry !> scheme information including fluid, boundary and flow information type ( mus_scheme_type ), intent ( inout ) :: scheme ! --------------------------------------------------------------------------- integer :: iLevel ! counter for level integer :: minLevel , maxLevel integer :: hwmVal integer :: ii ! --------------------------------------------------------------------------- minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel call tem_horizontalSpacer ( fUnit = dbgUnit ( 1 ), before = 1 ) write ( dbgUnit ( 1 ), * ) 'Get into routine: mus_construction' call tem_startTimer ( timerHandle = mus_timerHandles % initLvlD ) ! set up the data structures for the kernel write ( logUnit ( 1 ), * ) 'Starting to initialize the geometry' call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) ! finalize scheme layout ! copy growing array of stencil to allocatable array of stencil ! and destroy growing array call mus_finalize_layout ( layout = scheme % layout , & & nElemsInTree = geometry % tree % nElems , & & minLevel = minLevel , & & maxLevel = maxLevel , & & proc = params % general % proc ) hwmVal = my_status_int ( 'VmHWM:' ) write ( logUnit ( 10 ), \"(A,I0)\" ) 'After finalize layout, VmHWM: ' , hwmVal ! 1. store treeIDs which use this stencil in the !    levelDesc( elemLevel )%elem ! 2. store the neighbors which can be loaded from the disc or accessed !    directly ! THIS MEANS THAT FOR ALL ELEMENTS (INCL. BOUNDARY ELEMENTS) NEIGHBORS ! ARE STORED BUT THEY DO NOT NEED TO EXIST IN THE MESH AT THIS POINT!!! call tem_init_elemLevels ( & & me = scheme % levelDesc , & & boundary = geometry % boundary , & & tree = geometry % tree , & & stencils = [ scheme % layout % fStencil ] ) hwmVal = my_status_int ( 'VmHWM:' ) write ( logUnit ( 10 ), \"(A,I0)\" ) 'After init elemLevels, VmHWM: ' , hwmVal ! 1. build all dependencies for fluid, halos and ghosts ! 2. build the pointers for each element to its neighbors/stencil elements ! All this information is stored in tem_levelDesc_type. ! ! THIS MEANS THAT FOR ALL ELEMENTS FOUND IN em_init_elemLevels THE CORRECT ! DEPENDENCIES AND NEIGHBORS ARE SET ! ! This is the heart of the topologic data structure creation and ! takes most of the compute time, depending on the mesh you have ! write ( logUnit ( 1 ), * ) 'Creating level descriptor ...' write ( logUnit ( 6 ), * ) 'before tem_find_allElements' write ( dbgUnit ( 6 ), * ) 'before find_allElements' ! The level descriptor is created from the below routine. ! the neigh array is created using the LD and communication buffers are filled up. call tem_find_allElements ( & & tree = geometry % tree , & & levelDesc = scheme % levelDesc , & & levelPointer = geometry % levelPointer , & & computeStencil = [ scheme % layout % fStencil ], & & commPattern = params % general % commPattern , & & cleanup = . true ., & & reqNesting = params % nNesting , & & proc = params % general % proc ) hwmVal = my_status_int ( 'VmHWM:' ) write ( logUnit ( 10 ), \"(A,I0)\" ) 'After find allElements, VmHWM: ' , hwmVal if ( main_debug % dumpTreeIDlists ) then call tem_dumpTreeIDlists ( minLevel , maxLevel , & & scheme % levelDesc ) end if write ( dbgUnit ( 6 ), * ) 'before horizontal dep' write ( logUnit ( 6 ), * ) 'before tem_build_horizontalDependencies' call tem_build_horizontalDependencies ( & & iStencil = 1 , & & levelDesc = scheme % levelDesc , & & tree = geometry % tree , & & computeStencil = scheme % layout % fStencil ) if ( main_debug % checkDependencies ) then call tem_debug_HorizontalDependencies ( 1 , & & scheme % levelDesc , geometry % tree , & & scheme % layout % fStencil ) end if hwmVal = my_status_int ( 'VmHWM:' ) write ( logUnit ( 10 ), \"(A,I0)\" ) 'After build horizontal, VmHWM: ' , hwmVal call calculate_nElems ( levelDesc = scheme % levelDesc , & & proc = params % general % proc , & & minLevel = minLevel , & & maxLevel = maxLevel ) ! allocate here since it needs to be deallocated by dynamic load ! balancing algorithm write ( logUnit ( 6 ), \"(A,I0,A,I0)\" ) 'allocate PDF from Level ' , minLevel , & & ' to ' , maxLevel allocate ( scheme % pdf ( minLevel : maxLevel ) ) allocate ( scheme % state ( minLevel : maxLevel ) ) write ( logUnit ( 4 ), * ) 'Allocating PDF state and neighbor array' ! Allocate the PDF state array do iLevel = minLevel , maxLevel write ( dbgUnit ( 1 ), * ) 'calculate nElems on level: ' , iLevel call mus_calc_nElems ( & & me = scheme % pdf ( iLevel ), & & nFluids = scheme % levelDesc ( iLevel )% elem & & % nElems ( eT_fluid ), & & nGhostFromCoarser = scheme % levelDesc ( iLevel )% elem & & % nElems ( eT_ghostFromCoarser ), & & nGhostFromFiner = scheme % levelDesc ( iLevel )% elem & & % nElems ( eT_ghostFromFiner ), & & nHalos = scheme % levelDesc ( iLevel )% elem & & % nElems ( eT_halo ) ) allocate ( scheme % state ( iLevel )% val ( scheme % pdf ( iLevel )% nSize & & * scheme % varSys % nScalars , 2 ) ) !For debugging purposes, set complete flow field to invalid do ii = 1 , scheme % pdf ( iLevel )% nSize * scheme % varSys % nScalars scheme % state ( iLevel )% val ( ii , 1 ) = - 100000 0.0_rk scheme % state ( iLevel )% val ( ii , 2 ) = - 100000 0.0_rk end do call mus_pdf_allocate ( me = scheme % pdf ( iLevel ), & & nScalars = scheme % varSys % nScalars , & & QQ = scheme % layout % fStencil % QQ , & & nElems_bcBuffer = 0 , & & isPDF = scheme % readVarIsPdf ) end do hwmVal = my_status_int ( 'VmHWM:' ) write ( logUnit ( 10 ), \"(A,I0)\" ) 'After allocate PDF, VmHWM: ' , hwmVal write ( dbgUnit ( 6 ), * ) 'clean up elem list in level desctiptor' write ( logUnit ( 6 ), * ) 'clean up elem list in level descriptor' ! KJ: @todo de-activate for adaptive grid refinement do iLevel = minLevel , maxLevel call destroy ( me = scheme % levelDesc ( iLevel )% elem ) end do write ( dbgUnit ( 6 ), * ) 'after clean up' call tem_stopTimer ( timerHandle = mus_timerHandles % initLvlD ) call tem_horizontalSpacer ( before = 1 , fUnit = logUnit ( 1 ) ) write ( logUnit ( 1 ), \"(A,F10.3)\" ) 'Done initializing geometry. Took [s]' , & & tem_getTimerVal ( timerHandle = mus_timerHandles % initLvlD ) call tem_horizontalSpacer ( after = 1 , fUnit = logUnit ( 1 ) ) write ( dbgUnit ( 1 ), \"(A)\" ) 'after the construction' end subroutine mus_hvs_construct ! ****************************************************************************** ! end module mus_hvs_construction_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_hvs_construction_module.f90.html"},{"title":"mus_pdf_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_pdf_module.f90~~AfferentGraph sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2016, 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2013 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2017 Jana Gericke <jana.gericke@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> Definitions for the main state and neighbor arrays !! module mus_pdf_module ! include treelm modules use env_module , only : rk , globalMaxLevels , long_k use tem_construction_module , only : tem_levelDesc_type use tem_debug_module , only : dbgUnit use tem_logging_module , only : logUnit implicit none private public :: pdf_data_type public :: mus_calc_nElems public :: mus_pdf_allocate public :: mus_swap_Now_Next public :: allocate_momBuf !> This level-wise data type contains the PDF arrays which are fed into the !! kernel. !! The solver updates the state vector and finds the position of the neighbor !! vectors by looking it up in the neigh array type pdf_data_type ! Per level element numbers !> number of local fluid elements integer :: nElems_fluid !> number of halo elements (from remote processes) integer :: nElems_halo !> number of ghost elements (from other levels) integer :: nElems_ghostFromCoarser !> number of ghost elements (from other levels) integer :: nElems_ghostFromFiner !> number of ghost elements (from other levels) integer :: nElems_ghost !> number of local elements (fluid+halos+ghost) integer :: nElems_local !> fluid elements + ghostFromCoarser elements (elements for solver). !! PDF and auxFied are interpolated for ghostFromFiner and there is no !! need to do collision on these elements. integer :: nElems_solve !> fluid elements + ghostFromCoarse + ghostFromFiner integer :: nElems_computed !> number of elements padded to 4 integer :: nSize !> which buffer to use for current time step integer :: nNow = 1 !> which buffer to use for next time step integer :: nNext = 2 !> Connectivity array !! Points to where to send respective pdfs !! Access in a neigh way !! Size: QQ * nSize !! allocated in routine: mus_pdf_allocate integer , allocatable , dimension (:) :: neigh !dir$ attributes align : 32 :: neigh !> containing state vector values of elements which have a boundary !! It always uses AOS data layout !! allocated in routine: mus_pdf_allocate !! filled for each iteration in routine: fill_bcBuffer real ( kind = rk ), allocatable , dimension (:) :: bcBuffer !> Buffer storing the moments of all source from Coarser real ( kind = rk ), allocatable :: momBuf (:,:) end type pdf_data_type contains ! **************************************************************************** ! !> Compute nElems for different types subroutine mus_calc_nElems ( me , nFluids , nGhostFromCoarser , nGhostFromFiner , & & nHalos ) ! -------------------------------------------------------------------------- type ( pdf_data_type ) :: me integer , intent ( in ) :: nFluids , nGhostFromCoarser , nGhostFromFiner , nHalos ! -------------------------------------------------------------------------- integer :: remainder me % nElems_fluid = nFluids me % nElems_ghostFromCoarser = nGhostFromCoarser me % nElems_ghostFromFiner = nGhostFromFiner me % nElems_halo = nHalos me % nElems_local = nFluids + nGhostFromCoarser + nGhostFromFiner + nHalos me % nElems_ghost = nGhostFromCoarser + nGhostFromFiner me % nElems_solve = nFluids + nGhostFromCoarser me % nElems_computed = nFluids + nGhostFromCoarser + nGhostFromFiner remainder = mod ( me % nElems_local , 4 ) me % nSize = me % nElems_local + mod ( 4 - remainder , 4 ) ! print out number of elements of all kinds write ( dbgUnit ( 1 ), \"(A   )\" ) '' write ( dbgUnit ( 1 ), \"(A   )\" ) ' Number of local elements: ' write ( dbgUnit ( 1 ), \"(A,I0)\" ) '   fluid: ' , me % nElems_fluid write ( dbgUnit ( 1 ), \"(A,I0)\" ) '   ghostFromCoarser: ' , & & me % nElems_ghostFromCoarser write ( dbgUnit ( 1 ), \"(A,I0)\" ) '   ghostFromFiner:   ' , me % nElems_ghostFromFiner write ( dbgUnit ( 1 ), \"(A,I0)\" ) '   halo: ' , me % nElems_halo write ( dbgUnit ( 1 ), \"(A,I0)\" ) '   size: ' , me % nSize write ( dbgUnit ( 1 ), \"(A   )\" ) '' write ( logUnit ( 1 ), \"(A,I0)\" ) ' nSize of state array: ' , me % nSize end subroutine mus_calc_nElems ! **************************************************************************** ! ! **************************************************************************** ! subroutine mus_pdf_allocate ( me , nScalars , QQ , nElems_bcBuffer , isPDF ) ! -------------------------------------------------------------------------- type ( pdf_data_type ), intent ( inout ) :: me integer , intent ( in ) :: nScalars , QQ , nElems_bcBuffer logical , intent ( in ) :: isPDF ! -------------------------------------------------------------------------- if ( isPDF ) then allocate ( me % neigh ( me % nSize * QQ ) ) allocate ( me % bcBuffer ( nElems_bcBuffer * nScalars ) ) if ( nElems_bcBuffer /= 0 ) me % bcBuffer = - 1.0_rk end if end subroutine mus_pdf_allocate ! **************************************************************************** ! ! **************************************************************************** ! subroutine mus_swap_Now_Next ( me ) ! -------------------------------------------------------------------------- type ( pdf_data_type ), intent ( inout ) :: me ! -------------------------------------------------------------------------- me % nNow = mod ( me % nNow , 2 ) + 1 me % nNext = mod ( me % nNext , 2 ) + 1 end subroutine mus_swap_Now_Next ! **************************************************************************** ! ! **************************************************************************** ! subroutine allocate_momBuf ( me , nVals ) type ( pdf_data_type ), intent ( inout ) :: me integer , intent ( in ) :: nVals if ( nVals > 0 ) then allocate ( me % momBuf ( 10 , nVals ) ) else allocate ( me % momBuf ( 0 , 0 ) ) end if end subroutine allocate_momBuf ! **************************************************************************** ! end module mus_pdf_module ! **************************************************************************** ! ! **************************************************************************** ! !>\\page datastructures Data structures !! The Octree data structure is mapped to a one-dimensional array in order to !! have an efficient data structure on which the solver can act on in a !! performant way. An efficient representation of the elements and their !! neighbor relations is chosen. !! The fluid elements are mapped to a one-dimensional array and the neighboring !! relations are introduced by an additional connectivity array. The access of a !! neighbor element is performed by looking up the correct position of an !! element's link neighbor in the connectivity array, thus constituting an !! indirect access. !! !! \\image html  statevector_neighborlist.png !! !! The different dependencies of each link in an element require a thorough !! treatment, when data is exchanged at domain boundaries. Only the links, which !! point outside the domain have to be sent to neighbor partitions, and the !! links pointing inwards have to be filled with valid values from these.","tags":"","loc":"sourcefile/mus_pdf_module.f90.html"},{"title":"mus_source_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_source_module.f90~~EfferentGraph sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_source_module.f90~~AfferentGraph sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2016, 2018-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012-2013 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2015, 2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016, 2019 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! Module containing subroutines for initialize Musubi source !! variables and update source terms !! module mus_source_module ! include treelm modules use mpi use env_module , only : rk , long_k , long_k_mpi use tem_aux_module , only : tem_abort use tem_varSys_module , only : tem_varSys_type use tem_time_module , only : tem_time_type use treelmesh_module , only : treelmesh_type use tem_bc_prop_module , only : tem_bc_prop_type use tem_logging_module , only : logUnit use tem_construction_module , only : tem_levelDesc_type use tem_geometry_module , only : tem_baryOfID use tem_timer_module , only : tem_startTimer , tem_stopTimer use tem_tools_module , only : tem_horizontalSpacer use tem_debug_module , only : dbgUnit use tem_subTree_module , only : tem_create_subTree_of use tem_stencil_module , only : tem_stencilHeader_type use tem_stencil_module , only : tem_stencilHeader_type ! include musubi modules use mus_derVarPos_module , only : mus_derVarPos_type use mus_pdf_module , only : pdf_data_type use mus_field_module , only : mus_field_type use mus_source_type_module , only : mus_source_type , mus_source_op_type , & & mus_turbChannelForce_type , & & mus_HRRCorrectionTerm_type use mus_physics_module , only : mus_convertFac_type use mus_absorbLayer_module , only : mus_init_absorbLayer use mus_timer_module , only : mus_timerHandles implicit none private public :: mus_init_sourceTerms public :: mus_apply_sourceTerms public :: mus_update_sourceVars contains ! ************************************************************************** ! !> This routine does set_params and setupIndices for all sources terms !! by gathering points to apply souce term before. subroutine mus_init_sourceTerms ( field , nFields , globSrc , varSys , tree , & & bc_prop , stencil , nElems_solve , levelDesc ) ! -------------------------------------------------------------------------- !> Number of fields integer , intent ( in ) :: nFields !> contains sources of all fields type ( mus_field_type ), intent ( inout ) :: field (:) !> global source type ( mus_source_type ), intent ( inout ) :: globSrc !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> bc property which is used to identify elements belong to certain BCs type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> Number of elements to solve in all levels !! nFluids + nGhostFromCoarser integer , intent ( in ) :: nElems_solve ( tree % global % minLevel :) !> Level descriptors type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( tree % global % minLevel :) !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil ! -------------------------------------------------------------------------- integer :: iLevel , iField , iSrc integer :: nSolve , minLevel , maxLevel ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'Initializing Source terms ...' write ( dbgUnit ( 3 ), * ) 'Initializing Source terms ...' minLevel = tree % global % minLevel maxLevel = tree % global % maxLevel ! allocate source element array do iField = 1 , nFields do iSrc = 1 , field ( iField )% internalSource % varDict % nVals allocate ( field ( iField )% internalSource % method ( iSrc )% elemLvl ( minLevel : maxLevel ) ) end do end do ! get source parameter to store in data variable for coupling write ( logUnit ( 10 ), * ) ' Initializing internal sources' do iLevel = minLevel , maxLevel write ( logUnit ( 10 ), * ) '  iLevel: ' , iLevel write ( dbgUnit ( 3 ), * ) '  iLevel: ' , iLevel ! Use barycenter of all elements to solve i.e fluid+ghost to apply ! source terms nSolve = nElems_solve ( iLevel ) do iField = 1 , nFields write ( dbgUnit ( 3 ), * ) '  field source: ' , iField call mus_init_internalSource ( & & source = field ( iField )% internalSource , & & varSys = varSys , & & nSolve = nSolve , & & iLevel = iLevel , & & stencil = stencil ) end do end do ! iLevel ! immediately exit this routine if there are no source terms to apply if ( all ( field (:)% source % varDict % nVals == 0 ) & & . and . globSrc % varDict % nVals == 0 ) then write ( logUnit ( 1 ), * ) 'No active source terms' return end if ! allocate source element array do iField = 1 , nFields do iSrc = 1 , field ( iField )% source % varDict % nVals allocate ( field ( iField )% source % method ( iSrc )% elemLvl ( minLevel : maxLevel ) ) end do end do do iSrc = 1 , globSrc % varDict % nVals allocate ( globSrc % method ( iSrc )% elemLvl ( minLevel : maxlevel ) ) end do ! get source parameter to store in data variable for coupling write ( logUnit ( 10 ), * ) ' Setup indices for sources' write ( dbgUnit ( 3 ), * ) ' Setup indices for source' do iLevel = minLevel , maxLevel write ( logUnit ( 10 ), * ) '  iLevel: ' , iLevel write ( dbgUnit ( 3 ), * ) '  iLevel: ' , iLevel ! Use barycenter of all elements to solve i.e fluid+ghost to apply ! source terms nSolve = nElems_solve ( iLevel ) do iField = 1 , nFields write ( dbgUnit ( 3 ), * ) '  field source: ' , iField ! Store idx for active field source variables call mus_setupIndices_forSrc ( source = field ( iField )% source , & & varSys = varSys , & & tree = tree , & & bc_prop = bc_prop , & & stencil = stencil , & & nSolve = nSolve , & & bary = levelDesc ( iLevel ) & & % baryOfTotal , & & iLevel = iLevel ) end do write ( dbgUnit ( 3 ), * ) '  glob source: ' ! Store idx for active glob source variables call mus_setupIndices_forSrc ( source = globSrc , & & varSys = varSys , & & tree = tree , & & bc_prop = bc_prop , & & stencil = stencil , & & nSolve = nSolve , & & bary = levelDesc ( iLevel ) & & % baryOfTotal , & & iLevel = iLevel ) end do ! iLevel call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_init_sourceTerms ! ************************************************************************** ! ! ************************************************************************** ! !> This routines does setup indices for given source within a field or !! global. Index are stored for points which source term is active subroutine mus_setupIndices_forSrc ( source , varSys , nSolve , bary , iLevel , & & tree , bc_prop , stencil ) ! -------------------------------------------------------------------------- !> Source term to fill in type ( mus_source_type ), intent ( inout ) :: source !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> stencil used to find bcID on certain links type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> bc property which is used to identify elements belong to certain BCs type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> Number of elements to apply source term  on this level integer , intent ( in ) :: nSolve !> Space coordinates to apply source terms real ( kind = rk ), intent ( in ) :: bary (:,:) !> Current level integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------------- integer :: iVar , iElem , counter , src_nElems integer :: data_varPos integer , allocatable :: idx (:) integer ( kind = long_k ) :: nElems_var ( source % varDict % nVals ) ! -------------------------------------------------------------------------- allocate ( idx ( nSolve )) do iVar = 1 , source % varDict % nVals idx = 0 data_varPos = source % method ( iVar )% data_varPos ! number of components of the source field ! nComps = varSys%method%val(data_varPos)%nComponents ! set params call varSys % method % val ( data_varPos )% set_params ( & & varSys = varSys , & & instring = 'isSurface = false' ) call varSys % method % val ( data_varPos )% setup_indices ( & & varSys = varSys , & & point = bary , & & iLevel = iLevel , & & tree = tree , & & nPnts = nSolve , & & idx = idx ) ! Store only valid idx to apply source term only on shapes defined ! for a data variable src_nElems = count ( idx > 0 ) nElems_var ( iVar ) = src_nElems source % method ( iVar )% elemLvl ( iLevel )% nElems = src_nElems allocate ( source % method ( iVar )% elemLvl ( iLevel )% posInTotal ( src_nElems )) allocate ( source % method ( iVar )% elemLvl ( iLevel )% idx ( src_nElems )) !KM!      allocate(source%method(iVar)%elemLvl(iLevel)%val(src_nElems*nComps)) select case ( trim ( source % varDict % val ( iVar )% key )) case ( 'absorb_layer' , 'absorb_layer_inlet' , 'absorb_layer_outlet' ) call mus_init_absorbLayer ( absLayer = source % method ( iVar )% absLayer , & & dynAvg = source % method ( iVar ) & & % elemLvl ( iLevel )% dynAvg , & & nElems = src_nElems ) case ( 'turb_channel_force_accel' ) call mus_init_turbChanForce ( turbChanForce = source % method ( iVar ) & & % turbChanForce , & & tree = tree , & & bc_prop = bc_prop , & & stencil = stencil ) end select counter = 0 do iElem = 1 , nSolve if ( idx ( iElem ) > 0 ) then counter = counter + 1 source % method ( iVar )% elemLvl ( iLevel )% posInTotal ( counter ) = iElem source % method ( iVar )% elemLvl ( iLevel )% idx ( counter ) = idx ( iElem ) end if end do end do !iVar !KM!call MPI_Reduce(nElems_var, glob_nElems_var, source%varDict%nVals, & !KM!  &             long_k_mpi, mpi_sum,                              & !KM!  &             0, tree%global%comm, ierror                        ) do iVar = 1 , source % varDict % nVals data_varPos = source % method ( iVar )% data_varPos write ( dbgUnit ( 3 ), * ) 'Source iVar: ' , iVar , & & trim ( varSys % varName % val ( data_varPos )) write ( dbgUnit ( 3 ), * ) 'Total source nElems: ' , nElems_var ( iVar ) write ( logUnit ( 10 ), * ) 'Source iVar: ' , iVar , & & trim ( varSys % varName % val ( data_varPos )) write ( logUnit ( 10 ), * ) 'Total source nElems: ' , nElems_var ( iVar ) end do end subroutine mus_setupIndices_forSrc ! ************************************************************************** ! ! ************************************************************************** ! !> This routines does setup indices for given source within a field or !! global. Index are stored for points which source term is active subroutine mus_init_internalSource ( source , varSys , nSolve , iLevel , stencil ) ! -------------------------------------------------------------------------- !> Source term to fill in type ( mus_source_type ), intent ( inout ) :: source !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> Number of elements to apply source term  on this level integer , intent ( in ) :: nSolve !> Current level integer , intent ( in ) :: iLevel !> layout descriptor type ( tem_stencilHeader_type ), intent ( in ) :: stencil ! -------------------------------------------------------------------------- integer :: iVar , src_nElems ! -------------------------------------------------------------------------- do iVar = 1 , source % varDict % nVals ! Internal sources are applied to all fluid + ghostFromCoarser src_nElems = nSolve source % method ( iVar )% elemLvl ( iLevel )% nElems = nSolve select case ( trim ( source % varDict % val ( iVar )% key )) case ( 'hrr_correction' ) call mus_init_hrrCorrection ( HRR_Corr = source % method ( iVar ) & & % elemLvl ( iLevel )% HRR_Corr , & & nElems = src_nElems , & & nDim = stencil % nDims ) end select end do !iVar end subroutine mus_init_internalSource ! ************************************************************************** ! ! ************************************************************************** ! !> Create subTree and store nElemsGlobal in all proc for turbulent !! channel force subroutine mus_init_turbChanForce ( turbChanForce , tree , bc_prop , stencil ) ! -------------------------------------------------------------------------- !> Contains info for turbulent channel force type ( mus_turbChannelForce_type ), intent ( inout ) :: turbChanForce !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> bc property which is used to identify elements belong to certain BCs type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> stencil used to find bcID on certain links type ( tem_stencilHeader_type ), intent ( in ) :: stencil ! -------------------------------------------------------------------------- integer :: iErr ! -------------------------------------------------------------------------- call tem_create_subTree_of ( inTree = tree , & & bc_prop = bc_prop , & & stencil = stencil , & & subTree = turbChanForce % subTree_utau , & & inShape = turbChanForce % geom_utau ) call tem_create_subTree_of ( inTree = tree , & & bc_prop = bc_prop , & & stencil = stencil , & & subTree = turbChanForce % subTree_umean , & & inShape = turbChanForce % geom_umean ) ! Store global nElems in all proc to compute average velocity call mpi_allreduce ( turbChanForce % subTree_utau % nElems , & & turbChanForce % nElemsGlobal_utau , & & 1 , mpi_integer , mpi_sum , tree % global % comm , iErr ) call mpi_allreduce ( turbChanForce % subTree_umean % nElems , & & turbChanForce % nElemsGlobal_umean , & & 1 , mpi_integer , mpi_sum , tree % global % comm , iErr ) turbChanForce % forceDyn = 0.0_rk end subroutine mus_init_turbChanForce ! ************************************************************************** ! ! ************************************************************************** ! !> Initialize arrays to store time average density and velocity for !! dynamic hrrCorrection. !! \\todo KM: 20210301 Allocate also for ghost cells! subroutine mus_init_hrrCorrection ( HRR_Corr , nElems , nDim ) ! -------------------------------------------------------------------------- !> HRR correction term type type ( mus_HRRCorrectionTerm_type ), intent ( inout ) :: HRR_Corr !> Number of source elements integer , intent ( in ) :: nElems !> number of dimensions integer , intent ( in ) :: nDim ! -------------------------------------------------------------------------- allocate ( HRR_Corr % dens ( nElems )) allocate ( HRR_Corr % vel ( nElems , nDim )) HRR_Corr % dens (:) = 0.0_rk HRR_Corr % vel (:,:) = 0.0_rk end subroutine mus_init_hrrCorrection ! ************************************************************************** ! ! ************************************************************************** ! !> Apply all source terms i.e field specific source and global source on !! all fields. !! subroutine mus_apply_sourceTerms ( field , nFields , globSrc , pdf , varSys , & & iLevel , time , phyConvFac , state , & & auxField , derVarPos ) ! -------------------------------------------------------------------------- !> Number of fields integer , intent ( in ) :: nFields !> contains sources of all fields type ( mus_field_type ), intent ( in ) :: field ( nFields ) !> global source type ( mus_source_type ), intent ( in ) :: globSrc !> pdf datatype type ( pdf_data_type ), intent ( inout ) :: pdf !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> current level integer , intent ( in ) :: iLevel !> current timing information type ( tem_time_type ), intent ( in ) :: time !> state type containing the state vector to update real ( kind = rk ), intent ( inout ) :: state (:,:) !> auxField array real ( kind = rk ), intent ( in ) :: auxField (:) !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- ! counter variables integer :: iSrc , iField integer :: now , next ! -------------------------------------------------------------------------- call tem_startTimer ( timerHandle = mus_timerHandles % source ) ! \\todo create buffer for source to copy state values before applying ! source term to avoid using state which overwritten by source variable now = pdf % nNow next = pdf % nNext ! loop over all active sourve variable to apply source. ! Note: Internal field sources are added to state in compute routine do iField = 1 , nFields do iSrc = 1 , field ( iField )% source % varDict % nVals call field ( iField )% source % method ( iSrc )% applySrc ( & & inState = state (:, now ), & & outState = state (:, next ), & & neigh = pdf % neigh (:), & & auxField = auxField , & & nPdfSize = pdf % nSize , & & iLevel = iLevel , & & varSys = varSys , & & time = time , & & derVarPos = derVarPos , & & phyConvFac = phyConvFac ) end do end do ! apply global source do iSrc = 1 , globSrc % varDict % nVals call globSrc % method ( iSrc )% applySrc ( & & inState = state (:, now ), & & outState = state (:, next ), & & neigh = pdf % neigh (:), & & auxField = auxField , & & nPdfSize = pdf % nSize , & & iLevel = iLevel , & & varSys = varSys , & & time = time , & & derVarPos = derVarPos , & & phyConvFac = phyConvFac ) end do call tem_stopTimer ( timerHandle = mus_timerHandles % source ) end subroutine mus_apply_sourceTerms ! **************************************************************************** ! ! ************************************************************************** ! !> Updated all source variables i.e field specific source and global source on !! all fields. !! subroutine mus_update_sourceVars ( nFields , field , globSrc , varSys , iLevel , & & auxField , phyConvFac , derVarPos ) ! -------------------------------------------------------------------------- !> Number of fields integer , intent ( in ) :: nFields !> contains sources of all fields type ( mus_field_type ), intent ( inout ) :: field ( nFields ) !> global source type ( mus_source_type ), intent ( inout ) :: globSrc !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> current level integer , intent ( in ) :: iLevel !> auxField array real ( kind = rk ), intent ( in ) :: auxField (:) !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- ! counter variables integer :: iSrc , iField ! -------------------------------------------------------------------------- call tem_startTimer ( timerHandle = mus_timerHandles % source ) ! update field source variables do iField = 1 , nFields do iSrc = 1 , field ( iField )% source % varDict % nVals call field ( iField )% source % method ( iSrc )% updateSourceVar ( & & auxField = auxField , & & iLevel = iLevel , & & varSys = varSys , & & phyConvFac = phyConvFac , & & derVarPos = derVarPos ) end do end do ! update global source variables do iSrc = 1 , globSrc % varDict % nVals call globSrc % method ( iSrc )% updateSourceVar ( & & auxField = auxField , & & iLevel = iLevel , & & varSys = varSys , & & phyConvFac = phyConvFac , & & derVarPos = derVarPos ) end do call tem_stopTimer ( timerHandle = mus_timerHandles % source ) end subroutine mus_update_sourceVars ! ************************************************************************** ! end module mus_source_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_source_module.f90.html"},{"title":"mus_weights_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_weights_module.f90~~EfferentGraph sourcefile~mus_weights_module.f90 mus_weights_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_weights_module.f90->sourcefile~mus_timer_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_weights_module.f90~~AfferentGraph sourcefile~mus_weights_module.f90 mus_weights_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_weights_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! This module include the routine required for element wie dumping weight !! for better load balancing. !! Dump weights at end of simulation if 'write_weights' is defined in the config !! file. Weights are based on element wise time measurements module mus_weights_module ! include treelm modules use env_module , only : PathLen , rk , tem_create_EndianSuffix use treelmesh_module , only : treelmesh_type , tem_dump_weights use tem_construction_module , only : tem_levelDesc_type use tem_topology_module , only : tem_levelOf use tem_element_module , only : eT_fluid use tem_logging_module , only : logUnit use tem_debug_module , only : dbgUnit ! include musubi modules use mus_bc_header_module , only : glob_boundary_type use mus_timer_module , only : mus_timerHandles , get_computeTime , & & get_intpFromCoarserTime , & & get_intpFromFinerTime , & & get_bcBufferTime , & & get_boundaryTime implicit none private public :: mus_getWeights public :: mus_dumpWeights contains ! ************************************************************************** ! !> Calculate weights using timing from compute kernel, interpolation and !! boundary routines subroutine mus_getWeights ( weights , tree , minLevel , maxLevel , levelDesc , & & nBCs , globBC ) ! -------------------------------------------------------------------------- ! weights for fluid elements real ( kind = rk ), intent ( out ) :: weights (:) !> geometry infomation type ( treelmesh_type ), intent ( in ) :: tree !> min level and max level integer , intent ( in ) :: minLevel , maxLevel !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( minLevel : maxLevel ) !> global IBM type ! type( mus_IBM_globType ), intent(in) :: globIBM !> Number of boundary conditions integer , intent ( in ) :: nBCs !> BC elements information type ( glob_boundary_type ), intent ( in ) :: globBC ( nBCs ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- ! Assign weights based on compute and intp time call assign_level_weights ( weights ) ! Assign weights based on boundary condition call assign_bc_weights ( weights ) contains ! ************************************************************************ ! !> Assign weights based on compute kernel and interpolation subroutine assign_level_weights ( weights ) ! ------------------------------------------------------------------------ ! weights for fluid elements real ( kind = rk ), intent ( out ) :: weights (:) ! ------------------------------------------------------------------------ real ( kind = rk ) :: level_weight ( minLevel : maxLevel ) integer :: iLevel , iElem ! ------------------------------------------------------------------------ write ( logUnit ( 7 ), \"(A)\" ) 'Assign weights by Computation and Interpolation' write ( dbgUnit ( 1 ), \"(A)\" ) 'Assign weights by Computation and Interpolation' write ( dbgUnit ( 1 ), \"(A5,4A10)\" ) 'level' , 'computeT' , 'intpT' , 'nElems' , & & 'weight' do iLevel = minLevel , maxLevel if ( levelDesc ( iLevel )% elem % nElems ( eT_fluid ) > 0 ) then ! include compute and intp time level_weight ( iLevel ) = ( get_computeTime ( iLevel ) & & + get_intpFromCoarserTime ( iLevel ) & & + get_intpFromFinerTime ( iLevel ) & & ) / levelDesc ( iLevel )% elem % nElems ( eT_fluid ) else level_weight ( iLevel ) = 0._rk end if write ( dbgUnit ( 1 ), \"(I5,E10.2,E10.2,I10,E10.2)\" ) iLevel , & & get_computeTime ( iLevel ), & & get_intpFromCoarserTime ( iLevel ) & & + get_intpFromFinerTime ( iLevel ), & & levelDesc ( iLevel )% elem % nElems ( eT_fluid ), & & level_weight ( iLevel ) end do ! iLevel = minLevel, maxLevel do iElem = 1 , tree % nElems iLevel = tem_levelOf ( tree % treeID ( iElem )) weights ( iElem ) = level_weight ( iLevel ) end do write ( dbgUnit ( 1 ), \"(A)\" ) '' ! Debug output !      write(dbgUnit(1),*) \"Calculate level weight based on intp and \" & !        &                 // \"compute time\" !      write(dbgUnit(1),\"(A8, 4A15)\") \"level\", \"nFluids\", \"t intp\", & !        &                            \"t compute\", \"weight\" !      write(dbgUnit(1),\"(I8, I15, 3F15.10)\") iLevel,                        & !        &  levelDesc(iLevel)%elem%nElems( eT_fluid ),                       & !        &  tem_getTimerVal(timerHandle = mus_timerHandles%compute(iLevel)), & !        &  tem_getTimerVal(timerHandle = mus_timerHandles                   & !        &                                %intpFromCoarser(iLevel)),         & !        &  level_weight( iLevel ) end subroutine assign_level_weights !************************************************************************* ! ! ************************************************************************ ! !> Append weights based on boundary condition subroutine assign_bc_weights ( weights ) ! ------------------------------------------------------------------------ ! weights for fluid elements real ( kind = rk ), intent ( inout ) :: weights (:) ! ----------------------------------------------------------------------- integer :: iBC , iLevel , iElem , posInTotal , posInTree real ( kind = rk ) :: bc_w , buffer_w ! ------------------------------------------------------------------------ write ( logUnit ( 7 ), \"(A)\" ) 'Assign weights by Boundary Conditions' write ( dbgUnit ( 1 ), \"(A)\" ) 'Assign weights by Boundary Conditions' ! Assume all bc elements shared the same cost of filling bc buffer if ( levelDesc ( minLevel )% bc_elemBuffer % nVals > 0 ) then buffer_w = get_bcBufferTime () / dble ( levelDesc ( minLevel )% bc_elemBuffer & & % nVals ) else buffer_w = 0.0_rk end if write ( dbgUnit ( 1 ), \"(A,ES10.2)\" ) 'buffer weight: ' , buffer_w write ( dbgUnit ( 1 ), \"(A2,3A10)\" ) 'BC' , 'Time' , 'nElems' , 'weight' do iBC = 1 , nBCs if ( globBC ( iBC )% nElems_local > 0 ) then ! calc BC weight: bc_w(ii) = bc_time(ii) / bc_nElems(ii) bc_w = get_boundaryTime ( iBC ) / dble ( globBC ( iBC )% nElems_local ) & & + buffer_w do iLevel = minLevel , maxLevel do iElem = 1 , globBC ( iBC )% nElems_Fluid ( iLevel ) posInTotal = globBC ( iBC )% elemLvl ( iLevel )% elem % val ( iElem ) posInTree = levelDesc ( iLevel )% pntTID ( posInTotal ) weights ( posInTree ) = weights ( posInTree ) + bc_w end do end do write ( dbgUnit ( 1 ), \"(I2,ES10.2,I10,ES10.2)\" ) iBC , & & get_boundaryTime ( iBC ), & & globBC ( iBC )% nElems_local , & & bc_w end if ! globBC( iBC )%nElems_local > 0 end do write ( dbgUnit ( 1 ), \"(A)\" ) '' end subroutine assign_bc_weights ! ********************************************************************** ! end subroutine mus_getWeights ! ************************************************************************ ! ! ************************************************************************ ! !> Dump weights to a file. subroutine mus_dumpWeights ( tree , weights , basename ) ! ------------------------------------------------------------------------ type ( treelmesh_type ), intent ( in ) :: tree real ( kind = rk ), intent ( in ) :: weights (:) character ( len = pathLen ), intent ( in ) :: basename ! ------------------------------------------------------------------------ integer :: iError character ( len = PathLen ) :: filename character ( len = 4 ) :: EndianSuffix ! ------------------------------------------------------------------------ iError = 0 EndianSuffix = tem_create_EndianSuffix () filename = trim ( basename ) // EndianSuffix call tem_dump_weights ( me = tree , & & filename = filename , & & weights = weights ) end subroutine mus_dumpWeights ! ************************************************************************** ! end module mus_weights_module","tags":"","loc":"sourcefile/mus_weights_module.f90.html"},{"title":"mus_mesh_adaptation_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_mesh_adaptation_module.f90~~EfferentGraph sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !! author: Kartik Jain !> This module contains the code responsible for adaptively refining the mesh !! during run time. !! module mus_mesh_adaptation_module ! include treelm modules use mpi use env_module , only : rk , long_k use tem_adaptation_module , only : tem_adapt_dump_newMesh use tem_comm_env_module , only : tem_comm_env_type use tem_adaptation_config_module , only : tem_adapt_type ! include musubi modules use mus_scheme_type_module , only : mus_scheme_type use mus_geom_module , only : mus_geom_type implicit none private public :: mus_adapt_refine contains ! **************************************************************************** ! !> Wrap up the routines required for dynamic load balancing subroutine mus_adapt_refine ( geometry , scheme , proc , adapt ) ! -------------------------------------------------------------------------- !> Treelmesh data type ( mus_geom_type ) , intent ( inout ) :: geometry !> scheme type type ( mus_scheme_type ) , intent ( inout ) :: scheme type ( tem_comm_env_type ) , intent ( in ) :: proc !> mesh adaptation type ( tem_adapt_type ) , intent ( in ) :: adapt ! -------------------------------------------------------------------------- ! Now you get the adaptively refined mesh back ! Dump it to the disk at the current moment call tem_adapt_dump_newMesh ( levelDesc = scheme % levelDesc , & & tree = geometry % tree , & & proc = proc ) end subroutine mus_adapt_refine end module mus_mesh_adaptation_module","tags":"","loc":"sourcefile/mus_mesh_adaptation_module.f90.html"},{"title":"mus_initPoisson_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initpoisson_module.f90~~EfferentGraph sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2017-2018 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for lbm incompressible model. module mus_initPoisson_module ! include treelm modules use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_compute_Poisson_module , only : mus_Poisson_advRel_generic , & & mus_Poisson_advRel_d2q9 , & & mus_PBLinear_advRel_generic , & & mus_PBnonLinear_advRel_generic use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_Poisson public :: mus_init_advRel_PBLinear public :: mus_init_advRel_PBnonLinear contains ! ************************************************************************** ! !> Initialize the relaxation model for lbm poisson equation subroutine mus_init_advRel_Poisson ( relaxation , layout , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing relaxation model for Poisson: ' & & // trim ( relaxation ) select case ( trim ( relaxation )) case ( 'bgk' ) select case ( trim ( layout ) ) case ( 'd2q9' ) compute => mus_Poisson_advRel_d2q9 case default compute => mus_Poisson_advRel_generic end select case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select end subroutine mus_init_advRel_Poisson ! ************************************************************************** ! ! ************************************************************************** ! !> Initialize the relaxation model for lbm poisson equation subroutine mus_init_advRel_PBLinear ( relaxation , layout , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing relaxation model for Poisson-Boltzmann ' & & // 'linear: ' // trim ( relaxation ) select case ( trim ( relaxation )) case ( 'bgk' ) compute => mus_PBLinear_advRel_generic case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select end subroutine mus_init_advRel_PBLinear ! ************************************************************************** ! ! ************************************************************************** ! !> Initialize the relaxation model for lbm poisson equation subroutine mus_init_advRel_PBnonLinear ( relaxation , layout , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing relaxation model for Poisson-Boltzmann ' & & // 'nonLinear: ' // trim ( relaxation ) select case ( trim ( relaxation )) case ( 'bgk' ) compute => mus_PBnonLinear_advRel_generic case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select end subroutine mus_init_advRel_PBnonLinear ! ************************************************************************** ! end module mus_initPoisson_module","tags":"","loc":"sourcefile/mus_initpoisson_module.f90.html"},{"title":"mus_turb_wallFunc_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_turb_wallfunc_module.f90~~EfferentGraph sourcefile~mus_turb_wallfunc_module.f90 mus_turb_wallFunc_module.f90 sourcefile~mus_wall_function_abstract_module.f90 mus_wall_function_abstract_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_musker_module.f90 mus_wall_function_musker_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_musker_module.f90 sourcefile~mus_wall_function_reichardt_module.f90 mus_wall_function_reichardt_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_reichardt_module.f90 sourcefile~mus_wall_function_schmitt_module.f90 mus_wall_function_schmitt_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_schmitt_module.f90 sourcefile~mus_wall_function_musker_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_reichardt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_schmitt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2022 Kannan Masilamani <kannan.masilaman@dlr.de> ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! Copyright (c) 2023 Harald Klimach <harald.klimach@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains turbulent wall function type and routines to calculate !! friction velocity and stream-wise velocity component. module mus_turb_wallFunc_module ! include treelm modules use env_module , only : rk , long_k , labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_float_module , only : operator (. fle .) ! include aotus modules use aotus_module , only : flu_State , aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType , aot_get_val use mus_wall_function_abstract_module , only : mus_wall_function_type use mus_wall_function_musker_module , only : mus_wall_function_musker_type use mus_wall_function_schmitt_module , only : mus_wall_function_schmitt_type , & & get_uTau_logLayer , & & get_uTau_subVisousLayer , & & sc_lLmt , sc_uLmt use mus_wall_function_reichardt_module , only : mus_wall_function_reichardt_type implicit none private public :: mus_turb_wallFunc_type public :: mus_load_turb_wallFunc !> Contains friction velocity and turbulent viscosity on boundary elements on !! each level type mus_turb_wallFunc_data_type !> Turbulent viscosity on boundary element computed using mixing length !! formulation in lattice unit !! nu_t = (vonKarman*distToBnd)**2 * |du/dy| real ( kind = rk ), allocatable :: tVisc (:) !> Friction velocity on first neighbor in normal direction in lattice unit !! computed from wall model real ( kind = rk ), allocatable :: velTau (:) !> Distance to boundary from first fluid in normal direction !! in lattice unit. real ( kind = rk ), allocatable :: distToBnd (:) !> Distance to boundary from first fluid neighbor in normal direction !! in lattice unit. real ( kind = rk ), allocatable :: neighDistToBnd (:) !> Unit normal for each boundary element. !! Size: (3, nElems) real ( kind = rk ), allocatable :: unitNormal (:,:) !> Force on each boundary element. !! Size: (3, nElems) real ( kind = rk ), allocatable :: bndForce (:,:) !> Moment on each boundary element. !! Size: (3, nElems) real ( kind = rk ), allocatable :: bndMoment (:,:) end type mus_turb_wallFunc_data_type !> Contains function pointers to compute friction velocity and stream-wise !! velocity component type mus_turb_wallFunc_type !> is true if wall function is active logical :: isActive = . false . !> Wall model function character ( len = labelLen ) :: wall_func !> Nonlinear solver type character ( len = labelLen ) :: nonlinear_solver !> Von-Karman constant. Default = 0.4_rk real ( kind = rk ) :: vonKarman = 0.4_rk !> Use vanDriest damping function to damp turbulent viscosity logical :: useVanDriest = . true . !> Contains data computed in turbulent wall bc routine on each level type ( mus_turb_wallFunc_data_type ), allocatable :: dataOnLvl (:) !> Function pointer to compute friction velocity procedure ( mus_proc_calcFricVel ), pointer , pass ( this ) :: calcFricVel => null () !> Function pointer to compute strean-wise velocity component procedure ( mus_proc_calcStreamWiseVel ), pointer , nopass :: & & calcStreamWiseVel => null () !> Allocate wall function object class ( mus_wall_function_type ), allocatable :: wall_function !> Function pointer to the iterative method procedure ( mus_iterative_method_interface ), pointer , nopass :: & & iterativeMethod => null () end type mus_turb_wallFunc_type !> Interface definition for the turbulent wall bc routines abstract interface !> This abstract interface defines the interface to calculate turbulent wall !! friction velocity from given velocity and distance to boundary. !! All inputs and output are in lattice units. pure subroutine mus_proc_calcFricVel ( this , velTau , velSW , distToBnd , & & viscKine , nElems ) import :: rk , mus_wall_function_type , mus_turb_wallFunc_type !> Turbulent wall model to use for the computation class ( mus_turb_wallFunc_type ), intent ( in ) :: this !> Friction velocity computed from wall model. !! it is inout to provide velTau from previous timestep as initial velTau !! for fixed-point or Newton iteration solver real ( kind = rk ), intent ( inout ) :: velTau (:) !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW (:) !> Distance to the boundary in the discrete normal direction real ( kind = rk ), intent ( in ) :: distToBnd (:) !> Kinematic viscosity real ( kind = rk ), intent ( in ) :: viscKine (:) !> Number of elements in input and output arrays integer , intent ( in ) :: nElems end subroutine mus_proc_calcFricVel !> This abstract interface defines the interface to calculate stream-wise !! velocity component from friction velocity and distance to boundary. !! All inputs and output are in lattice units. pure subroutine mus_proc_calcStreamWiseVel ( velSW , velTau , distToBnd , & & viscKine , nElems , wall_function ) import :: rk , mus_wall_function_type !> Stream-wise velocity component from wall model real ( kind = rk ), intent ( out ) :: velSW (:) !> Friction velocity computd from wall model real ( kind = rk ), intent ( in ) :: velTau (:) !> Distance to the boundary in the discrete normai direction real ( kind = rk ), intent ( in ) :: distToBnd (:) !> Kinematic viscosity real ( kind = rk ), intent ( in ) :: viscKine (:) !> Number of elements in input and output arrays integer , intent ( in ) :: nElems !> Allocate wall function object class ( mus_wall_function_type ), intent ( in ) :: wall_function end subroutine mus_proc_calcStreamWiseVel !> This routine computes friction velocity from wall model profile !! using Newton iteration method pure function mus_iterative_method_interface ( velTau_initialGuess , velSW , & & y , nu , wall_function ) result ( velTau_new ) ! -------------------------------------------------------------------- ! import :: rk , mus_wall_function_type !> Friction velocity computed from previsous time step real ( kind = rk ), intent ( in ) :: velTau_initialGuess !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> Number of elements in input and output arrays class ( mus_wall_function_type ), intent ( in ) :: wall_function !> Friction velocity computed in this routine real ( kind = rk ) :: velTau_new end function mus_iterative_method_interface end interface !! Constant parameters for Implicit equation solver integer , parameter :: imEq_nIter = 1000 real ( kind = rk ), parameter :: imEq_tol = 1e-10 contains ! -------------------------------------------------------------------------- ! !> This routine loads wall model and nonlinear solver type for nonlinear !! equation subroutine mus_load_turb_wallFunc ( me , conf , parent ) ! -------------------------------------------------------------------- ! !> Turbulent wall model type to fill assign wall model type ( mus_turb_wallFunc_type ), intent ( inout ) :: me !> lua flu state type ( flu_state ) :: conf !> bc parent handle integer , intent ( in ) :: parent ! -------------------------------------------------------------------- ! integer :: iError ! -------------------------------------------------------------------- ! write ( logUnit ( 2 ), \"(A)\" ) '  Loading turbulent wall_function >>>' me % isActive = . true . call load_wall_function ( me , conf , parent ) call load_iterativeMethod ( me , conf , parent ) ! Von-Karman constant call aot_get_val ( L = conf , & & thandle = parent , & & key = 'von_karman' , & & val = me % vonKarman , & & default = 0.4_rk , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' & & // 'von_karman:' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type (should be number)!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if end if write ( logUnit ( 2 ), * ) '  von Karman: ' , me % vonKarman ! Use van Driest damping function call aot_get_val ( L = conf , & & thandle = parent , & & key = 'use_van_driest' , & & val = me % useVanDriest , & & default = . true ., & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' & & // 'use_van_driest:' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type (should be bool)!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if end if write ( logUnit ( 2 ), * ) '  use van Driest: ' , me % useVanDriest me % calcStreamWiseVel => computeStreamWiseVel write ( logUnit ( 2 ), \"(A)\" ) '  <<< Done loading turbulent wall_function' end subroutine mus_load_turb_wallFunc ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> Load the iterativeMethod to use in the turbulent wall model from the user !! configuration. subroutine load_iterativeMethod ( me , conf , parent ) ! -------------------------------------------------------------------- ! !> Turbulent wall model type to fill assign wall model type ( mus_turb_wallFunc_type ), intent ( inout ) :: me !> lua flu state type ( flu_state ) :: conf !> bc parent handle integer , intent ( in ) :: parent ! -------------------------------------------------------------------- ! integer :: iError ! -------------------------------------------------------------------- ! call aot_get_val ( L = conf , & & thandle = parent , & & key = 'nonlinear_solver' , & & val = me % nonlinear_solver , & & default = 'fixed_point' , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' & & // 'nonlinear_solver:' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type (should be string)!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if end if select case ( trim ( me % nonlinear_solver )) case ( 'fixed_point' ) me % iterativeMethod => fixedPoint_method case ( 'newton' ) me % iterativeMethod => newton_method case default call tem_abort ( 'Error: Unsupported nonlinear solver ' & & // trim ( me % nonlinear_solver ) // ' for wall function' ) end select write ( logUnit ( 2 ), * ) '  nonlinear solver: ' , trim ( me % nonlinear_solver ) end subroutine load_iterativeMethod ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> Load the iterativeMethod to use in the turbulent wall model from the user !! configuration. subroutine load_wall_function ( me , conf , parent ) ! -------------------------------------------------------------------- ! !> Turbulent wall model type to fill assign wall model type ( mus_turb_wallFunc_type ), intent ( inout ) :: me !> lua flu state type ( flu_state ) :: conf !> bc parent handle integer , intent ( in ) :: parent ! -------------------------------------------------------------------- ! integer :: iError ! -------------------------------------------------------------------- ! call aot_get_val ( L = conf , & & thandle = parent , & & key = 'wall_function' , & & val = me % wall_func , & & default = 'musker' , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving wall_function:' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type (should be a string)!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if end if select case ( trim ( me % wall_func )) case ( 'musker' ) allocate ( mus_wall_function_musker_type :: me % wall_function ) me % calcFricVel => compute_fricVel case ( 'reichardt' ) allocate ( mus_wall_function_reichardt_type :: me % wall_function ) me % calcFricVel => compute_fricVel case ( 'power_law' ) allocate ( mus_wall_function_schmitt_type :: me % wall_function ) me % calcFricVel => fricVel_Schmitt case default call tem_abort ( \"Error: Unknown turbulent wall function \" & & // trim ( me % wall_func ) ) end select write ( logUnit ( 2 ), * ) '  wall function: ' , trim ( me % wall_func ) end subroutine load_wall_function ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> This routine computes friction velocity from Schmitt wall model. ! I am forced to make an extra subroutine because the wall profile is a ! combination of implicit and explicit functions pure subroutine fricVel_Schmitt ( this , velTau , velSW , distToBnd , viscKine , & & nElems ) ! -------------------------------------------------------------------- ! !> Pass the calling object as an argument class ( mus_turb_wallFunc_type ), intent ( in ) :: this !> Friction velocity computed from wall model. !! it is inout to provide velTau from previous timestep as initial velTau !! for fixed-point or Newton iteration solver real ( kind = rk ), intent ( inout ) :: velTau (:) !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW (:) !> Distance to the boundary in the discrete normai direction real ( kind = rk ), intent ( in ) :: distToBnd (:) !> Kinematic viscosity real ( kind = rk ), intent ( in ) :: viscKine (:) !> Number of elements in input and output arrays integer , intent ( in ) :: nElems ! -------------------------------------------------------------------- ! integer :: iElem real ( kind = rk ) :: visc_div_dist , yPlus ! -------------------------------------------------------------------- ! do iElem = 1 , nElems visc_div_dist = viscKine ( iElem ) / distToBnd ( iElem ) yPlus = velTau ( iElem ) / visc_div_dist if ( yPlus >= sc_uLmt ) then ! Interial layer, use powerlaw profile from werner and wengle velTau ( iElem ) = get_uTau_logLayer ( visc_div_dist = visc_div_dist , & & velSW = velSW ( iElem ) ) else if ( yPlus < sc_lLmt ) then ! viscous sublayer, use linear profile. velTau ( iElem ) = get_uTau_subVisousLayer ( visc_div_dist = visc_div_dist , & & velSW = velSW ( iElem ) ) else ! if ( yPlus >= sc_lLmt .and. yPlus < sc_uLmt) ! Buffer layer, use logarithmic profile ! the class Schmitt wall function has been modified such that the ! derivative of uPlus with respect to uTau is always in the buffer layer velTau ( iElem ) = this % iterativeMethod ( & & velTau_initialGuess = velTau ( iElem ), & & velSW = velSW ( iElem ), & & y = distToBnd ( iElem ), & & nu = viscKine ( iElem ), & & wall_function = this % wall_function ) end if end do end subroutine fricVel_Schmitt ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> This routine computes friction velocity from wall model profile !! using Newton iteration method pure subroutine compute_fricVel ( this , velTau , velSW , distToBnd , viscKine , & & nElems ) ! -------------------------------------------------------------------- ! !> Pass the calling object as an argument class ( mus_turb_wallFunc_type ), intent ( in ) :: this !> Friction velocity computed from wall model. !! it is inout to provide velTau from previous timestep as initial velTau !! for fixed-point or Newton iteration solver real ( kind = rk ), intent ( inout ) :: velTau (:) !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW (:) !> Distance to the boundary in the discrete normai direction real ( kind = rk ), intent ( in ) :: distToBnd (:) !> Kinematic viscosity real ( kind = rk ), intent ( in ) :: viscKine (:) !> Number of elements in input and output arrays integer , intent ( in ) :: nElems ! -------------------------------------------------------------------- ! integer :: iElem ! -------------------------------------------------------------------- ! do iElem = 1 , nElems velTau ( iElem ) = this % iterativeMethod ( & & velTau_initialGuess = velTau ( iElem ), & & velSW = velSW ( iElem ), & & y = distToBnd ( iElem ), & & nu = viscKine ( iElem ), & & wall_function = this % wall_function ) end do end subroutine compute_fricVel ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> This routine computes friction velocity from wall model profile !! using Newton iteration method pure function newton_method ( velTau_initialGuess , velSW , y , nu , & & wall_function ) result ( velTau_new ) ! -------------------------------------------------------------------- ! !> Friction velocity computed from previsous time step real ( kind = rk ), intent ( in ) :: velTau_initialGuess !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> Number of elements in input and output arrays class ( mus_wall_function_type ), intent ( in ) :: wall_function !> Friction velocity computed in this routine real ( kind = rk ) :: velTau_new ! -------------------------------------------------------------------- ! real ( kind = rk ) :: error integer :: iter real ( kind = rk ) :: yPlus , yPlus_fac , velTau_old real ( kind = rk ) :: fx , dfdx ! -------------------------------------------------------------------- ! iter = 0 yPlus_fac = y / nu velTau_old = velTau_initialGuess newton : do yPlus = velTau_old * yPlus_fac ! Function of u_tau fx = velSW / velTau_old - wall_function % get_uPlus ( yPlus ) ! derivative of function w.r.t u_tau dfdx = - velSW / velTau_old ** 2 - & & - ( wall_function % get_d_uPlus_d_uTau ( y = y , & & uTau = velTau_old , & & nu = nu ) ) velTau_new = velTau_old - ( fx / dfdx ) error = abs ( velTau_new - velTau_old ) velTau_old = velTau_new iter = iter + 1 if (( error . fle . imEq_tol ) & & . or . ( iter >= imEq_nIter )) exit newton end do newton end function newton_method ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> This routine computes friction velocity from wall model profile !! using fixed-point iterative method pure function fixedPoint_method ( velTau_initialGuess , velSW , y , nu , & & wall_function ) result ( velTau_new ) ! -------------------------------------------------------------------- ! !> Friction velocity computed from previsous time step real ( kind = rk ), intent ( in ) :: velTau_initialGuess !> Stream-wise velocity component from which friction velocity is computed real ( kind = rk ), intent ( in ) :: velSW !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> Number of elements in input and output arrays class ( mus_wall_function_type ), intent ( in ) :: wall_function !> Friction velocity computed in this routine real ( kind = rk ) :: velTau_new ! -------------------------------------------------------------------- ! real ( kind = rk ) :: error integer :: iter real ( kind = rk ) :: velTau_old , yPlus , yPlus_fac ! -------------------------------------------------------------------- ! iter = 0 yPlus_fac = y / nu velTau_old = velTau_initialGuess fixed_point : do yPlus = velTau_old * yPlus_fac velTau_new = velSW / wall_function % get_uPlus ( yPlus ) error = abs ( velTau_new - velTau_old ) velTau_old = velTau_new iter = iter + 1 if (( error . fle . imEq_tol ) & & . or . ( iter >= imEq_nIter )) exit fixed_point end do fixed_point end function fixedPoint_method ! -------------------------------------------------------------------------- ! ! -------------------------------------------------------------------------- ! !> This routines computes streamWise velocity component from friction velocity !! and distance to boundary using any wall function profile. pure subroutine computeStreamWiseVel ( velSW , velTau , distToBnd , viscKine , & & nElems , wall_function ) ! -------------------------------------------------------------------- ! !> Stream-wise velocity component from wall model real ( kind = rk ), intent ( out ) :: velSW (:) !> Friction velocity computd from wall model real ( kind = rk ), intent ( in ) :: velTau (:) !> Distance to the boundary in the discrete normai direction real ( kind = rk ), intent ( in ) :: distToBnd (:) !> Kinematic viscosity real ( kind = rk ), intent ( in ) :: viscKine (:) !> Number of elements in input and output arrays integer , intent ( in ) :: nElems !> Allocate wall function object class ( mus_wall_function_type ), intent ( in ) :: wall_function ! -------------------------------------------------------------------- ! integer :: iElem real ( kind = rk ) :: yPlus ! -------------------------------------------------------------------- ! do iElem = 1 , nElems yPlus = distToBnd ( iElem ) * velTau ( iElem ) / viscKine ( iElem ) velSW ( iElem ) = wall_function % get_uPlus ( yPlus ) * velTau ( iElem ) end do end subroutine computeStreamWiseVel ! -------------------------------------------------------------------------- ! end module mus_turb_wallFunc_module","tags":"","loc":"sourcefile/mus_turb_wallfunc_module.f90.html"},{"title":"mus_WALE_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_wale_module.f90~~EfferentGraph sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_wale_module.f90~~AfferentGraph sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains function to compute eddy viscosity for !! Wall-Adapting Local Eddy-Viscosity turbulence !! model. !! This implementation follows the LES described by Weickert et al. !! Weickert, M., Teike, G., Schmidt, O., & Sommerfeld, M. (2010). !! Investigation of the LES WALE turbulence model within the lattice Boltzmann !! framework. Computers and Mathematics with Applications, 59(7), 2200–2214. !! author: Kannan Masilamani module mus_WALE_module ! treelm modules use env_module , only : rk , eps use tem_param_module , only : div1_2 , div1_3 use tem_compileconf_module , only : vlen ! musubi modules use mus_turbulence_module , only : mus_turbulence_config_type use mus_gradData_module , only : mus_gradData_type , mus_Grad_type implicit none private public :: mus_turbVisc_WALE_3D public :: mus_turbVisc_WALE_2D contains ! ************************************************************************** ! !> Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity) !! model !! \\todo add reference and formula subroutine mus_turbVisc_WALE_3D ( turbVisc , turbConfig , gradData , auxField , & & velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> Contains turbulenct coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- integer :: iElem real ( kind = rk ) :: SR ( 6 ), Sd ( 6 ), oneThird_trSd , Sd_sqr , SR_sqr , OP1 , OP2 real ( kind = rk ) :: visc_coeff !> gradient of velocity real ( kind = rk ) :: gradU ( 3 , 3 , vlen ) real ( kind = rk ) :: gradU_sqr ( 3 , 3 , vlen ) integer :: ndims integer :: nChunks , iChunks , nChunkElems , low_bound , elempos ! -------------------------------------------------------------------------- ! viscosity coeff visc_coeff = ( turbConfig % coeff % C_w * dxL ) ** 2 nDims = 3 nChunks = ceiling ( real ( nSolve , kind = rk ) / real ( vlen , kind = rk )) do iChunks = 1 , nChunks ! calculate the end  number of iElem loop nChunkElems = min ( vlen , nSolve - (( iChunks - 1 ) * vlen )) low_bound = ( iChunks - 1 ) * vlen gradU (:,:, 1 : nChunkElems ) = Grad % U_ptr ( auxField = auxField , & & gradData = gradData , & & velPos = velPos , & & nAuxScalars = nAuxScalars , & & nDims = nDims , & & nSolve = nChunkElems , & & elemOffset = low_bound ) do iElem = 1 , nChunkElems gradU_sqr (:,:, iElem ) = matmul ( gradU (:,:, iElem ), gradU (:,:, iElem )) end do !iElem do iElem = 1 , nChunkElems ! traceless symmetric part of the square of the velocity gradient tensor ! Sd_ij = 1/2(du_k/dx_i du_j/dx_k + du_k/dx_j du_i/dx_k) !       - 1/3\\delta_ij du_k/dx_l du_l/dx_k oneThird_trSd = ( gradU_sqr ( 1 , 1 , iElem ) + gradU_sqr ( 2 , 2 , iElem ) & & + gradU_sqr ( 3 , 3 , iElem )) * div1_3 Sd ( 1 ) = gradU_sqr ( 1 , 1 , iElem ) - oneThird_trSd !XX Sd ( 2 ) = gradU_sqr ( 2 , 2 , iElem ) - oneThird_trSd !YY Sd ( 3 ) = gradU_sqr ( 3 , 3 , iElem ) - oneThird_trSd !ZZ Sd ( 4 ) = 0.5_rk * ( gradU_sqr ( 1 , 2 , iElem ) + gradU_sqr ( 2 , 1 , iElem )) !XY Sd ( 5 ) = 0.5_rk * ( gradU_sqr ( 2 , 3 , iElem ) + gradU_sqr ( 3 , 2 , iElem )) !YZ Sd ( 6 ) = 0.5_rk * ( gradU_sqr ( 1 , 3 , iElem ) + gradU_sqr ( 3 , 1 , iElem )) !XZ ! double inner product of Sd: Sd_ij Sd_ij Sd_sqr = Sd ( 1 ) ** 2 + Sd ( 2 ) ** 2 + Sd ( 3 ) ** 2 & & + 2.0_rk * ( Sd ( 4 ) ** 2 + Sd ( 5 ) ** 2 + Sd ( 6 ) ** 2 ) ! symmetric strain rate tensors SR ( 1 ) = gradU ( 1 , 1 , iElem ) !XX SR ( 2 ) = gradU ( 2 , 2 , iElem ) !YY SR ( 3 ) = gradU ( 3 , 3 , iElem ) !ZZ SR ( 4 ) = ( gradU ( 1 , 2 , iElem ) + gradU ( 2 , 1 , iElem )) * 0.5_rk !XY SR ( 5 ) = ( gradU ( 2 , 3 , iElem ) + gradU ( 3 , 2 , iElem )) * 0.5_rk !YZ SR ( 6 ) = ( gradU ( 1 , 3 , iElem ) + gradU ( 3 , 1 , iElem )) * 0.5_rk !XZ ! double inner product of tensor SR_sqr = SR ( 1 ) ** 2 + SR ( 2 ) ** 2 + SR ( 3 ) ** 2 & & + 2.0_rk * ( SR ( 4 ) ** 2 + SR ( 5 ) ** 2 + SR ( 6 ) ** 2 ) ! sub-grid scale kinetic energy ! k_sgs = (C_w&#94;2 * dx /C_k)&#94;2 (OP1/OP2)&#94;2 ! subgrid scale eddy viscosity ! nu_kgs = C_k dx sqrt(k_sgs) = (C_w * dx)&#94;2 (OP1/OP2) ! OP1 = (Sd_ij Sd_ij)&#94;(3/2) ! OP2 = (SR_ij SR_ij)&#94;(5/2) + (Sd_ij Sd_ij)&#94;(5/4) ! Add small fraction to denominator to avoid division by zero OP1 = Sd_sqr ** 1.5_rk OP2 = SR_sqr ** 2.5_rk + Sd_sqr ** 1.25_rk + eps elemPos = low_bound + iElem ! turbulent viscosity turbVisc ( elemPos ) = visc_coeff * ( OP1 / OP2 ) / dtL end do !iElem end do !iChunks end subroutine mus_turbVisc_WALE_3D ! ************************************************************************** ! ! ************************************************************************** ! !> Calculate eddy viscosity with WALE (Wall-Adapting Local Eddy-viscosity) !! model !! \\todo add reference and formula subroutine mus_turbVisc_WALE_2D ( turbVisc , turbConfig , gradData , auxField , & & velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> Contains turbulenct coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- integer :: iElem real ( kind = rk ) :: gradU ( 2 , 2 , vlen ) real ( kind = rk ) :: gradU_sqr ( 2 , 2 , vlen ) real ( kind = rk ) :: SR ( 3 ), Sd ( 3 ), onehalf_trSd , Sd_sqr , SR_sqr , OP1 , OP2 integer :: ndims integer :: nChunks , iChunks , nChunkElems , low_bound , elemPos real ( kind = rk ) :: visc_coeff !> gradient of velocity ! -------------------------------------------------------------------------- visc_coeff = ( turbConfig % coeff % C_w * dxL ) ** 2 nDims = 2 nChunks = ceiling ( real ( nSolve , kind = rk ) / real ( vlen , kind = rk )) do iChunks = 1 , nChunks ! calculate the end  number of iElem loop nChunkElems = min ( vlen , nSolve - (( iChunks - 1 ) * vlen )) low_bound = ( iChunks - 1 ) * vlen gradU (:,:, 1 : nChunkElems ) = Grad % U_ptr ( auxField = auxField , & & gradData = gradData , & & velPos = velPos , & & nAuxScalars = nAuxScalars , & & nDims = nDims , & & nSolve = nChunkElems , & & elemOffset = low_bound ) do iElem = 1 , nChunkElems ! square of velocity gradient. gradU . gradU gradU_sqr (:,:, iElem ) = matmul ( gradU (:,:, iElem ), gradU (:,:, iElem )) end do !iElem do iElem = 1 , nChunkElems ! traceless symmetric part of the square of the velocity gradient tensor ! Sd_ij = 1/2(du_k/dx_i du_j/dx_k + du_k/dx_j du_i/dx_k) !       - 1/3\\delta_ij du_k/dx_l du_l/dx_k onehalf_trSd = ( gradU_sqr ( 1 , 1 , iElem ) + gradU_sqr ( 2 , 2 , iElem )) * div1_2 Sd ( 1 ) = gradU_sqr ( 1 , 1 , iElem ) - onehalf_trSd !XX Sd ( 2 ) = gradU_sqr ( 2 , 2 , iElem ) - onehalf_trSd !YY Sd ( 3 ) = 0.5_rk * ( gradU_sqr ( 1 , 2 , iElem ) + gradU_sqr ( 2 , 1 , iElem )) !XY ! double inner product of Sd: Sd_ij Sd_ij Sd_sqr = Sd ( 1 ) ** 2 + Sd ( 2 ) ** 2 + 2.0_rk * Sd ( 3 ) ** 2 ! symmetric strain rate tensors SR ( 1 ) = gradU ( 1 , 1 , iElem ) SR ( 2 ) = gradU ( 2 , 2 , iElem ) SR ( 3 ) = ( gradU ( 1 , 2 , iElem ) + gradU ( 2 , 1 , iElem )) * 0.5_rk ! double inner product of tensor SR_sqr = SR ( 1 ) ** 2 + SR ( 2 ) ** 2 + 2.0_rk * SR ( 3 ) ** 2 ! sub-grid scale kinetic energy ! k_sgs = (C_w&#94;2 * dx /C_k)&#94;2 (OP1/OP2)&#94;2 ! subgrid scale eddy viscosity ! nu_kgs = C_k dx sqrt(k_sgs) = (C_w * dx)&#94;2 (OP1/OP2) ! OP1 = (Sd_ij Sd_ij)&#94;(3/2) ! OP2 = (SR_ij SR_ij)&#94;(5/2) + (Sd_ij Sd_ij)&#94;(5/4) ! Add small fraction to denominator to avoid division by zero OP1 = Sd_sqr ** 1.5_rk OP2 = SR_sqr ** 2.5_rk + Sd_sqr ** 1.25_rk + eps elemPos = low_bound + iElem ! turbulent viscosity turbVisc ( elemPos ) = visc_coeff * ( OP1 / OP2 ) / dtL end do !iElem end do !iChunks end subroutine mus_turbVisc_WALE_2D ! ************************************************************************** ! end module mus_WALE_module","tags":"","loc":"sourcefile/mus_wale_module.f90.html"},{"title":"mus_bc_var_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_bc_var_module.f90~~EfferentGraph sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_bc_var_module.f90~~AfferentGraph sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! This module provides variable to extract from boundary condition module mus_bc_var_module use iso_c_binding , only : c_loc , c_ptr , c_f_pointer ! include treelm modules use env_module , only : rk , labelLen use tem_logging_module , only : logUnit use tem_variable_module , only : tem_variable_type use tem_topology_module , only : tem_levelOf use tem_time_module , only : tem_time_type use treelmesh_module , only : treelmesh_type use tem_property_module , only : prp_hasBnd use tem_varSys_module , only : tem_varSys_type , tem_varSys_op_type , & & tem_varSys_append_derVar , & & tem_varSys_proc_point , & & tem_varSys_proc_element , & & tem_varSys_proc_setParams , & & tem_varSys_proc_getParams , & & tem_varSys_proc_setupIndices , & & tem_varSys_proc_getValOfIndex , & & tem_varSys_getElement_dummy , & & tem_varSys_setupIndices_dummy , & & tem_varSys_getValOfIndex_dummy , & & tem_varSys_setParams_dummy , & & tem_varSys_getParams_dummy use tem_aux_module , only : tem_abort use tem_grow_array_module , only : grw_labelArray_type , append use tem_dyn_array_module , only : dyn_labelArray_type , init , append use tem_stencil_module , only : tem_stencilHeader_type ! include musubi modules use mus_field_module , only : mus_field_type use mus_varSys_module , only : mus_varSys_data_type , & & mus_varSys_solverData_type , & & mus_get_new_solver_ptr , & & mus_deriveVar_forPoint use mus_bc_header_module , only : glob_boundary_type implicit none private public :: mus_append_bcVar contains ! ************************************************************************** ! !> This routine adds boundary variables for tracking subroutine mus_append_bcVar ( varSys , solverData , derVarName , nFields , & & field , stencil ) ! -------------------------------------------------------------------------- !> global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> array of derive physical variables type ( grw_labelArray_type ), intent ( inout ) :: derVarName !> number of fields integer , intent ( in ) :: nFields !> Field contains sources and boundary infos type ( mus_field_type ), intent ( in ) :: field ( nFields ) !> Compute stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil ! -------------------------------------------------------------------------- integer :: iField , iBC , iVar , nComponents , addedPos , iIn logical :: wasAdded character ( len = labelLen ), allocatable :: input_varname (:) character ( len = labelLen ) :: varName procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_setParams ), pointer :: set_params => null () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => null () procedure ( tem_varSys_proc_setupIndices ), pointer :: & & setup_indices => null () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: & & get_valOfIndex => null () type ( c_ptr ) :: method_data type ( dyn_labelArray_type ) :: bcVarName integer :: nBCtypes ! -------------------------------------------------------------------------- nullify ( get_point , get_element , set_params , get_params , setup_indices , & & get_valOfIndex ) write ( logUnit ( 1 ), * ) 'Appending boundary variables ' ! all fields have same number of bc nBCtypes = size ( field ( 1 )% bc ) ! First list of bc variables to append call init ( me = bcVarName , length = 0 ) do iField = 1 , nFields do iBC = 1 , nBCtypes select case ( trim ( field ( iField )% bc ( iBC )% BC_kind )) case ( 'wall_libb' , 'velocity_bounceback' , 'velocity_bfl' , & & 'velocity_noneq_expol' ) call append ( me = bcVarName , & & val = 'bc_normal' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_qval' , & & pos = addedPos , & & wasAdded = wasAdded ) case ( 'turbulent_wall' , 'turbulent_wall_noneq_expol' , & & 'turbulent_wall_eq' ) call append ( me = bcVarName , & & val = 'bc_normal' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_fric_velocity' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_turb_viscosity' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_norm_dist_to_bnd' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_y_plus' , & & pos = addedPos , & & wasAdded = wasAdded ) call append ( me = bcVarName , & & val = 'bc_qval' , & & pos = addedPos , & & wasAdded = wasAdded ) end select end do end do do iField = 1 , nFields do iVar = 1 , bcVarName % nVals call append ( me = derVarName , val = bcVarName % val ( iVar )) ! set default pointers, overwrite if neccessary get_element => tem_varSys_getElement_dummy get_point => mus_deriveVar_forPoint setup_indices => tem_varSys_setupIndices_dummy get_valOfIndex => tem_varSys_getValOfIndex_dummy method_data = mus_get_new_solver_ptr ( solverData ) set_params => tem_varSys_setParams_dummy get_params => tem_varSys_getParams_dummy select case ( trim ( adjustl ( bcVarName % val ( iVar )))) case ( 'bc_normal' ) get_element => access_bcNormal_forElement nComponents = 3 allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case ( 'bc_qval' ) get_element => access_qVal_forElement nComponents = stencil % QQN allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case ( 'bc_fric_velocity' ) get_element => access_bcFricVel_forElement nComponents = 1 allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case ( 'bc_norm_dist_to_bnd' ) get_element => access_bcNormDistToBnd_forElement nComponents = 1 allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case ( 'bc_turb_viscosity' ) get_element => access_bcTurbVisc_forElement nComponents = 1 allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case ( 'bc_y_plus' ) get_element => access_bcYPlus_forElement nComponents = 1 allocate ( input_varname ( 1 )) input_varname ( 1 ) = 'pdf' case default write ( logUnit ( 1 ), * ) 'WARNING: Unknown variable: ' // & & trim ( bcVarName % val ( iVar )) cycle !go to next variable end select ! update variable names with field label varname = trim ( field ( iField )% label ) // trim ( adjustl ( bcVarName % val ( iVar ))) do iIn = 1 , size ( input_varname ) input_varname ( iIn ) = trim ( field ( iField )% label )& & // trim ( input_varname ( iIn )) end do ! append variable to varSys call tem_varSys_append_derVar ( me = varSys , & & varName = trim ( varname ), & & nComponents = nComponents , & & input_varname = input_varname , & & method_data = method_data , & & get_point = get_point , & & get_element = get_element , & & set_params = set_params , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valOfIndex = get_valOfIndex , & & pos = addedPos , & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logUnit ( 10 ), * ) ' Appended variable:' // trim ( varname ) else if ( addedpos < 1 ) then write ( logUnit ( 1 ), * ) 'Error: variable ' // trim ( varname ) // & & ' is not added to variable system' end if deallocate ( input_varname ) end do end do end subroutine mus_append_bcVar ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns the boundary normal pointing inside the domain !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_bcNormal_forElement ( fun , varsys , elempos , time , & & tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , posInBndID , minBcID , bcLevelPointer type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! res is always AOS layout res = 0.0_rk associate ( globBC => fPtr % solverData % scheme % globBC ) do iElem = 1 , nElems ! This routine is valid only for boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if (. not . globBC ( minBcID )% isWall ) then res ( ( iElem - 1 ) * fun % nComponents + 1 : iElem * fun % nComponents ) & & = globBC ( minBcID )% elemLvl ( iLevel )% normal % val (:, bcLevelPointer ) end if end if end do !iElem end associate end subroutine access_bcNormal_forElement ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns the boundary qValues !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_qVal_forElement ( fun , varsys , elempos , time , & & tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , posInBndID , minBcID , bcLevelPointer type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! res is always AOS layout res = 0.0_rk associate ( globBC => fPtr % solverData % scheme % globBC ) do iElem = 1 , nElems ! This routine is valid only for boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if (. not . globBC ( minBcID )% isWall ) then res ( ( iElem - 1 ) * fun % nComponents + 1 : iElem * fun % nComponents ) & & = globBC ( minBcID )% elemLvl ( iLevel )% qVal % val (:, bcLevelPointer ) end if end if end do !iElem end associate end subroutine access_qVal_forElement ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns friction velocity computed in turbulent_wall bc and !! stored in mus_turb_wallFunc_data_type routine. !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_bcFricVel_forElement ( fun , varsys , elempos , time , & & tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , iField , posInBndID , minBcID , bcLevelPointer type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! Position of dependent pdf is iField iField = fun % input_varPos ( 1 ) ! res is always AOS layout res = 0.0_rk associate ( field => fPtr % solverData % scheme % field ( iField )) do iElem = 1 , nElems ! This routine is valid only for turbulent wall boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if ( minBcID > 0 ) then if ( field % bc ( minBcID )% turbWallFunc % isActive ) then res ( iElem ) = field % bc ( minBcID )% turbWallFunc % dataOnLvl ( iLevel ) & & % velTau ( bcLevelPointer ) end if end if end if end do !iElem end associate end subroutine access_bcFricVel_forElement ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns normal distance to boundary calculated in !! mus_init_turbWallFunc and stored in mus_turb_wallFunc_data_type routine. !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_bcNormDistToBnd_forElement ( fun , varsys , elempos , & & time , tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , iField , posInBndID , minBcID , bcLevelPointer type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! Position of dependent pdf is iField iField = fun % input_varPos ( 1 ) ! res is always AOS layout res = 0.0_rk associate ( field => fPtr % solverData % scheme % field ( iField )) do iElem = 1 , nElems ! This routine is valid only for turbulent wall boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if ( minBcID > 0 ) then if ( field % bc ( minBcID )% turbWallFunc % isActive ) then res ( iElem ) = field % bc ( minBcID )% turbWallFunc % dataOnLvl ( iLevel ) & & % distToBnd ( bcLevelPointer ) end if end if end if end do !iElem end associate end subroutine access_bcNormDistToBnd_forElement ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns turbulent viscosity computed in turbulent_wall bc !! according to RANS formulation and stored in mus_turb_wallFunc_data_type !! routine. !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_bcTurbVisc_forElement ( fun , varsys , elempos , time ,& & tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , iField , posInBndID , minBcID , bcLevelPointer type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! Position of dependent pdf is iField iField = fun % input_varPos ( 1 ) ! res is always AOS layout res = 0.0_rk associate ( field => fPtr % solverData % scheme % field ( iField )) do iElem = 1 , nElems ! This routine is valid only for turbulent wall boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if ( minBcID > 0 ) then if ( field % bc ( minBcID )% turbWallFunc % isActive ) then res ( iElem ) = field % bc ( minBcID )% turbWallFunc % dataOnLvl ( iLevel ) & & % tVisc ( bcLevelPointer ) end if end if end if end do !iElem end associate end subroutine access_bcTurbVisc_forElement ! ************************************************************************** ! ! ************************************************************************** ! !> This routine returns yPlus = distToBnd * fric_vel / visc !! !! The interface has to comply to the abstract interface !! [[tem_varSys_module:tem_varSys_proc_element]]. recursive subroutine access_bcYPlus_forElement ( fun , varsys , elempos , time , & & tree , nElems , nDofs , res ) ! -------------------------------------------------------------------- ! !> Description of the method to obtain the variables, here some preset !! values might be stored, like the space time function to use or the !! required variables. class ( tem_varSys_op_type ), intent ( in ) :: fun !> The variable system to obtain the variable from. type ( tem_varSys_type ), intent ( in ) :: varSys !> Position of the TreeID of the element to get the variable for in the !! global treeID list. integer , intent ( in ) :: elempos (:) !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> global treelm mesh info type ( treelmesh_type ), intent ( in ) :: tree !> Number of values to obtain for this variable (vectorized access). integer , intent ( in ) :: nElems !> Number of degrees of freedom within an element. integer , intent ( in ) :: nDofs !> Resulting values for the requested variable. !! !! Linearized array dimension: !! (n requested entries) x (nComponents of this variable) !! x (nDegrees of freedom) !! Access: (iElem-1)*fun%nComponents*nDofs + !!         (iDof-1)*fun%nComponents + iComp real ( kind = rk ), intent ( out ) :: res (:) ! -------------------------------------------------------------------- ! integer :: iElem , iLevel , iField , posInBndID , minBcID , bcLevelPointer real ( kind = rk ) :: distToBnd , velTau , viscKine type ( mus_varSys_data_type ), pointer :: fPtr ! -------------------------------------------------------------------- ! call C_F_POINTER ( fun % method_Data , fPtr ) ! Position of dependent pdf is iField iField = fun % input_varPos ( 1 ) ! res is always AOS layout res = 0.0_rk associate ( field => fPtr % solverData % scheme % field ( iField ), & & levelPointer => fPtr % solverData % geometry % levelPointer , & & fluid => fPtr % solverData % scheme % field ( 1 )% fieldProp % fluid ) do iElem = 1 , nElems ! This routine is valid only for turbulent wall boundary elements if ( btest ( tree % elemPropertyBits ( elemPos ( iElem ) ), & & prp_hasBnd ) ) then ! position of current element in boundary_ID list posInBndID = fPtr % solverData % geometry % posInBndID ( elempos ( iElem ) ) minBcID = fPtr % solverData % geometry % minBcID ( posInBndID ) bcLevelPointer = fPtr % solverData % geometry % bcLevelPointer ( posInBndID ) iLevel = tem_levelOf ( tree % treeID ( elemPos ( iElem ) ) ) if ( minBcID > 0 ) then if ( field % bc ( minBcID )% turbWallFunc % isActive ) then distToBnd = field % bc ( minBcID )% turbWallFunc % dataOnLvl ( iLevel ) & & % distToBnd ( bcLevelPointer ) velTau = field % bc ( minBcID )% turbWallFunc % dataOnLvl ( iLevel ) & & % velTau ( bcLevelPointer ) viscKine = fluid % viscKine % dataOnLvl ( iLevel )% val ( & & levelPointer ( elemPos ( iElem ) ) ) res ( iElem ) = distToBnd * velTau / viscKine end if end if end if end do !iElem end associate end subroutine access_bcYPlus_forElement ! ************************************************************************** ! end module mus_bc_var_module","tags":"","loc":"sourcefile/mus_bc_var_module.f90.html"},{"title":"mus_initFluidIncomp_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initfluidincomp_module.f90~~EfferentGraph sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2024 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2013-2015 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for lbm incompressible model. module mus_initFluidIncomp_module ! include treelm modules use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_bgk_module , only : mus_advRel_kCFD_rBGK_vStdNoOpt_l use mus_d3q19_module , only : mus_advRel_kFluidIncomp_rBGK_vStd_lD3Q19 , & & mus_advRel_kFluidIncomp_rTRT_vStd_lD3Q19 use mus_d3q27_module , only : mus_advRel_kCFD_rBGK_vStd_lD3Q27 use mus_d2q9_module , only : mus_advRel_kFluidIncomp_rBGK_vStd_lD2Q9 , & & mus_advRel_kFluidIncomp_rMRT_vStd_lD2Q9 use mus_mrt_d3q19_module , only : mus_advRel_kCFD_rMRT_vStdNoOpt_l , & & mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q19 , & & mus_advRel_kFluidIncomp_rMRT_vStdNoOpt_lD3Q19 use mus_mrt_d3q27_module , only : mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q27 , & & mus_advRel_kCFD_rMRT_vStdNoOpt_lD3Q27 use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_fluidIncomp contains ! ************************************************************************** ! !> Initialize the relaxation model for lbm incompressible model subroutine mus_init_advRel_fluidIncomp ( relaxation , variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing fluid_incompressible relaxation model: ' & & // trim ( relaxation ) // ' for layout ' // trim ( layout ) select case ( trim ( relaxation )) case ( 'bgk' ) call mus_init_advRel_fluidIncomp_bgk ( variant , layout , compute ) case ( 'mrt' ) call mus_init_advRel_fluidIncomp_mrt ( variant , layout , compute ) case ( 'trt' ) select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q19' ) compute => mus_advRel_kFluidIncomp_rTRT_vStd_lD3Q19 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"trt\"' ) end select case default call tem_abort ( 'Unsupported relaxation \"' // trim ( relaxation ) // '\" for ' & & // 'kind \"fluid_incompressible\"' ) end select end subroutine mus_init_advRel_fluidIncomp ! ************************************************************************** ! ! ************************************************************************** ! !> This routine assigns compute routine for bgk relaxation !! !! Supported variants are: !!   * standard        - Optimized routines for specifc layouts. !!   * standard_no_opt - no optimized routines for any layouts. subroutine mus_init_advRel_fluidIncomp_bgk ( variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kCFD_rBGK_vStd_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluidIncomp_rBGK_vStd_lD3Q19 case ( 'd2q9' ) compute => mus_advRel_kFluidIncomp_rBGK_vStd_lD2Q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // ' relaxation \"bgk\" for variant \"' // trim ( variant ) // '\"' ) end select case ( 'standard_no_opt' ) compute => mus_advRel_kCFD_rBGK_vStdNoOpt_l case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"bgk\"' ) end select end subroutine mus_init_advRel_fluidIncomp_bgk ! ************************************************************************** ! ! ************************************************************************** ! !> This routine assigns compute routine for mrt relaxation !! !! Supported variants are: !!   * standard        - Optimized routines for specifc layouts. !!   * standard_no_opt - no optimized routines for any layouts. !!   * bgk             - Uses no optimized routine but !!                       in mus_mrtRelaxation_module all relaxation parameters !!                       are set to same omega to recover bgk. subroutine mus_init_advRel_fluidIncomp_mrt ( variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluidIncomp_rMRT_vStd_lD3Q19 case ( 'd2q9' ) compute => mus_advRel_kFluidIncomp_rMRT_vStd_lD2Q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"mrt\" for variant \"' // trim ( variant ) // '\"' ) end select case ( 'standard_no_opt' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kCFD_rMRT_vStdNoOpt_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluidIncomp_rMRT_vStdNoOpt_lD3Q19 case default compute => mus_advRel_kCFD_rMRT_vStdNoOpt_l end select case ( 'bgk' ) compute => mus_advRel_kCFD_rMRT_vStdNoOpt_l case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"mrt\"' ) end select end subroutine mus_init_advRel_fluidIncomp_mrt ! ************************************************************************** ! end module mus_initFluidIncomp_module","tags":"","loc":"sourcefile/mus_initfluidincomp_module.f90.html"},{"title":"mus_dynLoadBal_module.f90 – Musubi","text":"This routine serves as a wrapper to call other routines responsible for\ndynamic load balancing in Musubi. The dynamic load balancing algorithm\nfollows the SPARTA algorithm in an iterative way to perform balancing for\nMultilevel simulations as well as complex boundary conditions. This file depends on sourcefile~~mus_dynloadbal_module.f90~~EfferentGraph sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_weights_module.f90 mus_weights_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_weights_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2014-2016, 2018-2022 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !! This routine serves as a wrapper to call other routines responsible for !! dynamic load balancing in Musubi. The dynamic load balancing algorithm !! follows the SPARTA algorithm in an iterative way to perform balancing for !! Multilevel simulations as well as complex boundary conditions. !! module mus_dynLoadBal_module ! include treelm modules use mpi use env_module , only : PathLen , labelLen , rk , long_k , rk_mpi use treelmesh_module , only : treelmesh_type , & & exchange_elements , & & tem_dump_weights use tem_restart_module , only : tem_init_restart , & & tem_restart_finalize use tem_general_module , only : tem_general_type use tem_bc_prop_module , only : tem_bc_prop_type use tem_topology_module , only : tem_levelOf use tem_aux_module , only : check_mpi_error , tem_abort use tem_tools_module , only : tem_horizontalSpacer use tem_dyn_array_module , only : append use tem_stencil_module , only : append use tem_time_module , only : tem_time_dump , tem_time_sim_stamp use tem_construction_module , only : tem_levelDesc_type use tem_sparta_module , only : tem_balance_sparta , tem_sparta_type , & & tem_exchange_sparta , & & tem_destroy_sparta , & & tem_derive_sparta , tem_init_sparta use tem_element_module , only : eT_fluid use tem_logging_module , only : logUnit use tem_debug_module , only : dbgUnit use tem_convergence_module , only : tem_init_convergence use tem_varMap_module , only : tem_varMap_type use tem_property_module , only : prp_hasBnd , prp_hasQVal use tem_spacetime_fun_module , only : tem_create_subTree_of_st_funList use tem_operation_var_module , only : tem_opVar_reduction_transient_init ! include musubi modules use mus_bc_general_module , only : mus_init_boundary use mus_bc_header_module , only : glob_boundary_type use mus_bndForce_module , only : mus_init_bndForce use mus_param_module , only : mus_param_type use mus_scheme_type_module , only : mus_scheme_type use mus_scheme_layout_module , only : mus_init_layout , mus_define_layout use mus_scheme_module , only : mus_init_scheme , mus_scheme_cleanup use mus_geom_module , only : mus_geom_type , mus_build_posInProp use mus_tools_module , only : check_density , dump_linear_partition use mus_interpolate_module , only : mus_init_interpolate use mus_source_module , only : mus_init_sourceTerms use mus_transport_var_module , only : mus_init_transport_var use mus_construction_module , only : mus_construct use mus_flow_module , only : fillHelperElementsCoarseToFine , & & fillHelperElementsFineToCoarse use mus_IBM_module , only : mus_unload_IBM , mus_reload_IBM , & & mus_IBM_globType use mus_fluid_module , only : mus_init_fluid use mus_gradData_module , only : mus_init_gradData use mus_time_module , only : mus_timeControl_homogenize use mus_varSys_module , only : mus_varSys_solverData_type use mus_tracking_module , only : mus_init_tracker use mus_timer_module , only : mus_timerHandles , & & mus_reset_levelTimer , & & mus_reset_BCTimer use mus_buffer_module , only : mus_pdf_unserialize , & & mus_pdf_serialize use mus_weights_module , only : mus_getWeights , mus_dumpWeights use mus_auxField_module , only : mus_calcAuxFieldAndExchange , & & mus_intpAuxFieldCoarserAndExchange implicit none private public :: mus_perform_dynLoadBal contains ! **************************************************************************** ! !> Wrap up the routines required for dynamic load balancing subroutine mus_perform_dynLoadBal ( scheme , params , geometry , solverData ) ! -------------------------------------------------------------------------- !> scheme type type ( mus_scheme_type ), intent ( inout ) :: scheme !> Global parameters type ( mus_param_type ), intent ( inout ) :: params !> Treelmesh data type ( mus_geom_type ), intent ( inout ) :: geometry !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target :: solverData ! -------------------------------------------------------------------------- integer :: minLevel , maxLevel real ( kind = rk ), allocatable :: PDFbuffer (:) type ( tem_sparta_type ) :: sparta ! -------------------------------------------------------------------------- write ( logUnit ( 1 ), \"(A)\" ) 'Performing dynamic load balance ...' minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel ! Cleanup IBM write ( dbgUnit ( 3 ), * ) \"Cleanup IBM\" call mus_unload_IBM ( me = geometry % globIBM % IBM , & & proc = params % general % proc , & & minLevel = minLevel , & & maxLevel = maxLevel ) ! deallocate( geometry%posInBndID ) ! deallocate( geometry%posInQVal  ) ! -------------------------------------------------------------------------- ! Collect PDF from all levels write ( logUnit ( 7 ), * ) \"Serialize PDF following the order of treeID list\" allocate ( PDFbuffer ( geometry % tree % nElems * scheme % varSys % nScalars ) ) call mus_pdf_serialize ( scheme , & & geometry % tree % treeID ( 1 : geometry % tree % nElems ), & & geometry % levelPointer ( 1 : geometry % tree % nElems ), & & scheme % statevarMap , geometry % tree % nElems , & & PDFbuffer , minLevel , maxLevel ) ! -------------------------------------------------------------------------- ! levelPointer not used anymore if ( allocated ( geometry % levelPointer )) then deallocate ( geometry % levelPointer ) end if ! -------------------------------------------------------------------------- !         Balance the tree and free all arrays for reconstruction          ! ! -------------------------------------------------------------------------- ! Calculate weights for each element, ! Dump weight onto disk ! Call sparta to obtain new nElems and offset call tem_init_sparta ( sparta , params % general % proc % comm_size ) call mus_balance ( levelDesc = scheme % levelDesc , & ! &               globIBM   = scheme%field(1)%globIBM,  & & general = params % general , & & tree = geometry % tree , & & nBCs = geometry % boundary % nBCtypes , & & globBC = scheme % globBC , & & sparta = sparta , & & minLevel = minLevel , & & maxLevel = maxLevel ) call exchange_tree_bc ( sparta , & & geometry , & & params % general % proc % comm , & & params % general % proc % comm_size ) if ( params % dump_linear_partition ) then call dump_linear_partition ( treeID = geometry % tree % treeID , & & nElems = geometry % tree % nElems , & & offset = geometry % tree % elemOffset , & & myRank = params % general % proc % rank , & & iter = params % general % simControl % now % iter ) end if ! Unload and reload tree and boundary ---------------------------- ! Destroy the arrays which were allocated for performing new construction ! variables deallcoated include: !   globBC, levelDesc, pdf, layout%stencil call mus_scheme_cleanup ( scheme , minLevel , maxLevel , & & geometry % boundary % nBCtypes ) ! -------------------------------------------------------------------------- !           Reconstruct the levelDesc, reinitialize the simulation         ! ! -------------------------------------------------------------------------- ! ! Re-initialize growing array of stencil as it is destroyed in ! mus_finialize_stencil and growing array stencil must be created ! for new list of boundary elements after load balancing ! Initialize layout growing array !call mus_init_layout( scheme%layout ) ! define fStencil with predefined stencil layouts call mus_define_layout ( layout = scheme % layout , & & stencilName = scheme % header % layout , & & nElems = geometry % tree % nElems ) ! Initialize schemes: stencil, interpolation nSources and variable system call mus_init_scheme ( me = scheme , & & tree = geometry % tree , & & solverData = solverData ) call mus_construct ( scheme = scheme , & & geometry = geometry , & & params = params ) ! -------------------------------------------------------------------------- !           exchange PDF and unserialize ! -------------------------------------------------------------------------- ! exchange PDF write ( logUnit ( 7 ), \"(A)\" ) \"Going to exchange PDF\" ! call tem_output_sparta( sparta, logUnit(1) ) call tem_exchange_sparta ( sparta , PDFbuffer , & & scheme % varSys % nScalars , params % general % proc % comm ) call tem_destroy_sparta ( sparta ) ! copy PDF from buffer to PDF type write ( logUnit ( 7 ), \"(A)\" ) \"Copy serialized PDF back to level-wise array\" call mus_pdf_unserialize ( scheme , & & geometry % tree % treeID ( 1 : geometry % tree % nElems ), & & geometry % levelPointer ( 1 : geometry % tree % nElems ), & & scheme % statevarMap , geometry % tree % nElems , PDFbuffer , & & geometry % tree % global % minLevel , geometry % tree % global % maxLevel ) deallocate ( PDFbuffer ) ! -------------------------------------------------------------------------- ! read Restart, reset BC, fill ghost by interpolation, tracking call mus_reset_aux ( scheme = scheme , & & geometry = geometry , & & params = params ) call mus_reload_IBM ( me = geometry % globIBM % IBM , & & iField = 1 , & & levelDesc = scheme % levelDesc , & & tree = geometry % tree ) write ( logUnit ( 1 ), \"(A)\" ) 'Done with dynamic load balance.' write ( logUnit ( 1 ), \"(A)\" ) '' end subroutine mus_perform_dynLoadBal ! **************************************************************************** ! ! **************************************************************************** ! !> This subroutine initializes musubi after a dynamic load balancing is !! performed. !! subroutine mus_reset_aux ( scheme , params , geometry ) ! -------------------------------------------------------------------------- !> scheme type type ( mus_scheme_type ), intent ( inout ) :: scheme !> Global parameters type ( mus_param_type ), intent ( inout ) :: params !> Treelmesh data type ( mus_geom_type ), intent ( inout ) :: geometry ! -------------------------------------------------------------------------- integer :: minLevel , maxLevel , iLevel , ii ! real(kind=rk) :: total_density ! -------------------------------------------------------------------------- minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel !> initialize fluid type which contains relaxation parameter !! and function pointers to get mrt paramter and nonEqScaling factor !! for interpolation select case ( trim ( scheme % header % kind ) ) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) if ( scheme % nFields > 1 ) then call tem_abort ( 'chosen scheme kind supports only one field' ) end if ! initialize fluid viscosity relaxation paramters call mus_init_fluid ( & & me = scheme % field ( 1 )% fieldProp % fluid , & & physics = params % physics , & & schemeHeader = scheme % header , & & minLevel = minLevel , & & maxLevel = maxLevel , & & levelDesc = scheme % levelDesc (:), & & pdf = scheme % pdf (:), & & stencil = scheme % layout % fStencil , & & general = params % general , & & tNow = params % general % simControl % now ) end select ! Initialize gradient data. Required for LES tuburbulent and evaluating ! gradient of a variable allocate ( scheme % gradData ( minLevel : maxLevel )) do iLevel = minLevel , maxLevel call mus_init_gradData ( me = scheme % gradData ( iLevel ), & & neigh = scheme % pdf ( iLevel )% neigh (:), & !&                     levelDesc = scheme%levelDesc(iLevel),        & & stencil = scheme % layout % fStencil , & & nSize = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & nScalars = scheme % varSys % nScalars ) end do ! create subTree for all spacetime function in the linked list of ! spacetime function call tem_create_subTree_of_st_funList ( & & me = scheme % st_funList , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil ) ! initialize the source terms for all fields and global source if ( all ( scheme % field (:)% source % varDict % nVals /= 0 ) & & . or . scheme % globSrc % varDict % nVals /= 0 ) then write ( logUnit ( 0 ), * ) 'Error: In dynamic load balancing while reinitialize ' write ( logUnit ( 0 ), * ) 'source terms. Source terms must be deallocated first' call tem_abort () call mus_init_sourceTerms ( field = scheme % field (:), & & nFields = scheme % nFields , & & globSrc = scheme % globSrc , & & varSys = scheme % varSys , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & nElems_solve = scheme % pdf (:)% nElems_solve , & & levelDesc = scheme % levelDesc , & & stencil = scheme % layout % fStencil ) end if ! initialize transport variables like velocity for passive scalar if ( scheme % transVar % varDict % nVals /= 0 ) then write ( logUnit ( 0 ), * ) 'Error: In dynamic load balancing while reinitialize ' write ( logUnit ( 0 ), * ) 'transport var. It must be deallocated first!' call tem_abort () call mus_init_transport_var ( me = scheme % transVar , & & varSys = scheme % varSys , & & tree = geometry % tree , & & nElems_solve = scheme % pdf (:)% nElems_solve , & & levelDesc = scheme % levelDesc ) end if ! -------------------------------------------------------------------------- !                      Reinitialize the global restart                     ! ! -------------------------------------------------------------------------- ! 1. finalize restart by freeing all mpi types call tem_restart_finalize ( me = params % general % restart ) ! 2. initialize restart again call tem_init_restart ( me = params % general % restart , & & solver = params % general % solver , & ! &                    varSys  = scheme%varSys,          & & varMap = scheme % stateVarMap , & & tree = geometry % tree ) ! -------------------------------------------------------------------------- !              Initialize tracking, interpolation and boundaries           ! ! -------------------------------------------------------------------------- ! ------------------------------------------------------------------------ !                  Reinitialize the tracking objects                     ! ! ------------------------------------------------------------------------ ! initialize tracking objects. call mus_init_tracker ( scheme = scheme , & & geometry = geometry , & & params = params ) ! ------------------------------------------------------------------------ !                  Reinitialize the tracking objects                     ! ! ------------------------------------------------------------------------ ! convergence objects if ( params % general % simControl % abortCriteria % steady_state ) then write ( logUnit ( 1 ), \"(A)\" ) 'Initializing convergence...' write ( dbgUnit ( 1 ), \"(A)\" ) 'init convergence' do ii = 1 , size ( params % general % simControl % abortCriteria % convergence ) call mus_timeControl_homogenize ( & & me = params % general % simControl % abortCriteria & & % convergence ( ii )% header % timeControl , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) end do call tem_init_convergence ( me = params % general % simControl & & % abortCriteria % convergence , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil , & & globProc = params % general % proc , & & varSys = scheme % varSys ) end if if ( minLevel /= maxlevel ) then write ( logUnit ( 1 ), \"(A)\" ) 'Initializing interpolation...' ! initialize the interpolation call mus_init_interpolate ( & & intp = scheme % intp , & & levelDesc = scheme % levelDesc , & & schemeHeader = scheme % header , & & stencil = scheme % layout % fStencil , & & minLevel = minLevel , & & maxLevel = maxLevel , & & fieldProp = scheme % field (:)% fieldProp ) end if ! ------------------------------------------------------------------------ !                    Reinitialize the interpolation                      ! ! ------------------------------------------------------------------------ write ( logUnit ( 1 ), \"(A)\" ) 'Fill ghost element by interpolation and do' & & // ' communication' call fillHelperElementsFineToCoarse ( scheme = scheme , & & general = params % general , & & physics = params % physics , & & iLevel = minLevel , & & maxLevel = maxLevel ) call fillHelperElementsCoarseToFine ( scheme = scheme , & & general = params % general , & & physics = params % physics , & & iLevel = minLevel , & & minLevel = minLevel , & & maxLevel = maxLevel ) ! reinitialize auxiliary field variable from state for fluid and ghost ! elements. Since set boundary is applied before load balancing, the ! auxField for fluid and ghostFromCoarser must be computed state ! using FETCH and ghostFromFiner must be interpolated do iLevel = minLevel , maxLevel call mus_calcAuxFieldAndExchange ( & & auxField = scheme % auxField ( iLevel ), & & calcAuxField = scheme % calcAuxField , & & state = scheme % state ( iLevel )% val (:, & & scheme % pdf ( iLevel )% nNext ), & & pdfData = scheme % pdf ( iLevel ), & & nFields = scheme % nFields , & & field = scheme % field (:), & & globSrc = scheme % globSrc , & & stencil = scheme % layout % fStencil , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos , & & general = params % general , & & phyConvFac = params % physics % fac ( iLevel ), & & iLevel = iLevel , & & minLevel = geometry % tree % global % minLevel , & & schemeHeader = scheme % header , & & quantities = scheme % layout % quantities ) if ( iLevel < maxLevel ) then call mus_intpAuxFieldCoarserAndExchange ( & & intp = scheme % intp , & & tAuxField = scheme % auxField ( iLevel ), & & sAuxField = scheme % auxField ( iLevel + 1 ), & & tLevelDesc = scheme % levelDesc ( iLevel ), & & stencil = scheme % layout % fStencil , & & iLevel = iLevel , & & nAuxScalars = scheme % varSys % nAuxScalars , & & general = params % general ) end if end do ! ------------------------------------------------------------------------ !                    Reinitialize the boundaries                         ! ! ------------------------------------------------------------------------ ! Boundary force calculation is valid only for single field schemes ! like fluid and fluid_incompressible so initialize only if nFields = 1 if ( geometry % boundary % nBCtypes > 0 . and . scheme % nFields == 1 ) then call mus_init_bndForce ( bndForce = geometry % bndForce , & & bndMoment = geometry % bndMoment , & & bc_prop = geometry % boundary , & & schemeHeader = scheme % header , & & bc = scheme % field ( 1 )% bc ) end if write ( logUnit ( 1 ), * ) 'Initialize boundary routines' ! initialize each field boundary by looping over the field inside ! init_boundary_field call mus_init_boundary ( field = scheme % field , & & pdf = scheme % pdf , & & state = scheme % state , & & auxField = scheme % auxField , & & tree = geometry % tree , & & levelDesc = scheme % levelDesc , & & layout = scheme % layout , & & schemeHeader = scheme % header , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos , & & globBC = scheme % globBC , & & bc_prop = geometry % boundary ) call mus_reset_levelTimer () call mus_reset_bcTimer () ! Reinitialize time reduction operation variable and set last index ! with current value. call tem_opVar_reduction_transient_init ( & & varSys = scheme % varSys , & & tree = geometry % tree , & & redTransVarMap = scheme % redTransVarMap , & & time = params % general % simControl % now ) end subroutine mus_reset_aux ! **************************************************************************** ! ! **************************************************************************** ! !> This routine performs the load balancing for multilevel simulations. The !! weights are calculated on the basis of levelwise run time, which are then !! fed to sparta for calculation of splitting positions. Restart files are !! saved and the simulation is restarted with the newly distributed mesh subroutine mus_balance ( tree , minLevel , maxLevel , levelDesc , nBCs , globBC , & & general , sparta ) ! -------------------------------------------------------------------------- !> geometry infomation type ( treelmesh_type ), intent ( inout ) :: tree !> min level and max level integer , intent ( in ) :: minLevel , maxLevel !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( minLevel : maxLevel ) !> global IBM type ! type( mus_IBM_globType ), intent(in) :: globIBM !> Number of boundary conditions integer , intent ( in ) :: nBCs !> BC elements information type ( glob_boundary_type ), intent ( in ) :: globBC ( nBCs ) !> global parameters type ( tem_general_type ), intent ( in ) :: general !> Sparta data type type ( tem_sparta_type ), intent ( inout ) :: sparta ! -------------------------------------------------------------------------- character ( len = PathLen ) :: basename character ( len = labelLen ) :: timestamp ! weights for fluid elements real ( kind = rk ), allocatable :: weights (:) ! -------------------------------------------------------------------------- ! allocate weights allocate ( weights ( tree % nElems ) ) ! Calculate weights according to compute, intp and bc routines call mus_getWeights ( weights = weights , & & tree = tree , & & minLevel = minLevel , & & maxLevel = maxLevel , & & levelDesc = levelDesc , & & nBCs = nBCs , & & globBC = globBC ) if ( general % balance % weight ) then write ( logUnit ( 3 ), \"(A)\" ) \"Dump weight file onto disk\" ! Dump the weights using the current sim time in the basename ! Weight file name can be: simulation_name_weight_t timestamp = tem_time_sim_stamp ( general % simControl % now ) write ( basename , '(a)' ) & & './balance/' // trim ( general % solver % simName ) // '_weight_t' & & // trim ( timestamp ) call mus_dumpWeights ( tree = tree , & & weights = weights , & & basename = basename ) end if ! Call the sparta to get new myElems and offset and sparta call tem_balance_sparta ( weight = weights , & & myPart = general % proc % rank , & & nParts = general % proc % comm_size , & & offset = tree % elemOffset , & & myElems = tree % nElems , & & sparta = sparta , & & comm = general % proc % comm ) deallocate ( weights ) end subroutine mus_balance ! **************************************************************************** ! ! **************************************************************************** ! subroutine exchange_tree_bc ( sparta , geometry , comm , comm_size ) type ( tem_sparta_type ), intent ( in ) :: sparta type ( mus_geom_type ), intent ( inout ) :: geometry integer , intent ( in ) :: comm , comm_size type ( tem_sparta_type ) :: sparta_bc , sparta_qVal ! tree is still OLD, but tree%nElems is already NEW if ( geometry % boundary % nBCtypes > 0 ) then write ( logUnit ( 7 ), \"(A)\" ) \"Set sparta info for BCID exchange\" call tem_init_sparta ( sparta_bc , comm_size ) call tem_derive_sparta ( & & origin = sparta , & & derived = sparta_bc , & & nElems = sparta % old_size , & & elemPropertyBits = geometry % tree % elemPropertyBits , & & prpBit = prp_hasbnd , & & comm = comm , & & nParts = comm_size ) if ( any ( geometry % boundary % hasQval ) ) then write ( logUnit ( 7 ), \"(A)\" ) \"Set sparta info for qValue exchange\" call tem_init_sparta ( sparta_qVal , comm_size ) call tem_derive_sparta ( & & origin = sparta , & & derived = sparta_qVal , & & nElems = sparta % old_size , & & elemPropertyBits = geometry % tree % elemPropertyBits , & & prpBit = prp_hasqVal , & & comm = comm , & & nParts = comm_size ) end if end if ! call tem_output_sparta( sparta, logUnit(1) ) ! Unload and reload tree and boundary ---------------------------- ! call unload_treelmesh( geometry%tree ) ! call load_treelmesh( me      = geometry%tree, & !   &                  nParts  = params%general%proc%comm_size ) call exchange_elements ( geometry % tree , sparta ) ! EXCHANGE BCID if ( geometry % boundary % nBCtypes > 0 ) then write ( logUnit ( 7 ), \"(A)\" ) \"Exchange boundaryID by sparta\" call tem_exchange_sparta ( sparta_bc , & & geometry % boundary % boundary_ID , & & geometry % boundary % nSides , & & comm ) call tem_destroy_sparta ( sparta_bc ) if ( any ( geometry % boundary % hasQVal ) ) then write ( logUnit ( 7 ), \"(A)\" ) \"Exchange qValue by sparta\" call tem_exchange_sparta ( sparta_qVal , & & geometry % boundary % qVal , & & geometry % boundary % nSides , & & comm ) call tem_destroy_sparta ( sparta_qVal ) end if end if call mus_build_posInProp ( geometry ) end subroutine exchange_tree_bc ! **************************************************************************** ! end module mus_dynLoadBal_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_dynloadbal_module.f90.html"},{"title":"mus_scheme_header_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_scheme_header_module.f90~~AfferentGraph sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2017 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2024 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2014 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains scheme property type and module related to scheme prop module mus_scheme_header_module ! include treelm modules use env_module , only : LabelLen , rk use tem_tools_module , only : tem_horizontalSpacer use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_NonExistent use aot_table_module , only : aot_table_open , aot_table_close use aot_out_module , only : aot_out_type , aot_out_val , aot_out_open_table , & & aot_out_close_table implicit none private public :: mus_scheme_header_type , mus_scheme_header_out public :: mus_load_scheme_header public :: mus_relaxation_header_type !> Datatype containing additional options for the relaxation like variant and !! other variant specific parameters type mus_relaxation_header_type !> Varaint name of the relaxation. Set to \"default\" to select default !! relaxation character ( len = labelLen ) :: variant !> Addtional information to load for regularited bgk like !! \"regularized\", \"recursive_regularited\" and \"hybrid_recursive_regularized\" !! variant. real ( kind = rk ) :: regularization_omega !> todo move omega_Cum, omega_Lim, DRT_tauN, lambda from mus_fluid_type !! to here end type mus_relaxation_header_type !> Datatype containing information to identify the scheme !! !! Combination of scheme kind, relaxation and layout%stencilKind !! are used to choose the correct compute kernel for the !! scheme !! !!> | type | options | !!> |:-----------------|:--------------| !!> | kind | **fluid** (default)             | !!> |      | **fluid_incompressible**        | !!> |      | **isotherm_acEq**               | !!> |      | **multispecies_gas**            | !!> |      | **multispecies_liquid**         | !!> |      | **nernst_planck**               | !!> |      | **passive_scalar**              | !!> |      | **poisson**                     | !!> |      | **poisson_boltzmann_linear**    | !!> |      | **poisson_boltzmann_nonlinear** | !!> |------|---------------------------------| !!> | layout | **d2q9**           | !!> |        | **d3q19** (default)| !!> |        | **d3q27**          | !!> |        | _d1q3_             | !!> |        | _d2q5_             | !!> |        | _d3q6_             | !!> |        | _d3q7_             | !!> |        | _d3q13_            | !!> |        | _d3q15_            | !!> |        | _flekkoy_          | !!> |--------|--------------------| !!> | relaxation | **bgk**  (default)       | !!> |            | **mrt**                  | !!> |            | **trt**                  | !!> |            | **bgk_withthermodynfac** | !!> |            | **mrt_withthermodynfac** | !!> |            | _cumulant_               | !!> |            | _cascaded_               | !!> |            | _vec_fma_                | !!> |            | _test_                   | !!> |            | _bgk_noFluid_            | !!> |------------|--------------------------| !!> | variant for bgk relaxation | **standard**  (default)       | !!> |                            | **improved**                  | !!> |                            | **block**                     | !!> |                            | **mrt**                       | !!> |------------------------------------------------------------| type mus_scheme_header_type !> scheme kind, Ex: fluid, fluid_incompressible, multispecies_gas, !! multispecies_liquid, poisson, poisson_boltzmann_linear, !! poisson_boltzmann_nonlinear, nernst_planck, isotherm_acEq character ( len = labelLen ) :: kind !> scheme layout, Ex: d3q19 character ( len = labelLen ) :: layout !> scheme relaxation type Ex: BGK, MRT, bgk_pl, bgk_cy, bgk_cs... character ( len = labelLen ) :: relaxation !> Variant and additional options for a relaxation type ( mus_relaxation_header_type ) :: relaxHeader end type mus_scheme_header_type contains ! ************************************************************************** ! !> load scheme header info from lua file identify table or from scheme table !! or from config !! !! Load scheme label, kind, layoutKind and relaxation !!```lua !! identify = { kind = 'simType', !!              layout = 'stencilLayout', !!              relaxation = 'relaxationType' } !!``` !! For a possible selection of the other parameters !! - simType: fluid, fluid_incompressible, multispecies_liquid !! - [[mus_scheme_layout_module]]: d2q9, d3q19, ... !! - relaxationType: bgk, mrt, ... !! subroutine mus_load_scheme_header ( me , conf , parent , scaling ) !--------------------------------------------------------------------------- !> returns scheme identify information type ( mus_scheme_header_type ), intent ( out ) :: me type ( flu_State ) :: conf !< flu state !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> scaling: diffusive or acoustic? character ( len =* ), intent ( in ) :: scaling ! -------------------------------------------------------------------------- integer :: thandle !< handle for scheme identify table integer :: relax_handle integer :: iError ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), '(A)' ) 'Loading Scheme identify table: ' !default values me % kind = 'fluid' me % layout = 'd3q19' me % relaxation = 'bgk' call aot_table_open ( L = conf , & & parent = parent , & & thandle = thandle , & & key = 'identify' ) if ( thandle > 0 ) then ! get schemekind call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'kind' , & & val = me % kind , & & default = 'fluid' , & & ErrCode = iError ) ! get layoutkind call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'layout' , & & val = me % layout , & & default = 'd3q19' , & & ErrCode = iError ) ! Load relaxation as table to load additional information for relaxation. ! if not a table then variant is set to default. call aot_table_open ( L = conf , & & parent = thandle , & & thandle = relax_handle , & & key = 'relaxation' ) if ( relax_handle == 0 ) then ! get relaxation call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'relaxation' , & & val = me % relaxation , & & default = 'bgk' , & & ErrCode = iError ) me % relaxHeader % variant = 'standard' else ! load relaxation options from a table ! get relaxation call aot_get_val ( L = conf , & & thandle = relax_handle , & & key = 'name' , & & val = me % relaxation , & & default = 'bgk' , & & ErrCode = iError ) call load_relaxation_header ( me = me % relaxHeader , & & conf = conf , & & thandle = relax_handle ) end if call aot_table_close ( L = conf , thandle = relax_handle ) else write ( logUnit ( 1 ), '(A)' ) 'Scheme Identify table not defined.' write ( logUnit ( 1 ), '(A)' ) 'Setting default values for scheme..' end if call aot_table_close ( L = conf , thandle = thandle ) write ( logUnit ( 1 ), '(A)' ) 'kind: ' // trim ( me % kind ) write ( logUnit ( 1 ), '(A)' ) 'Layout: ' // trim ( me % layout ) write ( logUnit ( 1 ), '(A)' ) 'relaxation: ' // trim ( me % relaxation ) write ( logUnit ( 1 ), '(A)' ) '  variant: ' // & & trim ( me % relaxHeader % variant ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) ! Both multispeciees and poisson equation must have diffusive scaling ! since diffusive scaling is used to recover macroscopic equations ! from asymptotic analysis select case ( trim ( me % kind )) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) if ( trim ( scaling ) /= 'acoustic' ) then call tem_abort ( 'ERROR: Choose scaling = \"acoustic\" for ' & & // trim ( me % kind )) end if case ( 'multispecies_gas' , 'multispecies_liquid' , 'nernst_planck' , & & 'passive_scalar, ''poisson' , 'poisson_boltzmann_linear' , & & 'poisson_boltzmann_nonlinear' ) if ( trim ( scaling ) /= 'diffusive' ) then call tem_abort ( 'ERROR: Choose scaling = \"diffusive\" for ' & & // trim ( me % kind )) end if end select end subroutine mus_load_scheme_header ! ************************************************************************** ! ! ***************************************************************************! !> Load relaxation options from a table subroutine load_relaxation_header ( me , conf , thandle ) ! -------------------------------------------------------------------------- type ( mus_relaxation_header_type ), intent ( out ) :: me type ( flu_State ) :: conf !< flu state !> relaxation handle integer , intent ( in ) :: thandle ! -------------------------------------------------------------------------- integer :: iError ! -------------------------------------------------------------------------- call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'variant' , & & val = me % variant , & & default = 'standard' , & & ErrCode = iError ) select case ( trim ( me % variant )) case ( 'regularized' , 'recursive_regularied' , 'hybrid_recursive_regularized' ) call aot_get_val ( L = conf , & & thandle = thandle , & & key = 'regularization_omega' , & & val = me % regularization_omega , & & ErrCode = iError ) if ( btest ( iError , aoterr_NonExistent )) then call tem_abort ( 'Error: regularization_omega is not specified for ' & & // 'regularized variant' ) end if write ( logUnit ( 1 ), '(A, F10.7)' ) '  regularization_omega: ' , & & me % regularization_omega end select end subroutine load_relaxation_header ! ***************************************************************************! ! ************************************************************************** ! !> Dumps scheme header subroutine mus_scheme_header_out ( me , conf ) ! ---------------------------------------------------------------------------- !> returns scheme identify information type ( mus_scheme_header_type ), intent ( in ) :: me type ( aot_out_type ) :: conf ! -------------------------------------------------------------------------- ! the label does not have to be outputted. ! because it is the name of the outputted varSys call aot_out_open_table ( put_conf = conf , tname = 'identify' ) call aot_out_val ( put_conf = conf , & & vname = 'kind' , & & val = trim ( me % kind )) call aot_out_val ( put_conf = conf , & & vname = 'relaxation' , & & val = trim ( me % relaxation )) call aot_out_val ( put_conf = conf , & & vname = 'layout' , & & val = trim ( me % layout )) call aot_out_close_table ( put_conf = conf ) end subroutine mus_scheme_header_out ! ************************************************************************** ! end module mus_scheme_header_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_scheme_header_module.f90.html"},{"title":"mus_wall_function_schmitt_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_wall_function_schmitt_module.f90~~EfferentGraph sourcefile~mus_wall_function_schmitt_module.f90 mus_wall_function_schmitt_module.f90 sourcefile~mus_wall_function_abstract_module.f90 mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_schmitt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_wall_function_schmitt_module.f90~~AfferentGraph sourcefile~mus_wall_function_schmitt_module.f90 mus_wall_function_schmitt_module.f90 sourcefile~mus_turb_wallfunc_module.f90 mus_turb_wallFunc_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_schmitt_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types, function and routines for wall function !! computations relative to Schmitt profile. !! Ref to following paper for Schmitt three layer equations. !! Haussmann, M. et al. (2019) ‘Large-eddy simulation coupled with wall models !! for turbulent channel flows at high Reynolds numbers with a lattice !! Boltzmann method — Application to Coriolis mass flowmeter’, Computers & !! Mathematics with Applications. Elsevier Ltd, 78(10), pp. 3285–3302. !! !! author: Gregorio Gerardo Spinelli module mus_wall_function_schmitt_module ! include treelm modules use env_module , only : rk use mus_wall_function_abstract_module , only : mus_wall_function_type implicit none private !! Constant parameters for Schmitt's law real ( kind = rk ), parameter :: vonKA = 0.4_rk real ( kind = rk ), parameter :: sc_uLmt = 3 0._rk real ( kind = rk ), parameter :: sc_lLmt = 5._rk ! we need the limit to be public due to the function that computer the ! friction velocity created in mus_turb_wallFunc_module ! we need tot ake care of explicit and implicit part of the wall profile public :: sc_uLmt , sc_lLmt public :: mus_wall_function_schmitt_type ! function used to get friction velocity where the Schmitt profile ! has an explicit function public :: get_uTau_subVisousLayer public :: get_uTau_logLayer !> extend the abstract subclass mus_wall_function_type type , extends ( mus_wall_function_type ) :: mus_wall_function_schmitt_type contains !> function to get uPlus procedure , nopass :: get_uPlus !> function to apply the newton method ! F = uPlus_n - uPlus_(n+1) ! here we compute the derivative of uPlus_(n+1) w.r.t. u_tau ! this function computes the derivative of uPlus with respect to uTau procedure , nopass :: get_d_uPlus_d_uTau end type mus_wall_function_schmitt_type contains !> function to get uPlus pure function get_uPlus ( yPlus ) result ( uPlus ) !> yPlus real ( kind = rk ), intent ( in ) :: yPlus !> output: uPlus real ( kind = rk ) :: uPlus ! ------------------------------------------------------------------------------ ! calculated with sympy if ( yPlus >= sc_uLmt ) then ! log layer, use powerlaw profile from werner and wengle uPlus = 8.3_rk * yPlus ** 0.142857142857143_rk else if ( yPlus < sc_lLmt ) then ! viscous sublayer, use linear profile. uPlus = yPlus else ! if ( yPlus >= sc_lLmt .and. yPlus < sc_uLmt) ! Buffer layer, use logarithmic profile uPlus = 0.242384365402773_rk * ( 1 9.8872196713232_rk * vonKA + & & ( 0.46051701859881_rk * vonKA + 3.40119738166216_rk ) & & * log ( yPlus ) - 5.47401601371867_rk ) / vonKA end if end function get_uPlus !> function to get the derivative of uPlus with respect to uTau pure function get_d_uPlus_d_uTau ( y , uTau , nu ) result ( d_uPlus_d_uTau ) !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> uTau at iteration n real ( kind = rk ), intent ( in ) :: uTau !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> output: derivative of uPlus with respect to uTau real ( kind = rk ) :: d_uPlus_d_uTau ! ------------------------------------------------------------------------------ ! obtained as diff from sympy in python ! Buffer layer, use logarithmic profile d_uPlus_d_uTau = 0.242384365402773_rk * ( 0.46051701859881_rk * vonKA & & + 3.40119738166216_rk ) / ( vonKA * uTau ) end function get_d_uPlus_d_uTau ! function used to get friction velocity where the Schmitt profile ! has an explicit function - viscous sub layer pure function get_uTau_subVisousLayer ( visc_div_dist , velSW ) result ( uTau ) !> dynamic viscosity divided by vertical distance from the wall real ( kind = rk ), intent ( in ) :: visc_div_dist !> velocity stream-wise parallel to wall real ( kind = rk ), intent ( in ) :: velSW !> friction velocity real ( kind = rk ) :: uTau ! ------------------------------------------------------------------------------ ! obtained as diff from sympy in python ! Buffer layer, use logarithmic profile uTau = sqrt ( velSW * visc_div_dist ) end function get_uTau_subVisousLayer ! function used to get friction velocity where the Schmitt profile ! has an explicit function - log layer pure function get_uTau_logLayer ( visc_div_dist , velSW ) result ( uTau ) !> dynamic viscosity divided by vertical distance from the wall real ( kind = rk ), intent ( in ) :: visc_div_dist !> velocity stream-wise parallel to wall real ( kind = rk ), intent ( in ) :: velSW !> friction velocity real ( kind = rk ) :: uTau ! ------------------------------------------------------------------------------ ! obtained as diff from sympy in python ! Buffer layer, use logarithmic profile uTau = 0.156966389612661_rk * & & ( visc_div_dist ** 0.142857142857143_rk * velSW ) ** 0.875_rk end function get_uTau_logLayer end module mus_wall_function_schmitt_module","tags":"","loc":"sourcefile/mus_wall_function_schmitt_module.f90.html"},{"title":"mus_eNRTL_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_enrtl_module.f90~~AfferentGraph sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013, 2015-2017 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module contains an interface for external C++ code to compute !! liquid mixture property like thermodynamic factor and !! Maxwell-Stefan Diffusivity coefficients module mus_eNRTL_module use , intrinsic :: iso_c_binding , only : c_ptr , c_int , c_double , c_float , & & c_int_least8_t , c_int_least64_t , & & c_char , c_loc , c_bool use env_module , only : rk implicit none private public :: mus_init_eNRTL public :: mus_calc_thermFactor public :: mus_calc_MS_DiffMatrix !> This function initialize eNRTL model by loading liquid mixture !! property from filename interface function init_enrtl_loc ( filename , nSpc ) bind ( c , name = 'init_enrtl' ) !function init_enrtl_f90( filename ) bind(c, name='_Z10init_enrtlPKc') use , intrinsic :: iso_c_binding character ( kind = c_char ), dimension ( * ) :: filename integer ( kind = c_int ), intent ( out ) :: nSpc !> Result, indicating the status of encode integer ( kind = c_int ) :: init_enrtl end function init_enrtl_loc end interface !> This routine calculates thermodynamic factor for given mole_frac !! of all species interface subroutine calc_therm_factor_loc ( nSpc , Temp , Press , Mole_frac , & & Therm_factors ) bind ( c , name = 'calc_therm_factor_C' ) use , intrinsic :: iso_c_binding integer ( kind = c_int ), value , intent ( in ) :: nSpc real ( kind = c_double ), value , intent ( in ) :: Temp real ( kind = c_double ), value , intent ( in ) :: Press real ( kind = c_double ), dimension ( * ), intent ( in ) :: Mole_frac real ( kind = c_double ), dimension ( * ), intent ( out ) :: Therm_factors end subroutine calc_therm_factor_loc end interface !> This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix !! for given mole_frac of all species interface subroutine calc_ms_diff_matrix_from_molefrac ( nSpc , Temp , Press , Mole_frac , & & D_ij_out ) bind ( c , name = 'calc_ms_diff_matrix_from_molefrac_C' ) use , intrinsic :: iso_c_binding integer ( kind = c_int ), value , intent ( in ) :: nSpc real ( kind = c_double ), value , intent ( in ) :: Temp real ( kind = c_double ), value , intent ( in ) :: Press real ( kind = c_double ), dimension ( * ), intent ( in ) :: Mole_frac real ( kind = c_double ), dimension ( * ), intent ( out ) :: D_ij_out end subroutine calc_ms_diff_matrix_from_molefrac end interface !> This routine calculates Maxwell-Stefan diffusivity coeffcient Matrix !! for given mole_frac of all species interface subroutine calc_ms_diff_matrix_from_moledens ( nSpc , Temp , Press , Mole_dens , & & D_ij_out ) bind ( c , name = 'calc_ms_diff_matrix_from_moledens_C' ) use , intrinsic :: iso_c_binding integer ( kind = c_int ), value , intent ( in ) :: nSpc real ( kind = c_double ), value , intent ( in ) :: Temp real ( kind = c_double ), value , intent ( in ) :: Press real ( kind = c_double ), dimension ( * ), intent ( in ) :: Mole_dens real ( kind = c_double ), dimension ( * ), intent ( out ) :: D_ij_out end subroutine calc_ms_diff_matrix_from_moledens end interface interface mus_calc_thermFactor module procedure mus_calc_thermFactor_single end interface mus_calc_thermFactor interface mus_calc_MS_DiffMatrix module procedure mus_calc_MS_DiffMatrix_single end interface contains ! ************************************************************************** ! !> This function loads property file using external c-function function mus_init_eNRTL ( filename , nFields ) result ( success ) ! -------------------------------------------------------------------------! character ( kind = c_char ), dimension ( * ) :: filename !> number of fields in mixture integer , intent ( out ) :: nFields logical :: success ! -------------------------------------------------------------------------! integer ( kind = c_int ) :: nFields_c integer ( kind = c_int ) :: success_c ! -------------------------------------------------------------------------! success_c = init_eNRTL_loc ( filename , nFields_c ) if ( success_c == 0 ) then success = . true . nFields = nFields_c else success = . false . nFields = - 1 end if end function mus_init_eNRTL ! ************************************************************************** ! !> This routine calculates thermodynamic factor for given mole_frac !! of all species for single element subroutine mus_calc_thermFactor_single ( nFields , temp , press , mole_frac , & & therm_factors ) ! -------------------------------------------------------------------------! !> number of fields in mixture integer , intent ( in ) :: nFields !> mixture temperature real ( kind = rk ), intent ( in ) :: temp !> mixture pressure real ( kind = rk ), intent ( in ) :: press !> mole fraction of all species of single element real ( kind = rk ), intent ( in ) :: mole_frac ( nFields ) !> thermodynamic factor matrix real ( kind = rk ), intent ( out ) :: therm_factors ( nFields , nFields ) ! -------------------------------------------------------------------------! integer ( kind = c_int ) :: nFields_c real ( kind = c_double ) :: temp_c , press_c real ( kind = c_double ) :: mole_frac_c ( nFields ) real ( kind = c_double ) :: therm_factors_c ( nFields * nFields ) integer :: iField , iField_2 ! -------------------------------------------------------------------------! nFields_c = int ( nFields , kind = c_int ) temp_c = real ( temp , kind = c_double ) press_c = real ( press , kind = c_double ) do iField = 1 , nFields mole_frac_c ( iField ) = real ( mole_frac ( iField ), kind = c_double ) end do call calc_therm_factor_loc ( nFields_c , temp_c , press_c , mole_frac_c , & & therm_factors_c ) do iField = 1 , nFields do iField_2 = 1 , nFields therm_factors ( iField , iField_2 ) = & & therm_factors_c (( iField - 1 ) * nFields + iField_2 ) end do end do !    therm_factors = 0.0_rk !    do iField = 1, nFields !      therm_factors(iField, iField) = 1.0_rk !    end do !    write(*,*) 'Therm_factors_c ', therm_factors_c !    write(*,*) 'Therm_factors ' !    do iField = 1, nFields !    write(*,*) 'iField ', iField, ' factors ', therm_factors(iField,:) !    end do end subroutine mus_calc_thermFactor_single ! ************************************************************************** ! !> This routine calculates Diffusivity coefficients matrix for given mole_frac !! of all species for single element subroutine mus_calc_MS_DiffMatrix_single ( nFields , temp , press , mole_dens , & & D_ij_out ) ! -------------------------------------------------------------------------! !> number of fields in mixture integer , intent ( in ) :: nFields !> mixture temperature real ( kind = rk ), intent ( in ) :: temp !> mixture pressure real ( kind = rk ), intent ( in ) :: press !> mole density of all species of single element real ( kind = rk ), intent ( in ) :: mole_dens ( nFields ) !> thermodynamic factor matrix real ( kind = rk ), intent ( out ) :: D_ij_out ( nFields , nFields ) ! -------------------------------------------------------------------------! integer ( kind = c_int ) :: nFields_c real ( kind = c_double ) :: temp_c , press_c real ( kind = c_double ) :: mole_dens_c ( nFields ) real ( kind = c_double ) :: D_ij_out_c ( nFields * nFields ) integer :: iField , iField_2 ! -------------------------------------------------------------------------! nFields_c = int ( nFields , kind = c_int ) temp_c = real ( temp , kind = c_double ) press_c = real ( press , kind = c_double ) do iField = 1 , nFields mole_dens_c ( iField ) = real ( mole_dens ( iField ), kind = c_double ) end do !    write(*,*) 'nFields ', nFields !    write(*,*) 'temp ', temp !    write(*,*) 'press ', press !    write(*,*) 'mole_dens ', mole_dens call calc_ms_diff_matrix_from_moledens ( nFields_c , temp_c , press_c , & & mole_dens_c , D_ij_out_c ) do iField = 1 , nFields do iField_2 = 1 , nFields D_ij_out ( iField , iField_2 ) = D_ij_out_c (( iField - 1 ) * nFields + iField_2 ) end do end do !    write(*,*) 'D_ij_out_c ', D_ij_out_c !    write(*,*) 'D_ij_out ' !    do iField = 1, nFields !      write(*,*) 'iField ', iField, ' factors ', D_ij_out(iField,:) !    end do end subroutine mus_calc_MS_DiffMatrix_single end module mus_eNRTL_module","tags":"","loc":"sourcefile/mus_enrtl_module.f90.html"},{"title":"mus_initFluid_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initfluid_module.f90~~EfferentGraph sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013, 2017 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2024 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2021 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for lbm model. module mus_initFluid_module use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use mus_bgk_module , only : mus_advRel_kCFD_rBGK_vStdNoOpt_l use mus_compute_cumulant_module , only : cumulant_d3q27 , cascaded_d3q27 , & & cumulant_d3q27_extended_generic , & & cumulant_d3q27_extended_fast use mus_d3q27_module , only : mus_advRel_kCFD_rBGK_vStd_lD3Q27 , & & mus_advRel_kFluid_rTRT_vStd_lD3Q27 , & & mus_advRel_kFluid_rBGK_vImproved_lD3Q27 , & & bgk_Regularized_d3q27 , & & bgk_RecursiveRegularized_d3q27 , & & bgk_ProjectedRecursiveRegularized_d3q27 , & & bgk_HybridRecursiveRegularized_d3q27 , & & bgk_DualRelaxationTime_RR_d3q27 , & & bgk_HybridRecursiveRegularizedCorr_d3q27 use mus_d3q19_module , only : mus_advRel_kFluid_rBGK_vStd_lD3Q19 , & & mus_advRel_kFluid_rBGK_vBlock_lD3Q19 , & & mus_advRel_kFluid_rTRT_vStd_lD3Q19 , & & bgk_Regularized_d3q19 , & & bgk_RecursiveRegularized_d3q19 , & & bgk_ProjectedRecursiveRegularized_d3q19 , & & bgk_HybridRecursiveRegularized_d3q19 , & & bgk_DualRelaxationTime_RR_d3q19 , & & bgk_HybridRecursiveRegularizedCorr_d3q19 use mus_d2q9_module , only : mus_advRel_kFluid_rMRT_vStd_lD2Q9 , & & mus_advRel_kFluid_rBGK_vStd_lD2Q9 , & & mus_advRel_kFluid_rBGK_vImproved_lD2Q9 , & & bgk_Regularized_d2q9 , & & bgk_RecursiveRegularized_d2q9 , & & bgk_ProjectedRecursiveRegularized_d2q9 , & & bgk_HybridRecursiveRegularized_d2q9 , & & bgk_DualRelaxationTime_RR_d2q9 , & & bgk_HybridRecursiveRegularizedCorr_d2q9 use mus_mrt_d3q19_module , only : mus_advRel_kFluid_rMRT_vStd_lD3Q19 , & & mus_advRel_kFluid_rMRT_vStdNoOpt_lD3Q19 , & & mus_advRel_kCFD_rMRT_vStdNoOpt_l use mus_mrt_d3q27_module , only : mus_advRel_kFluid_rMRT_vStd_lD3Q27 , & & mus_advRel_kCFD_rMRT_vStdNoOpt_lD3Q27 use mus_test_module , only : vec_fma use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_fluid contains ! ************************************************************************** ! !> Assigning compute kernel routine by scheme relaxation type for fluid kind. !! subroutine mus_init_advRel_fluid ( relaxation , variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: relaxation character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing fluid relaxation model: ' & & // trim ( relaxation ) // ' for layout ' // trim ( layout ) select case ( trim ( relaxation )) case ( 'bgk' ) call mus_init_advRel_fluid_bgk ( variant , layout , compute ) case ( 'mrt' ) call mus_init_advRel_fluid_mrt ( variant , layout , compute ) case ( 'trt' ) call mus_init_advRel_fluid_trt ( variant , layout , compute ) case ( 'cumulant' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => cumulant_d3q27 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'cumulant_extended' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => cumulant_d3q27_extended_fast case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'cumulant_extended_generic' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => cumulant_d3q27_extended_generic case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'cascaded' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => cascaded_d3q27 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'vec_fma' , 'test' ) compute => vec_fma case ( 'hrr_bgk' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_HybridRecursiveRegularized_d3q27 case ( 'd3q19' ) compute => bgk_HybridRecursiveRegularized_d3q19 case ( 'd2q9' ) compute => bgk_HybridRecursiveRegularized_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'hrr_bgk_corrected' , 'prr_bgk_corrected' , 'rr_bgk_corrected' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_HybridRecursiveRegularizedCorr_d3q27 case ( 'd3q19' ) compute => bgk_HybridRecursiveRegularizedCorr_d3q19 case ( 'd2q9' ) compute => bgk_HybridRecursiveRegularizedCorr_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'drt_bgk' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_DualRelaxationTime_RR_d3q27 case ( 'd3q19' ) compute => bgk_DualRelaxationTime_RR_d3q19 case ( 'd2q9' ) compute => bgk_DualRelaxationTime_RR_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'rr_bgk' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_RecursiveRegularized_d3q27 case ( 'd3q19' ) compute => bgk_RecursiveRegularized_d3q19 case ( 'd2q9' ) compute => bgk_RecursiveRegularized_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'prr_bgk' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_ProjectedRecursiveRegularized_d3q27 case ( 'd3q19' ) compute => bgk_ProjectedRecursiveRegularized_d3q19 case ( 'd2q9' ) compute => bgk_ProjectedRecursiveRegularized_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case ( 'r_bgk' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => bgk_Regularized_d3q27 case ( 'd3q19' ) compute => bgk_Regularized_d3q19 case ( 'd2q9' ) compute => bgk_Regularized_d2q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"' // trim ( relaxation ) // '\"' ) end select case default call tem_abort ( 'Unsupported relaxation \"' // trim ( relaxation ) // '\" for ' & & // 'kind \"fluid\"' ) end select end subroutine mus_init_advRel_fluid ! ************************************************************************** ! ! ************************************************************************** ! !> This routine assigns compute routine for bgk relaxation. !! !! Supported variants are: !!   * standard        - Optimized routines for specifc layouts. !!   * standard_no_opt - Semi or no optimized routines for any layouts. !!   * improved        - improved BGK with Galilean correction term for !!                       specific layouts. !!   * block           - routines for vector machine. Implemented only for !!                       D3Q19 subroutine mus_init_advRel_fluid_bgk ( variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kCFD_rBGK_vStd_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluid_rBGK_vStd_lD3Q19 case ( 'd2q9' ) compute => mus_advRel_kFluid_rBGK_vStd_lD2Q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"bgk\" for variant \"' // trim ( variant ) // '\"' ) end select case ( 'standard_no_opt' ) compute => mus_advRel_kCFD_rBGK_vStdNoOpt_l case ( 'improved' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kFluid_rBGK_vImproved_lD3Q27 case ( 'd2q9' ) compute => mus_advRel_kFluid_rBGK_vImproved_lD2Q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"bgk\" for variant \"' // trim ( variant ) // '\"' ) end select case ( 'block' ) select case ( trim ( layout )) case ( 'd3q19' ) compute => mus_advRel_kFluid_rBGK_vBlock_lD3Q19 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"bgk\" for variant \"' // trim ( variant ) // '\"' ) end select case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"bgk\"' ) end select end subroutine mus_init_advRel_fluid_bgk ! ************************************************************************** ! ! ************************************************************************** ! !> This routine assigns compute routine for mrt relaxation !! !! Supported variants are: !!   * standard        - Optimized routines for specifc layouts. !!   * standard_no_opt - no optimized routines for any layouts. !!   * bgk             - Uses no optimized routine but !!                       in mus_mrtRelaxation_module all relaxation parameters !!                       are set to same omega to recover bgk. subroutine mus_init_advRel_fluid_mrt ( variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kFluid_rMRT_vStd_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluid_rMRT_vStd_lD3Q19 case ( 'd2q9' ) compute => mus_advRel_kFluid_rMRT_vStd_lD2Q9 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"mrt\" for variant \"' // trim ( variant ) // '\"' ) end select case ( 'standard_no_opt' ) select case ( trim ( layout )) case ( 'd3q27' ) compute => mus_advRel_kCFD_rMRT_vStdNoOpt_lD3Q27 case ( 'd3q19' ) compute => mus_advRel_kFluid_rMRT_vStdNoOpt_lD3Q19 case default compute => mus_advRel_kCFD_rMRT_vStdNoOpt_l end select case ( 'bgk' ) compute => mus_advRel_kCFD_rMRT_vStdNoOpt_l case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"mrt\"' ) end select end subroutine mus_init_advRel_fluid_mrt ! ************************************************************************** ! ! ************************************************************************** ! !> This routine assigns compute routine for trt relaxation !! !! Supported variants are: !!   * standard        - Optimized routines for specifc layouts. subroutine mus_init_advRel_fluid_trt ( variant , layout , compute ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: variant character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! -------------------------------------------------------------------------- select case ( trim ( variant )) case ( 'standard' ) select case ( trim ( layout )) case ( 'd3q19' ) compute => mus_advRel_kFluid_rTRT_vStd_lD3Q19 case ( 'd3q27' ) compute => mus_advRel_kFluid_rTRT_vStd_lD3Q27 case default call tem_abort ( 'Unsupported layout \"' // trim ( layout ) // '\" for ' & & // 'relaxation \"trt\" for variant \"' // trim ( variant ) // '\"' ) end select case default call tem_abort ( 'Unsupported variant \"' // trim ( variant ) // '\" for ' & & // 'relaxation \"trt\"' ) end select end subroutine mus_init_advRel_fluid_trt ! ************************************************************************** ! end module mus_initFluid_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_initfluid_module.f90.html"},{"title":"mus_source_type_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_source_type_module.f90~~EfferentGraph sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_source_type_module.f90~~AfferentGraph sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_turbchanforce_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** ! !> author: Kannan Masilamani !! Module containing subroutines for building MUSUBI specific source !! variables !! module mus_source_type_module ! include treelm modules use env_module , only : rk , long_k , labelLen use tem_tools_module , only : upper_to_lower use tem_aux_module , only : tem_abort use tem_varMap_module , only : tem_possible_variable_type , & & init , append , truncate , & & tem_variable_loadMapping use tem_stencil_module , only : tem_stencilHeader_type use tem_varSys_module , only : tem_varSys_type use tem_stringKeyValuePair_module , only : grw_stringKeyValuePairArray_type , & & init , append , truncate use tem_stencil_module , only : tem_stencilHeader_type use tem_time_module , only : tem_time_type use treelmesh_module , only : treelmesh_type use tem_logging_module , only : logUnit use tem_shape_module , only : tem_shape_type , tem_load_shape use tem_subTree_type_module , only : tem_subTree_type ! include musubi modules use mus_scheme_header_module , only : mus_scheme_header_type use mus_physics_module , only : mus_convertFac_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_absorbLayer_module , only : mus_absorbLayer_type , & & mus_absorbLayer_dynAvg_type , & & mus_load_absorbLayer ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_Fatal , & & aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , aot_get_val implicit none private public :: mus_source_type public :: mus_source_op_type public :: mus_turbChannelForce_type public :: mus_HRRCorrectionTerm_type public :: mus_create_poss_srcVar public :: mus_load_source_var public :: mus_source_cleanup public :: mus_applySrc_dummy public :: mus_addSrcToAuxField_dummy public :: mus_updateSrcVar_dummy ! ************************************************************************** ! !> Stores correction term for HRR_bgk type mus_HRRCorrectionTerm_type !> density real ( kind = rk ), allocatable :: dens (:) !> velocity real ( kind = rk ), allocatable :: vel (:,:) end type mus_HRRCorrectionTerm_type ! ************************************************************************** ! ! ************************************************************************** ! !> Contains information to compute average bulk velocity for dynamic_force. !! In turb_channel_force, the force term is adapted according to difference !! between reference bulk velocity and simulated plane average bulk velocity !! to avoid linear increase in simulated bulk velocits. !! For more information: !! https://www.wias-berlin.de/people/john/ELECTRONIC_PAPERS/JR07.IJNMF.pdf type mus_turbChannelForce_type !> tracking shapes type ( tem_shape_type ) :: geom_utau ( 1 ) !1 type ( tem_shape_type ) :: geom_umean ( 1 ) !1 !> sub-tree resulting from the elements within the tracking shape !! The sub-tree also holds the sub-communicator !! This data needs to be UPDATED after balance type ( tem_subTree_type ) :: subTree_utau !one for utau and umean type ( tem_subTree_type ) :: subTree_umean !one for utau and umean !> Reference bulk velocity in physical unit real ( kind = rk ) :: refVelBulk !> Characteristic height in physical unit real ( kind = rk ) :: refHeight !> Stream-wise direction to compute average velocity !! x=1, y=2, z=3 integer :: flow_direction !> Dynamic Force term for turbulent channel in physical unit [m/s&#94;2] !! F_dyn = (refVelBulk-avgVelXBulk) * refVelBulk / refHeight real ( kind = rk ) :: forceDyn ( 3 ) !> Global number of elements in defined shape integer :: nElemsGlobal_utau integer :: nElemsGlobal_umean end type mus_turbChannelForce_type ! ************************************************************************** ! ! ************************************************************************** ! !> Contains source elements position in state array and idx to access !! data variable refered in config file. !! This type is defined for each level type mus_source_elems_type !> Number of source elements on this level. !! nFluids + nGhosts integer :: nElems !> Position of elements in state array to apply source terms. !! Position in state array is same as position in total list !! Size: nElems integer , allocatable :: posInTotal (:) !> Index to access point data type to retrieve values from variable !! refered for source variable integer , allocatable :: idx (:) !> source field value obtained from ST_fun data variable. !! Filled only for elements where source is active i.e. elements in !! posInTotal. !! size: nElems*nComponents !! \\todo KM: might be not neccessary !KM!    real(kind=rk), allocatable :: val(:) !> Contains time average values of density and velocity for dynamic !! absorblayer. !! \\todo KM: 02042021 Introduce method_data c_ptr and point to !! dynAvg for absorbLayer and change intent(inout) to intent(in) in !! proc_addSrcToAuxField. type ( mus_absorbLayer_dynAvg_type ) :: dynAvg ! source term for HRR_bgk type ( mus_HRRCorrectionTerm_type ) :: HRR_Corr end type mus_source_elems_type ! ************************************************************************** ! ! ************************************************************************** ! !> Description contains list of elements on which source is active and !! function pointer to update source type mus_source_op_type !> Position of this source term variable in the varSys integer :: srcTerm_varPos !> Position of data variable provided in config file in the varSys integer :: data_varPos !> Contains source elements position in state array/total list for !! each level type ( mus_source_elems_type ), allocatable :: elemLvl (:) !> Function to update state with source term procedure ( proc_apply_source ), pointer :: applySrc => null () !> to use source field array !KM!logical :: useSrcFieldVal = .false. !> name of the source variable character ( len = labelLen ) :: varname !> Function pointer to append source field to auxilary variable procedure ( proc_addSrcToAuxField ), pointer :: addSrcToAuxField => null () !> Function pointer to update source variable which are dependent on !! auxField. procedure ( proc_updateSourceVar ), pointer :: updateSourceVar => null () !> Order of approximation for source like force, electric_field, !! charge_density. !! Order = 1, uses force term in BE approximated by forward Euler method !! Order = 2, uses force term in BE approximated by Trapezoidal method. !! For order 2, macroscopic source is also added to auxField. !! For fluid, fluid_incompressible, multispecies_liquid: source is added !! to momentum and for poisson: source is added to potential. !! Default: order = 2. integer :: order !> Additional config information for absorbLayer type ( mus_absorbLayer_type ) :: absLayer !> Contains information to compute average bulk velocity for dynamic_force type ( mus_turbChannelForce_type ) :: turbChanForce end type mus_source_op_type ! *************************************************************************** ! ! *************************************************************************** ! !> Description of musubi source type type mus_source_type !> Contains source elements position in tree%treeID and !! function pointer to update source !! Size: varDict%nVals type ( mus_source_op_type ), allocatable :: method (:) !> Dictionary of source variable with !! varDict%val()%key is the name of source variable and !! varDict%val()%value is the name of variable provided for the key type ( grw_stringKeyValuePairArray_type ) :: varDict end type mus_source_type ! *************************************************************************** ! ! *************************************************************************** ! abstract interface !> Abstract interface to update state with source terms subroutine proc_apply_source ( fun , inState , outState , neigh , auxField , & & nPdfSize , iLevel , varSys , time , phyConvFac , derVarPos ) import :: rk , mus_source_op_type , tem_varSys_type , tem_time_type , & & mus_convertFac_type , mus_derVarPos_type !> Description of method to update source class ( mus_source_op_type ), intent ( in ) :: fun !> input  pdf vector !! \\todo KM: instate is passed to compute auxField. !! Since auxField is precomputed from instate and passed to this routine. !! instate can be removed real ( kind = rk ), intent ( in ) :: inState (:) !> output pdf vector real ( kind = rk ), intent ( inout ) :: outState (:) !> connectivity Array corresponding to state vector integer , intent ( in ) :: neigh (:) !> auxField array real ( kind = rk ), intent ( in ) :: auxField (:) !> number of elements in state Array integer , intent ( in ) :: nPdfSize !> current level integer , intent ( in ) :: iLevel !> variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) end subroutine proc_apply_source !> Interface to add source to auxField vars in source_op_type for !! all nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner). !! Halo elements are exchanged subroutine proc_addSrcToAuxField ( fun , auxField , iLevel , time , varSys , & & phyConvFac , derVarPos ) import :: rk , tem_varSys_type , mus_derVarPos_type , mus_convertFac_type , & & tem_time_type , mus_source_op_type !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> output auxField array real ( kind = rk ), intent ( inout ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> current timing information type ( tem_time_type ), intent ( in ) :: time !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) end subroutine proc_addSrcToAuxField !> Interface to update source variable which has dependency on auxField. !! Applied on all nSolve elements (nFluids+nGhostFromCoarser+nGhostFromFiner). !! Halo elements are exchanged !! This should be called after adding sorce term to state so that both !! auxField and apply_source uses same source value in one multilevel cycle. subroutine proc_updateSourceVar ( fun , auxField , iLevel , varSys , phyConvFac , & & derVarPos ) import :: rk , tem_varSys_type , mus_derVarPos_type , mus_convertFac_type , & & treelmesh_type , mus_source_op_type !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> input auxField array on current level real ( kind = rk ), intent ( in ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor on current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) end subroutine proc_updateSourceVar end interface ! *************************************************************************** ! contains ! *************************************************************************** ! !> Routine initialize possible source variable depends on scheme kind subroutine mus_create_poss_srcVar ( poss_srcVar , schemeHeader ) ! --------------------------------------------------------------------------! !> possible source variables type ( tem_possible_variable_type ), intent ( out ) :: poss_srcVar !> Identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! --------------------------------------------------------------------------! integer :: QQ ! --------------------------------------------------------------------------! ! used only for HRR Correction term select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) QQ = 9 case ( 'd3q19' ) QQ = 19 case ( 'd3q27' ) QQ = 27 case default ! Musubi will be aborted later, other layouts not supported!!!! QQ = - 1 end select write ( logUnit ( 10 ), * ) 'Creating possible source terms ' call init ( me = poss_srcVar , length = 2 ) select case ( trim ( schemeHeader % kind )) case ( 'fluid' , 'fluid_incompressible' ) ! body force call append ( me = poss_srcVar , & & varName = 'force' , & & nComponents = 3 ) ! dynamic body force for turbulent channel call append ( me = poss_srcVar , & & varName = 'turb_channel_force_accel' , & & nComponents = 3 ) ! absorb layer, STfun should return sponge_strength ! Target pressure and velocity are defined under absorb_layer_target call append ( me = poss_srcVar , & & varName = 'absorb_layer' , & & nComponents = 1 ) ! Absorn layer for inlet boundary with dynamic pressure and ! constant velocity. call append ( me = poss_srcVar , & & varName = 'absorb_layer_inlet' , & & nComponents = 1 ) ! Absorn layer for outlet boundary with constant pressure and ! dynamic velocity. call append ( me = poss_srcVar , & & varName = 'absorb_layer_outlet' , & & nComponents = 1 ) ! HRR correction term, might be usefull also for other schemes?? call append ( me = poss_srcVar , & & varName = 'hrr_correction' , & & nComponents = QQ ) case ( 'passive_scalar' ) call append ( me = poss_srcVar , & & varName = 'equal_injection' , & & nComponents = 1 ) call append ( me = poss_srcVar , & & varName = 'injection' , & & nComponents = 1 ) case ( 'nernst_planck' ) call append ( me = poss_srcVar , & & varName = 'electric_field' , & & nComponents = 3 ) case ( 'multispecies_liquid' ) call append ( me = poss_srcVar , & & varName = 'electric_field' , & & nComponents = 3 ) call append ( me = poss_srcVar , & & varName = 'force' , & & nComponents = 3 ) case ( 'poisson' ) call append ( me = poss_srcVar , & & varName = 'charge_density' , & & nComponents = 1 ) case default write ( logUnit ( 1 ), * ) 'No possible source term defined for scheme kind:' & & // trim ( schemeHeader % kind ) end select call truncate ( poss_srcVar ) end subroutine mus_create_poss_srcVar ! *************************************************************************** ! ! ***************************************************************************! !> Routine load musubi source terms for given key. !! key is glob_source or source subroutine mus_load_source_var ( me , possVars , conf , parent , key , varSys ) ! --------------------------------------------------------------------------! !> Source variable type to initialize type ( mus_source_type ), intent ( out ) :: me !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: possVars !> flu state type ( flu_State ) :: conf !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> key to load source term character ( len =* ), intent ( in ) :: key !> Global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys ! --------------------------------------------------------------------------! integer :: iSrc , iError , srchandle character ( len = labelLen ) :: varname_order ! --------------------------------------------------------------------------! ! initialize growing array stringKeyValuePair call init ( me = me % varDict ) ! load the global source variables call tem_variable_loadMapping ( possVars = possVars , & & conf = conf , & & parent = parent , & & key = key , & & varDict = me % varDict , & & varSys = varSys ) ! truncate varDict call truncate ( me = me % varDict ) ! If source is defined then reopen source table to load order of ! approximatation to use for defined source variable if ( me % varDict % nVals > 0 ) then ! allocate source method allocate ( me % method ( me % varDict % nVals )) call aot_table_open ( L = conf , & & parent = parent , & & thandle = srchandle , & & key = key ) do iSrc = 1 , me % varDict % nVals varname_order = trim ( me % varDict % val ( iSrc )% key ) // '_order' call aot_get_val ( L = conf , & & thandle = srchandle , & & key = varname_order , & & val = me % method ( iSrc )% order , & & default = 2 , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving source' & & // 'order' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () endif end if write ( logUnit ( 1 ), '(A,I0)' ) ' Order of approximation for ' & & // trim ( me % varDict % val ( iSrc )% key ) // ': ' , & & me % method ( iSrc )% order ! Load additional information for absorblayer select case ( trim ( me % varDict % val ( iSrc )% key )) case ( 'turb_channel_force_accel' ) call load_turbChanForce ( me = me % method ( iSrc )% turbChanForce , & & conf = conf , & & key = 'turb_channel_force_dynamic' , & & parent = srchandle ) case ( 'absorb_layer' ) call mus_load_absorbLayer ( me = me % method ( iSrc )% absLayer & & % config , & & conf = conf , & & key = 'absorb_layer_target' , & & parent = srchandle , & & loadPres = . true ., & & loadVel = . true . ) case ( 'absorb_layer_inlet' ) call mus_load_absorbLayer ( me = me % method ( iSrc )% absLayer & & % config , & & conf = conf , & & key = 'absorb_layer_inlet_target' , & & parent = srchandle , & & loadPres = . false ., & & loadVel = . true . ) case ( 'absorb_layer_outlet' ) call mus_load_absorbLayer ( me = me % method ( iSrc )% absLayer & & % config , & & conf = conf , & & key = 'absorb_layer_outlet_target' , & & parent = srchandle , & & loadPres = . true ., & & loadVel = . false . ) end select end do else allocate ( me % method ( 0 )) end if end subroutine mus_load_source_var ! ***************************************************************************! ! ************************************************************************** ! !> Load shape, bulk velocity and height for turbulent channel force subroutine load_turbChanForce ( me , conf , key , parent ) ! -------------------------------------------------------------------------! !> Turbulent channel force type ( mus_turbChannelForce_type ), intent ( out ) :: me !> flu state type ( flu_State ) :: conf !> Table name to load target states character ( len =* ), intent ( in ) :: key !> parent source handle integer , intent ( in ) :: parent ! -------------------------------------------------------------------------! integer :: turbForce_handle , iError character ( len = 1 ) :: flow_direction ! -------------------------------------------------------------------------! ! -------------------------------------------------------------------------! call aot_table_open ( L = conf , & & parent = parent , & & thandle = turbForce_handle , & & key = trim ( key ) ) ! Load Shape, bulk velocity and height for turbulent channel force write ( logUnit ( 1 ), * ) ' * Turbulent channel force:' call aot_get_val ( L = conf , & & thandle = turbForce_handle , & & key = 'ref_velocity_bulk' , & & val = me % refVelBulk , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading ref_velocity_bulk!' call tem_abort () end if write ( logUnit ( 1 ), * ) '    ref_velocity_bulk =' , me % refVelBulk call aot_get_val ( L = conf , & & thandle = turbForce_handle , & & key = 'ref_height' , & & val = me % refHeight , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading ref_height!' call tem_abort () end if call aot_get_val ( L = conf , & & thandle = turbForce_handle , & & key = 'flow_direction' , & & val = flow_direction , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading flow_direction!' call tem_abort () end if write ( logUnit ( 1 ), * ) '    flow_direction =' // flow_direction select case ( flow_direction ) case ( 'x' , 'X' ) me % flow_direction = 1 case ( 'y' , 'Y' ) me % flow_direction = 2 case ( 'z' , 'Z' ) me % flow_direction = 3 case default call tem_abort ( 'Unknown flow_direction' ) end select ! load geometry call tem_load_shape ( conf = conf , & & parent = turbForce_handle , & & key = 'shape_utau' , & & me = me % geom_utau ( 1 ) ) call tem_load_shape ( conf = conf , & & parent = turbForce_handle , & & key = 'shape_umean' , & & me = me % geom_umean ( 1 ) ) if (. not . allocated ( me % geom_utau ( 1 )% canoND )) then allocate ( me % geom_utau ( 1 )% canoND ( 0 )) end if if ( size ( me % geom_utau ( 1 )% canoND ) == 0 & & . and . size ( me % geom_utau ( 1 )% bcLabels ) == 0 ) then write ( logUnit ( 1 ), * ) 'Error: Requires single shape for turb_channel_force' call tem_abort () end if if (. not . allocated ( me % geom_umean ( 1 )% canoND )) & & allocate ( me % geom_umean ( 1 )% canoND ( 0 )) if ( size ( me % geom_umean ( 1 )% canoND ) == 0 & & . and . trim ( me % geom_umean ( 1 )% kind ) /= 'all' ) then write ( logUnit ( 1 ), * ) 'Error: Requires single shape for turb_channel_force' call tem_abort () end if end subroutine load_turbChanForce ! ************************************************************************** ! ! ************************************************************************** ! !> This routine act as a destructor for source type. !! The arrays allocated in mus_init_sourceTerms are destroyed here subroutine mus_source_cleanup ( me ) ! -------------------------------------------------------------------------- type ( mus_source_type ), intent ( inout ) :: me ! -------------------------------------------------------------------------- integer :: iSrc ! -------------------------------------------------------------------------- ! KM: DO NOT DESTROY VARDICT IN SOURCE_TYPE AS IT CONTAINS CONFIG INFO do iSrc = 1 , me % varDict % nVals deallocate ( me % method ( iSrc )% elemLvl ) end do end subroutine mus_source_cleanup ! ************************************************************************** ! ! ************************************************************************** ! !> Dummy routine for apply source subroutine mus_applySrc_dummy ( fun , inState , outState , neigh , auxField , & & nPdfSize , iLevel , varSys , time , phyConvFac , derVarPos ) ! -------------------------------------------------------------------------- !> Description of method to update source class ( mus_source_op_type ), intent ( in ) :: fun !> input  pdf vector !! \\todo KM: instate is passed to compute auxField. !! Since auxField is precomputed from instate and passed to this routine. !! instate can be removed real ( kind = rk ), intent ( in ) :: inState (:) !> output pdf vector real ( kind = rk ), intent ( inout ) :: outState (:) !> connectivity Array corresponding to state vector integer , intent ( in ) :: neigh (:) !> auxField array real ( kind = rk ), intent ( in ) :: auxField (:) !> number of elements in state Array integer , intent ( in ) :: nPdfSize !> current level integer , intent ( in ) :: iLevel !> variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> Point in time at which to evaluate the variable. type ( tem_time_type ), intent ( in ) :: time !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- ! abort only if source is active and function pointer is not assinged write ( logUnit ( 6 ), * ) 'WARNING: Dummy routine for applySrc' end subroutine mus_applySrc_dummy ! ************************************************************************** ! ! ************************************************************************** ! !> Dummy routine for add source to auxField subroutine mus_addSrcToAuxField_dummy ( fun , auxField , iLevel , time , varSys , & & phyConvFac , derVarPos ) ! ------------------------------------------------------------------------ ! !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> output auxField array real ( kind = rk ), intent ( inout ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> current timing information type ( tem_time_type ), intent ( in ) :: time !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor for current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! ------------------------------------------------------------------------ ! ! abort only if source is active and function pointer is not assinged write ( logUnit ( 6 ), * ) 'WARNING: Dummy routine for addSrcToAuxField' end subroutine mus_addSrcToAuxField_dummy ! ************************************************************************** ! ! ************************************************************************** ! !> Dummy routine for update source variable subroutine mus_updateSrcVar_dummy ( fun , auxField , iLevel , varSys , phyConvFac , & & derVarPos ) ! ------------------------------------------------------------------------ ! !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> input auxField array on current level real ( kind = rk ), intent ( in ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor on current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- write ( logUnit ( 6 ), * ) 'WARNING: Dummy routine for updateSourceVar' end subroutine mus_updateSrcVar_dummy ! ************************************************************************** ! end module mus_source_type_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_source_type_module.f90.html"},{"title":"mus_directions_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_directions_module.f90~~AfferentGraph sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module contains parameters to address the stencil directions. These !! parameters are valid for all stencils, however, the direction `q00` and !! `q000` needs to be set on each use according to `QQ`. module mus_directions_module implicit none private integer , parameter , public :: qN00 = 1 !< west    x- integer , parameter , public :: q0N0 = 2 !< south   y- integer , parameter , public :: q00N = 3 !< bottom  z- integer , parameter , public :: q100 = 4 !< east    x+ integer , parameter , public :: q010 = 5 !< north   y+ integer , parameter , public :: q001 = 6 !< top     z+ integer , parameter , public :: q0NN = 7 !<         z-,y- integer , parameter , public :: q0N1 = 8 !<         z+,y- integer , parameter , public :: q01N = 9 !<         z-,y+ integer , parameter , public :: q011 = 10 !<         z+,y+ integer , parameter , public :: qN0N = 11 !<         x-,z- integer , parameter , public :: q10N = 12 !<         x+,z- integer , parameter , public :: qN01 = 13 !<         x-,z+ integer , parameter , public :: q101 = 14 !<         x+,z+ integer , parameter , public :: qNN0 = 15 !<         y-,x- integer , parameter , public :: qN10 = 16 !<         y+,x- integer , parameter , public :: q1N0 = 17 !<         y-,x+ integer , parameter , public :: q110 = 18 !<         y+,x+ integer , parameter , public :: qNNN = 19 !<         x-,y-,z- integer , parameter , public :: qNN1 = 20 !<         x-,y-,z+ integer , parameter , public :: qN1N = 21 !<         x-,y+,z- integer , parameter , public :: qN11 = 22 !<         x-,y+,z+ integer , parameter , public :: q1NN = 23 !<         x+,y-,z- integer , parameter , public :: q1N1 = 24 !<         x+,y-,z+ integer , parameter , public :: q11N = 25 !<         x+,y+,z- integer , parameter , public :: q111 = 26 !<         x+,y+,z+ integer , parameter , public :: qN0 = 1 !< west   x- integer , parameter , public :: q0N = 2 !< south  y- integer , parameter , public :: q10 = 3 !< east   x+ integer , parameter , public :: q01 = 4 !< north  y+ integer , parameter , public :: qNN = 5 !<        y-,x- integer , parameter , public :: qN1 = 6 !<        y+,x- integer , parameter , public :: q1N = 7 !<        y-,x+ integer , parameter , public :: q11 = 8 !<        y+,x+ integer , parameter , public :: q__W = 1 !< west   x- integer , parameter , public :: q__S = 2 !< south  y- integer , parameter , public :: q__E = 3 !< east   x+ integer , parameter , public :: q__N = 4 !< north  y+ integer , parameter , public :: q_SW = 5 !<        y-,x- integer , parameter , public :: q_NW = 6 !<        y+,x- integer , parameter , public :: q_SE = 7 !<        y-,x+ integer , parameter , public :: q_NE = 8 !<        y+,x+ ! QQ, q00 and q000 cannot be exported, as they are different for different ! stencils. They need to be defined in using modules. end module","tags":"","loc":"sourcefile/mus_directions_module.f90.html"},{"title":"mus_initNernstPlanck_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initnernstplanck_module.f90~~EfferentGraph sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for lbm incompressible model. module mus_initNernstPlanck_module ! include treelm modules use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_compute_nernstPlanck_module , only : mus_nernstPlanck_advRel_generic use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_nernstPlanck contains ! ************************************************************************** ! !> Initialize the relaxation model for lbm poisson equation subroutine mus_init_advRel_nernstPlanck ( relaxation , layout , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing relaxation model for nernst_planck: ' & & // trim ( relaxation ) select case ( trim ( relaxation )) case ( 'bgk' ) select case ( trim ( layout ) ) case default compute => mus_nernstPlanck_advRel_generic end select case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select end subroutine mus_init_advRel_nernstPlanck ! ************************************************************************** ! end module mus_initNernstPlanck_module","tags":"","loc":"sourcefile/mus_initnernstplanck_module.f90.html"},{"title":"mus_auxField_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_auxfield_module.f90~~EfferentGraph sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_auxfield_module.f90~~AfferentGraph sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019-2020, 2022 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! This module contains routine to retrieve auxiliary field variables for !! getElement, getPoint, setupIndices and getValOfIndex. !! Auxilary field variables are: !!    * density and velocity for fluid !!    * species desity and velocity for multispecies !!    * potential for poisson !! module mus_auxField_module use env_module , only : rk use tem_param_module , only : rho0 , rho0Inv use tem_varSys_module , only : tem_varSys_type , tem_varSys_op_type use treelmesh_module , only : treelmesh_type use tem_stencil_module , only : tem_stencilHeader_type use tem_comm_module , only : tem_commpattern_type , tem_communication_type , & & tem_comm_init use tem_construction_module , only : tem_levelDesc_type use tem_general_module , only : tem_general_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_interpolate_header_module , only : mus_interpolation_type use mus_pdf_module , only : pdf_data_type use mus_source_type_module , only : mus_source_type use mus_field_module , only : mus_field_type use mus_physics_module , only : mus_convertFac_type use mus_scheme_derived_quantities_module , only : mus_scheme_derived_quantities_type implicit none private public :: mus_init_auxFieldArrays public :: mus_auxFieldVar_type public :: mus_proc_calcAuxField public :: mus_initAuxFieldFluidAndExchange public :: mus_calcAuxFieldAndExchange public :: mus_intpAuxFieldCoarserAndExchange public :: mus_intpAuxFieldFinerAndExchange !> Contains auxiliary field variable values per level and communication !! buffers type mus_auxFieldVar_type !> auxiliary field variable values computed from pre-collision PDF !! after PDF exchange !! Size: nSize*nScalars !! Element order is same as state array !! Access: (iElem-1)*nScalars + varSys%method%val(iVar)%auxField_varPos !! See mus_append_auxField for the name of the variable stored in this !! array as it depends on the scheme kind. real ( kind = rk ), allocatable :: val (:) !> Local Fluids required by remote processes type ( tem_communication_type ) :: sendBuffer !> Local ghostFromCoarser required by remote processes type ( tem_communication_type ) :: sendBufferFromCoarser !> Local ghostFromFiner required by remote processes type ( tem_communication_type ) :: sendBufferFromFiner !> My halos which are fluids on remote processes type ( tem_communication_type ) :: recvBuffer !> My halos which are ghostFromCoarser on remote processes type ( tem_communication_type ) :: recvBufferFromCoarser !> My halos which are ghostFromFiner on remote processes type ( tem_communication_type ) :: recvBufferFromFiner end type mus_auxFieldVar_type abstract interface !> Interface to compute auxField vars i.e. conserved macroscopic moments !! from pre-collision PDF for fluid and ghostFromCoarser. !! auxField on GhostFromFiner elements are interpolated and !! halo elements are exchanged !! For Multicomponent models: in calcAuxField function, the velocity !! is computed on transformed PDF such that force term can be added to it !! in addSrcToAuxField routine. The auxField is updated with correct !! velocity field in compute kernel !! i.e. velocity of original PDF is obtained by solving !! linear equation system  in compute kernel subroutine mus_proc_calcAuxField ( auxField , state , neigh , nSize , nSolve , & & iLevel , stencil , varSys , derVarPos , quantities ) import :: rk , tem_varSys_type , tem_stencilHeader_type , mus_derVarPos_type , & & mus_scheme_derived_quantities_type !> output auxField array real ( kind = rk ), intent ( inout ) :: auxField (:) !> input state array real ( kind = rk ), intent ( in ) :: state (:) !> connectivity array integer , intent ( in ) :: neigh (:) !> number of elements in the state array integer , intent ( in ) :: nSize !> number of fluid elements + ghostFromCoarser integer , intent ( in ) :: nSolve !> current level integer , intent ( in ) :: iLevel !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) !> Class that contains pointers to the proper derived quantities functions type ( mus_scheme_derived_quantities_type ), intent ( in ) :: quantities end subroutine mus_proc_calcAuxField end interface contains ! ************************************************************************* ! !> This routine initialize auxField var val array and communication buffers subroutine mus_init_auxFieldArrays ( me , levelDesc , pattern , nSize , nAuxScalars ) ! --------------------------------------------------------------------- ! !> Auxiliary field variable type ( mus_auxFieldVar_type ), intent ( out ) :: me !> levelDesc to access communication buffers of state array type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> communication pattern type ( tem_commPattern_type ), intent ( in ) :: pattern !> Number of elements in state array integer , intent ( in ) :: nSize !> Number of scalars in auxiliary variables integer , intent ( in ) :: nAuxScalars ! --------------------------------------------------------------------- ! ! --------------------------------------------------------------------- ! allocate ( me % val ( nSize * nAuxScalars )) me % val (:) = - 100000 0.0_rk ! initialize send buffer call init_commBuffer ( buffer_aux = me % sendBuffer , & & buffer_State = levelDesc % sendBuffer ) ! initialize recv buffer call init_commBuffer ( buffer_aux = me % recvBuffer , & & buffer_State = levelDesc % recvBuffer ) ! initialize send buffer call init_commBuffer ( buffer_aux = me % sendBufferFromCoarser , & & buffer_State = levelDesc % sendBufferFromCoarser ) ! initialize recv buffer call init_commBuffer ( buffer_aux = me % recvBufferFromCoarser , & & buffer_State = levelDesc % recvBufferFromCoarser ) ! initialize send buffer call init_commBuffer ( buffer_aux = me % sendBufferFromFiner , & & buffer_State = levelDesc % sendBufferFromFiner ) ! initialize recv buffer call init_commBuffer ( buffer_aux = me % recvBufferFromFiner , & & buffer_State = levelDesc % recvBufferFromFiner ) contains ! ************************************************************************ ! subroutine init_commBuffer ( buffer_aux , buffer_state ) !------------------------------------------------------------------------- !> communication buffer for velocity field type ( tem_communication_type ), intent ( out ) :: buffer_aux !> communication buffer of state array which is already initialized !! in tem_construction_module type ( tem_communication_type ), intent ( in ) :: buffer_state !------------------------------------------------------------------------- ! positions, in velocity vectors integer , allocatable :: pos (:) integer :: iProc , iElem , iScal , counter , elemPos !------------------------------------------------------------------------- ! copy information about target and source procs from pdf sendBuffer to ! velocity sendBuffer call tem_comm_init ( buffer_aux , buffer_state % nProcs ) buffer_aux % proc = buffer_state % proc buffer_aux % nElemsProc = buffer_state % nElemsProc allocate ( pos ( maxval ( buffer_aux % nElemsProc * nAuxScalars ))) do iProc = 1 , buffer_aux % nProcs counter = 0 do iElem = 1 , buffer_aux % nElemsProc ( iProc ) ! halo element position in the levelDesc total list elemPos = buffer_state % elemPos ( iProc )% val ( iElem ) do iScal = 1 , nAuxScalars counter = counter + 1 pos ( counter ) = ( elemPos - 1 ) * nAuxScalars + iScal end do end do ! copy position array to me%pos, allocate me%val array call pattern % initBuf_real ( buffer_aux % buf_real ( iProc ), pos , counter ) end do deallocate ( pos ) end subroutine init_commBuffer ! ************************************************************************ ! end subroutine mus_init_auxFieldArrays ! ************************************************************************* ! ! ************************************************************************** ! !> This routine initializes auxField for fluid elements using SAVE access on !! PDF initialized by IC subroutine mus_initAuxFieldFluidAndExchange ( auxField , state , neigh , nElems , & & nSize , nFields , stencil , varSys , & & derVarPos , iLevel , general , quantities ) !--------------------------------------------------------------------------- !> auxilary field array type ( mus_auxFieldVar_type ), intent ( inout ) :: auxField !> state array real ( kind = rk ), intent ( in ) :: state (:) !> connectivity vector integer , intent ( in ) :: neigh (:) !> number of elements to compute auxField integer , intent ( in ) :: nElems !> number of elements in state array integer , intent ( in ) :: nSize !> number of fields integer , intent ( in ) :: nFields !> current level integer , intent ( in ) :: iLevel !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> contains auxField position of all fields in varSys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) !> contains commPattern, MPI communicator and simControl type ( tem_general_type ), intent ( in ) :: general !> Class that contains pointers to the proper derived quantities functions type ( mus_scheme_derived_quantities_type ), intent ( in ) :: quantities !--------------------------------------------------------------------------- integer :: iField !--------------------------------------------------------------------------- ! calculate auxField from local state do iField = 1 , nFields call derVarPos ( iField )% auxFieldFromState ( state = state , & & neigh = neigh , & & iField = iField , & & nElems = nElems , & & nSize = nSize , & & iLevel = iLevel , & & stencil = stencil , & & varSys = varSys , & & auxField = auxField % val , & & quantities = quantities ) end do ! communicate velocity field. Requires for tubulence to compute ShearRate ! from velocity gradient. ! exchange velocity halo on current level call general % commpattern % exchange_real ( & & send = auxField % sendBuffer , & & recv = auxField % recvBuffer , & & state = auxField % val (:), & & message_flag = iLevel + 100 , & & comm = general % proc % comm ) end subroutine mus_initAuxFieldFluidAndExchange ! ************************************************************************** ! ! ************************************************************************* ! !> This routine compute auxField variable from pre-collision pdf and exchange !! halos subroutine mus_calcAuxFieldAndExchange ( auxField , calcAuxField , state , & & pdfData , nFields , field , globSrc , stencil , varSys , derVarPos , & & phyConvFac , general , iLevel , minLevel , schemeHeader , quantities ) ! -------------------------------------------------------------------- ! !> auxilary field array type ( mus_auxFieldVar_type ), intent ( inout ) :: auxField !> function pointer to calculate auxField procedure ( mus_proc_calcAuxField ), pointer , intent ( in ) :: calcAuxField !> state array real ( kind = rk ), intent ( in ) :: state (:) !> contains neigh array and nElems on current level type ( pdf_data_type ), intent ( in ) :: pdfData !> Number of fields integer , intent ( in ) :: nFields !> contains sources of all fields type ( mus_field_type ), intent ( inout ) :: field ( nFields ) !> global source type ( mus_source_type ), intent ( inout ) :: globSrc !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> contains auxField position of all fields in varSys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) !> physics conversion factors for this level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> contains commPattern, MPI communicator and simControl type ( tem_general_type ), intent ( in ) :: general !> current level integer , intent ( in ) :: iLevel !> minlevel integer , intent ( in ) :: minLevel !> scheme header type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> Class that contains pointers to the proper derived quantities functions type ( mus_scheme_derived_quantities_type ), intent ( in ) :: quantities ! -------------------------------------------------------------------- ! integer :: nSolve , iField , iSrc ! -------------------------------------------------------------------- ! ! calculate auxField only for fluids and ghostfromcoarser (buffer ghost). ! ghostFromFiner are interpolated nSolve = pdfData % nElems_fluid + pdfData % nElems_ghostFromCoarser ! calculate velocity for fluid and ghost elements call calcAuxField ( auxField = auxField % val (:), & & state = state , & & neigh = pdfData % neigh , & & nSize = pdfData % nSize , & & nSolve = nSolve , & & iLevel = iLevel , & & stencil = stencil , & & varSys = varSys , & & derVarPos = derVarPos , & & quantities = quantities ) ! update auxField with source term ! Field add field source and then add globSrc do iField = 1 , nFields do iSrc = 1 , field ( iField )% source % varDict % nVals call field ( iField )% source % method ( iSrc )% addSrcToAuxField ( & & auxField = auxField % val (:), & & iLevel = iLevel , & & time = general % simControl % now , & & varSys = varSys , & & phyConvFac = phyConvFac , & & derVarPos = derVarPos ) end do ! Add internal source to auxField. Internal source is added to state ! in compute routine do iSrc = 1 , field ( iField )% internalSource % varDict % nVals call field ( iField )% internalSource % method ( iSrc )% addSrcToAuxField ( & & auxField = auxField % val (:), & & iLevel = iLevel , & & time = general % simControl % now , & & varSys = varSys , & & phyConvFac = phyConvFac , & & derVarPos = derVarPos ) end do end do ! apply global source do iSrc = 1 , globSrc % varDict % nVals call globSrc % method ( iSrc )% addSrcToAuxField ( & & auxField = auxField % val (:), & & iLevel = iLevel , & & time = general % simControl % now , & & varSys = varSys , & & phyConvFac = phyConvFac , & & derVarPos = derVarPos ) end do ! communicate velocity field. Requires for tubulence to compute ShearRate ! from velocity gradient. ! exchange velocity halo on current level call general % commpattern % exchange_real ( & & send = auxField % sendBuffer , & & recv = auxField % recvBuffer , & & state = auxField % val (:), & & message_flag = iLevel + 100 , & & comm = general % proc % comm ) ! communicate ghost halos from coarser if ( iLevel > minLevel ) then call general % commpattern % exchange_real ( & & send = auxField % sendBufferFromCoarser , & & recv = auxField % recvBufferFromCoarser , & & state = auxField % val (:), & & message_flag = iLevel + 200 , & & comm = general % proc % comm ) end if end subroutine mus_calcAuxFieldAndExchange ! ************************************************************************* ! ! ************************************************************************* ! !> This routine interpolate auxField variable for ghostFromFiner and exchange !! halos subroutine mus_intpAuxFieldCoarserAndExchange ( intp , tAuxField , sAuxField , & & tLevelDesc , stencil , iLevel , & & nAuxScalars , general ) ! -------------------------------------------------------------------- ! !> Interpolation type type ( mus_interpolation_type ), intent ( inout ) :: intp !> target auxilary field array type ( mus_auxFieldVar_type ), intent ( inout ) :: tAuxField !> source auxilary field array type ( mus_auxFieldVar_type ), intent ( in ) :: sAuxField !> level descriptor on target level type ( tem_levelDesc_type ), intent ( in ) :: tLevelDesc !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> current level integer , intent ( in ) :: iLevel !> number of scalars to interpolate integer , intent ( in ) :: nAuxScalars !> contains commPattern, MPI communicator and simControl type ( tem_general_type ), intent ( in ) :: general ! -------------------------------------------------------------------- ! call intp % fillMineFromFiner % do_intpArbiVal ( & & tLevelDesc = tLevelDesc , & & level = iLevel , & & stencil = stencil , & & sVal = sAuxField % val (:), & & tVal = tAuxField % val (:), & & nTargets = tLevelDesc % intpFromFiner % nVals , & & targetList = tLevelDesc % intpFromFiner % val , & & nScalars = nAuxScalars ) ! exchange velocity halo fromFiner, required to compute velocity ! gradient call general % commPattern % exchange_real ( & & send = tAuxField % sendBufferFromFiner , & & recv = tAuxField % recvBufferFromFiner , & & state = tAuxField % val (:), & & message_flag = iLevel + 300 , & & comm = general % proc % comm ) end subroutine mus_intpAuxFieldCoarserAndExchange ! ************************************************************************* ! ! ************************************************************************* ! !> This routine interpolate auxField variable for ghostFromCoarser and exchange !! halos subroutine mus_intpAuxFieldFinerAndExchange ( intp , tAuxField , sAuxField , & & tLevelDesc , stencil , iLevel , & & nAuxScalars , general ) ! -------------------------------------------------------------------- ! !> Interpolation type type ( mus_interpolation_type ), intent ( inout ) :: intp !> target auxilary field array type ( mus_auxFieldVar_type ), intent ( inout ) :: tAuxField !> source auxilary field array type ( mus_auxFieldVar_type ), intent ( in ) :: sAuxField !> level descriptor on target level type ( tem_levelDesc_type ), intent ( in ) :: tLevelDesc !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> current level integer , intent ( in ) :: iLevel !> number of scalars to interpolate integer , intent ( in ) :: nAuxScalars !> contains commPattern, MPI communicator and simControl type ( tem_general_type ), intent ( in ) :: general ! -------------------------------------------------------------------- ! integer :: iOrder ! -------------------------------------------------------------------- ! do iOrder = 0 , intp % config % order call intp % fillFinerFromMe ( iOrder )% do_intpArbiVal ( & & tLevelDesc = tLevelDesc , & & level = iLevel , & & stencil = stencil , & & sVal = sAuxField % val (:), & & tVal = tAuxField % val (:), & & nTargets = tLevelDesc % intpFromCoarser ( iOrder )% nVals , & & targetList = tLevelDesc % intpFromCoarser ( iOrder )% val , & & nScalars = nAuxScalars ) end do ! exchange velocity halo fromFiner, required to compute velocity ! gradient call general % commPattern % exchange_real ( & & send = tAuxField % sendBufferFromCoarser , & & recv = tAuxField % recvBufferFromCoarser , & & state = tAuxField % val (:), & & message_flag = iLevel + 200 , & & comm = general % proc % comm ) end subroutine mus_intpAuxFieldFinerAndExchange ! ************************************************************************* ! end module mus_auxField_module","tags":"","loc":"sourcefile/mus_auxfield_module.f90.html"},{"title":"mus_derVarPos_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_dervarpos_module.f90~~EfferentGraph sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_dervarpos_module.f90~~AfferentGraph sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_dervarpos_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2014-2016, 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Kannan Masilamani !! This module contains the type defintion which stores position of all !! derive variables in global varSys. !! module mus_derVarPos_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_varSys_module , only : tem_varSys_type use tem_stencil_module , only : tem_stencilHeader_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_scheme_derived_quantities_module , only : mus_scheme_derived_quantities_type implicit none private public :: mus_derVarPos_type public :: mus_derive_FromMacro_dummy public :: mus_derive_FromState_dummy public :: mus_derive_FromPreColState_dummy !> This type stores the position of each variable in the global sys type mus_derVarPos_type integer :: pdf = - 1 integer :: fetch_pdf = - 1 integer :: omega = - 1 integer :: density = - 1 integer :: moleDensity = - 1 integer :: pressure = - 1 integer :: kinePress = - 1 integer :: velocity = - 1 !integer :: grad_velocity     = -1 ! all species velocities integer :: spc_velocities = - 1 integer :: velMag = - 1 integer :: momentum = - 1 ! all species momentums integer :: spc_momenta = - 1 integer :: shearStress = - 1 integer :: wss = - 1 integer :: shearMag = - 1 integer :: strainRate = - 1 integer :: shearRate = - 1 integer :: kineticEnergy = - 1 integer :: temperature = - 1 integer :: moleFrac = - 1 integer :: massFrac = - 1 integer :: moleflux = - 1 integer :: equilibrium = - 1 integer :: nonEquilibrium = - 1 integer :: equilibriumVel = - 1 integer :: potential = - 1 procedure ( derive_FromMacro ), pointer , nopass :: equilFromMacro => null () ! return velocity of single species procedure ( derive_FromState ), pointer , nopass :: velFromState => null () procedure ( derive_FromState ), pointer , nopass :: equilFromState => null () ! return momentum of single species procedure ( derive_FromState ), pointer , nopass :: momFromState => null () ! return velocity of all species procedure ( derive_FromState ), pointer , nopass :: velocitiesFromState => null () ! return momentum of all species procedure ( derive_FromState ), pointer , nopass :: momentaFromState => null () ! return velocity of single species from precollision state procedure ( derive_FromPreColState ), pointer , nopass & & :: velFromPreColState => null () !> return auxField from local pdf state procedure ( derive_auxFromState ), pointer :: auxFieldFromState => null () ! KM: \\todo use this function pointer in interpolation !> return equilibrium from auxilary variable for given nElems procedure ( derive_equilFromAux ), pointer , nopass :: equilFromAux => null () !> function to compute equilFromAux for single element end type mus_derVarPos_type abstract interface !> interface to derive equilibrium from macro. !! Mainly used in initial condition and boundary condition routines !! to avoid dublication of routines between different scheme kinds. !! In this interface, solver definition can be access via !! varSys%method%val(1)%method_data c_ptr subroutine derive_FromMacro ( density , velocity , iField , nElems , varSys , & & layout , res ) import :: rk , tem_varSys_type , mus_scheme_layout_type !> Array of density. !! Single species: dens_1, dens_2 .. dens_n !! multispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ... !!                dens_n_sp1, dens_n_sp2 !! Access: (iElem-1)*nFields + iField real ( kind = rk ), intent ( in ) :: density (:) !> Array of velocity. !! Size: (3, n*nFields) !! Access: ( iComp, (iElem-1)*nFields + iField ) real ( kind = rk ), intent ( in ) :: velocity (:, :) !> Current field integer , intent ( in ) :: iField !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n*nComponents of res real ( kind = rk ), intent ( out ) :: res (:) end subroutine derive_FromMacro !> Interface that takes state array as input !! calculate density, velocity or eq as output !! State should be AOS layout subroutine derive_FromState ( state , iField , nElems , varSys , layout , res ) import :: rk , tem_varSys_type , mus_scheme_layout_type !> Array of state !! n * layout%stencil(1)%QQ * nFields real ( kind = rk ), intent ( in ) :: state (:) !> Current field integer , intent ( in ) :: iField !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n * nComponents of res !! Access: (iElem-1)*nComp + iComp !! To derive velocities of all species, dimension: n*nFields*nComp !! Access: (iElem-1)*nFields*nComp + (iField-1)*nComp + iComp real ( kind = rk ), intent ( out ) :: res (:) end subroutine derive_FromState !> Interface that takes state array as input !! calculate density, velocity or eq as output from FETCH state i.e. !! precollision state !! State should be AOS layout subroutine derive_FromPreColState ( state , neigh , iField , nSize , nElems , & & varSys , layout , res ) import :: rk , tem_varSys_type , mus_scheme_layout_type !> Array of state !! n * layout%stencil(1)%QQ * nFields real ( kind = rk ), intent ( in ) :: state (:) !> connectivity array integer , intent ( in ) :: neigh (:) !> Current field integer , intent ( in ) :: iField !> number of elements in state array integer , intent ( in ) :: nSize !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n * nComponents of res !! Access: (iElem-1)*nComp + iComp !! To derive velocities of all species, dimension: n*nFields*nComp !! Access: (iElem-1)*nFields*nComp + (iField-1)*nComp + iComp real ( kind = rk ), intent ( out ) :: res (:) end subroutine derive_FromPreColState !> Derive equilibrium from auxField for given nelems subroutine derive_equilFromAux ( derVarPos , auxField , iField , nElems , & & varSys , layout , res ) import :: rk , tem_varSys_type , mus_scheme_layout_type , mus_derVarPos_type !> Position of current field derive variable in variable system class ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> Array of auxField. !! Single species: dens_1, vel_1, dens_2, vel_2, .. dens_n, vel_n !! multispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2, !!                dens_2_sp1, vel_2_spc2, dens_2_sp2, vel_2_spc2 ... !!                dens_n_sp1, vel_n_sp1, dens_n_sp2, vel_n_spc2 !! Access: (iElem-1)*nFields + iField real ( kind = rk ), intent ( in ) :: auxField (:) !> Current field integer , intent ( in ) :: iField !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n*QQ of res real ( kind = rk ), intent ( out ) :: res (:) end subroutine derive_equilFromAux !> Derive auxField from local state. !! \\todo KM: pass external force to add to auxField subroutine derive_auxFromState ( derVarPos , state , neigh , iField , nElems , & & nSize , iLevel , stencil , varSys , auxField , quantities ) import :: rk , tem_varSys_type , mus_derVarPos_type , tem_stencilHeader_type , & & mus_scheme_derived_quantities_type !> Position of current field derive variable in variable system class ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> Array of state !! nSize * layout%stencil(1)%QQ * nFields !! use IDX macro to access this state real ( kind = rk ), intent ( in ) :: state (:) !> connectivity vector integer , intent ( in ) :: neigh (:) !> Current field integer , intent ( in ) :: iField !> number of elements to compute integer , intent ( in ) :: nElems !> number of elements in state array integer , intent ( in ) :: nSize !> current level integer , intent ( in ) :: iLevel !> stencil header contains discrete velocity vectors type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> Class that contains pointers to the proper derived quantities functions type ( mus_scheme_derived_quantities_type ), intent ( in ) :: quantities !> Output of this routine !! auxField is inout to allow storing auxField for each species !! seperately !! Size: nElems*nAuxScalars real ( kind = rk ), intent ( inout ) :: auxField (:) end subroutine derive_auxFromState !> Derive equilibrium from auxField for single element pure function derive_equilFromAuxFunc ( derVarPos , auxField , iField , & & varSys , layout ) result ( res ) import :: rk , tem_varSys_type , mus_scheme_layout_type , mus_derVarPos_type !> Position of current field derive variable in variable system class ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> Array of auxField of single element. !! Single species: dens_1, vel_1 !! multispecies: dens_1_sp1, vel_1_spc1, dens_1_sp2, vel_1_spc2, !! Access: (iElem-1)*nFields + iField real ( kind = rk ), intent ( in ) :: auxField (:) !> Current field integer , intent ( in ) :: iField !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: QQ of res real ( kind = rk ) :: res ( layout % fStencil % QQ ) end function derive_equilFromAuxFunc !> Derive auxField from state for single element pure function derive_auxFromStateFunc ( derVarPos , state , iField , stencil , & & varSys ) result ( res ) import :: rk , tem_varSys_type , mus_derVarPos_type , tem_stencilHeader_type !> Position of derive variable in variable system class ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> Array of state !! layout%stencil(1)%QQ * nFields real ( kind = rk ), intent ( in ) :: state (:) !> Current field integer , intent ( in ) :: iField !> stencil header contains discrete velocity vectors type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> Output of this routine !! Size: nAuxScalars real ( kind = rk ) :: res ( varSys % nAuxScalars ) end function derive_auxFromStateFunc end interface contains ! ************************************************************************** ! subroutine mus_derive_FromMacro_dummy ( density , velocity , iField , nElems , & & varSys , layout , res ) !> Array of density. !! Single species: dens_1, dens_2 .. dens_n !! multispecies: dens_1_sp1, dens_1_sp2, dens_2_sp1, dens_2_sp2 ... !!                dens_n_sp1, dens_n_sp2 !! Access: (iElem-1)*nFields + iField real ( kind = rk ), intent ( in ) :: density (:) !> Array of velocity. !! Size: (3, n*nFields) !! Access: ( iComp, (iElem-1)*nFields + iField ) real ( kind = rk ), intent ( in ) :: velocity (:, :) !> Current field integer , intent ( in ) :: iField !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n*nComponents of res real ( kind = rk ), intent ( out ) :: res (:) call tem_abort ( 'Dummy routine for derive_FromMacro' ) end subroutine mus_derive_FromMacro_dummy ! ************************************************************************** ! ! ************************************************************************** ! ! Interface that takes state array as input ! calculate density, velocity or eq as output ! State should be AOS layout subroutine mus_derive_FromState_dummy ( state , iField , nElems , varSys , layout , & & res ) !> Array of state !! n * layout%stencil(1)%QQ * nFields real ( kind = rk ), intent ( in ) :: state (:) !> Current field integer , intent ( in ) :: iField !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n * nComponents of res !! Access: (iElem-1)*nComp + iComp !! To derive velocities of all species, dimension: n*nFields*nComp !! Access: (iElem-1)*nFields*nComp + (iField-1)*nComp + iComp real ( kind = rk ), intent ( out ) :: res (:) call tem_abort ( 'Dummy routine for derive_FromState' ) end subroutine mus_derive_FromState_dummy ! ************************************************************************** ! ! ************************************************************************** ! ! Interface that takes state array as input ! calculate density, velocity or eq as output from FETCH state i.e. ! precollision state ! State should be AOS layout subroutine mus_derive_FromPreColState_dummy ( state , neigh , iField , nSize , & & nElems , varSys , layout , res ) !> Array of state !! n * layout%stencil(1)%QQ * nFields real ( kind = rk ), intent ( in ) :: state (:) !> connectivity array integer , intent ( in ) :: neigh (:) !> Current field integer , intent ( in ) :: iField !> number of elements in state array integer , intent ( in ) :: nSize !> number of elements integer , intent ( in ) :: nElems !> variable system which is required to access fieldProp !! information via variable method data c_ptr type ( tem_varSys_type ), intent ( in ) :: varSys !> scheme layout contains stencil definition and lattice weights type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Output of this routine !! Dimension: n * nComponents of res !! Access: (iElem-1)*nComp + iComp !! To derive velocities of all species, dimension: n*nFields*nComp !! Access: (iElem-1)*nFields*nComp + (iField-1)*nComp + iComp real ( kind = rk ), intent ( out ) :: res (:) call tem_abort ( 'Dummy routine for derive_FromPreColState' ) end subroutine mus_derive_FromPreColState_dummy ! ************************************************************************** ! end module mus_derVarPos_module","tags":"","loc":"sourcefile/mus_dervarpos_module.f90.html"},{"title":"mus_poisson_module.f90 – Musubi","text":"In this module the poission equation is considered.\nThe file type contains all relevant information.\nIt is a one dimensional case. This file depends on sourcefile~~mus_poisson_module.f90~~EfferentGraph sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_poisson_module.f90~~AfferentGraph sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2017-2018 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2018 Jana Gericke <jana.gericke@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **********************************************************************! !! In this module the poission equation is considered. !! The file type contains all relevant information. !! It is a one dimensional case. !> author: sindhuja module mus_poisson_module use env_module , only : rk use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit , tem_toStr use aotus_module , only : flu_State , aot_get_val , aoterr_Fatal , & & aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , aot_table_length use aot_out_module , only : aot_out_type , aot_out_val , aot_out_open_table , & & aot_out_close_table use mus_physics_module , only : mus_physics_type , faraday , gasConst_R implicit none private public :: mus_poisson_type public :: mus_load_poisson public :: mus_load_poissonBoltzmann !> Contains information to calculate rhs for poisson boltzmann equation. !! Definition of linear and non-linear poisson boltzmann equation !! can be found in !! Masilamani, K. (2010). WaLBerla : Investigation of Electrostatic Effects !! in Particulate and Electro-Osmotic Flows. Master Thesis. !! FRIEDRICH-ALEXANDER-UNIVERSITÄT ERLANGEN-NÜRNBERG. type mus_poisson_boltzmann_type !> Neccesary if source term is poisson_boltzmann logical :: active !> abosulte temperature in Kelvin real ( kind = rk ) :: temp !> Number of ions integer :: nIons !> valence of the ion !! size: nions integer , allocatable :: valence (:) !> Mole density of ions in the bulk real ( kind = rk ) :: moleDens0 !> RHS coeff for linear poisson boltzmann equation real ( kind = rk ) :: RHS_coeff !> Gas constant in lattice unit real ( kind = rk ) :: gasConst_R_LB !> Faraday constant in lattice unit real ( kind = rk ) :: faradayLB !!> Boltzmann constant in lattice unit !real(kind=rk) :: k_b !!> Fundamental charge in lattice unit !real(kind=rk) :: charge end type mus_poisson_boltzmann_type !> Contains information to solve the poission equation type mus_poisson_type !> Potential diffusivty to tune omega and stability real ( kind = rk ) :: pot_diff !> relaxation parameter real ( kind = rk ) :: omega !> the dielectric constant C&#94;2 J&#94;-1 m&#94;-1 real ( kind = rk ) :: permittivity !> information of poisson boltmann equation type ( mus_poisson_boltzmann_type ) :: PB end type mus_poisson_type contains ! **************************************************************************** !> load input to solve poisson equation subroutine mus_load_poisson ( me , conf , parent , minLevel , cs_lattice , physics ,& & schemeKind ) !------------------------------------------------------------------------- !> poisson type type ( mus_poisson_type ), intent ( out ) :: me !> flu state type ( flu_state ) :: conf !> parent handle integer , intent ( in ), optional :: parent !> minlevel integer , intent ( in ) :: minLevel !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> lattice speed of sound calculated for defined stencil layout !! required to compute omega from potential diffusivity real ( kind = rk ), intent ( in ) :: cs_lattice !> scheme kind character ( len =* ), intent ( in ) :: schemeKind ! ------------------------------------------------------------------------- integer :: poisson_handle integer :: iError , iIon real ( kind = rk ) :: debye_length_inv_sqr , valence_sqr_sum , debye_length ! ------------------------------------------------------------------------- ! if poisson informations in scheme table parentHandle /= 0 if ( present ( parent ) ) then call aot_table_open ( L = conf , & & parent = parent , & & thandle = poisson_handle , & & key = 'poisson' ) else call aot_table_open ( L = conf , thandle = poisson_handle , & & key = 'poisson' ) end if if ( poisson_handle == 0 ) then write ( logUnit ( 1 ), * ) 'No poisson table defined' call tem_abort () end if write ( logUnit ( 1 ), * ) 'Loading poisson informations' ! Load potential diffusivity to control evolution speed and stability call aot_get_val ( L = conf , & & thandle = poisson_handle , & & key = 'potential_diffusivity' , & & val = me % pot_diff , & & ErrCode = iError ) me % pot_diff = me % pot_diff / physics % fac ( minLevel )% visc if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'potentail_diffusivity:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if ! Relaxation parameter omega is compted from potential diffusivity me % omega = 1.0_rk / ( me % pot_diff / cs_lattice ** 2 + 0.5_rk ) ! load permittivity call aot_get_val ( L = conf , & & thandle = poisson_handle , & & key = 'permittivity' , & & val = me % permittivity , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'permittivity:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if me % permittivity = me % permittivity / ( physics % coulomb0 ** 2 & & / ( physics % fac ( minLevel )% energy * physics % dxLvl ( minLevel )) ) select case ( trim ( schemeKind )) case ( 'poisson_boltzmann_linear' , 'poisson_boltzmann_nonlinear' ) call mus_load_poissonBoltzmann ( me = me % PB , & & conf = conf , & & parent = poisson_handle , & & physics = physics ) case default me % PB % active = . false . end select call aot_table_close ( L = conf , thandle = poisson_handle ) write ( logUnit ( 1 ), \"(A)\" ) 'Poisson properties:' write ( logUnit ( 1 ), \"(A)\" ) '  potential_diffusivty: ' & & // trim ( tem_toStr ( me % pot_diff )) write ( logUnit ( 1 ), \"(A)\" ) '  omega: ' // trim ( tem_toStr ( me % omega )) write ( logUnit ( 1 ), \"(A)\" ) '  permittivity: ' // trim ( tem_toStr ( me % permittivity )) if ( me % PB % active ) then ! Convert boltzmann constant into lattice units ! me%PB%k_b = k_b / ( physics%fac(minLevel)%energy / physics%temp0 ) ! Convert Faraday constant into lattice unit me % PB % faradayLB = faraday / physics % fac ( minLevel )% faraday ! convert gas constant into lattice unit me % PB % gasConst_R_LB = gasConst_R / physics % fac ( minLevel )% gasConst ! electric charge in lattice units ! me%PB%charge = coulomb_ref / physics%coulomb0 ! calculate debye length in lattice units valence_sqr_sum = sum ( me % PB % valence ** 2 ) !debye_length_inv_sqr = valence_sqr_sum * me%PB%moleDens0    & !  &                   * me%PB%charge**2                     & !  &                  / (me%permittivity*me%PB%k_b*me%PB%temp) debye_length_inv_sqr = valence_sqr_sum * me % PB % moleDens0 & & * me % PB % faradayLB ** 2 & & / ( me % permittivity * me % PB % gasConst_R_LB * me % PB % temp ) me % PB % RHS_coeff = debye_length_inv_sqr debye_length = 1.0_rk / sqrt ( debye_length_inv_sqr ) & & * physics % dxLvl ( minLevel ) write ( logUnit ( 1 ), \"(A)\" ) '  Paramters for poisson boltzmann Eq:' write ( logUnit ( 1 ), \"(A)\" ) '  temp: ' // trim ( tem_toStr ( me % PB % temp )) write ( logUnit ( 1 ), \"(A)\" ) '  moleDens: ' // trim ( tem_toStr ( me % PB % moleDens0 )) write ( logUnit ( 1 ), \"(A)\" ) '  faradayLB: ' // trim ( tem_toStr ( me % PB % faradayLB )) write ( logUnit ( 1 ), \"(A)\" ) '  Gas Const R: ' & & // trim ( tem_toStr ( me % PB % gasConst_R_LB )) write ( logUnit ( 1 ), \"(A)\" ) '  valence : ' do iIon = 1 , me % PB % nIons write ( logUnit ( 1 ), \"(A)\" ) '     ' // trim ( tem_toStr ( me % PB % valence ( iIon ))) end do write ( logUnit ( 1 ), \"(A)\" ) '  RHS_coeff: ' // trim ( tem_toStr ( me % PB % RHS_coeff )) write ( logUnit ( 1 ), \"(A)\" ) '  Debye length: ' // trim ( tem_toStr ( debye_length )) end if end subroutine mus_load_poisson ! ***************************************************************************! ! **************************************************************************** !> Load input to solve poisson boltzmann equation subroutine mus_load_poissonBoltzmann ( me , conf , parent , physics ) !------------------------------------------------------------------------- !> poisson bolztmann type type ( mus_poisson_boltzmann_type ), intent ( out ) :: me !> flu state type ( flu_state ) :: conf !> parent handle integer , intent ( in ), optional :: parent !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics ! ------------------------------------------------------------------------- integer :: PB_handle , valence_handle integer :: iError integer , allocatable :: vError (:), errFatal (:) ! ------------------------------------------------------------------------- ! Load information for poisson boltzmann equation call aot_table_open ( L = conf , & & parent = parent , & & thandle = PB_handle , & & key = 'poisson_boltzmann' ) if ( PB_handle /= 0 ) then me % active = . true . ! load absolute temperature call aot_get_val ( L = conf , & & thandle = PB_handle , & & key = 'temp' , & & val = me % temp , & & default = 27 3._rk , & & ErrCode = iError ) me % temp = me % temp / physics % temp0 ! load mole density at bulk call aot_get_val ( L = conf , & & thandle = PB_handle , & & key = 'moleDens0' , & & val = me % moleDens0 , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'moleDens0:' if ( btest ( iError , aoterr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if me % moleDens0 = me % moleDens0 / physics % moleDens0 ! load valence call aot_table_open ( L = conf , & & parent = PB_handle , & & thandle = valence_handle , & & key = 'valence' ) me % nIons = aot_table_length ( L = conf , thandle = valence_handle ) allocate ( errFatal ( me % nIons ) ) errFatal = aotErr_Fatal call aot_get_val ( L = conf , & & thandle = PB_handle , & & key = 'valence' , & & val = me % valence , & & maxlength = me % nIons , & & ErrCode = vError ) if ( any ( btest ( vError , errFatal )) ) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving ' // & & 'resi_coeff table' call tem_abort () endif !      call aot_get_val(L       = conf,       & !        &              thandle = PB_handle,  & !        &              key     = 'valence ', & !        &              val     = me%valence, & !        &              default = 1,          & !        &              ErrCode = iError      ) else write ( logUnit ( 3 ), * ) 'No poisson boltzmann table defined' me % active = . false . end if call aot_table_close ( L = conf , thandle = PB_handle ) end subroutine mus_load_poissonBoltzmann ! ***************************************************************************! end module mus_poisson_module","tags":"","loc":"sourcefile/mus_poisson_module.f90.html"},{"title":"mus_eNRTL_dummy.f90 – Musubi","text":"Source Code ! Copyright (c) 2013, 2015, 2017, 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> This module contains an interface for external C++ code to compute !! liquid mixture property like thermodynamic factor and !! Maxwell-Stefan Diffusivity coefficients module mus_eNRTL_module use env_module , only : rk use tem_logging_module , only : logUnit use , intrinsic :: iso_c_binding , only : c_char , c_int implicit none private public :: mus_init_eNRTL public :: mus_calc_thermFactor public :: mus_calc_MS_DiffMatrix interface mus_calc_thermFactor module procedure mus_calc_thermFactor_single end interface mus_calc_thermFactor interface mus_calc_MS_DiffMatrix module procedure mus_calc_MS_DiffMatrix_single end interface mus_calc_MS_DiffMatrix contains ! **************************************************************************** ! !> Dummy routine which sets thermodynamic factor matrix to diagonal matrix subroutine mus_calc_thermFactor_single ( nFields , temp , press , mole_frac , & & therm_factors ) ! -------------------------------------------------------------------------! !> number of fields in mixture integer , intent ( in ) :: nFields !> mixture temperature real ( kind = rk ), intent ( in ) :: temp !> mixture pressure real ( kind = rk ), intent ( in ) :: press !> mole fraction of all species of single element real ( kind = rk ), intent ( in ) :: mole_frac ( nFields ) !> thermodynamic factor matrix real ( kind = rk ), intent ( out ) :: therm_factors ( nFields , nFields ) ! -------------------------------------------------------------------------! integer :: iField ! -------------------------------------------------------------------------! therm_factors = 0.0_rk do iField = 1 , nFields therm_factors ( iField , iField ) = 1.0_rk end do end subroutine mus_calc_thermFactor_single ! **************************************************************************** ! ! **************************************************************************** ! !> Dummy routine which sets diffusivity coeff matrix to diagonal matrix subroutine mus_calc_MS_DiffMatrix_single ( nFields , temp , press , mole_dens , & & D_ij_out ) ! -------------------------------------------------------------------------! !> number of fields in mixture integer , intent ( in ) :: nFields !> mixture temperature real ( kind = rk ), intent ( in ) :: temp !> mixture pressure real ( kind = rk ), intent ( in ) :: press !> mole density of all species of single element real ( kind = rk ), intent ( in ) :: mole_dens ( nFields ) !> thermodynamic factor matrix real ( kind = rk ), intent ( out ) :: D_ij_out ( nFields , nFields ) ! -------------------------------------------------------------------------! D_ij_out = 1.0_rk end subroutine mus_calc_MS_DiffMatrix_single ! **************************************************************************** ! ! **************************************************************************** ! !> Dummy function to init_enrtl function mus_init_eNRTL ( filename , nFields ) result ( success ) ! -------------------------------------------------------------------------! character ( kind = c_char ), dimension ( * ) :: filename !> Number of fields defined in the property file integer , intent ( out ) :: nFields !> Result, indicating the status of encode logical :: success ! -------------------------------------------------------------------------! write ( logUnit ( 1 ), * ) 'Using eNRTL dummy module' success = . true . nFields = 0 end function mus_init_eNRTL ! **************************************************************************** ! end module mus_eNRTL_module","tags":"","loc":"sourcefile/mus_enrtl_dummy.f90.html"},{"title":"mus_source_var_turbChanForce_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_source_var_turbchanforce_module.f90~~EfferentGraph sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_source_var_turbchanforce_module.f90~~AfferentGraph sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_turbchanforce_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** ! !> author: Kannan Masilamani !! Module containing subroutines for building MUSUBI specific source !! variables for turbulent channel flow. To avoid cyclic inclusions !! module mus_source_var_turbChanForce_module use , intrinsic :: iso_c_binding , only : c_f_pointer ! include treelm modules use mpi use env_module , only : rk , rk_mpi use tem_param_module , only : rho0 , cs2 use tem_varSys_module , only : tem_varSys_type use tem_varMap_module , only : init , append , truncate use tem_stringKeyValuePair_module , only : init , truncate use tem_topology_module , only : tem_levelOf ! include musubi modules use mus_physics_module , only : mus_convertFac_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_source_type_module , only : mus_source_op_type use mus_varSys_module , only : mus_varSys_data_type implicit none private ! update auxField dependent source variables public :: mus_updateSrcVar_turbChanForce contains ! ************************************************************************** ! !> Compute dynamic force term using auxField for turbulent channel !! force. subroutine mus_updateSrcVar_turbChanForce ( fun , auxField , iLevel , varSys , & & phyConvFac , derVarPos ) ! ------------------------------------------------------------------------ ! !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> input auxField array on current level real ( kind = rk ), intent ( in ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor on current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- integer :: vel_pos ( 3 ) integer :: iElem , nElemsGlobal_uTau , posInTotal , elemOff type ( mus_varSys_data_type ), pointer :: fPtr integer :: iErr , iBC , iLvlLoc real ( kind = rk ) :: vel_bulk , vel_tau real ( kind = rk ) :: avgVelBulk , avgVelTau ! index 1 for vel_tau and 2 for vel_bulk to get global avg with one mpi call real ( kind = rk ) :: avgVel ( 2 ), avgVelGlobal ( 2 ) real ( kind = rk ) :: forceDyn , gradU ( 3 , 3 , 1 ) logical :: velTauFromBnd ! -------------------------------------------------------------------------- ! position of velocity field in auxField vel_pos = varSys % method % val ( derVarPos ( 1 )% velocity )% auxField_varPos ( 1 : 3 ) ! First variable is always pdf so just use to access method_data call C_F_POINTER ( varSys % method % val ( 1 )% method_Data , fPtr ) ! Calculate average bulk velocityX over defined shape. associate ( levelPointer => fPtr % solverData % geometry % levelPointer , & & auxFieldTot => fPtr % solverData % scheme % auxField , & & gradDataTot => fPtr % solverData % scheme % gradData , & & viscKineTot => fPtr % solverData % scheme % field ( 1 )% fieldProp & & % fluid % viscKine % dataOnLvl , & & map2Global_umean => fun % turbChanForce % subTree_umean % map2global , & & map2Global_utau => fun % turbChanForce % subTree_utau % map2global , & & physics => fPtr % solverData % physics , & & tree => fPtr % solverData % geometry % tree , & & grad => fPtr % solverData % scheme % Grad ) ! Do average only at every multilevel cycle i.e. when iLevel=minLevel if ( iLevel == tree % global % minLevel ) then ! Initialize variables vel_bulk = 0.0_rk vel_tau = 0.0_rk velTauFromBnd = . false . nElemsGlobal_uTau = 0 !> If wall model BC is applied than compute the friction velocity ! that is obtained directly from the wall model and perform the spatial ! averaging. do iBC = 1 , fPtr % solverData % geometry % boundary % nBCtypes select case ( trim ( fPtr % solverData % scheme % field ( 1 )% BC ( iBC )% BC_kind )) case ( 'turbulent_wall' , 'turbulent_wall_noneq_expol' , & & 'turbulent_wall_eq' ) if ( allocated ( fPtr % solverData % scheme % field ( 1 )% BC ( iBC ) & & % turbWallFunc % dataOnLvl )) then velTauFromBnd = . true . do iLvlLoc = tree % global % minLevel , tree % global % maxLevel ! vel_tau in turbWallFunc is in lattice unit so convert it vel_tau = vel_tau + sum ( fPtr % solverData % scheme % field ( 1 ) & & % BC ( iBC )% turbWallFunc & & % dataOnLvl ( iLvlLoc )% velTau (:) ) & & * physics % fac ( iLvlLoc )% vel end do nElemsGlobal_uTau = nElemsGlobal_uTau & & + fPtr % solverData % scheme % globBC ( iBC )% nElems_Total end if end select end do !> If wall model BC is not used than compute the friction velocity from !! the single sided finite difference's and perform the spatial averaging. !! Friction velocity is computed only on elements intersected by !! shape_utau defined in musubi.lua. if (. not . velTauFromBnd ) then nElemsGlobal_uTau = fun % turbChanForce % nElemsGlobal_utau select case ( fun % turbChanForce % flow_direction ) case ( 1 ) ! x-direction do iElem = 1 , fun % turbChanForce % subTree_utau % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_utau ( iElem ) ) iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_utau ( iElem ) ) ) ! elemOffset refers to the previous number of elements processed gradU (:,:,:) = grad % U_ptr ( & & auxField = auxFieldTot ( iLvlLoc )% val (:), & & gradData = gradDataTot ( iLvlLoc ), & & velPos = vel_Pos , & & nAuxScalars = varSys % nAuxScalars , & & nDims = 3 , & & nSolve = 1 , & & elemOffset = posInTotal - 1 ) ! compute uTau using the dudy component of velocity gradient tensor vel_tau = vel_tau + sqrt ( viscKineTot ( iLvlLoc )% val ( posInTotal ) & & * abs ( gradU ( 1 , 2 , 1 )) ) & & * physics % fac ( iLvlLoc )% vel !write(dbgunit(1), *) 'posInTotal: ', posInTotal, 'gradU: ', gradU(1,2,1) end do case ( 2 ) ! y-direction do iElem = 1 , fun % turbChanForce % subTree_utau % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_utau ( iElem ) ) iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_utau ( iElem ) ) ) gradU (:,:,:) = grad % U_ptr ( & & auxField = auxFieldTot ( iLvlLoc )% val (:), & & gradData = gradDataTot ( iLvlLoc ), & & velPos = vel_Pos , & & nAuxScalars = varSys % nAuxScalars , & & nDims = 3 , & & nSolve = 1 , & & elemOffset = posInTotal - 1 ) ! compute uTau using the dvdx component of velocity gradient tensor vel_tau = vel_tau + sqrt ( viscKineTot ( iLvlLoc )% val ( posInTotal ) & & * abs ( gradU ( 2 , 1 , 1 )) ) & & * physics % fac ( iLvlLoc )% vel end do case ( 3 ) ! z-direction do iElem = 1 , fun % turbChanForce % subTree_utau % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_utau ( iElem ) ) iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_utau ( iElem ) ) ) gradU (:,:,:) = grad % U_ptr ( & & auxField = auxFieldTot ( iLvlLoc )% val (:), & & gradData = gradDataTot ( iLvlLoc ), & & velPos = vel_Pos , & & nAuxScalars = varSys % nAuxScalars , & & nDims = 3 , & & nSolve = 1 , & & elemOffset = posInTotal - 1 ) ! compute uTau using the dwdy component of velocity gradient tensor vel_tau = vel_tau + sqrt ( viscKineTot ( iLvlLoc )% val ( posInTotal ) & & * abs ( gradU ( 3 , 2 , 1 )) ) & & * physics % fac ( iLvlLoc )% vel end do end select end if !> Bulk mean velocity part of forcing is independent whether a wall ! modelBC is used or not select case ( fun % turbChanForce % flow_direction ) case ( 1 ) ! x-direction do iElem = 1 , fun % turbChanForce % subTree_umean % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_umean ( iElem ) ) ! elemoffset for auxField elemoff = ( posInTotal - 1 ) * varSys % nAuxScalars ! velocity X in defined shape to compute average iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_umean ( iElem ) ) ) vel_bulk = vel_bulk + auxFieldTot ( iLvlLoc )% val ( elemOff + vel_pos ( 1 )) & & * physics % fac ( iLvlLoc )% vel end do case ( 2 ) ! y-direction do iElem = 1 , fun % turbChanForce % subTree_umean % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_umean ( iElem ) ) ! elemoffset for auxField elemoff = ( posInTotal - 1 ) * varSys % nAuxScalars ! velocity X in defined shape to compute average iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_umean ( iElem ) ) ) vel_bulk = vel_bulk + auxFieldTot ( iLvlLoc )% val ( elemOff + vel_pos ( 2 )) & & * physics % fac ( iLvlLoc )% vel end do case ( 3 ) ! z-direction do iElem = 1 , fun % turbChanForce % subTree_umean % nElems ! map2Global refers to position in treeid list ! levelPointer refers to position in level wise total list posInTotal = levelPointer ( map2Global_umean ( iElem ) ) ! elemoffset for auxField elemoff = ( posInTotal - 1 ) * varSys % nAuxScalars ! velocity X in defined shape to compute average iLvlLoc = tem_levelOf ( tree % treeID ( map2Global_umean ( iElem ) ) ) vel_bulk = vel_bulk + auxFieldTot ( iLvlLoc )% val ( elemOff + vel_pos ( 3 )) & & * physics % fac ( iLvlLoc )% vel end do end select avgVel ( 1 ) = vel_tau avgVel ( 2 ) = vel_bulk ! Calculate total friction and bulk velocity call mpi_allreduce ( avgVel , avgVelGlobal , & & 2 , rk_mpi , mpi_sum , tree % global % comm , iErr ) ! compute average friction velocity avgVelTau = avgVelGlobal ( 1 ) / nElemsGlobal_uTau ! compute average bulk velocity in physical unit avgVelBulk = avgVelGlobal ( 2 ) / fun % turbChanForce % nElemsGlobal_umean ! Dynamic force term for turbulent channel ! F_dyn = (refVelBulk-avgVelBulk) * refVelBulk / refHeight forceDyn = avgVelTau ** 2 / fun % turbChanForce % refHeight & & + ( fun % turbChanForce % refVelBulk - avgVelBulk ) & & * fun % turbChanForce % refVelBulk / fun % turbChanForce % refHeight fun % turbChanForce % forceDyn = 0.0_rk !write(dbgunit(1), *) 'avgVelBulk: ', avgVelBulk , 'avgVelTau:', avgVelTau !write(dbgunit(1), *) 'vel_tau: ', vel_tau !flush(dbgunit(1)) !write(dbgunit(1), *) 'forceDyn_phy: ', forceDyn select case ( fun % turbChanForce % flow_direction ) case ( 1 ) ! x-direction fun % turbChanForce % forceDyn ( 1 ) = forceDyn case ( 2 ) ! y-direction fun % turbChanForce % forceDyn ( 2 ) = forceDyn case ( 3 ) ! z-direction fun % turbChanForce % forceDyn ( 3 ) = forceDyn end select end if end associate end subroutine mus_updateSrcVar_turbChanForce end module mus_source_var_turbChanForce_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_source_var_turbchanforce_module.f90.html"},{"title":"mus_turbulence_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_turbulence_module.f90~~EfferentGraph sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_turbulence_module.f90~~AfferentGraph sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2021 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2019-2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains data types, function and routines for turbulence !! model. Especially the routine to compute turbulent eddy viscosity for !! different turbulence model !! !! author: Kannan Masilamani module mus_turbulence_module ! include treelm modules use env_module , only : rk , labelLen use tem_tools_module , only : upper_to_lower , & & tem_horizontalSpacer use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_comm_module , only : tem_communication_type , & & tem_commPattern_type , & & tem_comm_init use tem_construction_module , only : tem_levelDesc_type ! include aotus modules use aotus_module , only : aoterr_Fatal , & & aoterr_NonExistent , & & flu_State , & & aoterr_WrongType , & & aot_get_val use aot_table_module , only : aot_table_open , & & aot_table_close ! include musubi modules use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_gradData_module , only : mus_gradData_type , mus_Grad_type implicit none private public :: mus_turbulence_type public :: mus_turbulence_config_type public :: mus_turbulence_data_type public :: mus_init_turbulenceData public :: mus_load_turbulence public :: mus_turb_calcVisc public :: mus_turb_updateViscOfTurbWall !> Contains large Eddy Turbulence (LES) model coefficients type les_coeff_type !> Smagorinsky constant. !! C_s = sqrt(C_k sqrt(C_k/C_e) ) = 0.16778594 = 0.17 real ( kind = rk ) :: C_s !> Model constant for WALE (Wall-Adapting Local Eddy-Viscosity) !! default: 0.5 real ( kind = rk ) :: C_w !> Model constant for Vreman model !! In literature: C_v = sqrt(2.5) C_s = 0.27 real ( kind = rk ) :: C_v !> Modal constant for turbulent kinetic energy dissipation rate !! default: 1.048 real ( kind = rk ) :: C_e !> Model constant for eddy-viscosity coefficient !! default: 0.094_rk !! https://caefn.com/openfoam/smagorinsky-sgs-model real ( kind = rk ) :: C_k end type les_coeff_type !> Contains turbulence information loaded from config file type mus_turbulence_config_type !> turbulence model type character ( len = labelLen ) :: model !> les model coefficients type ( les_coeff_type ) :: coeff !> To compute strain-rate from non-equilibrium PDF for Smagorinsky les model. !! If true then velocity and grad data are not required logical :: compSR_fromPDF = . false . !> Use Kolmogorov scale for interpolation turbulent viscosity for multilevel logical :: useKolmogorovScale = . true . end type mus_turbulence_config_type !> Contains velocity and gradient data to compute eddy viscosity type mus_turbulence_data_type !> Communication buffers to communicate visoscity field !! Local Fluids required by remote processes type ( tem_communication_type ) :: sendBuffer !> My halos which are fluids on remote processes type ( tem_communication_type ) :: recvBuffer !> Local ghostFromCoarser required by remote processes type ( tem_communication_type ) :: sendBufferFromCoarser !> Local ghostFromFiner required by remote processes type ( tem_communication_type ) :: sendBufferFromFiner !> My halos which are ghostFromCoarser on remote processes type ( tem_communication_type ) :: recvBufferFromCoarser !> My halos which are ghostFromFiner on remote processes type ( tem_communication_type ) :: recvBufferFromFiner !> Normalized turbulence viscosity !! i.e. viscosity scaled to current level i.e. visc/dtL !! Size: nSize (nFluids+nGhosts+nHalos) !! Used gradData to compute viscosity for nFluids and nGhosts. !! This viscosity is interpolated and scaled for setting nonEq term !! interpolation routines. The source element of interpolation might be !! halo so they are communicated. !! !! Simple scaling assumping norm of strainrate tensor |S| in different !! level is small: !! Schneider, A. (2015). A Consistent Large Eddy Approach for !! Lattice Boltzmann Methods and its Application to Complex Flows. !! Technical University Kaiserslautern. !! v_c = 4 v_f. Scaled visc: v&#94;s = v/dt. !! => v&#94;s_c dtL_c = 4 v&#94;s_f dtL_f => v&#94;s_c = 2 v&#94;s_f !! !! Kolmogorov scaling: !! Touil, H., Ricot, D., & Lévêque, E. (2014). Direct and large-eddy !! simulation of turbulent flows on composite multi-resolution grids by !! the lattice Boltzmann method. Journal of Computational Physics, 256, !! 220–233. !! v&#94;s_c = 2&#94;(1/3) v&#94;s_f real ( kind = rk ), allocatable :: visc (:) end type mus_turbulence_data_type !> Contains function pointers to obtain normalized turbulence viscosity. !! Viscosity is normalized to current level i.e. v_s = v/dt type mus_turbulence_visc_proc_type !> this procedure compute eddy viscosity from velocity field depending !! turbulence and lbm (compressible/incompressible) models procedure ( proc_calc_turb_visc_fromGradU ), pointer , nopass & & :: fromGradU => null () !> this procedure compute eddy viscosity from preCollision PDF. !! It is used for Smagorinsky model which depends only on strain rate !! that can be calculated using local nonEquilibrium. !! Is assigned when compSR_fromPDF is .true. procedure ( proc_calc_turb_visc_fromPreColPDF ), pointer , nopass & & :: fromPreColPDF => null () end type mus_turbulence_visc_proc_type !> Contains information required to compute eddy viscosity type mus_turbulence_type !> is true if turbulence table is defined logical :: active !> information loaded from config file type ( mus_turbulence_config_type ) :: config !> contains level-wise turbulence data to compute eddy viscosity !! size: minlevel:maxLevel type ( mus_turbulence_data_type ), allocatable :: dataOnLvl (:) !> contains turbulence viscosity function pointers type ( mus_turbulence_visc_proc_type ) :: calcVisc !> Factor to scale normalized turbulent viscosity from coarse to fine !! depending on whether useKolmogorovScale true or false !! if useKolmogorovScale fac_c2f = 1/2&#94;(1/3) else fac_c2f = 1/2 !! How to use: v&#94;s_f = fac_c2f v&#94;s_c real ( kind = rk ) :: fac_c2f !> Factor to scale normalized turbulent viscosity from fine to coarse !! depending on whether useKolmogorovScale true or false !! if useKolmogorovScale fac_f2c = 2&#94;(1/3) else fac_f2c = 2 !! How to use: v&#94;s_c = fac_f2c v&#94;s_f real ( kind = rk ) :: fac_f2c end type mus_turbulence_type !> interface to calculate subgrid scale turbulent eddy viscosity abstract interface !> This function computes turbulent viscosity from gradient U subroutine proc_calc_turb_visc_fromGradU ( turbVisc , turbConfig , gradData , & & auxField , velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) import :: rk , mus_turbulence_config_type , mus_gradData_type , mus_Grad_type !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> turbulence config contains oefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> turbulence coefficients !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad end subroutine proc_calc_turb_visc_fromGradU !> This function compute turbulent viscosity from pre-collision PDF subroutine proc_calc_turb_visc_fromPreColPDF ( turbVisc , turbConfig , state , & & neigh , auxField , densPos , velPos , nSize , nSolve , nScalars , nAuxScalars ,& & layout , dxL , dtL , viscKine ) import :: rk , mus_turbulence_config_type , mus_scheme_layout_type !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> turbulence type is implicitly passed to access turbulence coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> state array real ( kind = rk ), intent ( in ) :: state (:) !> neigh array to obtain precollision pdf integer , intent ( in ) :: neigh (:) !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of density in auxField integer , intent ( in ) :: densPos !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> number of elements in state array integer , intent ( in ) :: nSize !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in state array integer , intent ( in ) :: nScalars !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> scheme layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Background kinematic viscosity divided by dtL real ( kind = rk ), intent ( in ) :: viscKine (:) end subroutine proc_calc_turb_visc_fromPreColPDF end interface contains ! ************************************************************************** ! !> load turbulence table subroutine mus_load_turbulence ( me , conf , parent ) !-------------------------------------------------------------------------- !> fluid type type ( mus_turbulence_type ), intent ( out ) :: me !> lua state type ( flu_state ) :: conf !> parent handle integer , intent ( in ), optional :: parent !-------------------------------------------------------------------------- integer :: turb_table , iError !-------------------------------------------------------------------------- ! if fluid informations in scheme table parentHandle /= 0 if ( present ( parent ) ) then call aot_table_open ( L = conf , & & parent = parent , & & thandle = turb_table , & & key = 'turbulence' ) else call aot_table_open ( L = conf , thandle = turb_table , key = 'turbulence' ) end if if ( turb_table == 0 ) then write ( logUnit ( 1 ), * ) 'No turbulence table defined' me % config % compSR_fromPDF = . false . me % active = . false . return endif write ( logUnit ( 1 ), * ) 'Loading turbulence informations' me % active = . true . ! default is set to false for other models, its optional only for ! Smagorinsky model me % config % compSR_fromPDF = . false . ! load turbulence model call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'model' , & & val = me % config % model , & & default = 'smagorinsky' , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving model :' if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'Variable not existent!' write ( logUnit ( 1 ), * ) 'Using default model: smagorinsky' end if if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () end if end if write ( logUnit ( 1 ), * ) '  model: ' , trim ( me % config % model ) select case ( upper_to_lower ( trim ( me % config % model ))) case ( 'smagorinsky' ) call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'compute_strainrate_fromPDF' , & & val = me % config % compSR_fromPDF , & & default = . true ., & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  use preCol PDF to calc strainrate: ' , & & me % config % compSR_fromPDF ! use Smagorinsky constant when computing eddy viscosity from PDF ! else use C_k and C_e if ( me % config % compSR_fromPDF ) then call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'c_s' , & & val = me % config % coeff % C_s , & & default = 0.17_rk , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  C_s: ' , me % config % coeff % C_s else call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'c_e' , & & val = me % config % coeff % C_e , & & default = 1.048_rk , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  C_e: ' , me % config % coeff % C_e call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'c_k' , & & val = me % config % coeff % C_k , & & default = 0.094_rk , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  C_k: ' , me % config % coeff % C_k end if case ( 'wale' ) call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'c_w' , & & val = me % config % coeff % C_w , & & default = 0.5_rk , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  C_w: ' , me % config % coeff % C_w case ( 'vreman' ) ! load model coefficients. ! Vreman model constant is related to Smagorinsky constant: c_v = 2.5*c_s&#94;2 ! For c_s=0.17, c_v is approximately 0.07 call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'c_v' , & & val = me % config % coeff % C_v , & & default = 0.07_rk , & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  C_v: ' , me % config % coeff % C_v case default call tem_abort ( 'Error: Unknown turbulence model' ) end select ! to use Kolmogorov scale for multilevel call aot_get_val ( L = conf , & & thandle = turb_table , & & key = 'use_kolmogorov_scale' , & & val = me % config % useKolmogorovScale , & & default = . true ., & & ErrCode = iError ) write ( logUnit ( 1 ), * ) '  Use Kolmogorov scale: ' , me % config % useKolmogorovScale ! set scaling factor to convert turbulent viscosity from coarse to fine ! and vice versa if ( me % config % useKolmogorovScale ) then me % fac_f2c = 2.0_rk ** ( 1.0_rk / 3.0_rk ) me % fac_c2f = 1.0_rk / me % fac_f2c else me % fac_f2c = 2.0_rk me % fac_c2f = 1.0_rk / me % fac_f2c end if call aot_table_close ( L = conf , thandle = turb_table ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_turbulence ! ************************************************************************** ! ! ************************************************************************** ! !> This initialize turbulence data type which includes velocity array !! and communication buffer subroutine mus_init_turbulenceData ( me , & !turbConfig, & levelDesc , pattern , nSize ) !--------------------------------------------------------------------------- !> turbulence data type ( mus_turbulence_data_type ), intent ( out ) :: me !!> tubulence configuration !type(mus_turbulence_config_type), intent(in) :: turbConfig !> levelDesc to access communication buffers of state array type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> communication pattern type ( tem_commPattern_type ), intent ( in ) :: pattern !> Number of elements in state array integer , intent ( in ) :: nSize !--------------------------------------------------------------------------- ! allocate tubulence viscosity array allocate ( me % visc ( nSize )) ! initialize turbulent viscosity with zeros to fill ghost elements. ! Actual turbulent viscosity are computed before stream-collision after ! calculating auxField in control_routine me % visc (:) = 0.0_rk ! allocate send and recv buffer to exchange turbulenc viscosity !if (.not. turbConfig%compSR_fromPDF) then ! initialize communication buffers for viscosity call init_commBuffer ( buffer_visc = me % sendBuffer , & & buffer_State = levelDesc % sendBuffer ) call init_commBuffer ( buffer_visc = me % recvBuffer , & & buffer_State = levelDesc % recvBuffer ) call init_commBuffer ( buffer_visc = me % sendBufferFromCoarser , & & buffer_State = levelDesc % SendBufferFromCoarser ) call init_commBuffer ( buffer_visc = me % recvBufferFromCoarser , & & buffer_State = levelDesc % recvBufferFromCoarser ) call init_commBuffer ( buffer_visc = me % sendBufferFromFiner , & & buffer_State = levelDesc % sendBufferFromFiner ) call init_commBuffer ( buffer_visc = me % recvBufferFromFiner , & & buffer_State = levelDesc % recvBufferFromFiner ) !end if contains ! ************************************************************************ ! subroutine init_commBuffer ( buffer_visc , buffer_state ) !------------------------------------------------------------------------- !> communication buffer for velocity field type ( tem_communication_type ), intent ( out ) :: buffer_visc !> communication buffer of state array which is already initialized !! in tem_construction_module type ( tem_communication_type ), intent ( in ) :: buffer_state !------------------------------------------------------------------------- integer :: iProc !------------------------------------------------------------------------- ! copy information about target and source procs from pdf sendBuffer to ! velocity sendBuffer call tem_comm_init ( buffer_visc , buffer_state % nProcs ) buffer_visc % proc = buffer_state % proc buffer_visc % nElemsProc = buffer_state % nElemsProc do iProc = 1 , buffer_visc % nProcs call pattern % initBuf_real ( me = buffer_visc % buf_real ( iProc ), & & pos = buffer_state % elemPos ( iProc )% val , & & nVals = buffer_state % nElemsProc ( iProc ) ) end do end subroutine init_commBuffer ! ************************************************************************ ! end subroutine mus_init_turbulenceData ! ************************************************************************** ! ! ************************************************************************** ! !> This routine compute turbulence viscosity and stores in turbulence data type subroutine mus_turb_calcVisc ( turbData , turbConfig , calcTurbVisc , state , & & neigh , auxField , gradData , densPos , velPos , & & nSize , nSolve , nScalars , nAuxScalars , layout , & & dxL , dtL , viscKine , Grad ) ! -------------------------------------------------------------------------- !> turbulence data type type ( mus_turbulence_data_type ), intent ( inout ) :: turbData !> turbulence configuration type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> turbulence function type ( mus_turbulence_visc_proc_type ), intent ( in ) :: calcTurbVisc !> state array real ( kind = rk ), intent ( in ) :: state (:) !> neigh array to obtain precollision pdf integer , intent ( in ) :: neigh (:) !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> position of density in auxField integer , intent ( in ) :: densPos !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> number of elements in state array integer , intent ( in ) :: nSize !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in state array integer , intent ( in ) :: nScalars !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> scheme layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> lattice element size in current level real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Background kinematic viscosity divided by dtL real ( kind = rk ), intent ( in ) :: viscKine (:) !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- ! calculate turbulent viscosity if ( turbConfig % compSR_fromPDF ) then call calcTurbVisc % fromPreColPDF ( turbVisc = turbData % visc ( 1 : nSolve ), & & turbConfig = turbConfig , & & state = state , & & neigh = neigh , & & auxField = auxField , & & densPos = densPos , & & velPos = velPos , & & nSize = nSize , & & nSolve = nSolve , & & nScalars = nScalars , & & nAuxScalars = nAuxScalars , & & layout = layout , & & dxL = dxL , & & dtL = dtL , & & viscKine = viscKine ) else call calcTurbVisc % fromGradU ( turbVisc = turbData % visc ( 1 : nSolve ), & & turbConfig = turbConfig , & & gradData = gradData , & & auxField = auxField , & & velPos = velPos , & & nSolve = nSolve , & & nAuxScalars = nAuxScalars , & & dxL = dxL , & & dtL = dtL , & & Grad = Grad ) end if end subroutine mus_turb_calcVisc ! ************************************************************************** ! ! ************************************************************************** ! !> This routine update turbulent viscosity of boundary elements from RANS !! viscosity computed in turbulent_wall boundary. subroutine mus_turb_updateViscOfTurbWall ( turbData , viscTurbWall , nElems_bnd , & & elemPos ) ! -------------------------------------------------------------------------- !> turbulence data type type ( mus_turbulence_data_type ), intent ( inout ) :: turbData !> Turbulent viscosity on turbulent wall boundary computed in set boundary real ( kind = rk ), intent ( in ) :: viscTurbWall (:) !> Number of elements in turbulent_wall boundary integer , intent ( in ) :: nElems_bnd !> Position of boundary element in levelwise total list or state array integer , intent ( in ) :: elemPos (:) ! -------------------------------------------------------------------------- integer :: iElem ! -------------------------------------------------------------------------- do iElem = 1 , nElems_bnd turbData % visc ( elemPos ( iElem )) = viscTurbWall ( iElem ) end do end subroutine mus_turb_updateViscOfTurbWall ! ************************************************************************** ! end module mus_turbulence_module","tags":"","loc":"sourcefile/mus_turbulence_module.f90.html"},{"title":"mus_bc_nernstPlanck_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_bc_nernstplanck_module.f90~~EfferentGraph sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2019, 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> Boundary condition treatment routines for Nernst-Planck equation !! !! A detailed description on the implementation details are given in !! boundary_implementation !! module mus_bc_nernstPlanck_module ! include treelm modules use env_module , only : rk , eps use tem_time_module , only : tem_time_type use treelmesh_module , only : treelmesh_type use tem_varSys_module , only : tem_varSys_type use tem_construction_module , only : tem_levelDesc_type use tem_debug_module , only : dbgUnit use tem_param_module , only : cs2inv ! include musubi modules use mus_bc_header_module , only : boundary_type , glob_boundary_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_field_prop_module , only : mus_field_prop_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_param_module , only : mus_param_type use mus_physics_module , only : mus_physics_type use mus_mixture_module , only : mus_mixture_type implicit none private public :: moleDens_nonEqExpol_curved public :: moleDens_neumann_curved public :: moleDens_nonEqExpol public :: moleDens_neumann contains ! **************************************************************************** ! !> No comment yet! !! !! @TODO add comment !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine moleDens_nonEqExpol_curved ( me , state , bcBuffer , globBC , & & levelDesc , tree , nSize , iLevel , & & sim_time , neigh , layout , fieldProp , & & varPos , nScalars , varSys , derVarPos , & & physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! coefficients which are calculated in mus_bc_header_module real ( kind = rk ) :: c_w , c_f , c_ff , c_neq_f , c_neq_ff ! also determined in mus_bc_header_module integer :: iDir , posInBuffer , posInNeighBuf ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , moleDens_b ! variables for fluid element real ( kind = rk ) :: feq_f , fneq_f , moleDens_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , moleDens_ff ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdfTmp ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! potential on surface (link-wise) real ( kind = rk ) :: moleDens_w ( me % links ( iLevel )% nVals ) real ( kind = rk ) :: vel_w ( me % links ( iLevel )% nVals * 3 ), vel_b ( 3 ) integer :: bcVel_pos , bcMoleDens_pos , iLink , QQ , QQN real ( kind = rk ) :: ucx ! -------------------------------------------------------------------------- QQ = layout % fstencil % QQ QQN = layout % fstencil % QQN ! position of boundary moleDensity in varSys bcMoleDens_pos = me % bc_states % moleDens % varPos ! Get moleDensity on boundary call varSys % method % val ( bcMoleDens_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % moleDens & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = moleDens_w ) ! convert physical moleDensity into LB moleDensity moleDens_w = moleDens_w / physics % moleDens0 ! position of boundary velocity in varSys bcVel_pos = me % bc_states % velocity % varPos ! Get velocity call varSys % method % val ( bcVel_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % velocity & & % pntIndex % indexLvl ( iLevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = globBC % nElems ( iLevel ), & & res = vel_w ) ! convert physical velocity into LB velocity vel_w = vel_w / physics % fac ( iLevel )% vel do iLink = 1 , me % links ( iLevel )% nVals ! load coefficients c_w = me % nonEqExpol ( iLevel )% c_w ( iLink ) c_f = me % nonEqExpol ( iLevel )% c_f ( iLink ) c_ff = me % nonEqExpol ( iLevel )% c_ff ( iLink ) c_neq_f = me % nonEqExpol ( iLevel )% c_neq_f ( iLink ) c_neq_ff = me % nonEqExpol ( iLevel )% c_neq_ff ( iLink ) ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate moleDensity of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdfTmp ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) moleDens_f = sum ( pdfTmp ) ! velocity at boundary node vel_b = vel_w (( iLink - 1 ) * 3 + 1 : iLink * 3 ) !> Pre-calculate velocitiy terms ucx = dble ( layout % fStencil % cxDirRK ( 1 , iDir )) * vel_b ( 1 ) & & + dble ( layout % fStencil % cxDirRK ( 2 , iDir )) * vel_b ( 2 ) & & + dble ( layout % fStencil % cxDirRK ( 3 , iDir )) * vel_b ( 3 ) ! calulate moleDensity of the overnext fluid neighbor element (_ff) posInNeighBuf = me % nonEqExpol ( iLevel )% posInNeighBuf ( iLink ) pdf_ff = me % neigh ( iLevel )% neighBufferPost ( 1 , & & ( posInNeighBuf - 1 ) * QQ + 1 : ( posInNeighBuf - 1 ) * QQ + QQ ) moleDens_ff = sum ( pdf_ff ) ! compute moleDensity on boundary (eq.18) moleDens_b = c_w * moleDens_w ( iLink ) + c_f * moleDens_f + c_ff * moleDens_ff ! compute equlibrium (according to eq.17) ! fEq_b is on boundary node feq_b = layout % weight ( iDir ) * moleDens_b * ( 1.0_rk + ucx * cs2inv ) ! fEq_loc is local element value feq_f = layout % weight ( iDir ) * moleDens_f * ( 1.0_rk + ucx * cs2inv ) ! feq_ff is of overnext fluid feq_ff = layout % weight ( iDir ) * moleDens_ff * ( 1.0_rk + ucx * cs2inv ) ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdfTmp ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff fneq_b = c_nEq_f * fneq_f + c_nEq_ff * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end subroutine moleDens_nonEqExpol_curved ! **************************************************************************** ! ! **************************************************************************** ! !> No comment yet! !! !! @TODO add comment !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine moleDens_neumann_curved ( me , state , bcBuffer , globBC , levelDesc , & & tree , nSize , iLevel , sim_time , neigh , & & layout , fieldProp , varPos , nScalars , & & varSys , derVarPos , physics , iField , & & mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! coefficients which are calculated in mus_bc_header_module real ( kind = rk ) :: c_neq_f , c_neq_ff ! also determined in mus_bc_header_module integer :: iDir , posInBuffer , posInNeighBuf ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , moleDens_b ! variables for fluid element real ( kind = rk ) :: feq_f , fneq_f , moleDens_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , moleDens_ff ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdfTmp ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! mole flux on surface (link-wise) real ( kind = rk ) :: moleFlux_w ( me % links ( iLevel )% nVals ) real ( kind = rk ) :: vel_w ( me % links ( iLevel )% nVals * 3 ), vel_b ( 3 ) integer :: bcVel_pos , iLink , QQ integer :: bcMoleFlux_pos real ( kind = rk ) :: normal ( 3 ), moleFlux_b real ( kind = rk ) :: ucx ! -------------------------------------------------------------------------- !write(*,*) 'bclabel ', trim(me%label) QQ = layout % fStencil % QQ ! position of boundary mole flux variable in varSys bcMoleFlux_pos = me % bc_states % moleFlux % varPos ! Get moleDensity on boundary call varSys % method % val ( bcmoleFlux_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % moleFLux & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = moleFlux_w ) ! convert physical moleflux into Lattice unit moleFlux_w = moleFlux_w / physics % fac ( iLevel )% moleflux ! position of boundary velocity in varSys bcVel_pos = me % bc_states % velocity % varPos ! Get velocity call varSys % method % val ( bcVel_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % velocity & & % pntIndex % indexLvl ( iLevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = globBC % nElems ( iLevel ), & & res = vel_w ) ! convert physical velocity into LB velocity vel_w = vel_w / physics % fac ( iLevel )% vel do iLink = 1 , me % links ( iLevel )% nVals ! load coefficients c_neq_f = me % nonEqExpol ( iLevel )% c_neq_f ( iLink ) c_neq_ff = me % nonEqExpol ( iLevel )% c_neq_ff ( iLink ) ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdfTmp ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) moleDens_f = sum ( pdfTmp ) ! velocity at boundary node vel_b = vel_w (( iLink - 1 ) * 3 + 1 : iLink * 3 ) !> Pre-calculate velocitiy terms ucx = dble ( layout % fStencil % cxDirRK ( 1 , iDir )) * vel_b ( 1 ) & & + dble ( layout % fStencil % cxDirRK ( 2 , iDir )) * vel_b ( 2 ) & & + dble ( layout % fStencil % cxDirRK ( 3 , iDir )) * vel_b ( 3 ) ! calulate potential of the overnext fluid neighbor element (_ff) posInNeighBuf = me % nonEqExpol ( iLevel )% posInNeighBuf ( iLink ) pdf_ff = me % neigh ( iLevel )% neighBufferPost ( 1 , & & ( posInNeighBuf - 1 ) * QQ + 1 : ( posInNeighBuf - 1 ) * QQ + QQ ) moleDens_ff = sum ( pdf_ff ) !write(*,*) 'normal ', globBC%elemLvl(iLevel)%normal%val(:, me%nonEqExpol(iLevel)%posInBCelems(iLink)) !write(*,*) 'normal Ind', globBC%elemLvl(iLevel)%normalInd%val(me%nonEqExpol(iLevel)%posInBCelems(iLink)) normal = globBC % elemLvl ( iLevel )% normal & & % val (:, me % nonEqExpol ( iLevel )% posInBCelems ( iLink )) moleFlux_b = moleFlux_w ( iLink ) & & * dot_product ( layout % fStencil % cxDirRK (:, iDir ), normal ) ! calulate moleDensity on boundary moleDens_b = ( 4.0_rk * moleDens_f - moleDens_ff - 2.0_rk * moleFlux_b ) & & / 3.0_rk ! compute equlibrium (according to eq.17) ! fEq_b is on boundary fEq_b = layout % weight ( iDir ) * moleDens_b * ( 1.0_rk + ucx * cs2inv ) ! fEq_loc is local element value fEq_f = layout % weight ( iDir ) * moleDens_f * ( 1.0_rk + ucx * cs2inv ) ! feq is of overnext fluid fEq_ff = layout % weight ( iDir ) * moleDens_ff * ( 1.0_rk + ucx * cs2inv ) ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdfTmp ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff fneq_b = c_nEq_f * fneq_f + c_nEq_ff * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end subroutine moleDens_neumann_curved ! **************************************************************************** ! ! **************************************************************************** ! !> No comment yet! !! !! @TODO add comment !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine moleDens_nonEqExpol ( me , state , bcBuffer , globBC , levelDesc , & & tree , nSize , iLevel , sim_time , neigh , & & layout , fieldProp , varPos , nScalars , varSys , & & derVarPos , physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! also determined in mus_bc_header_module integer :: iDir , posInBuffer ! variables for fictious boundary element real ( kind = rk ) :: feq_b , moleDens_b ! variables for overnext fluid element real ( kind = rk ) :: feq_f , moleDens_f real ( kind = rk ) :: inv_moleDens ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdfTmp ( layout % fStencil % QQ ) ! potential on surface (link-wise) real ( kind = rk ) :: moleDens_w ( me % links ( iLevel )% nVals ) real ( kind = rk ) :: vel_w ( me % links ( iLevel )% nVals * 3 ), vel_b ( 3 ) integer :: bcVel_pos , bcMoleDens_pos , iLink , QQ , QQN real ( kind = rk ) :: ucx ! -------------------------------------------------------------------------- QQ = layout % fstencil % QQ QQN = layout % fstencil % QQN inv_moleDens = 1._rk / mixture % moleDens0LB ! position of boundary moleDensity in varSys bcMoleDens_pos = me % bc_states % moleDens % varPos ! Get potential_phy on boundary call varSys % method % val ( bcMoleDens_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % moleDens & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = moleDens_w ) ! convert physical moleDensity into LB potential moleDens_w = moleDens_w * inv_moleDens ! position of boundary velocity in varSys bcVel_pos = me % bc_states % velocity % varPos ! Get velocity call varSys % method % val ( bcVel_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % velocity & & % pntIndex % indexLvl ( iLevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = globBC % nElems ( iLevel ), & & res = vel_w ) ! convert physical velocity into LB velocity vel_w = vel_w / physics % fac ( iLevel )% vel do iLink = 1 , me % links ( iLevel )% nVals ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate moleDensity of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdfTmp ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) moleDens_f = sum ( pdfTmp ) ! velocity at boundary node vel_b = vel_w (( iLink - 1 ) * 3 + 1 : iLink * 3 ) !> Pre-calculate velocitiy terms ucx = dble ( layout % fStencil % cxDirRK ( 1 , iDir )) * vel_b ( 1 ) & & + dble ( layout % fStencil % cxDirRK ( 2 , iDir )) * vel_b ( 2 ) & & + dble ( layout % fStencil % cxDirRK ( 3 , iDir )) * vel_b ( 3 ) ! compute moleDensity on boundary (eq.18) moleDens_b = moleDens_w ( iLink ) ! velocity at boundary node vel_b = vel_w (( iLink - 1 ) * 3 + 1 : iLink * 3 ) ! compute equlibrium (according to eq.17) ! fEq_b is on boundary node feq_b = layout % weight ( iDir ) * moleDens_b * ( 1.0_rk + ucx * cs2inv ) ! feq_ff is of overnext fluid feq_f = layout % weight ( iDir ) * moleDens_f * ( 1.0_rk + ucx * cs2inv ) ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + ( pdfTmp ( iDir ) - feq_f ) end do !iLink end subroutine moleDens_nonEqExpol ! **************************************************************************** ! ! **************************************************************************** ! !> No comment yet! !! !! @TODO add comment !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine moleDens_neumann ( me , state , bcBuffer , globBC , levelDesc , tree , & & nSize , iLevel , sim_time , neigh , layout , & & fieldProp , varPos , nScalars , varSys , derVarPos , & & physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> Level descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! also determined in mus_bc_header_module integer :: iDir , posInBuffer , posInNeighBuf ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , moleDens_b real ( kind = rk ) :: feq_f , fneq_f , moleDens_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , moleDens_ff ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdfTmp ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! molefluxy on surface (link-wise) real ( kind = rk ) :: moleFlux_w ( me % links ( iLevel )% nVals ) integer :: bcVel_pos , iLink , QQ integer :: bcMoleFlux_pos real ( kind = rk ) :: normal ( 3 ), moleFlux_b real ( kind = rk ) :: vel_w ( me % links ( iLevel )% nVals * 3 ), vel_b ( 3 ) real ( kind = rk ) ucx ! -------------------------------------------------------------------------- !write(*,*) 'bclabel ', trim(me%label) QQ = layout % fStencil % QQ ! position of boundary moleflux variable in varSys bcMoleFlux_pos = me % bc_states % moleFlux % varPos ! Get potential_phy on boundary call varSys % method % val ( bcMoleFlux_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % moleFlux & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = moleFlux_w ) ! convert physical moleflux into Lattice unit moleFlux_w = moleFlux_w / physics % fac ( iLevel )% moleflux ! position of boundary velocity in varSys bcVel_pos = me % bc_states % velocity % varPos ! Get velocity call varSys % method % val ( bcVel_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % velocity & & % pntIndex % indexLvl ( iLevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = globBC % nElems ( iLevel ), & & res = vel_w ) ! convert physical velocity into LB velocity vel_w = vel_w / physics % fac ( iLevel )% vel do iLink = 1 , me % links ( iLevel )% nVals ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdfTmp ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) moleDens_f = sum ( pdfTmp ) ! velocity at boundary node vel_b = vel_w (( iLink - 1 ) * 3 + 1 : iLink * 3 ) !> Pre-calculate velocitiy terms ucx = dble ( layout % fStencil % cxDirRK ( 1 , iDir )) * vel_b ( 1 ) & & + dble ( layout % fStencil % cxDirRK ( 2 , iDir )) * vel_b ( 2 ) & & + dble ( layout % fStencil % cxDirRK ( 3 , iDir )) * vel_b ( 3 ) ! calulate potential of the overnext fluid neighbor element (_ff) posInNeighBuf = me % nonEqExpol ( iLevel )% posInNeighBuf ( iLink ) pdf_ff = me % neigh ( iLevel )% neighBufferPost ( 1 , & & ( posInNeighBuf - 1 ) * QQ + 1 : ( posInNeighBuf - 1 ) * QQ + QQ ) moleDens_ff = sum ( pdf_ff ) !write(*,*) 'normal ', globBC%elemLvl(iLevel)%normal%val(:, me%nonEqExpol(iLevel)%posInBCelems(iLink)) !write(*,*) 'normal Ind', globBC%elemLvl(iLevel)%normalInd%val(me%nonEqExpol(iLevel)%posInBCelems(iLink)) normal = globBC % elemLvl ( iLevel )% normal & & % val (:, me % nonEqExpol ( iLevel )% posInBCelems ( iLink )) moleFlux_b = moleFlux_w ( iLink ) & & * dot_product ( layout % fStencil % cxDirRK (:, iDir ), normal ) ! calulate moleDens on boundary moleDens_b = ( 4.0_rk * moleDens_f - moleDens_ff - 2.0_rk * moleFlux_b ) & & / 3.0_rk ! compute equlibrium (according to eq.17) ! fEq_b is on boundary fEq_b = layout % weight ( iDir ) * moleDens_b * ( 1.0_rk + ucx * cs2inv ) ! feq is of fluid fEq_f = layout % weight ( iDir ) * moleDens_f * ( 1.0_rk + ucx * cs2inv ) ! feq is of overnext fluid fEq_ff = layout % weight ( iDir ) * moleDens_ff * ( 1.0_rk + ucx * cs2inv ) ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdfTmp ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff ! KM: For straight boundary, qVal is 0.5 in consistent with ! second order extrapolation of potential fneq_b = 0.5_rk * fneq_f + 0.5_rk * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end subroutine moleDens_neumann ! **************************************************************************** ! end module mus_bc_nernstPlanck_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_bc_nernstplanck_module.f90.html"},{"title":"mus_scheme_layout_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_scheme_layout_module.f90~~EfferentGraph sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_scheme_layout_module.f90~~AfferentGraph sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_hrrinit_module.f90 mus_hrrInit_module.f90 sourcefile~mus_hrrinit_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012-2013, 2015-2018 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2013 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2018 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** ! !> author: Simon Zimny !! scheme_layout module, providing the scheme_layout datatype and the !! functionality to read the lua files and to set the predefined stencils. !! !! !! # Scheme Layout !! !! The layout includes all information about the stencil, the inverse !! directions, the prevailing directions and the weights. !! !! In MUSUBI one can choose among the following predefined layouts: !! !! -  'predefined_d3q19': !!    The D3Q19 model. The advection relaxation kernel for this model is highly !!    optimized. !! -  'predefined_d3q7': !!    The more simple D3Q7 model. The advection relaxation kernel for this !!    model is highly optimized. !! -  'Flekkoy': !!    The Flekkoy model consists of a D3Q6 stencil and is used for passive !!    scalar transport. !! !! In MUSUBI it is also possible to define a new layout in the lua file. This !! feature is implemented to test new layouts. In case one wants to run !! multiple simulations using this layout, it is highly recommended to !! implement a new kernel (the following files have to be extended: !! [[mus_flow_module]] and related modules in source/compute. !! !! Defining a new Layout !! To define a new layout one has to set `layout = 'new_stencil'`. To define the !! stencil the following information has to be provided: !! !!  -  the number of offsets (QQ) !!  -  the offsets (disc_vel) !!  -  the weights (weight) !!  -  the inverse directions (inv_dir) as integers pointing on the belonging !!     offsets !!  -  the prevailing directions (prev_dir) as reals giving the distance in the !!     different directions !! !! The following example shows how to define the standard D3Q19 as a new !! layout: !! !!```lua !! -- Scheme !! scheme = { !!  label = 'test', !!  layout = 'new_stencil', !!  -- Initial condition !!  initial_condition = { !!                       density = 1.0, !!                       velocityX = 0.0, !!                       velocityY = 0.0, !!                       velocityZ = 0.0 }, !!  -- Boundary conditions !!  boundary_condition = { !!  { label = 'wall', !!    kind = 'velocity_bounceback', !!    velocityX = 0.03, velocityY = 0.0, velocityZ = 0.0 }, !!  { label = 'wall', !!    kind = 'wall', !!    velocityX = 0.0, velocityY = 0.0, velocityZ = 0.0 } !!  }, !!  fluid = { relaxation_scheme = 'BGK', !!            omega = 1.8, !!            rho0 = 1.0 }, !!  -- Defining the new Stencil !!  stencil = { !!             QQ = 19, !!             disc_vel = { !!              {-1,0,0},{0,-1,0},{0,0,-1},{1,0,0},{0,1,0},{0,0,1},{0,-1,-1},{0,-1,1},{0,1,-1}, !!              {0,1,1},{-1,0,-1},{1,0,-1},{-1,0,1},{1,0,1},{-1,-1,0},{-1,1,0},{1,-1,0},{1,1,0}, !!              {0,0,0} !!             }, !!             weight = { !!              (1.0/18.0),(1.0/18.0),(1.0/18.0),(1.0/18.0),(1.0/18.0),(1.0/18.0),(1.0/36.0),(1.0/36.0),(1.0/36.0), !!              (1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0),(1.0/36.0), !!              (1.0/3.0) !!             }, !!             inv_dir = { !!                         4,  5,  6,  1,  2,  3, 10,  9,  8, !!                         7, 14, 13, 12, 11, 18, 17, 16, 15, !!                        19 !!             }, !!             prev_dir = { !!              {1.,0.,0.},{0.,1.,0.},{0.,0.,1.},{1.,0.,0.},{0.,1.,0.},{0.,0.,1.}, !!              {0.,0.5*math.sqrt(2.),0.5*math.sqrt(2.)},{0.,0.5*math.sqrt(2.),0.5*math.sqrt(2.)}, !!              {0.,0.5*math.sqrt(2.),0.5*math.sqrt(2.)},{0.,0.5*math.sqrt(2.),0.5*math.sqrt(2.)}, !!              {0.5*math.sqrt(2.),0.,0.5*math.sqrt(2.)},{0.5*math.sqrt(2.),0.,0.5*math.sqrt(2.)}, !!              {0.5*math.sqrt(2.),0.,0.5*math.sqrt(2.)},{0.5*math.sqrt(2.),0.,0.5*math.sqrt(2.)}, !!              {0.5*math.sqrt(2.),0.5*math.sqrt(2.),0.},{0.5*math.sqrt(2.),0.5*math.sqrt(2.),0.}, !!              {0.5*math.sqrt(2.),0.5*math.sqrt(2.),0.},{0.5*math.sqrt(2.),0.5*math.sqrt(2.),0.} !!             } !!  } !! } !!``` !! module mus_scheme_layout_module ! include treelm modules use mpi use env_module , only : rk , long_k , labelLen use tem_aux_module , only : tem_abort use tem_stencil_module , only : tem_stencilHeader_type , tem_loadStencil , & & tem_identify_inverseDirections , & & tem_identify_prevailDirections , & & tem_stencil_zeroPos , & & tem_create_stencil , & & grw_stencilHeaderArray_type , init , & & destroy , truncate use tem_logging_module , only : logUnit use tem_param_module , only : div1_3 , div1_18 , div1_36 , div1_54 , div1_216 ,& & div2_27 , div8_27 , div1_4 , div1_8 , div1_6 , & & div2_3 , div1_9 , div4_9 , div1_24 , div1_2 use tem_dyn_array_module , only : dyn_labelArray_type , init , append , destroy use tem_grow_array_module , only : grw_intArray_type , init , append , destroy , & & truncate , grw_longArray_type use tem_comm_env_module , only : tem_comm_env_type use tem_tools_module , only : tem_horizontalSpacer ! include aotus modules use aotus_module , only : flu_state , aot_get_val use aot_table_module , only : aot_table_open , aot_table_close , aot_table_length use aot_out_module , only : aot_out_type , aot_out_val ! include musubi modules use mus_moments_type_module , only : mus_moment_type use mus_scheme_derived_quantities_module , only : mus_scheme_derived_quantities_type implicit none private public :: mus_scheme_layout_type public :: mus_load_newLayout public :: mus_init_layout public :: mus_finalize_layout public :: mus_destroy_stencil public :: mus_define_layout public :: mus_define_d3q19 public :: mus_define_d3q27 public :: mus_define_d3q7 public :: mus_define_d3q6 public :: mus_define_d2q9 public :: mus_define_d1q3 public :: mus_weights_out public :: mus_set_weights_d1q3 public :: mus_set_weights_d2q9 public :: mus_set_weights_d3q6 public :: mus_set_weights_d3q7 public :: mus_set_weights_d3q19 public :: mus_set_weights_d3q27 !> data structure containing all information related to the !! compute stencil. Several stencils can be defined. !! [[mus_moments_module]] Moments are directly related to the !! stencil layout and are therefore defined here type mus_scheme_layout_type !> fluid stencil same as stencil(1) type ( tem_stencilHeader_type ) :: fStencil !> number of stencils used in this scheme integer :: nStencils !> Temporary growing array of stencil !! It is copied to stencil(:) and destroyed, where this is destroyed? type ( grw_stencilHeaderArray_type ) :: grwStencil !> The list of stencil types, the stencils for the individual schemes !! is ordered as follows: !! -------------------------------------------------------------------------------------- !! | flSt | bcSt1_field1 ... bcStN_field1 ... bcSt1_fieldM ... bcStN_fieldM | addSt ... | !! -------------------------------------------------------------------------------------- !! Unique stencil label for boundary stencils are created with boundary label !! and stencil%cxDir therefore each stencil is limited to one boundary type type ( tem_stencilHeader_type ), allocatable :: stencil (:) !> dynamic array of labels created from stencil directions to create unique !! growing array of grwStencil type ( dyn_labelArray_type ) :: stencil_labels !> position of fluid stencil in grwStencil integer :: fStencil_pos !> The weights for the different discrete velocities real ( kind = rk ), allocatable :: weight (:) !> Lattice speed of sound for fStencil !! $\\sum_i (weight_i*cx_i*cx_i) = c_s&#94;2 I real ( kind = rk ) :: cs !> Prevailing directions real ( kind = rk ), allocatable :: prevailDir (:,:) !> Moment space definition type ( mus_moment_type ) :: moment !> New stencil definition loaded from config logical :: new_stencil = . false . !> derive quantities that depends on the layout such as velocity, pdf_eq, etc.. type ( mus_scheme_derived_quantities_type ) :: quantities end type mus_scheme_layout_type contains ! ****************************************************************************** ! !> load a new stencil definition from the lua file !! !! - a label !! - the stencil (predefined or new) !! - for a new defined stencil ( weights, inverse directions, prevailing !!   directions ) !! subroutine mus_load_newLayout ( me , parent_handle , conf ) ! --------------------------------------------------------------------------- integer , intent ( in ), optional :: parent_handle type ( mus_scheme_layout_type ) :: me type ( flu_State ) :: conf ! --------------------------------------------------------------------------- ! defining local variables integer :: stencil_handle integer :: weight_handle integer :: nWeights , iWeight integer :: invDir_handle integer :: iInvDir , nInvDirs integer :: prevDir_handle integer :: iPrevDir , nPrevDirs integer :: prevDirCoo_handle integer :: iPrevDirCoo integer :: iError ! --------------------------------------------------------------------------- if ( present ( parent_handle )) then ! open stencil table call aot_table_open ( L = conf , & & parent = parent_handle , & & thandle = stencil_handle , & & key = 'stencil' ) else ! open stencil table call aot_table_open ( L = conf , thandle = stencil_handle , key = 'stencil' ) end if ! If a new stencil is defined, the flag is set to true to ! differentiate between predefined and new stencil in initialization if ( stencil_handle > 0 ) then me % new_stencil = . true . write ( logUnit ( 1 ), * ) 'Reading the new Layout...' me % fStencil % label = 'new_stencil' ! Get the number of dimensions in which the stencil is defined call aot_get_val ( L = conf , & & thandle = stencil_handle , & & val = me % fStencil % nDims , & & ErrCode = iError , & & key = 'nDims' , & & default = - 1 ) ! load the stencil call tem_loadStencil ( stencil = me % fStencil , & & parent_handle = stencil_handle , & & conf = conf ) ! load additional information like weights, inv. directions, etc. call aot_table_open ( L = conf , & & parent = stencil_handle , & & thandle = weight_handle , & & key = 'weight' ) nWeights = aot_table_length ( L = conf , thandle = weight_handle ) if ( nWeights == me % fStencil % QQ ) then allocate ( me % weight ( nWeights )) do iWeight = 1 , nWeights call aot_get_val ( L = conf , & & thandle = weight_handle , & & val = me % weight ( iWeight ), & & ErrCode = iError , & & pos = iWeight ) end do call aot_table_close ( L = conf , thandle = weight_handle ) else write ( logUnit ( 1 ), * ) 'The number of defined weights does not ' // & & 'match the number of discrete velocities.' write ( logUnit ( 1 ), * ) nWeights , ' vs. ' , me % fStencil % QQ call tem_abort () end if call aot_table_open ( L = conf , & & parent = stencil_handle , & & thandle = invDir_handle , & & key = 'inv_dir' ) nInvDirs = aot_table_length ( L = conf , thandle = invDir_handle ) if ( nInvDirs == me % fStencil % QQ ) then allocate ( me % fStencil % cxDirInv ( nInvDirs )) do iInvDir = 1 , nInvDirs call aot_get_val ( L = conf , & & thandle = invDir_handle , & & val = me % fStencil % cxDirInv ( iInvDir ), & & ErrCode = iError , & & pos = iInvDir ) end do call aot_table_close ( L = conf , thandle = invDir_handle ) else call tem_identify_inverseDirections ( me % fStencil % cxDirInv , & & me % fStencil % cxDir ) end if call aot_table_open ( L = conf , & & parent = stencil_handle , & & thandle = prevDir_handle , & & key = 'prev_dir' ) nPrevDirs = aot_table_length ( L = conf , thandle = prevDir_handle ) if ( nPrevDirs > 0 ) then allocate ( me % prevailDir ( 3 , nPrevDirs )) do iPrevDir = 1 , nPrevDirs call aot_table_open ( L = conf , & & parent = prevDir_handle , & & thandle = prevDirCoo_handle , & & pos = iPrevDir ) do iPrevDirCoo = 1 , 3 call aot_get_val ( L = conf , & & thandle = prevDirCoo_handle , & & val = me % prevailDir ( iPrevDirCoo , iPrevDir ),& & ErrCode = iError , & & pos = iPrevDirCoo ) end do call aot_table_close ( L = conf , thandle = prevDirCoo_handle ) end do call aot_table_close ( L = conf , thandle = prevDir_handle ) else call tem_identify_prevailDirections ( me % prevailDir , & & me % fStencil % cxDir ) end if me % fStencil % restPosition = tem_stencil_zeroPos ( me % fStencil ) write ( logUnit ( 1 ), * ) 'A new stencil has been defined successfully.' if ( me % fStencil % nDims <= 0 ) then write ( logUnit ( 1 ), * ) 'Error: number of dimensions is not given for ' // & & 'the stencil' write ( logUnit ( 1 ), * ) 'Please define in the configuration file as ' write ( logUnit ( 1 ), * ) '  stencil = { nDims = 3, weights = ... }' call tem_abort end if end if end subroutine mus_load_newLayout ! ****************************************************************************** ! ! ****************************************************************************** ! !> Dump the weights in lua format. !! !! The style is: !! `weights = {w1, w2, ... , wN}` !! subroutine mus_weights_out ( me , conf ) ! --------------------------------------------------------------------------- !> weights real ( kind = rk ), intent ( in ) :: me (:) type ( aot_out_type ) :: conf ! --------------------------------------------------------------------------- call aot_out_val ( put_conf = conf , & & vname = 'weight' , & & val = me , & & max_per_line = 2 ) end subroutine mus_weights_out ! ****************************************************************************** ! ! ****************************************************************************** ! !> Initialize growing array of stencils !! subroutine mus_init_layout ( layout ) ! --------------------------------------------------------------------------- !> musubi schemes layout type type ( mus_scheme_layout_type ), intent ( inout ) :: layout ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Initializing stencil array: ' ! Init is explicitly called here to clear the eventuellay used arrays call init ( me = layout % grwStencil ) call init ( me = layout % stencil_labels ) end subroutine mus_init_layout ! ****************************************************************************** ! ! ****************************************************************************** ! !> This routine finialize grwStencil by truncating stencil elem arrays and !! set stencil%nElems subroutine mus_finalize_layout ( layout , nElemsInTree , minLevel , maxLevel , proc ) ! --------------------------------------------------------------------------- !> scheme layout type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> fluid tree from mesh integer , intent ( in ) :: nElemsInTree !> min and max level integer , intent ( in ) :: minLevel , maxLevel !> mpi communication type type ( tem_comm_env_type ), intent ( in ) :: proc ! --------------------------------------------------------------------------- integer :: iStencil , iLevel , iProc integer , allocatable :: nElems_totalStencil (:) integer :: nStencils_all ( proc % comm_size ), nStencils_total integer :: offset ( proc % comm_size ) integer :: iErr , charType , stencilPos logical :: wasAdded type ( dyn_labelArray_type ) :: stencil_labels type ( grw_longArray_type ) :: nElems character ( len = labelLen ), allocatable :: stencil_labels_total (:) ! --------------------------------------------------------------------------- ! truncate stencil array call truncate ( me = layout % grwStencil ) write ( logUnit ( 5 ), '(a)' ) ' Finalizing stencils...' allocate ( layout % stencil ( layout % grwStencil % nVals ) ) layout % nStencils = layout % grwStencil % nVals ! copy stencil from growing array to allocatable array layout % stencil (:) = layout % grwStencil % val ( 1 : layout % nStencils ) ! update fluid stencil layout % fStencil = layout % stencil ( 1 ) ! detroy growing array call destroy ( me = layout % grwStencil ) do iStencil = 1 , layout % nStencils ! if stencil use all = .true. use all elements in tree ! else use stencil elements if ( layout % stencil ( iStencil )% useAll ) then layout % stencil ( iStencil )% nElems = nElemsInTree else call truncate ( me = layout % stencil ( iStencil )% elem ) layout % stencil ( iStencil )% nElems = layout % stencil ( iStencil )% elem % nVals do iLevel = minLevel , maxLevel call truncate ( me = layout % stencil ( iStencil )% elemLvl ( iLevel ) ) end do end if end do ! gather number of stencils across process call MPI_GATHER ( layout % nStencils , 1 , MPI_INTEGER , nStencils_all , 1 , & & MPI_INTEGER , proc % root , proc % comm , iErr ) if ( proc % rank == proc % root ) then ! total number of stencils nStencils_total = sum ( nStencils_all ) ! number of elements in each stencil in each process allocate ( nElems_totalStencil ( nStencils_total ) ) ! stencil labels allocate ( stencil_labels_total ( nStencils_total ) ) ! displacement to gather nElems vector offset ( 1 ) = 0 do iProc = 2 , proc % comm_size offset ( iProc ) = offset ( iProc - 1 ) + nStencils_all ( iProc - 1 ) end do else allocate ( nElems_totalStencil ( 0 ) ) allocate ( stencil_labels_total ( 0 ) ) end if ! gather number of elements per stencil on each process call MPI_GATHERV ( layout % stencil (:)% nElems , layout % nStencils , MPI_INTEGER , & & nElems_totalStencil , nStencils_all , offset , MPI_INTEGER , proc % root , & & proc % comm , iErr ) ! cast character array type to gather stencil labels call MPI_TYPE_CONTIGUOUS ( labelLen , MPI_CHARACTER , charType , iErr ) call MPI_TYPE_COMMIT ( charType , iErr ) ! gather stencil label to create unique stencil list call MPI_GATHERV ( layout % stencil_labels % val (:), layout % nStencils , charType ,& & stencil_labels_total , nStencils_all , offset , charType , proc % root , & & proc % comm , iErr ) if ( proc % rank == proc % root ) then ! create unique stencil labels and reduce nElems on each stencil do iProc = 1 , proc % comm_size do iStencil = 1 , nStencils_all ( iProc ) call append ( me = stencil_labels , & & val = stencil_labels_total ( offset ( iProc ) + iStencil ),& & pos = stencilPos , & & wasAdded = wasAdded ) if ( wasAdded ) then call append ( me = nElems , & & val = int ( nElems_totalStencil ( offset ( iProc ) + iStencil ),& & kind = long_k ) ) else nElems % val ( stencilPos ) = nElems % val ( stencilPos ) + & & int ( nElems_totalStencil ( offset ( iProc ) + iStencil ), kind = long_k ) end if end do end do write ( logUnit ( 5 ), '(a,i0)' ) ' Total Number of stencils: ' , stencil_labels % nVals do iStencil = 1 , stencil_labels % nVals write ( logUnit ( 5 ), '(a,i2,2a)' ) ' iStencil: ' , iStencil , & & ', label: ' , trim ( stencil_labels % val ( iStencil )) write ( logUnit ( 5 ), '(a,i0)' ) ' nElems: ' , nElems % val ( iStencil ) end do call destroy ( stencil_labels ) call destroy ( nElems ) end if end subroutine mus_finalize_layout ! ****************************************************************************** ! ! ****************************************************************************** ! !> Destroy the stencil !! subroutine mus_destroy_stencil ( stencil ) ! --------------------------------------------------------------------------- !>musubi schemes stencil type type ( tem_stencilHeader_type ), allocatable , intent ( out ) :: stencil (:) ! --------------------------------------------------------------------------- write ( logUnit ( 5 ), * ) 'Deallocating stencil layout...' if ( allocated ( stencil ) ) deallocate ( stencil ) end subroutine mus_destroy_stencil ! ****************************************************************************** ! ! **************************************************************************** ! !> This routine defines layout for predefined stencils subroutine mus_define_layout ( layout , stencilName , nElems ) ! ------------------------------------------------------------------------ ! !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> Name of the stencil to create character ( len =* ), intent ( in ) :: stencilName !> number of elements use this layout integer , intent ( in ) :: nElems ! ------------------------------------------------------------------------ ! ! create fStencil select case ( trim ( stencilName ) ) case ( 'd2q9' ) call mus_define_d2q9 ( layout = layout , & & nElems = nElems ) case ( 'd2q5' ) call mus_define_d2q5 ( layout = layout , & & nElems = nElems ) case ( 'd3q19' ) call mus_define_d3q19 ( layout = layout , & & nElems = nElems ) case ( 'd3q13' ) call mus_define_d3q13 ( layout = layout , & & nElems = nElems ) case ( 'd3q27' ) call mus_define_d3q27 ( layout = layout , & & nElems = nElems ) case ( 'd3q7' ) call mus_define_d3q7 ( layout = layout , & & nElems = nElems ) case ( 'd3q6' , 'flekkoy' ) call mus_define_d3q6 ( layout = layout , & & nElems = nElems ) case ( 'd1q3' ) call mus_define_d1q3 ( layout = layout , & & nElems = nElems ) case default call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'The chosen scheme layout is not available. ' write ( logUnit ( 1 ), * ) 'STOPPING!' write ( logUnit ( 1 ), * ) 'Choose one of:  ' write ( logUnit ( 1 ), * ) '  - d2q9 ' write ( logUnit ( 1 ), * ) '  - d2q5 ' write ( logUnit ( 1 ), * ) '  - d3q13 ' write ( logUnit ( 1 ), * ) '  - d3q19 ' write ( logUnit ( 1 ), * ) '  - d3q27 ' write ( logUnit ( 1 ), * ) '  - d3q7  ' write ( logUnit ( 1 ), * ) '  - d3q6  ' write ( logUnit ( 1 ), * ) '  - d1q3  ' call tem_abort () end select ! if ( .not. allocated( layout%weight ) & ! &  allocate( layout%weight( layout%fStencil%QQ ) ) end subroutine mus_define_layout ! **************************************************************************** ! ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d3q13 stencil. !! subroutine mus_define_d3q13 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd3q13' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) if ( . not . allocated ( layout % weight ) ) & & allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d3q13 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d3q13 ! ****************************************************************************** ! ! ****************************************************************************** ! subroutine mus_set_weights_d3q13 ( weights ) real ( kind = rk ) :: weights ( 13 ) weights ( 1 : 12 ) = div1_24 weights ( 13 ) = div1_2 end subroutine mus_set_weights_d3q13 ! ****************************************************************************** ! ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d3q19 stencil. !! subroutine mus_define_d3q19 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd3q19' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) if ( . not . allocated ( layout % weight ) ) & & allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d3q19 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d3q19 ! ****************************************************************************** ! ! ****************************************************************************** ! subroutine mus_set_weights_d3q19 ( weights ) real ( kind = rk ) :: weights ( 19 ) weights ( 1 : 6 ) = div1_18 weights ( 7 : 18 ) = div1_36 weights ( 19 ) = div1_3 end subroutine mus_set_weights_d3q19 ! ****************************************************************************** ! ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d3q27 stencil. !! subroutine mus_define_d3q27 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd3q27' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) if ( . not . allocated ( layout % weight ) ) & & allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d3q27 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d3q27 ! ****************************************************************************** ! subroutine mus_set_weights_d3q27 ( weights ) real ( kind = rk ) :: weights ( 27 ) weights ( 1 : 6 ) = div2_27 weights ( 7 : 18 ) = div1_54 weights ( 19 : 26 ) = div1_216 weights ( 27 ) = div8_27 end subroutine mus_set_weights_d3q27 ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d3q7 stencil. !! subroutine mus_define_d3q7 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd3q7' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d3q7 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d3q7 ! ****************************************************************************** ! subroutine mus_set_weights_d3q7 ( weights ) real ( kind = rk ) :: weights ( 7 ) weights ( 1 : 6 ) = div1_8 weights ( 7 ) = div1_4 end subroutine mus_set_weights_d3q7 ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d3q6 !! layout%fStencil, used by the Flekkoy model of passive scalar transport. !! subroutine mus_define_d3q6 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd3q6' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) allocate ( layout % weight ( layout % fStencil % QQ ) ) call mus_set_weights_d3q6 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d3q6 ! ****************************************************************************** ! subroutine mus_set_weights_d3q6 ( weights ) real ( kind = rk ) :: weights ( 6 ) weights ( 1 : 6 ) = div1_6 end subroutine mus_set_weights_d3q6 ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d2q9 stencil. !! subroutine mus_define_d2q9 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd2q9' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) if ( . not . allocated ( layout % weight ) ) & & allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d2q9 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d2q9 ! ****************************************************************************** ! ! ****************************************************************************** ! subroutine mus_set_weights_d2q9 ( weights ) real ( kind = rk ) :: weights ( 9 ) weights ( 1 : 4 ) = div1_9 weights ( 5 : 8 ) = div1_36 weights ( 9 ) = div4_9 end subroutine mus_set_weights_d2q9 ! ****************************************************************************** ! ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d2q5 stencil. !! subroutine mus_define_d2q5 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd2q5' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) if ( . not . allocated ( layout % weight ) ) & & allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d2q5 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d2q5 ! ****************************************************************************** ! ! ****************************************************************************** ! subroutine mus_set_weights_d2q5 ( weights ) real ( kind = rk ) :: weights ( 5 ) weights ( 1 : 4 ) = div1_4 weights ( 5 ) = 0.0_rk end subroutine mus_set_weights_d2q5 ! ****************************************************************************** ! ! ****************************************************************************** ! !> This subroutine sets the parameters for the predefined d2q9 stencil. !! subroutine mus_define_d1q3 ( layout , nElems ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout !> number of elements use this layout integer , intent ( in ) :: nElems ! --------------------------------------------------------------------------- ! fill the tem_stencilHeader_type call tem_create_stencil ( layout % fStencil , 'd1q3' ) ! setting the prevailing directions (normalized major directions without ! sign) call tem_identify_prevailDirections ( layout % prevailDir , & & layout % fStencil % cxDir ) allocate ( layout % weight ( layout % fStencil % QQ )) call mus_set_weights_d1q3 ( layout % weight ) layout % fStencil % useAll = . true . layout % fStencil % nElems = nElems layout % fStencil % restPosition = tem_stencil_zeroPos ( layout % fStencil ) ! speed of sound layout % cs = mus_calculate_speed_of_sound ( layout ) end subroutine mus_define_d1q3 ! ****************************************************************************** ! subroutine mus_set_weights_d1q3 ( weights ) real ( kind = rk ) :: weights ( 3 ) ! Weights from [1]  E. M. Viggen, The lattice Boltzmann method in ! acoustics, Scandinavian Symposium on Physical Acoustics, pp. 1–5, Mar. ! 2010. weights ( 1 : 2 ) = div1_6 weights ( 3 ) = div2_3 end subroutine mus_set_weights_d1q3 ! ****************************************************************************** ! ! ****************************************************************************** ! !> Calculate lattice speed of sound for given stencil function mus_calculate_speed_of_sound ( layout ) result ( c_sound ) ! --------------------------------------------------------------------------- !> scheme layout for pdf state type ( mus_scheme_layout_type ), intent ( inout ) :: layout real ( kind = rk ) :: c_sound ! --------------------------------------------------------------------------- c_sound = sqrt ( sum ( layout % fStencil % cxcx ( 1 ,:) * layout % weight (:) )) end function mus_calculate_speed_of_sound ! ****************************************************************************** ! end module mus_scheme_layout_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_scheme_layout_module.f90.html"},{"title":"mus_transport_var_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_transport_var_module.f90~~EfferentGraph sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_transport_var_module.f90~~AfferentGraph sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! *****************************************************************************! !> author: Kannan Masilamani !! Module containing subroutines for building MUSUBI specific transport !! variables to use in compute kernels and source update !! module mus_transport_var_module use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer ! include treelm modules use env_module , only : rk , long_k , labelLen , solSpecLen , newUnit use tem_aux_module , only : tem_abort use tem_varSys_module , only : tem_varSys_type , & & tem_varSys_append_derVar , & & tem_varSys_proc_point , & & tem_varSys_proc_element , & & tem_varSys_proc_setParams , & & tem_varSys_proc_getParams , & & tem_varSys_proc_setupIndices , & & tem_varSys_proc_getValOfIndex , & & tem_varSys_dump use tem_varMap_module , only : tem_possible_variable_type , & & init , append , truncate , & & tem_variable_loadMapping use tem_stringKeyValuePair_module , only : init , truncate , & & grw_stringKeyValuePairArray_type use tem_stencil_module , only : tem_stencilHeader_type use treelmesh_module , only : treelmesh_type use tem_geometry_module , only : tem_BaryOfID use tem_logging_module , only : logUnit use tem_operation_module , only : tem_indexLvl_type use tem_tools_module , only : tem_horizontalSpacer use tem_construction_module , only : tem_levelDesc_type use tem_dyn_array_module , only : PositionOfVal ! include musubi modules use mus_scheme_header_module , only : mus_scheme_header_type ! include aotus modules use aotus_module , only : flu_State use aot_out_module , only : aot_out_type , aot_out_open , aot_out_close , & & aot_out_val , aot_out_toChunk implicit none private public :: mus_transport_var_type public :: mus_create_poss_transVar public :: mus_load_transport_var public :: mus_init_transport_var ! ***************************************************************************! !> Description contains index to access value using variable function !! pointer type mus_transport_op_type !> Position of data variable provided in config file in the varSys integer :: data_varpos !> Indices for points for nElems_solve (nFluids + nGhostsFromCoarser). !! Order of index matches levelDesc%total list, required for setup_index, !! getvalof_Index type ( tem_indexLvl_type ) :: pntIndex end type mus_transport_op_type ! ***************************************************************************! ! ***************************************************************************! !> Description of musubi transport variable type type mus_transport_var_type !> Contains variable pntIndex to setup_index and getValOfIndex !! Size: varDict%nVals type ( mus_transport_op_type ), allocatable :: method (:) !> Dictionary of transport variable with !! varDict%val()%key is the name of transport variable and !! varDict%val()%value is the name of variable provided for the key type ( grw_stringKeyValuePairArray_type ) :: varDict end type mus_transport_var_type ! ***************************************************************************! contains ! ***************************************************************************! !> Routine initialize possible transport variable depends on scheme kind subroutine mus_create_poss_transVar ( poss_transVar , schemeHeader ) ! --------------------------------------------------------------------------! !> possible transport variables type ( tem_possible_variable_type ), intent ( out ) :: poss_transVar !> Identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! --------------------------------------------------------------------------! write ( logUnit ( 10 ), * ) 'Creating possible transport variables ' call init ( me = poss_transVar , length = 2 ) select case ( trim ( schemeHeader % kind )) case ( 'passive_scalar' , 'nernst_planck' ) call append ( me = poss_transVar , & & varName = 'transport_velocity' , & & nComponents = 3 ) case default write ( logUnit ( 1 ), * ) 'No possible transport variable defined for ' & & // 'scheme kind: ' // trim ( schemeHeader % kind ) end select call truncate ( poss_transVar ) end subroutine mus_create_poss_transVar ! ***************************************************************************! ! ***************************************************************************! !> Routine load musubi transport variables subroutine mus_load_transport_var ( me , possVars , conf , parent , varSys , & & schemeHeader ) ! --------------------------------------------------------------------------! !> transport variable type to initialize type ( mus_transport_var_type ), intent ( out ) :: me !> possible transport variables type ( tem_possible_variable_type ), intent ( in ) :: possVars !> flu state type ( flu_State ) :: conf !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> Global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! --------------------------------------------------------------------------! integer :: iVar ! --------------------------------------------------------------------------! write ( logUnit ( 1 ), * ) 'Loading transport variables' ! initialize growing array stringKeyValuePair call init ( me = me % varDict ) ! load the transport variables do iVar = 1 , possVars % varName % nVals call tem_variable_loadMapping ( & & expectedName = possVars % varName % val ( iVar ), & & conf = conf , & & thandle = parent , & & varDict = me % varDict , & & varSys = varSys , & & nComp = possVars % nComponents % val ( iVar ) ) end do select case ( trim ( schemeHeader % kind )) case ( 'passive_scalar' , 'nernst_planck' ) if ( me % varDict % nVals /= 1 ) then write ( logUnit ( 1 ), * ) 'Error: transport_velocity' & & // ' variable is not defined for lbm_ps' call tem_abort () end if end select call truncate ( me = me % varDict ) end subroutine mus_load_transport_var ! ***************************************************************************! ! ***************************************************************************! !> Initialize transport variable by calling setupIndices for every variable !! and store pntIndex subroutine mus_init_transport_var ( me , varSys , tree , nElems_solve , levelDesc ) ! -------------------------------------------------------------------------- !> transport variable to fill in type ( mus_transport_var_type ), intent ( inout ) :: me !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> Number of elements to solve in all levels !! nFluids + nGhosts integer , intent ( in ) :: nElems_solve ( tree % global % minLevel :) !> Level descriptors type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( tree % global % minLevel :) ! -------------------------------------------------------------------------- integer :: iLevel , iElem , iVar integer :: nSolve , minLevel , maxLevel real ( kind = rk ), allocatable :: bary (:,:) integer , allocatable :: idx (:) integer :: data_varPos ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'Initializing transport variables ...' ! immediately exit this routine if there are no transport variables if ( me % varDict % nVals == 0 ) then write ( logUnit ( 1 ), * ) 'No active transport variables' return else allocate ( me % method ( me % varDict % nVals )) end if do iVar = 1 , me % varDict % nVals data_varPos = PositionOfVal ( me = varSys % varName , & & val = trim ( me % varDict % val ( iVar )% value ) ) if ( data_varPos > 0 ) then me % method ( iVar )% data_varPos = data_varPos else write ( logUnit ( 1 ), * ) 'Error: variable ' & & // trim ( me % varDict % val ( iVar )% value ) & & // ' is not added to variable system' call tem_abort () end if end do minLevel = tree % global % minLevel maxLevel = tree % global % maxLevel write ( logunit ( 10 ), * ) ' setup indices for transport var' do ilevel = minlevel , maxlevel write ( logunit ( 10 ), * ) 'ilevel: ' , ilevel nsolve = nelems_solve ( ilevel ) ! gets barycenter of all elements to solve i.e fluid+ghost to ! access transport variable inside compute kernel and source update allocate ( bary ( nSolve , 3 )) do iElem = 1 , nSolve bary ( iElem , :) = tem_BaryOfId ( tree , levelDesc ( iLevel )% total ( iElem )) end do allocate ( idx ( nSolve )) do iVar = 1 , me % varDict % nVals idx = 0 data_varPos = me % method ( iVar )% data_varPos ! set params call varSys % method % val ( data_varPos )% set_params ( & & varSys = varSys , & & instring = 'isSurface = false' ) call varSys % method % val ( data_varPos )% setup_indices ( & & varSys = varSys , & & point = bary , & & iLevel = iLevel , & & tree = tree , & & nPnts = nSolve , & & idx = idx ) call append ( me % method ( iVar )% pntIndex % indexLvl ( iLevel ), idx ) end do !iVar deallocate ( idx ) deallocate ( bary ) end do !iLevel end subroutine mus_init_transport_var ! ***************************************************************************! end module mus_transport_var_module ! *****************************************************************************!","tags":"","loc":"sourcefile/mus_transport_var_module.f90.html"},{"title":"mus_geom_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_geom_module.f90~~EfferentGraph sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_geom_module.f90~~AfferentGraph sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_geom_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012, 2014 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2013-2016, 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013 Monika Harlacher <monika.harlacher@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains the definition of geometry type and routines to !! geometry information like mesh, boundary, immersed_boundary and restart module mus_geom_module ! include treelm modules use env_module , only : rk , long_k , globalMaxLevels use tem_global_module , only : tem_global_mesh_read use tem_property_module , only : prp_hasBnd , prp_hasQVal use treelmesh_module , only : treelmesh_type , load_tem use tem_bc_prop_module , only : tem_bc_prop_type , init_tem_bc_prop , & & load_tem_bc_qVal use tem_geometry_module , only : tem_build_treeToProp_pointer use tem_solveHead_module , only : tem_solveHead_type use tem_timeControl_module , only : tem_timeControl_start_at_sim use tem_restart_module , only : tem_restart_type , tem_load_restart use tem_comm_env_module , only : tem_comm_env_type use tem_simControl_module , only : tem_simControl_type use tem_tools_module , only : tem_horizontalSpacer use tem_logging_module , only : logUnit ! include musubi modules use mus_geomIncrHead_module , only : mus_geomIncrHead_type , & & mus_geomIncrHead_load use mus_IBM_module , only : mus_IBM_globType , mus_load_IBM implicit none private public :: mus_geom_type public :: mus_build_posInProp public :: mus_load_geom public :: mus_load_bc_data !> Geometric information and definitions type mus_geom_type !> tree data type type ( treelmesh_type ) :: tree !> boundary information as stored on disk type ( tem_bc_prop_type ) :: boundary !> The header type containing all the geometry increase information type ( mus_geomIncrHead_type ), allocatable :: geomIncr (:) !> Logical to define whether geometry increase is active or not logical :: dynamicGeom = . false . !> Tree element position in the boundary_ID( nDir, nElems) in bc_prop_type !! it has a size of tree%nElems !! How to use: !! do iElem = 1, tree%nElems !!   posInBndID = posInBndID( iElem ) !!   ! current element has boundary only if posInBndID>0 !!   ! else posInBndID = -1 !!   if (posInBnd > 0 ) !!     bnd_ID(1:nDir) = bc_prop%boundary_ID( 1:nDir, posInBndID ) !!   end if !! end do integer , allocatable :: posInBndID (:) !> Tree element position in the qVal( nDir, nElems) in bc_prop_type !! it has a size of tree%nElems !! How to use: !! do iElem = 1, tree%nElems !!   posInQVal = posInQVal( iElem ) !!   ! current element has qVal if posInQVal>0 else posInQVal = -1 !!   if (posInQVal > 0 ) !!     qVal(1:nDir) = bc_prop%qVal( 1:nDir, posInQVal ) !!   end if !! end do integer , allocatable :: posInQVal (:) !> tree element position in level descriptor total list !! it has a size of tree%nElems !! How to use: !! do iElem = 1, tree%nElems !!   treeID = tree%treeID( iElem ) !!   level = tem_levelOf( treeID ) !!   posInTotal = levelPointer( iElem ) !!   treeID = LevelDesc( iLevel )%total( posInTotal ) !! end do integer , allocatable :: levelPointer (:) !> Boundary element poisition in the levelwise globBC%elemLvl(:)%elem%val !! It has a size of geometry%boundary%property%nElems. !! It is used in tracking to extract value stored in boundary types. !! Hot to use this access normal direction of boundary element: !! do iElem = 1, tree%nElems !!   level = tem_levelOf( treeID ) !!   posInBndID = posInBndID(iElem) !!   if (posInBndID > 0) then !!     BCIDs = bc_prop%boundary_ID(:, posInBndID) !!     minBCID = minval(BCIDs, BCIDs > 0) !!     posInBcElem = bcLevelPointer(posInBndID) !!     normal = globBC%elemLvl(iLevel)%normal(posInBcElem) !!   end if !! end do integer , allocatable :: bcLevelPointer (:) !> Minimum bcID for each boundary element. !! if a element has more than one boundary then use minBcID which depends !! on boundary order in seeder configuration. integer , allocatable :: minBcID (:) !> immersed boundary data type ( mus_IBM_globType ) :: globIBM !> Contains Forces on boundary elements computed using momentum exchange !! method. This will be used to derive_bndForce routine to compute force !! of certain boundaries. !! Forces are stored in level-independent fashion as geometry%boundaryID !! loaded from mesh files. !! Dim1: geometry%boundaryi%property%nElems !! Dim2: 3 real ( kind = rk ), allocatable :: bndForce (:,:) !> Contains Moments on boundary elements computed using momentum exchange !! method. This will be used to derive_bndMoment routine to compute moment !! of certain boundaries. !! Forces are stored in level-independent fashion as geometry%boundaryID !! loaded from mesh files. !! Dim1: geometry%boundaryi%property%nElems !! Dim2: 3 real ( kind = rk ), allocatable :: bndMoment (:,:) end type mus_geom_type contains ! ************************************************************************** ! !> This routine load all geometry related datas like mesh, boundary !! and immersed_boundary. Restart is also loaded here because mesh is loaded !! in tem_load_restart if restart read is defined. subroutine mus_load_geom ( me , restart , solverHead , simControl , proc , & & scaleFactor , initial_balance ) ! -------------------------------------------------------------------------- !< contains geometry information which are loaded in this routine type ( mus_geom_type ), intent ( out ) :: me !> contains restart information type ( tem_restart_type ), intent ( out ) :: restart !> contains general description of the solver including flu_state type ( tem_solveHead_type ), intent ( inout ) :: solverHead !> contains simulation time control information type ( tem_simControl_type ), intent ( inout ) :: simControl !> contains MPI communication environment type ( tem_comm_env_type ), intent ( in ) :: proc !> Temporal scaling factor for multilevel mesh integer , intent ( in ) :: scaleFactor !> If true, do initial balancing using level_weights logical , intent ( in ) :: initial_balance ! -------------------------------------------------------------------------- integer :: iLevel , minLevel , maxLevel real ( kind = rk ) :: level_weights ( globalMaxLevels ) ! -------------------------------------------------------------------------- ! ------------------------------------------------------------------------- !  Load mesh                                                             ! ! ------------------------------------------------------------------------- ! First check, if we are starting from a restart ! KJ: Now the restart is read from initial conditions, which are loaded ! much later than the config in the process flow call tem_load_restart ( me = restart , & & conf = solverHead % conf ( 1 ), & & tree = me % tree , & & timing = simControl % now , & & globProc = proc ) if ( restart % controller % readRestart ) then ! If there is a restart, the timings in the params type have to be ! updated to those read from the restart call tem_timeControl_start_at_sim ( me = simControl % timeControl , & & now = simControl % now ) else write ( logUnit ( 1 ), * ) 'No read restart given. Loading mesh file' ! First load global info call tem_global_mesh_read ( me = me % tree % global , & & conf = solverHead % conf ( 1 ), & & myPart = proc % rank , & & nParts = proc % comm_size , & & comm = proc % comm ) minLevel = me % tree % global % minLevel maxLevel = me % tree % global % maxLevel if ( ( minLevel /= maxLevel ) . and . initial_balance ) then call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), \"(A)\" ) 'Do initial level-wise load balancing.' ! Calculate level wise weights to scaleFactor&#94;( level - minlevel ) !                 acoustic      diffusive !  ------------------------------------------------ !  fac =         |   2              4 !  ------------------------------------------------ !  minLevel      |   1              1 !  minLevel + 1  |   2              4 !  minLevel + 2  |   4              16 !  ... !  ------------------------------------------------ do iLevel = minLevel , maxLevel level_weights ( iLevel ) = dble ( scaleFactor ** ( iLevel - minLevel ) ) end do call load_tem ( me = me % tree , & & conf = solverHead % conf ( 1 ), & & myPart = proc % rank , & & nParts = proc % comm_size , & & comm = proc % comm , & & levelWeight = level_weights , & & meshDir = solverHead % meshFolder ) else ! load the tree from the mesh = '' definition in case no restartRead is ! given in this case the mesh from the restart header is read ! (in tem_load_restart) call load_tem ( me = me % tree , & & conf = solverHead % conf ( 1 ), & & myPart = proc % rank , & & nParts = proc % comm_size , & & comm = proc % comm , & & meshDir = solverHead % meshFolder ) end if ! minLevel /= maxLevel .and. initial_balance end if ! readRestart ! --------------------------------------------------------------------------- ! Done loading mesh.                                                       ! ! --------------------------------------------------------------------------- ! Load boundary and qval call mus_load_bc_data ( geometry = me , & & rank = proc % rank , & & comm = proc % comm ) ! Load solidification/fluidification settings call mus_geomIncrHead_load ( me = me % geomIncr , & & conf = solverHead % conf ( 1 ), & & dynamicGeom = me % dynamicGeom ) ! load IBM data call mus_load_IBM ( me = me % globIBM , & & conf = solverHead % conf ( 1 ), & & rank = proc % rank ) end subroutine mus_load_geom ! ************************************************************************** ! ! ************************************************************************** ! !> This routine invokes the treelm routines to load the boundary conditions !! subroutine mus_load_bc_data ( geometry , rank , comm ) ! -------------------------------------------------------------------------- type ( mus_geom_type ), intent ( inout ) :: geometry !< Treelmesh data integer , intent ( in ) :: rank , comm ! -------------------------------------------------------------------------- integer :: iProp ! -------------------------------------------------------------------------- ! ----------------------Load the boundary conditions------------------------ ! Boundary conditions are loaded even in the case of dynamic load balancing ! when the restart is done at requisite load balancing intervals call init_tem_bc_prop ( geometry % tree , rank , & & comm , geometry % boundary ) do iProp = 1 , geometry % tree % global % nProperties if ( geometry % tree % global % property ( iProp )% nElems > 0 ) then select case ( geometry % tree % global % property ( iProp )% bitpos ) case ( prp_hasBnd ) ! Already loaded case ( prp_hasQVal ) ! Load qVal from disk ! prp_hasQVal is the 2nd property in mesh write ( logUnit ( 1 ), \"(A)\" ) 'Loading qVal data from directory: ' & & // trim ( geometry % tree % global % dirname ) call load_tem_BC_qVal ( & & me = geometry % boundary , & & offset = geometry % tree % Property ( iProp )% Offset , & & nElems = geometry % tree % Property ( iProp )% nElems , & & basename = trim ( geometry % tree % global % dirname ) // 'qval' , & & mypart = rank , & & comm = comm ) write ( logUnit ( 1 ), * ) 'Done, reading the qVal!' end select ! property( iProp )%bitpos endif ! property( iProp )%nElems > 0 enddo ! iProp call mus_build_posInProp ( geometry ) ! when qVal exist, it is allocated inside load_tem_BC_qVal ! otherwise allocate it with size 0 if ( . not . allocated ( geometry % boundary % qVal ) ) then allocate ( geometry % boundary % qVAl ( 0 , 0 ) ) end if end subroutine mus_load_bc_data ! ************************************************************************** ! ! ************************************************************************** ! !> This routine builds mapping between elements in tree to to propery list subroutine mus_build_posInProp ( me ) ! -------------------------------------------------------------------------- type ( mus_geom_type ), intent ( inout ) :: me !< Treelmesh data ! -------------------------------------------------------------------------- integer :: iProp ! -------------------------------------------------------------------------- do iProp = 1 , me % tree % global % nProperties if ( me % tree % global % property ( iProp )% nElems > 0 ) then select case ( me % tree % global % property ( iProp )% bitpos ) case ( prp_hasBnd ) if ( allocated ( me % posInBndID )) deallocate ( me % posInBndID ) allocate ( me % posInBndID ( me % tree % nElems ) ) ! build me%posInBnd which maps tree to boundary%boundary_ID call tem_build_treeToProp_pointer ( & & treeToProp = me % posInBndID , & & nElems = me % tree % nElems ,& & ElemPropertyBits = me % tree % ElemPropertyBits ,& & prp_bit = prp_hasBnd ) call mus_build_minBcID ( minBcID = me % minBcID , & & bc_prop = me % boundary , & & posInBndID = me % posInBndID ) case ( prp_hasQVal ) if ( allocated ( me % posInQval )) deallocate ( me % posInQval ) allocate ( me % posInQval ( me % tree % nElems ) ) ! build me%posInQVal which maps tree to boundary%qVal call tem_build_treeToProp_pointer ( & & treeToProp = me % posInQVal , & & nElems = me % tree % nElems ,& & ElemPropertyBits = me % tree % ElemPropertyBits ,& & prp_bit = prp_hasQVal ) end select ! property( iProp )%bitpos endif ! property( iProp )%nElems > 0 enddo ! iProp end subroutine mus_build_posInProp ! ************************************************************************** ! ! ************************************************************************** ! !> This routine build minBcID for boundary elements, it is required if a !! element has more than one boundary in its directions. !! if a element has more than one boundary then use minBcID which depends !! on boundary order in seeder configuration subroutine mus_build_minBcID ( minBcID , bc_prop , posInBndID ) ! -------------------------------------------------------------------------- integer , allocatable , intent ( out ) :: minBcID (:) !> boundary information from mesh type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> tree element position in boundaryID integer , intent ( in ) :: posInBndID (:) ! -------------------------------------------------------------------------- integer :: iElem integer ( kind = long_k ) :: bcIDs ( bc_prop % nSides ) ! -------------------------------------------------------------------------- allocate ( minBcID ( bc_prop % property % nElems )) do iElem = 1 , bc_prop % property % nElems bcIDs = bc_prop % boundary_ID (:, iElem ) minBcID ( iElem ) = int ( minval ( bcIDs , bcIDs > 0_long_k )) end do end subroutine mus_build_minBcID ! ************************************************************************** ! end module mus_geom_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_geom_module.f90.html"},{"title":"mus_harvesting.f90 – Musubi","text":"This file depends on sourcefile~~mus_harvesting.f90~~EfferentGraph sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_param_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_timer_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> Musubi Harvesting Tool !! Visualization of restart file or tracking harvester formar, generated by !! musubi !! (c) 2015 University of Siegen !! !! For a documentation, run ./waf gendoxy and find the documentation at !! ./Documentation/html/index.html program mus_harvesting use iso_c_binding , only : c_loc ! treelm modules use mpi use env_module , only : pathLen use tem_general_module , only : tem_start , tem_finalize use tem_timeControl_module , only : tem_timeControl_start_at_sim use tem_tracking_module , only : tem_tracking_finalize , & & tem_tracking_print_last_VTK_files use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! musubi modules use mus_scheme_type_module , only : mus_scheme_type use mus_scheme_module , only : mus_init_scheme use mus_param_module , only : mus_param_type use mus_timer_module , only : mus_init_mainTimer , & & mus_init_levelTimer use mus_geom_module , only : mus_geom_type use mus_varSys_module , only : mus_varSys_solverData_type use mus_restart_module , only : mus_readRestart use mus_flow_module , only : fillHelperElementsCoarseToFine , & & fillHelperElementsFineToCoarse , & & mus_initAuxField use mus_construction_module , only : mus_construct ! libharvesting use hvs_output_module , only : hvs_output_file_type , hvs_output_open , & & hvs_output_close , hvs_output_write , & & hvs_output_init , hvs_output_finalize use hvs_aux_module , only : hvs_banner use mus_bndForce_module , only : mus_calcBndForce ! mus_harvesting use mus_hvs_config_module , only : mus_hvs_config_type , & & mus_hvs_config_load use mus_hvs_aux_module , only : mus_hvs_init_aux use mus_hvs_construction_module , only : mus_hvs_construct ! aotus use aotus_module , only : flu_State implicit none ! ----------------------------------------------------------------------------- type ( mus_scheme_type ), target :: scheme type ( mus_geom_type ), target :: geometry type ( mus_param_type ), target :: params type ( mus_varSys_solverData_type ), target :: solverData type ( mus_hvs_config_type ) :: config type ( hvs_output_file_type ) :: out_file integer :: ierr integer :: iTrack , iConfig integer :: nVars integer :: minLevel , maxLevel ! basename for output if tracking table is not defined ! trim(config%prefix)//trim(general%solver%simName)//trim(varSys%systemName) character ( len = pathLen ) :: basename ! ----------------------------------------------------------------------------- ! Initialize environment. call tem_start ( codeName = 'mus_harvesting' , & & version = '0.1' , & & general = params % general ) if ( params % general % proc % rank == 0 ) then call hvs_banner ( solveHead = params % general % solver , & & supportSolName = 'Musubi' ) end if call mus_init_mainTimer () ! Load mus_harvesting config file ! From this config file, try to load restart file from restart table key \"read\" ! If no restart read defined then abort. ! ! If restart read is defined then load basic scheme info ! like identify table, field, physics table from restart header file ! ! Load tracking and variable table from config file call mus_hvs_config_load ( me = config , & & scheme = scheme , & & solverData = solverData , & & geometry = geometry , & & params = params ) minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel call mus_init_levelTimer ( minLevel , maxLevel ) ! initialize scheme ! append variables loaded from restart header ! file as state variables call mus_init_scheme ( me = scheme , & & tree = geometry % tree , & & solverData = solverData ) !! If restart read variable is not pdf then set interpolation !! method to none to deactivate interpolation for !! derived variable if ( . not . scheme % readVarIsPdf ) then scheme % intp % config % method = 'none' if ( minLevel /= maxLevel ) then write ( logUnit ( 1 ), * ) 'WARNING: Multi-level interpolation is not supported' write ( logUnit ( 1 ), * ) 'for derived variables read from restart file' end if end if ! construct levelDescriptor, connectivity array if ( scheme % readVarIsPdf ) then call mus_construct ( scheme = scheme , & & geometry = geometry , & & params = params ) else ! Initialize only fluid element list. Ghost and halo elements are ! not required if variable read from restart is not PDF. call mus_hvs_construct ( scheme = scheme , & & geometry = geometry , & & params = params ) end if ! scheme%state%val array is allocated with single buffer so set nNow and nNext to 1 scheme % pdf ( minLevel : maxLevel )% nNow = 1 scheme % pdf ( minLevel : maxLevel )% nNext = 1 ! Init auxiliary features such as interpolation, boundaries, restart ! and the tracker call mus_hvs_init_aux ( scheme = scheme , & & geometry = geometry , & & params = params ) ! Read restart file call mus_readRestart ( levelPointer = geometry % levelPointer , & & restart = params % general % restart , & & scheme = scheme , & & tree = geometry % tree ) if ( scheme % readVarIsPdf ) then ! init auxiliary field variable from state for fluid elements in state and ! interpolate for ghost elements in do_intpArbiVal routine. call mus_initAuxField ( scheme , params % general , minLevel , maxLevel ) ! Fill all elements (ghost, halo) with valid values from fluid elements call fillHelperElementsFineToCoarse ( scheme = scheme , & & general = params % general , & & physics = params % physics , & & iLevel = minLevel , & & maxLevel = maxLevel ) call fillHelperElementsCoarseToFine ( scheme = scheme , & & general = params % general , & & physics = params % physics , & & iLevel = minLevel , & & minLevel = minLevel , & & maxLevel = maxLevel ) ! Force on boundary elements are computed from post-collision so calculate ! here after apply source and before tracking output call mus_calcBndForce ( bndForce = geometry % bndForce , & & bndMoment = geometry % bndMoment , & & posInBndID = geometry % posInBndID , & & nBCs = geometry % boundary % nBCtypes , & & field = scheme % field , & & globBC = scheme % globBC , & & minLevel = minLevel , & & maxLevel = maxLevel , & & state = scheme % state , & & pdf = scheme % pdf , & & levelDesc = scheme % levelDesc , & & layout = scheme % layout , & & varSys = scheme % varSys , & & physics = params % physics ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) ! For active tracking output is initialized in init_tracker in ini_aux if ( scheme % track % control % active ) then do iTrack = 1 , scheme % track % control % nActive iConfig = scheme % track % instance ( iTrack )% pntConfig if ( scheme % track % instance ( iTrack )% subTree % useGlobalMesh ) then ! Open the output files, this also generates the vertices for the mesh, ! and writes the mesh data to disk. Also writes header file depends ! on output vis_kind call hvs_output_open ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & use_iter = scheme % track % config ( iConfig )% output_config & & % vtk % iter_filename , & & mesh = geometry % tree , & & varSys = scheme % varSys , & & time = params % general % simControl % now ) ! Evaluate and write results to disk call hvs_output_write ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & varSys = scheme % varSys , & & mesh = geometry % tree ) ! Close opened files call hvs_output_close ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & varSys = scheme % varSys , & & mesh = geometry % tree ) else ! Open the output files, this also generates the vertices for the mesh, ! and writes the mesh data to disk. Also writes header file depends ! on output vis_kind call hvs_output_open ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & use_iter = scheme % track % config ( iConfig )% output_config & & % vtk % iter_filename , & & mesh = geometry % tree , & & varSys = scheme % varSys , & & subTree = scheme % track % instance ( iTrack )% subTree , & & time = params % general % simControl % now ) ! Evaluate and write results to disk call hvs_output_write ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & varSys = scheme % varSys , & & mesh = geometry % tree , & & subTree = scheme % track % instance ( iTrack )% subTree ) ! Close opened files call hvs_output_close ( & & out_file = scheme % track % instance ( iTrack )% output_file , & & varSys = scheme % varSys , & & mesh = geometry % tree , & & subTree = scheme % track % instance ( iTrack )% subTree ) end if !Global mesh end do !iTrack ! Finialize output call tem_tracking_finalize ( scheme % track ) else ! number of variables loaded from restart file nVars = scheme % stateVarMap % varName % nVals ! filename for output basename = trim ( config % prefix ) // trim ( params % general % solver % simName ) ! De-activate transient and spatial reduction !out_file%isTransientReduce = .false. out_file % ascii % isReduce = . false . ! No tracking defined, just dump the restart file ! Open the output files, this also generates the vertices for the mesh, ! and writes the mesh data to disk. call hvs_output_init ( out_file = out_file , & & out_config = config % output , & & tree = geometry % tree , & & varSys = scheme % varSys , & & varPos = scheme % stateVarMap % varPos & & % val (: nVars ), & & basename = trim ( basename ), & & globProc = params % general % proc , & & solver = params % general % solver ) ! Open output file handle call hvs_output_open ( out_file = out_file , & & use_iter = config % output % vtk % iter_filename , & & mesh = geometry % tree , & & varsys = scheme % varsys , & & time = params % general % simControl % now ) ! Fill output files with data. call hvs_output_write ( out_file = out_file , & & varsys = scheme % varsys , & & mesh = geometry % tree ) ! Close output files again. call hvs_output_close ( out_file = out_file , & & varsys = scheme % varsys , & & mesh = geometry % tree ) ! Finialize output call hvs_output_finalize ( out_file = out_file ) end if ! Finalize environment. call tem_finalize ( params % general ) end program mus_harvesting","tags":"","loc":"sourcefile/mus_harvesting.f90.html"},{"title":"mus_initIsothermAcEq_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initisothermaceq_module.f90~~EfferentGraph sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016 Philipp Otte <otte@mathcces.rwth-aachen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for lbm model for acoustic equations. module mus_initIsothermAcEq_module use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use mus_isotherm_acEq_module , only : bgk_advRel_isotherm_acEq_d3q19 use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_isotherm_acEq contains ! **************************************************************************** ! !> Assigning compute kernel routine by scheme relaxation type for !> isotherm_acEq kind. !! subroutine mus_init_advRel_isotherm_acEq ( relaxation , layout , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( inout ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing relaxation model: ' // trim ( relaxation ) select case ( trim ( relaxation )) case ( 'bgk' ) select case ( trim ( layout ) ) case ( 'd3q19' ) compute => bgk_advRel_isotherm_acEq_d3q19 case default write ( logUnit ( 1 ), * ) 'Stencil ' // trim ( layout ) // ' is not supported yet!' call tem_abort () end select case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select end subroutine mus_init_advRel_isotherm_acEq ! **************************************************************************** ! end module mus_initIsothermAcEq_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_initisothermaceq_module.f90.html"},{"title":"mus_timer_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_timer_module.f90~~AfferentGraph sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_weights_module.f90 mus_weights_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_weights_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_weights_module.f90->sourcefile~mus_timer_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_timer_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2021 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types and routines used to measure time spend on !! musubi routines. !! author: Kannan Masilamani !! module mus_timer_module use env_module , only : rk use tem_timer_module , only : tem_resetTimer , tem_addTimer ,& & tem_getTimerVal , tem_getNTimers implicit none private public :: mus_timerHandles public :: mus_timer_handle_type public :: mus_init_mainTimer public :: mus_init_levelTimer public :: mus_init_bcTimer public :: mus_reset_levelTimer public :: mus_reset_mainTimer public :: mus_reset_bcTimer public :: mus_get_timerHandles public :: mus_set_timerHandles public :: get_mainLoopTime public :: get_computeTime public :: get_computeRatio public :: get_auxTime public :: get_relaxTime public :: get_intpFromCoarserTime public :: get_intpFromCoarserRatio public :: get_intpFromFinerTime public :: get_intpFromFinerRatio public :: get_intpRatio public :: get_communicateTime public :: get_communicateRatio public :: get_bcBufferTime public :: get_bcBufferRatio public :: get_boundaryTime public :: get_boundaryRatio public :: get_stageTime public :: get_stageRatio integer , parameter , public :: nStages = 12 interface get_boundaryTime module procedure get_boundaryTime_total module procedure get_boundaryTime_byID end interface get_boundaryTime interface get_computeTime module procedure get_computeTime_total module procedure get_computeTime_atLevel end interface get_computeTime interface get_computeRatio module procedure get_computeRatio_total module procedure get_computeRatio_atLevel end interface get_computeRatio interface get_auxTime module procedure get_auxTime_total module procedure get_auxTime_atLevel end interface get_auxTime interface get_relaxTime module procedure get_relaxTime_total module procedure get_relaxTime_atLevel end interface get_relaxTime interface get_intpFromCoarserTime module procedure get_intpFromCoarserTime_total module procedure get_intpFromCoarserTime_atLevel end interface get_intpFromCoarserTime interface get_intpFromCoarserRatio module procedure get_intpFromCoarserRatio_total module procedure get_intpFromCoarserRatio_atLevel end interface get_intpFromCoarserRatio interface get_intpFromFinerTime module procedure get_intpFromFinerTime_total module procedure get_intpFromFinerTime_atLevel end interface get_intpFromFinerTime interface get_intpFromFinerRatio module procedure get_intpFromFinerRatio_total module procedure get_intpFromFinerRatio_atLevel end interface get_intpFromFinerRatio interface get_bcBufferTime module procedure get_bcBufferTime_total module procedure get_bcBufferTime_atLevel end interface get_bcBufferTime interface get_bcBufferRatio module procedure get_bcBufferRatio_total module procedure get_bcBufferRatio_atLevel end interface get_bcBufferRatio !> Musubi timer type -------------------------------------------------- type mus_timer_handle_type !> handle for the complete mainloop integer :: mainloop !> handle for loading / creating the mesh and config integer :: loadMesh !> handle for initialising the levelDescriptor integer :: initLvlD !> handle for writing restart integer :: wRestart !> handle for the dyn_loadBal routine integer :: balance !> handle for source terms integer :: source ! GGS: erase the following !integer :: kappa_abg, inv_kappa_abg, inner_loop !> First main handle position in treelm timer object integer :: first = 0 !> Last main handle position in treelm timer object integer :: last = - 1 ! level-wise timers: !> handle for advection relaxation integer , allocatable :: compute (:) !> handle for auxfield calculation integer , allocatable :: aux (:) !> handle for relax parameter update integer , allocatable :: relax (:) !> handle for communicate integer , allocatable :: comm (:) !> handle for interpolation and communicate integer , allocatable :: intpFromCoarser (:) integer , allocatable :: intpFromFiner (:) integer , allocatable :: commFromCoarser (:) integer , allocatable :: commFromFiner (:) !> handle for setboundary integer , allocatable :: setBnd (:) integer , allocatable :: bcBuffer (:) !> handle for immersed boundary method integer , allocatable :: doIBM (:) !> Stage timers for multi level recursive algorithm integer :: stage ( nStages ) !> min. level in mesh integer :: minLevel !> max. level in mesh integer :: maxLevel !> number of BCs integer :: nBCs end type mus_timer_handle_type !> Musubi timer type -------------------------------------------------- type ( mus_timer_handle_type ), save :: mus_timerHandles contains ! ------------------------------------------------------------------------ ! !> Timers initialization routine for whatever !! subroutine mus_init_mainTimer () ! -------------------------------------------------------------------- ! character ( len = 2 ) :: buffer integer :: ii ! -------------------------------------------------------------------- ! ! add timer handles to measure wall clock time of different routines call tem_addTimer ( timerHandle = mus_timerHandles % mainLoop , & & timerName = 'MainLoop' ) ! Set position of the fisrt handle mus_timerHandles % first = tem_getNTimers () call tem_addTimer ( timerHandle = mus_timerHandles % loadMesh ,& & timerName = 'LoadMesh' ) call tem_addTimer ( timerHandle = mus_timerHandles % initLvlD ,& & timerName = 'InitLvlD' ) call tem_addTimer ( timerHandle = mus_timerHandles % wRestart , & & timerName = 'wRestart' ) call tem_addTimer ( timerHandle = mus_timerHandles % balance , & & timerName = 'Balance' ) call tem_addTimer ( timerHandle = mus_timerHandles % source , & & timerName = 'Source' ) ! GGS: erase the following 3 !call tem_addTimer( timerHandle = mus_timerHandles%kappa_abg, & !  &                timerName   = 'Chimera_ops' ) ! !call tem_addTimer( timerHandle = mus_timerHandles%inv_kappa_abg, & !  &                timerName   = 'Backward_Chimera_ops' ) ! !call tem_addTimer( timerHandle = mus_timerHandles%inner_loop, & !  &                timerName   = 'Inner_Loop' ) ! Set position of the last handle mus_timerHandles % last = tem_getNTimers () do ii = 1 , nStages write ( buffer , \"(I2.2)\" ) ii call tem_addTimer ( timerHandle = mus_timerHandles % stage ( ii ), & & timerName = 'Stage' // ( buffer ) ) end do end subroutine mus_init_mainTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine mus_init_levelTimer ( minLevel , maxLevel ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: minLevel , maxLevel ! -------------------------------------------------------------------- ! integer :: iLevel character ( len = 3 ) :: level_string ! -------------------------------------------------------------------- ! mus_timerHandles % minLevel = minLevel mus_timerHandles % maxLevel = maxLevel ! Allocate level-wise handles allocate ( mus_timerHandles % compute ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % aux ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % relax ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % comm ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % intpFromCoarser ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % intpFromFiner ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % commFromCoarser ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % commFromFiner ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % doIBM ( minLevel : maxLevel ) ) allocate ( mus_timerHandles % bcBuffer ( minLevel : maxLevel ) ) do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel ! level prependix write ( level_string , \"(A, I2.2)\" ) \"L\" , iLevel call tem_addTimer ( timerHandle = mus_timerHandles % compute ( iLevel ), & & timerName = level_string // '_compute' ) call tem_addTimer ( timerHandle = mus_timerHandles % aux ( iLevel ), & & timerName = level_string // '_aux' ) call tem_addTimer ( timerHandle = mus_timerHandles % relax ( iLevel ), & & timerName = level_string // '_relax' ) call tem_addTimer ( timerHandle = mus_timerHandles % comm ( iLevel ), & & timerName = level_string // '_comm' ) call tem_addTimer ( timerHandle = mus_timerHandles & & % intpFromCoarser ( iLevel ), & & timerName = level_string // '_intpFromCoarser' ) call tem_addTimer ( timerHandle = mus_timerHandles % intpFromFiner ( iLevel ), & & timerName = level_string // '_intpFromFiner' ) call tem_addTimer ( timerHandle = mus_timerHandles & & % commFromCoarser ( iLevel ), & & timerName = level_string // '_commFromCoarser' ) call tem_addTimer ( timerHandle = mus_timerHandles % commFromFiner ( iLevel ), & & timerName = level_string // '_commFromFiner' ) call tem_addTimer ( timerHandle = mus_timerHandles % doIBM ( iLevel ), & & timerName = level_string // '_doIBM' ) call tem_addTimer ( timerHandle = mus_timerHandles % bcBuffer ( iLevel ), & & timerName = level_string // '_bcBuffer' ) end do end subroutine mus_init_levelTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine mus_reset_levelTimer () ! -------------------------------------------------------------------- ! integer :: iLevel , ii ! -------------------------------------------------------------------- ! do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel call tem_resetTimer ( timerhandle = mus_timerHandles % compute ( iLevel ) ) call tem_resetTimer ( timerhandle = mus_timerHandles % aux ( iLevel ) ) call tem_resetTimer ( timerhandle = mus_timerHandles % relax ( iLevel ) ) call tem_resetTimer ( timerhandle = mus_timerHandles % comm ( iLevel ) ) call tem_resetTimer ( & & timerhandle = mus_timerHandles % intpFromCoarser ( iLevel ) ) call tem_resetTimer ( & & timerhandle = mus_timerHandles % intpFromFiner ( iLevel ) ) call tem_resetTimer ( & & timerhandle = mus_timerHandles % commFromCoarser ( iLevel ) ) call tem_resetTimer ( & & timerhandle = mus_timerHandles % commFromFiner ( iLevel ) ) ! call tem_resetTimer( timerhandle = mus_timerHandles%setBnd(iLevel) ) call tem_resetTimer ( timerhandle = mus_timerHandles % doIBM ( iLevel ) ) call tem_resetTimer ( timerhandle = mus_timerHandles % bcBuffer ( iLevel ) ) end do do ii = 1 , nStages call tem_resetTimer ( timerhandle = mus_timerHandles % stage ( ii ) ) end do end subroutine mus_reset_levelTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine mus_reset_mainTimer () ! -------------------------------------------------------------------- ! call tem_resetTimer ( timerhandle = mus_timerHandles % mainLoop ) call tem_resetTimer ( timerhandle = mus_timerHandles % loadMesh ) call tem_resetTimer ( timerhandle = mus_timerHandles % initLvlD ) call tem_resetTimer ( timerhandle = mus_timerHandles % wRestart ) call tem_resetTimer ( timerhandle = mus_timerHandles % balance ) call tem_resetTimer ( timerhandle = mus_timerHandles % source ) end subroutine mus_reset_mainTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function returns musubi modular variable mus_timerHandles to apesmate !! and deallocate mus_timerHandles level timers. function mus_get_timerHandles () result ( timerHandles ) ! -------------------------------------------------------------------- ! type ( mus_timer_handle_type ) :: timerHandles ! -------------------------------------------------------------------- ! timerHandles = mus_timerHandles deallocate ( mus_timerHandles % compute ) deallocate ( mus_timerHandles % aux ) deallocate ( mus_timerHandles % relax ) deallocate ( mus_timerHandles % comm ) deallocate ( mus_timerHandles % intpFromCoarser ) deallocate ( mus_timerHandles % intpFromFiner ) deallocate ( mus_timerHandles % commFromCoarser ) deallocate ( mus_timerHandles % commFromFiner ) deallocate ( mus_timerHandles % setBnd ) deallocate ( mus_timerHandles % doIBM ) deallocate ( mus_timerHandles % bcBuffer ) end function mus_get_timerHandles ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine sets mus_timerHandles passed by apesmate subroutine mus_set_timerHandles ( timerHandles ) ! -------------------------------------------------------------------- ! type ( mus_timer_handle_type ), intent ( in ) :: timerHandles ! -------------------------------------------------------------------- ! mus_timerHandles = timerHandles end subroutine mus_set_timerHandles ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_computeTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + get_computeTime ( iLevel ) end do end function get_computeTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_computeTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % compute ( level ) ) end function get_computeTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_computeRatio_total () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_computeTime () / get_mainLoopTime () * 10 0._rk end function get_computeRatio_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_computeRatio_atLevel ( level ) result ( ratio ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_computeTime ( level ) / get_mainLoopTime () * 10 0._rk end function get_computeRatio_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_auxTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + get_auxTime ( iLevel ) end do end function get_auxTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_auxTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % aux ( level ) ) end function get_auxTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_relaxTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + get_relaxTime ( iLevel ) end do end function get_relaxTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_relaxTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % relax ( level ) ) end function get_relaxTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromCoarserTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + get_intpFromCoarserTime ( iLevel ) end do end function get_intpFromCoarserTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromCoarserTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( & & timerhandle = mus_timerHandles % intpFromCoarser ( level ) ) end function get_intpFromCoarserTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromCoarserRatio_total () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_intpFromCoarserTime () / get_mainLoopTime () * 10 0._rk end function get_intpFromCoarserratio_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromCoarserRatio_atLevel ( level ) result ( ratio ) ! -------------------------------------------------------------------- ! integer :: level real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_intpFromCoarserTime ( level ) / get_mainLoopTime () * 10 0._rk end function get_intpFromCoarserratio_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromFinerTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + tem_getTimerVal ( & & timerhandle = mus_timerHandles % intpFromFiner ( iLevel ) ) end do end function get_intpFromFinerTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromFinerTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % intpFromFiner ( level )) end function get_intpFromFinerTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromFinerRatio_total () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_intpFromFinerTime () / get_mainLoopTime () * 10 0._rk end function get_intpFromFinerRatio_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpFromFinerRatio_atLevel ( level ) result ( ratio ) ! -------------------------------------------------------------------- ! integer :: level real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_intpFromFinerTime ( level ) / get_mainLoopTime () * 10 0._rk end function get_intpFromFinerRatio_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_communicateTime () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + tem_getTimerVal ( & & timerhandle = mus_timerHandles % comm ( iLevel ) ) time = time + tem_getTimerVal ( & & timerhandle = mus_timerHandles % commFromFiner ( iLevel ) ) time = time + tem_getTimerVal ( & & timerhandle = mus_timerHandles % commFromCoarser ( iLevel ) ) end do end function get_communicateTime ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_communicateRatio () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_communicateTime () / get_mainLoopTime () * 10 0._rk end function get_communicateRatio ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_boundaryTime_byID ( bcID ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: bcID real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! if ( bcID > mus_timerHandles % nBCs ) then time = 0._rk else time = tem_getTimerVal ( timerhandle = mus_timerHandles % setBnd ( bcID ) ) end if end function get_boundaryTime_byID ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_boundaryTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: ii real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do ii = 1 , mus_timerHandles % nBCs time = time + get_boundaryTime ( ii ) end do end function get_boundaryTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_boundaryRatio () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_boundaryTime () / get_mainLoopTime () * 10 0._rk end function get_boundaryRatio ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpTime () result ( time ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = get_intpFromCoarserTime () + get_intpFromFinerTime () end function get_intpTime ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_intpRatio () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_intpTime () / get_mainLoopTime () * 10 0.0_rk end function get_intpRatio ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_mainLoopTime () result ( time ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % mainLoop ) end function get_mainLoopTime ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_stageTime ( ii ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: ii real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! if ( ii <= nStages ) then time = tem_getTimerVal ( timerhandle = mus_timerHandles % stage ( ii ) ) else time = - get_mainLoopTime () end if end function get_stageTime ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_stageRatio ( ii ) result ( ratio ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: ii real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_stageTime ( ii ) / get_mainLoopTime () * 10 0._rk end function get_stageRatio ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine mus_init_bcTimer ( nBCs ) integer , intent ( in ) :: nBCs character ( len = 4 ) :: bc_string integer :: ii mus_timerHandles % nBCs = nBCs allocate ( mus_timerHandles % setBnd ( nBCs ) ) do ii = 1 , nBCs write ( bc_string , \"(A, I2.2)\" ) \"BC\" , ii call tem_addTimer ( timerHandle = mus_timerHandles % setBnd ( ii ), & & timerName = bc_string // '_setBnd' ) end do end subroutine mus_init_bcTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine mus_reset_bcTimer ( ) integer :: ii do ii = 1 , mus_timerHandles % nBCs call tem_resetTimer ( timerhandle = mus_timerHandles % setBnd ( ii ) ) end do end subroutine mus_reset_bcTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_bcBufferTime_atLevel ( level ) result ( time ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = tem_getTimerVal ( timerhandle = mus_timerHandles % bcBuffer ( level ) ) end function get_bcBufferTime_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_bcBufferTime_total () result ( time ) ! -------------------------------------------------------------------- ! integer :: iLevel real ( kind = rk ) :: time ! -------------------------------------------------------------------- ! time = 0.0_rk do iLevel = mus_timerHandles % minLevel , mus_timerHandles % maxLevel time = time + get_bcBufferTime ( iLevel ) end do end function get_bcBufferTime_total ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_bcBufferRatio_atLevel ( level ) result ( ratio ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: level real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_bcBufferTime ( level ) / get_mainLoopTime () * 10 0._rk end function get_bcBufferRatio_atLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! function get_bcBufferRatio_total () result ( ratio ) ! -------------------------------------------------------------------- ! real ( kind = rk ) :: ratio ! -------------------------------------------------------------------- ! ratio = get_bcBufferTime () / get_mainLoopTime () * 10 0._rk end function get_bcBufferRatio_total ! ------------------------------------------------------------------------ ! end module mus_timer_module ! *************************************************************************** !","tags":"","loc":"sourcefile/mus_timer_module.f90.html"},{"title":"mus_config_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_config_module.f90~~EfferentGraph sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_config_module.f90~~AfferentGraph sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2012,2020-2021,2024 Harald Klimach <harald.klimach@dlr.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011 Konstantin Kleinheinz <k.kleinheinz@grs-sim.de> ! Copyright (c) 2011-2016, 2019-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2011-2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012-2015 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Verena Krupp <verena.krupp@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> In this module, all parameter files are read in !! as lua script or a sample configuration is being loaded !! !! Possible Parameter configuration !! !! - General Parameters !! - [[mus_scheme_layout_module]] for Scheme Definitions !! - [[tem_debug_module]] for Debug Parameters !! module mus_config_module ! include musubi modules use mpi use mus_param_module , only : mus_param_type , mus_load_param , & & mus_init_latticeUnit use mus_geom_module , only : mus_geom_type , mus_load_geom use mus_scheme_type_module , only : mus_scheme_type use mus_scheme_module , only : mus_load_scheme use mus_physics_module , only : mus_create_funcStr , mus_load_physics use mus_varSys_module , only : mus_varSys_solverData_type use mus_timer_module , only : mus_timerHandles use mus_tools_module , only : dump_linear_partition ! include treelm modules use env_module , only : pathLen , rk , long_k , globalMaxLevels use tem_aux_module , only : tem_open_distconf_array , tem_abort use tem_timer_module , only : tem_startTimer , & & tem_stopTimer use tem_tools_module , only : tem_horizontalSpacer use tem_general_module , only : tem_load_general use tem_logging_module , only : logUnit , tem_logging_load_primary use tem_comm_env_module , only : tem_comm_env_type use tem_debug_module , only : dbgUnit , tem_debug_load_main use tem_adaptation_config_module , only : tem_adapt_type , tem_load_adapt ! include aotus modules use aotus_module , only : flu_State , open_config_chunk implicit none private public :: mus_load_config public :: mus_open_config contains ! ************************************************************************** ! !> Read in LUA parameter file !! See http://www.lua.org for a reference on how to use !! Lua is a scripting language in itself which allows !! more complex parameter files including comments !! And load / create the mesh depending on the configuration subroutine mus_load_config ( scheme , solverData , geometry , params , adapt ) ! ---------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), target :: scheme !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target :: solverData !> Treelmesh data type ( mus_geom_type ), intent ( out ), target :: geometry !> Global parameters type ( mus_param_type ), target , intent ( inout ) :: params !> mesh adaptation type ( tem_adapt_type ), intent ( inout ) :: adapt ! ---------------------------------------------------------------------- ! character ( len = PathLen ) :: filename integer :: minLevel , maxLevel ! ---------------------------------------------------------------------- ! call tem_startTimer ( timerHandle = mus_timerHandles % loadMesh ) ! check whether params%general%solver%configFile is defined. When loading ! musubi from apes, musubi config file is provided via params if ( trim ( params % general % solver % configFile ) == '' ) then ! Get filename from command line argument call get_command_argument ( 1 , filename ) if ( trim ( filename ) == '' ) then filename = 'musubi.lua' end if params % general % solver % configFile = filename else filename = params % general % solver % configFile endif if ( params % general % proc % rank == 0 ) then write ( logUnit ( 1 ), * ) \"Loading configuration file: \" // trim ( filename ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end if ! open musubi config file and solver specific lua functions as chunk call mus_open_config ( conf = params % general % solver % conf , & & filename = filename , & & proc = params % general % proc ) ! load and initialize logUnit call tem_logging_load_primary ( conf = params % general % solver % conf ( 1 ), & & rank = params % general % proc % rank ) ! load and initialize debug unit call tem_debug_load_main ( conf = params % general % solver % conf ( 1 ), & & rank = params % general % proc % rank ) ! load general information call tem_load_general ( & & me = params % general , & & conf = params % general % solver % conf ( 1 ), & & solverAborts = params % mus_Aborts ) ! load global musubi params call mus_load_param ( params = params , & & conf = params % general % solver % conf ( 1 ) ) ! load geometry information like mesh, boundary, immersed_boundary and ! restart. If restart read is defined then simControl is updated call mus_load_geom ( me = geometry , & & restart = params % general % restart , & & solverHead = params % general % solver , & & simControl = params % general % simControl , & & proc = params % general % proc , & & scaleFactor = params % scaleFactor , & & initial_balance = params % initial_balance ) if ( params % dump_linear_partition ) then call dump_linear_partition ( treeID = geometry % tree % treeID , & & nElems = geometry % tree % nElems , & & offset = geometry % tree % elemOffset , & & myRank = params % general % proc % rank , & & iter = 0 ) end if ! minlevel and maxlevel of the mesh minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel ! Initialize requiredInterval for multilevel to determine one complete cycle params % reqInterval = params % scaleFactor ** ( maxLevel - minLevel ) ! Set lattice dx and dt according scaling type call mus_init_latticeUnit ( params % lattice , minLevel , maxLevel , & & params % scaleFactor ) ! load physics table for unit converstion call mus_load_physics ( me = params % physics , & & conf = params % general % solver % conf ( 1 ), & & tree = geometry % tree , & & scaleFactor = params % scaleFactor ) ! The scheme information is loaded from the configuration file by invoking ! the function. THIS IS REQUIRED EVEN IN THE CASE OF DYNAMIC LOAD BALANCING ! DUE TO PRESENCE OF DERIVED VARIABLE LISTS BUILDING INSIDE THE LOAD SCHEME ! SINGLE ROUTINE call mus_load_scheme ( me = scheme , & & solverData = solverData , & & geometry = geometry , & & conf = params % general % solver % conf ( 1 ), & & params = params ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) ! load adaptation table call tem_load_adapt ( me = adapt , & & conf = params % general % solver % conf ( 1 ) ) call tem_stopTimer ( timerHandle = mus_timerHandles % loadMesh ) end subroutine mus_load_config ! ************************************************************************** ! ! ************************************************************************** ! !> This routine loads musubi specific lua function from string and musubi !! input configuration file subroutine mus_open_config ( conf , filename , proc ) ! ---------------------------------------------------------------------- ! !> lua state to be stored type ( flu_State ), allocatable :: conf (:) !> name of the config file to be opened character ( len =* ), intent ( in ) :: filename !> process description to use type ( tem_comm_env_type ), intent ( in ) :: proc ! ---------------------------------------------------------------------- ! character ( len = 2048 ) :: fun_str !contains function to be used in musubi integer :: iThread ! ---------------------------------------------------------------------- ! ! allocate the array of lua states allocate ( conf ( proc % nThreads )) call mus_create_funcStr ( fun_str = fun_str ) !pre-loading musubi specific lua functions using same conf used to load !main musubi config file do iThread = 1 , proc % nThreads call open_config_chunk ( L = conf ( iThread ), chunk = fun_str ) end do ! Open the lua config call tem_open_distconf_array ( L = conf , & & filename = trim ( filename ), & & proc = proc ) end subroutine mus_open_config ! ************************************************************************** ! end module mus_config_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_config_module.f90.html"},{"title":"mus_mrtInit_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_mrtinit_module.f90~~AfferentGraph sourcefile~mus_mrtinit_module.f90 mus_mrtInit_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_mrtinit_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Gregorio Gerardo Spinelli !! This module provides the definitions of M and Minv for !! MRT advection relaxation scheme for all stencils. !! !! The weighted MRT (D3Q27) is based on the following paper !! Abbas Fakhari, Diogo Bolster, Li-Shi Luo !! \"A weighted multiple-relaxation-time lattice Boltzmann method for multiphase !! flows and its application to partial coalescence cascades\" !! Journal of Computational Physics, 2017 !! !! The MRT (D3Q19) implementation here is taken from:\\n !! J. Toelke, S. Freudiger, and M. Krafczyk, !! \"An adaptive scheme using hierarchical grids for lattice Boltzmann !! multi-phase flow simulations,\" Comput. Fluids, vol. 35, pp. 820–830, !! 2006. \\n module mus_mrtInit_module ! include treelm modules use env_module , only : rk use tem_param_module , only : div2_27 , div2_9 , div1_9 , div1_18 , div1_54 , & & div1_4 , div1_6 , div1_36 , div1_12 , div1_108 , & & div1_48 , div1_72 , div1_216 , div8_27 , div4_9 , & & div1_27 , div1_24 , div1_8 , div1_2 , div1_3 , & & div1_16 implicit none private public :: check_mrt_matrix_d3q19 public :: check_mrt_matrix_d3q27 !============================================================================= ! D3Q19 flow model !============================================================================= ! D3Q19 MRT pdf -> moment transformation matrix ! How to use: ! do iDir = 1, QQ !   moment(iDir) = sum( PDF(:) * MMtrD3Q19(iDir,:) ) ! end do !  W      S     B     E     N     T     BS    TS   BN    TN    BW    BE    TW    TE    SW    NW    SE    NE     0 real ( kind = rk ), dimension ( 19 , 19 ), parameter , public :: MMtrD3Q19 = & reshape (( / & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , - 1._rk , & - 2._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & 2._rk , 0._rk , 0._rk , - 2._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , 0._rk , & 0._rk , 2._rk , 0._rk , 0._rk , - 2._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , 0._rk , & 0._rk , 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , & & - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & 0._rk , 0._rk , 2._rk , 0._rk , 0._rk , - 2._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , & & - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & 2._rk , - 1._rk , - 1._rk , 2._rk , - 1._rk , - 1._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , & - 2._rk , 1._rk , 1._rk , - 2._rk , 1._rk , 1._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , & 0._rk , 1._rk , - 1._rk , 0._rk , 1._rk , - 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , & 0._rk , - 1._rk , 1._rk , 0._rk , - 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , & & - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , & & - 1._rk , - 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , & & - 1._rk , 1._rk , - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , & & - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk & / ),( / 19 , 19 / ), order = ( / 2 , 1 / ) ) real ( kind = rk ), dimension ( 19 , 19 ), parameter , public :: MMivD3Q19 = & reshape (( / & div1_18 , 0._rk , - div1_18 , - div1_6 , div1_6 , 0._rk , 0._rk , 0._rk , 0._rk , div1_12 , - div1_12 , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , - div1_6 , div1_6 , 0._rk , 0._rk , - div1_24 , div1_24 , & div1_8 , - div1_8 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , 0._rk , 0._rk , - div1_6 , div1_6 , - div1_24 , div1_24 , & - div1_8 , div1_8 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_18 , 0._rk , - div1_18 , div1_6 , - div1_6 , 0._rk , 0._rk , 0._rk , 0._rk , div1_12 , - div1_12 , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , div1_6 , - div1_6 , 0._rk , 0._rk , - div1_24 , div1_24 , & div1_8 , - div1_8 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , 0._rk , 0._rk , div1_6 , - div1_6 , - div1_24 , div1_24 , & - div1_8 , div1_8 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & div1_36 , div1_24 , div1_72 , 0._rk , 0._rk , - div1_12 , - div1_24 , - div1_12 , - div1_24 , - div1_24 , - div1_24 , & 0._rk , 0._rk , 0._rk , div1_4 , 0._rk , 0._rk , - div1_8 , div1_8 , & div1_36 , div1_24 , div1_72 , 0._rk , 0._rk , - div1_12 , - div1_24 , div1_12 , div1_24 , - div1_24 , - div1_24 , & 0._rk , 0._rk , 0._rk , - div1_4 , 0._rk , 0._rk , - div1_8 , - div1_8 , & div1_36 , div1_24 , div1_72 , 0._rk , 0._rk , div1_12 , div1_24 , - div1_12 , - div1_24 , - div1_24 , - div1_24 , & 0._rk , 0._rk , 0._rk , - div1_4 , 0._rk , 0._rk , div1_8 , div1_8 , & div1_36 , div1_24 , div1_72 , 0._rk , 0._rk , div1_12 , div1_24 , div1_12 , div1_24 , - div1_24 , - div1_24 , & 0._rk , 0._rk , 0._rk , div1_4 , 0._rk , 0._rk , div1_8 , - div1_8 , & div1_36 , div1_24 , div1_72 , - div1_12 , - div1_24 , 0._rk , 0._rk , - div1_12 , - div1_24 , div1_48 , div1_48 , & - div1_16 , - div1_16 , 0._rk , 0._rk , div1_4 , div1_8 , 0._rk , - div1_8 , & div1_36 , div1_24 , div1_72 , div1_12 , div1_24 , 0._rk , 0._rk , - div1_12 , - div1_24 , div1_48 , div1_48 , & - div1_16 , - div1_16 , 0._rk , 0._rk , - div1_4 , - div1_8 , 0._rk , - div1_8 , & div1_36 , div1_24 , div1_72 , - div1_12 , - div1_24 , 0._rk , 0._rk , div1_12 , div1_24 , div1_48 , div1_48 , & - div1_16 , - div1_16 , 0._rk , 0._rk , - div1_4 , div1_8 , 0._rk , div1_8 , & div1_36 , div1_24 , div1_72 , div1_12 , div1_24 , 0._rk , 0._rk , div1_12 , div1_24 , div1_48 , div1_48 , & - div1_16 , - div1_16 , 0._rk , 0._rk , div1_4 , - div1_8 , 0._rk , div1_8 , & div1_36 , div1_24 , div1_72 , - div1_12 , - div1_24 , - div1_12 , - div1_24 , 0._rk , 0._rk , div1_48 , div1_48 , & div1_16 , div1_16 , div1_4 , 0._rk , 0._rk , - div1_8 , div1_8 , 0._rk , & div1_36 , div1_24 , div1_72 , - div1_12 , - div1_24 , div1_12 , div1_24 , 0._rk , 0._rk , div1_48 , div1_48 , & div1_16 , div1_16 , - div1_4 , 0._rk , 0._rk , - div1_8 , - div1_8 , 0._rk , & div1_36 , div1_24 , div1_72 , div1_12 , div1_24 , - div1_12 , - div1_24 , 0._rk , 0._rk , div1_48 , div1_48 , & div1_16 , div1_16 , - div1_4 , 0._rk , 0._rk , div1_8 , div1_8 , 0._rk , & div1_36 , div1_24 , div1_72 , div1_12 , div1_24 , div1_12 , div1_24 , 0._rk , 0._rk , div1_48 , div1_48 , & div1_16 , div1_16 , div1_4 , 0._rk , 0._rk , div1_8 , - div1_8 , 0._rk , & div1_3 , - div1_2 , div1_6 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk & / ),( / 19 , 19 / ), order = ( / 2 , 1 / ) ) !============================================================================= ! D3Q27 flow model !============================================================================= ! D3Q27 WMRT pdf -> moment transformation matrix ! How to use: ! do iDir = 1, QQ !   moment(iDir) = sum( PDF(:) * WMMtrD3Q27(iDir,:) ) ! end do !  W      S     B     E     N     T     BS    TS   BN    TN    BW    BE    TW !  TE    SW    NW    SE    NE   BSW    TSW   BNW  TNW   BSE   TSE   BNE   TNE  0 real ( kind = rk ), dimension ( 27 , 27 ), parameter , public :: WMMtrD3Q27 = & & reshape (( / & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , & & - 1._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , & & - 1._rk , - 1._rk , 1._rk , 1._rk , 1._rk , - 1._rk , - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , 0._rk , & & 2._rk , - 1._rk , - 1._rk , 2._rk , - 1._rk , - 1._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 1._rk , - 1._rk , 0._rk , 1._rk , - 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , - 1._rk , - 1._rk , - 1._rk , & & 1._rk , 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , 1._rk , & & 1._rk , 1._rk , 1._rk , 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , - 1._rk , & & 2._rk , 0._rk , 0._rk , - 2._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , & & - 1._rk , - 1._rk , 1._rk , 1._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 0._rk , & & 0._rk , 2._rk , 0._rk , 0._rk , - 2._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & - 1._rk , 1._rk , - 1._rk , 1._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , 0._rk , & & 0._rk , 0._rk , 2._rk , 0._rk , 0._rk , - 2._rk , - 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , & & - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 1._rk , - 1._rk , 1._rk , - 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , - 1._rk , 1._rk , 1._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , 1._rk , - 1._rk , - 1._rk , 1._rk , 0._rk , & & - 1._rk , - 1._rk , - 1._rk , - 1._rk , - 1._rk , - 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 1._rk , & & - 2._rk , 1._rk , 1._rk , - 2._rk , 1._rk , 1._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , 2._rk , 2._rk , 2._rk , 2._rk , & & 2._rk , 2._rk , 2._rk , 2._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , - 1._rk , 1._rk , 0._rk , - 1._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , & & 2._rk , 2._rk , 2._rk , 2._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & - 1._rk , 1._rk , 1._rk , - 1._rk , 2._rk , 2._rk , - 2._rk , - 2._rk , - 2._rk , - 2._rk , 2._rk , 2._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 2._rk , - 2._rk , - 2._rk , 2._rk , 2._rk , - 2._rk , - 2._rk , 2._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - 1._rk , 1._rk , 1._rk , - 1._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , 2._rk , - 2._rk , 2._rk , - 2._rk , - 2._rk , 2._rk , - 2._rk , 2._rk , 0._rk , & & - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 2._rk , - 2._rk , 2._rk , - 2._rk , & & 2._rk , 2._rk , - 2._rk , - 2._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , 4._rk , 4._rk , 0._rk , & & 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , 0._rk , 2._rk , 2._rk , - 2._rk , - 2._rk , 0._rk , 0._rk , 0._rk , 0._rk , & & 2._rk , - 2._rk , 2._rk , - 2._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , - 4._rk , - 4._rk , 4._rk , 4._rk , 0._rk , & & 0._rk , 0._rk , - 1._rk , 0._rk , 0._rk , 1._rk , 2._rk , - 2._rk , 2._rk , - 2._rk , 2._rk , 2._rk , - 2._rk , - 2._rk , & & 0._rk , 0._rk , 0._rk , 0._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , - 4._rk , 4._rk , 0._rk , & & 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , 2._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , & & - 4._rk , - 4._rk , - 4._rk , - 4._rk , - 4._rk , 8._rk , 8._rk , 8._rk , 8._rk , 8._rk , 8._rk , 8._rk , 8._rk , - 1._rk & & / ),( / 27 , 27 / ), order = ( / 2 , 1 / ) ) ! D3Q27 MRT moment --> PDF transformation matrix ! How to use: ! do iDir = 1, QQ !   fneq(iDir) = sum( WMMIvD3Q27(iDir,:) * mneq(:) ) ! end do real ( kind = rk ), dimension ( 27 , 27 ), parameter , public :: WMMIvD3Q27 = & & reshape (( / & & div2_27 , - div2_9 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , div1_9 , 0._rk , 0._rk , div1_9 , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , - div1_18 , 0._rk , 0._rk , 0._rk , 0._rk , - div1_18 , 0._rk , 0._rk , div1_54 , & & div2_27 , 0._rk , - div2_9 , 0._rk , 0._rk , 0._rk , 0._rk , - div1_18 , div1_6 , 0._rk , 0._rk , div1_9 , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , div1_36 , - div1_12 , 0._rk , 0._rk , 0._rk , 0._rk , - div1_18 , 0._rk , div1_54 , & & div2_27 , 0._rk , 0._rk , - div2_9 , 0._rk , 0._rk , 0._rk , - div1_18 , - div1_6 , 0._rk , 0._rk , 0._rk , div1_9 , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , div1_36 , div1_12 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - div1_18 , div1_54 , & & div2_27 , div2_9 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , div1_9 , 0._rk , 0._rk , - div1_9 , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , - div1_18 , 0._rk , 0._rk , 0._rk , 0._rk , div1_18 , 0._rk , 0._rk , div1_54 , & & div2_27 , 0._rk , div2_9 , 0._rk , 0._rk , 0._rk , 0._rk , - div1_18 , div1_6 , 0._rk , 0._rk , - div1_9 , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , div1_36 , - div1_12 , 0._rk , 0._rk , 0._rk , 0._rk , div1_18 , 0._rk , div1_54 , & & div2_27 , 0._rk , 0._rk , div2_9 , 0._rk , 0._rk , 0._rk , - div1_18 , - div1_6 , 0._rk , 0._rk , 0._rk , - div1_9 , 0._rk , & & 0._rk , 0._rk , 0._rk , - div1_18 , div1_36 , div1_12 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , div1_18 , div1_54 , & & div1_54 , 0._rk , - div1_18 , - div1_18 , 0._rk , div1_6 , 0._rk , - div1_36 , 0._rk , div1_36 , 0._rk , - div1_72 , & & - div1_72 , 0._rk , - div1_8 , div1_8 , 0._rk , 0._rk , - div1_36 , 0._rk , 0._rk , - div1_12 , 0._rk , 0._rk , div1_36 , & & div1_36 , - div1_108 , & & div1_54 , 0._rk , - div1_18 , div1_18 , 0._rk , - div1_6 , 0._rk , - div1_36 , 0._rk , div1_36 , 0._rk , - div1_72 , & & div1_72 , 0._rk , - div1_8 , - div1_8 , 0._rk , 0._rk , - div1_36 , 0._rk , 0._rk , div1_12 , 0._rk , 0._rk , div1_36 , & & - div1_36 , - div1_108 , & & div1_54 , 0._rk , div1_18 , - div1_18 , 0._rk , - div1_6 , 0._rk , - div1_36 , 0._rk , div1_36 , 0._rk , div1_72 , & & - div1_72 , 0._rk , div1_8 , div1_8 , 0._rk , 0._rk , - div1_36 , 0._rk , 0._rk , div1_12 , 0._rk , 0._rk , - div1_36 , & & div1_36 , - div1_108 , & & div1_54 , 0._rk , div1_18 , div1_18 , 0._rk , div1_6 , 0._rk , - div1_36 , 0._rk , div1_36 , 0._rk , div1_72 , div1_72 , & & 0._rk , div1_8 , - div1_8 , 0._rk , 0._rk , - div1_36 , 0._rk , 0._rk , - div1_12 , 0._rk , 0._rk , - div1_36 , - div1_36 , & & - div1_108 , & & div1_54 , - div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , div1_6 , div1_72 , - div1_24 , div1_36 , - div1_72 , 0._rk , & & - div1_72 , div1_8 , 0._rk , - div1_8 , 0._rk , 0._rk , div1_72 , - div1_24 , 0._rk , 0._rk , - div1_12 , div1_36 , & & 0._rk , div1_36 , - div1_108 , & & div1_54 , div1_18 , 0._rk , - div1_18 , 0._rk , 0._rk , - div1_6 , div1_72 , - div1_24 , div1_36 , div1_72 , 0._rk , & & - div1_72 , - div1_8 , 0._rk , - div1_8 , 0._rk , 0._rk , div1_72 , - div1_24 , 0._rk , 0._rk , div1_12 , - div1_36 , & & 0._rk , div1_36 , - div1_108 , & & div1_54 , - div1_18 , 0._rk , div1_18 , 0._rk , 0._rk , - div1_6 , div1_72 , - div1_24 , div1_36 , - div1_72 , 0._rk , & & div1_72 , div1_8 , 0._rk , div1_8 , 0._rk , 0._rk , div1_72 , - div1_24 , 0._rk , 0._rk , div1_12 , div1_36 , 0._rk , & & - div1_36 , - div1_108 , & & div1_54 , div1_18 , 0._rk , div1_18 , 0._rk , 0._rk , div1_6 , div1_72 , - div1_24 , div1_36 , div1_72 , 0._rk , & & div1_72 , - div1_8 , 0._rk , div1_8 , 0._rk , 0._rk , div1_72 , - div1_24 , 0._rk , 0._rk , - div1_12 , - div1_36 , & & 0._rk , - div1_36 , - div1_108 , & & div1_54 , - div1_18 , - div1_18 , 0._rk , div1_6 , 0._rk , 0._rk , div1_72 , div1_24 , div1_36 , - div1_72 , - div1_72 , & & 0._rk , - div1_8 , div1_8 , 0._rk , 0._rk , 0._rk , div1_72 , div1_24 , - div1_12 , 0._rk , 0._rk , div1_36 , div1_36 , & & 0._rk , - div1_108 , & & div1_54 , - div1_18 , div1_18 , 0._rk , - div1_6 , 0._rk , 0._rk , div1_72 , div1_24 , div1_36 , - div1_72 , div1_72 , & & 0._rk , - div1_8 , - div1_8 , 0._rk , 0._rk , 0._rk , div1_72 , div1_24 , div1_12 , 0._rk , 0._rk , div1_36 , - div1_36 , & & 0._rk , - div1_108 , & & div1_54 , div1_18 , - div1_18 , 0._rk , - div1_6 , 0._rk , 0._rk , div1_72 , div1_24 , div1_36 , div1_72 , - div1_72 , & & 0._rk , div1_8 , div1_8 , 0._rk , 0._rk , 0._rk , div1_72 , div1_24 , div1_12 , 0._rk , 0._rk , - div1_36 , div1_36 , & & 0._rk , - div1_108 , & & div1_54 , div1_18 , div1_18 , 0._rk , div1_6 , 0._rk , 0._rk , div1_72 , div1_24 , div1_36 , div1_72 , div1_72 , 0._rk , & & div1_8 , - div1_8 , 0._rk , 0._rk , 0._rk , div1_72 , div1_24 , - div1_12 , 0._rk , 0._rk , - div1_36 , - div1_36 , & & 0._rk , - div1_108 , & & div1_216 , - div1_72 , - div1_72 , - div1_72 , div1_24 , div1_24 , div1_24 , 0._rk , 0._rk , div1_72 , - div1_72 , & & - div1_72 , - div1_72 , 0._rk , 0._rk , 0._rk , - div1_8 , div1_72 , 0._rk , 0._rk , div1_24 , div1_24 , div1_24 , & & - div1_72 , - div1_72 , - div1_72 , div1_216 , & & div1_216 , - div1_72 , - div1_72 , div1_72 , div1_24 , - div1_24 , - div1_24 , 0._rk , 0._rk , div1_72 , - div1_72 , & & - div1_72 , div1_72 , 0._rk , 0._rk , 0._rk , div1_8 , div1_72 , 0._rk , 0._rk , div1_24 , - div1_24 , - div1_24 , & & - div1_72 , - div1_72 , div1_72 , div1_216 , & & div1_216 , - div1_72 , div1_72 , - div1_72 , - div1_24 , - div1_24 , div1_24 , 0._rk , 0._rk , div1_72 , - div1_72 , & & div1_72 , - div1_72 , 0._rk , 0._rk , 0._rk , div1_8 , div1_72 , 0._rk , 0._rk , - div1_24 , - div1_24 , div1_24 , & & - div1_72 , div1_72 , - div1_72 , div1_216 , & & div1_216 , - div1_72 , div1_72 , div1_72 , - div1_24 , div1_24 , - div1_24 , 0._rk , 0._rk , div1_72 , - div1_72 , & & div1_72 , div1_72 , 0._rk , 0._rk , 0._rk , - div1_8 , div1_72 , 0._rk , 0._rk , - div1_24 , div1_24 , - div1_24 , & & - div1_72 , div1_72 , div1_72 , div1_216 , & & div1_216 , div1_72 , - div1_72 , - div1_72 , - div1_24 , div1_24 , - div1_24 , 0._rk , 0._rk , div1_72 , div1_72 , & & - div1_72 , - div1_72 , 0._rk , 0._rk , 0._rk , div1_8 , div1_72 , 0._rk , 0._rk , - div1_24 , div1_24 , - div1_24 , & & div1_72 , - div1_72 , - div1_72 , div1_216 , & & div1_216 , div1_72 , - div1_72 , div1_72 , - div1_24 , - div1_24 , div1_24 , 0._rk , 0._rk , div1_72 , div1_72 , & & - div1_72 , div1_72 , 0._rk , 0._rk , 0._rk , - div1_8 , div1_72 , 0._rk , 0._rk , - div1_24 , - div1_24 , div1_24 , & & div1_72 , - div1_72 , div1_72 , div1_216 , & & div1_216 , div1_72 , div1_72 , - div1_72 , div1_24 , - div1_24 , - div1_24 , 0._rk , 0._rk , div1_72 , div1_72 , div1_72 , & & - div1_72 , 0._rk , 0._rk , 0._rk , - div1_8 , div1_72 , 0._rk , 0._rk , div1_24 , - div1_24 , - div1_24 , div1_72 , & & div1_72 , - div1_72 , div1_216 , & & div1_216 , div1_72 , div1_72 , div1_72 , div1_24 , div1_24 , div1_24 , 0._rk , 0._rk , div1_72 , div1_72 , div1_72 , & & div1_72 , 0._rk , 0._rk , 0._rk , div1_8 , div1_72 , 0._rk , 0._rk , div1_24 , div1_24 , div1_24 , div1_72 , div1_72 , & & div1_72 , div1_216 , & & div8_27 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - div4_9 , 0._rk , 0._rk , 0._rk , 0._rk , & & 0._rk , 0._rk , 0._rk , div2_9 , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , 0._rk , - div1_27 & & / ),( / 27 , 27 / ), order = ( / 2 , 1 / ) ) contains ! **************************************************************************** ! !> Unoptimized explicit implementation !! !! This subroutine interface must match the abstract interface definition !! [[kernel]] in scheme/[[mus_scheme_type_module]].f90 in order to be callable !! via [[mus_scheme_type:compute]] function pointer. function check_mrt_matrix_d3q19 () result ( test ) logical :: test ! --------------------------------------------------------------------------- integer :: iDir real ( kind = rk ) :: M_Minv ! --------------------------------------------------------------------------- test = . false . ! check whether the M and Minv matrices are consistent. ! M * M_inv = I do iDir = 1 , 19 M_Minv = sum ( MMtrD3Q19 ( iDir ,:) * MMIvD3Q19 (:, iDir ) ) write ( * , * ) \"row = \" , iDir , \"; M_Sum = \" , sum ( MMtrD3Q19 ( iDir ,:) ), \"& &; MInv_Sum = \" , sum ( MMIvD3Q19 ( iDir ,:) ), \"& &; M_dot_M_inv = \" , M_Minv if ( abs ( M_Minv - 1._rk ) > 1e-15 ) then write ( * , * ) 'M * M_inv = ' , M_Minv , ' along direction ' , iDir test = . true . endif end do end function check_mrt_matrix_d3q19 ! **************************************************************************** ! ! **************************************************************************** ! !> Unoptimized explicit implementation !! !! This subroutine interface must match the abstract interface definition !! [[kernel]] in scheme/[[mus_scheme_type_module]].f90 in order to be callable !! via [[mus_scheme_type:compute]] function pointer. function check_mrt_matrix_d3q27 () result ( test ) logical :: test ! --------------------------------------------------------------------------- integer :: iDir real ( kind = rk ) :: M_Minv ! --------------------------------------------------------------------------- test = . false . ! check whether the M and Minv matrices are consistent. ! M * M_inv = I do iDir = 1 , 27 M_Minv = sum ( WMMtrD3Q27 ( iDir ,:) * WMMIvD3Q27 (:, iDir ) ) write ( * , * ) \"row = \" , iDir , \"; M_Sum = \" , sum ( WMMtrD3Q27 ( iDir ,:) ), \"& &; MInv_Sum = \" , sum ( WMMIvD3Q27 ( iDir ,:) ), \"& &; M_dot_M_inv = \" , M_Minv if ( abs ( M_Minv - 1._rk ) > 1e-15 ) then write ( * , * ) 'M * M_inv = ' , M_Minv , ' along direction ' , iDir test = . true . endif end do end function check_mrt_matrix_d3q27 ! **************************************************************************** ! end module mus_mrtInit_module","tags":"","loc":"sourcefile/mus_mrtinit_module.f90.html"},{"title":"mus_turb_viscosity_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_turb_viscosity_module.f90~~EfferentGraph sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_turb_viscosity_module.f90~~AfferentGraph sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module assigns function pointer to calculate turbulent viscosity !! according to turbulence model and scheme definition module mus_turb_viscosity_module ! include treelm modules use env_module , only : rk use tem_aux_module , only : tem_abort use mus_scheme_header_module , only : mus_scheme_header_type use mus_turbulence_module , only : mus_turbulence_type , & & mus_turbulence_config_type use mus_gradData_module , only : mus_gradData_type , mus_Grad_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_WALE_module , only : mus_turbVisc_WALE_2D , & & mus_turbVisc_WALE_3D use mus_Vreman_module , only : mus_turbVisc_Vreman_2D , & & mus_turbVisc_Vreman_3D use mus_Smagorinsky_module , only : mus_turbVisc_Smagorinsky_fromGradU3D , & & mus_turbVisc_Smagorinsky_fromGradU2D , & & mus_turbVisc_Smagorinsky_fromGradU3D_incomp , & & mus_turbVisc_Smagorinsky_fromGradU2D_incomp , & & mus_turbVisc_Smagorinsky_fromPreColPDF_2D , & & mus_turbVisc_Smagorinsky_fromPreColPDF_3D , & & mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_2D , & & mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_3D implicit none private public :: mus_assign_turbVisc_ptr contains ! ************************************************************************** ! !> This routine assigns function pointer to compute turbulence viscosity !! based on turbulence model and scheme header definition subroutine mus_assign_turbVisc_ptr ( turb , schemeHeader ) ! -------------------------------------------------------------------------- !> Scheme header information type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> turbulence type type ( mus_turbulence_type ), intent ( inout ) :: turb ! -------------------------------------------------------------------------- turb % calcVisc % fromGradU => mus_turbVisc_fromGradU_dummy turb % calcVisc % fromPreColPDF => mus_turbVisc_fromPreColPDF_dummy select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) select case ( trim ( turb % config % model )) case ( 'smagorinsky' ) select case ( trim ( schemeHeader % kind )) case ( 'fluid' ) if ( turb % config % compSR_fromPDF ) then turb % calcVisc % fromPreColPDF & & => mus_turbVisc_Smagorinsky_fromPreColPDF_2D else turb % calcVisc % fromGradU => mus_turbVisc_Smagorinsky_fromGradU2D end if case ( 'fluid_incompressible' ) if ( turb % config % compSR_fromPDF ) then turb % calcVisc % fromPreColPDF & & => mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_2D else turb % calcVisc % fromGradU & & => mus_turbVisc_Smagorinsky_fromGradU2D_incomp end if case default call tem_abort ( 'Error: Unknown scheme kind for turbulence ' & & // 'viscosity ptr' ) end select case ( 'wale' ) turb % calcVisc % fromGradU => mus_turbVisc_WALE_2D case ( 'vreman' ) turb % calcVisc % fromGradU => mus_turbVisc_Vreman_2D end select case ( 'd3q15' , 'd3q19' , 'd3q27' ) select case ( trim ( turb % config % model )) case ( 'smagorinsky' ) select case ( trim ( schemeHeader % kind )) case ( 'fluid' ) if ( turb % config % compSR_fromPDF ) then turb % calcVisc % fromPreColPDF & & => mus_turbVisc_Smagorinsky_fromPreColPDF_3D else turb % calcVisc % fromGradU => mus_turbVisc_Smagorinsky_fromGradU3D end if case ( 'fluid_incompressible' ) if ( turb % config % compSR_fromPDF ) then turb % calcVisc % fromPreColPDF & & => mus_turbVisc_Smagorinsky_fromPreColPDF_incomp_3D else turb % calcVisc % fromGradU & & => mus_turbVisc_Smagorinsky_fromGradU3D_incomp end if case default call tem_abort ( 'Error: Unknown scheme kind for turbulence ' & & // 'viscosity ptr' ) end select case ( 'wale' ) turb % calcVisc % fromGradU => mus_turbVisc_WALE_3D case ( 'vreman' ) turb % calcVisc % fromGradU => mus_turbVisc_Vreman_3D end select case default call tem_abort ( 'Error: Unknown layout for turbulence viscosity ptr' ) end select end subroutine mus_assign_turbVisc_ptr ! ************************************************************************** ! ! ************************************************************************** ! !> Dummy function for turbulent viscosity from Gradu procedure subroutine mus_turbVisc_fromGradU_dummy ( turbVisc , turbConfig , gradData , & & auxField , velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> turbulence config contains oefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> turbulence coefficients !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- call tem_abort ( 'DUMMY routine to calculate turbVisc from gradU' ) end subroutine mus_turbVisc_fromGradU_dummy ! ************************************************************************** ! ! ************************************************************************** ! !> Dummy function to compute turbulent viscosity from PDF subroutine mus_turbVisc_fromPreColPDF_dummy ( turbVisc , turbConfig , state , & & neigh , auxField , densPos , velPos , nSize , nSolve , nScalars , nAuxScalars ,& & layout , dxL , dtL , viscKine ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> turbulence type is implicitly passed to access turbulence coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> state array real ( kind = rk ), intent ( in ) :: state (:) !> neigh array to obtain precollision pdf integer , intent ( in ) :: neigh (:) !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of density in auxField integer , intent ( in ) :: densPos !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> number of elements in state array integer , intent ( in ) :: nSize !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in state array integer , intent ( in ) :: nScalars !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> scheme layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Background kinematic viscosity divided by dtL real ( kind = rk ), intent ( in ) :: viscKine (:) ! -------------------------------------------------------------------------- call tem_abort ( 'DUMMY routine to calculate turbVisc from PreCol PDF' ) end subroutine mus_turbVisc_fromPreColPDF_dummy ! ************************************************************************** ! end module mus_turb_viscosity_module","tags":"","loc":"sourcefile/mus_turb_viscosity_module.f90.html"},{"title":"mus_interpolate_header_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_interpolate_header_module.f90~~EfferentGraph sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_interpolate_header_module.f90~~AfferentGraph sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2011-2012 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2015, 2017-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012, 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2017-2018, 2020 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Manuel Hasert !! author: Jiaxing Qi !! Interpolation header to load confiugration and type definition module mus_interpolate_header_module ! include aotus modules use aotus_module , only : flu_State , aot_get_val use aot_table_module , only : aot_table_open , aot_table_close , aot_table_length use aot_out_module , only : aot_out_type , aot_out_val ! include treelm modules use env_module , only : rk , labelLen use tem_tools_module , only : tem_horizontalSpacer use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_debug_module , only : dbgUnit use tem_varSys_module , only : tem_varSys_type use tem_grow_array_module , only : grw_realArray_type , init use tem_construction_module , only : tem_levelDesc_type use tem_param_module , only : qN00 , q0N0 , q00N , q100 , q010 , q001 , & & q0NN , q0N1 , q01N , q011 , qN0N , q10N , & & qN01 , q101 , qNN0 , qN10 , q1N0 , q110 , & & qNNN , qNN1 , qN1N , qN11 , q1NN , q1N1 , & & q11N , q111 , q000 use tem_matrix_module , only : tem_intpMatrixLSF_type , init use tem_time_module , only : tem_time_type use tem_stencil_module , only : tem_stencilHeader_type ! include musubi modules use mus_field_prop_module , only : mus_field_prop_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_physics_module , only : mus_physics_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_directions_module , only : qN0 , q0N , q10 , q01 , qNN , qN1 , q1N , q11 implicit none private public :: mus_interpolation_type public :: mus_interpolation_config_type public :: mus_interpolation_method_type public :: mus_interpolation_stencil_type public :: mus_load_interpolate public :: mus_interpolate_out public :: mus_set_nSources !> Interpolation parameter to choose fillFinerFromMe integer , parameter , public :: no_intp = - 1 integer , parameter , public :: weighted_average = 0 integer , parameter , public :: linear = 1 integer , parameter , public :: quadratic = 2 ! D2Q9 directions are imported from mus_directions_module, we only need to ! specify q00 integer , parameter :: q00 = 9 !< rest !> This data types contains intpRoutine function pointer for FillFiner !! and FillCoarser. !! For fillFiner, it build least square fit matrix for linear !! quadratic interpolations !! For fillCoarser: currently we do simple average !! !! Why do we need different intpRoutine for fillFinerFromMe? !! The order of interpolation to finer depends on available number !! of coarser source elements so for every order we use different !! interpolation routines. !! We start with user defined interpolation order and !! If nMinSources for that order is not found then we fall back to lower order !! Weighted average will be the lowest level for which nMinSources = 1 type mus_interpolation_method_type !> Routine to interpolate coarse to fine for ghostFromCoarser elements !! and interpolate fine to coarse for ghostFromFiner elements. !! Sets pdf for ghost elements by f_eq + f_neq !! The moments required to compute equilibrium function are obtained !! from auxField array and the auxField of ghost elements are interpolate !! seperately using do_intpArbitraryField procedure ( intpRoutine ), pointer :: do_intp => null () !> Routine to interpolate coarse to fine and fine to coarse for !! arbitrary variables procedure ( intpRoutine_arbitraryVal ), pointer :: do_intpArbiVal => null () !> Matrix entries for linear/Quadratic interpolation least square fit !! ((A&#94;T)A)&#94;-1*(A&#94;T) !! Size: (6,9) for D2Q9 stencil !! Size: (10,QQ)  for D3Q19 and D3Q27 type ( tem_intpMatrixLSF_type ) :: intpMat_forLSF !> how many source elements are required by this interpolation order integer :: nMinSources !> Max number of sources amoung target ghosts !! Computed in mus_contruction::mus_intp_complete_coarseDep integer :: nMaxSources end type mus_interpolation_method_type !> Contains stencil for interpolation type mus_interpolation_stencil_type !> Is active only for specific layouts like d2q9, d3q19, d3q27 logical :: isActive = . false . !> cxDir for interpolation stencil for depFromCoarser integer , allocatable :: neighDir (:,:) end type mus_interpolation_stencil_type !> Contains information loaded from config file type mus_interpolation_config_type !> name of the order of the interpolation method for fillFinerFromMe character ( len = labelLen ) :: method !> Order of the interpolation for fillFinerFromMe integer :: order !> name of used weighting method character ( len = labelLen ) :: weights_method = 'linear_distance' !> Power factor for inverse distance weighting integer :: IDW_powerfac = 6 !> Stencil for linear interpolation. !! By default use stencil from weighted average logical :: useComputeStencil = . false . !> Interpolation test by comparing against the initial condition logical :: testInterpolation = . false . logical :: testEachElement = . false . logical :: testFluids = . false . logical :: noIntpFromFiner = . false . logical :: noIntpFromCoarser = . false . end type mus_interpolation_config_type !> definition of the used interpolation method type mus_interpolation_type !> Information loaded from config file type ( mus_interpolation_config_type ) :: config !> Interpolation routines to fillFiner !! Size: interpolation order type ( mus_interpolation_method_type ), allocatable :: fillFinerFromME (:) !> Interpolation routines to fillCoarser type ( mus_interpolation_method_type ) :: fillMineFromFiner !> stencil for weighted average interpolation type ( mus_interpolation_stencil_type ) :: weightedAvgStencil end type mus_interpolation_type ! ****************************************************************************** ! abstract interface !> This is the interface for all interpolation methods that !  can be called from outside to set state variable for ghost elements subroutine intpRoutine ( method , fieldProp , tLevelDesc , level , sState , & & sNeigh , snSize , sAuxfield , tState , tNeigh , tnSize , & & layout , nTargets , targetList , physics , time , varSys , derVarPos ) import :: mus_interpolation_method_type , mus_scheme_layout_type , & & mus_field_prop_type , tem_levelDesc_type , mus_physics_type , rk , & & tem_varSys_type , tem_time_type , mus_derVarPos_type class ( mus_interpolation_method_type ), intent ( inout ) :: method !> Array of field properties (fluid or species) type ( mus_field_prop_type ), target , intent ( in ) :: fieldProp (:) !> my refinement level integer , intent ( in ) :: level !> State vector of SOURCE elements real ( kind = rk ), intent ( in ) :: sState (:) integer , intent ( in ) :: sNeigh (:) integer , intent ( in ) :: snSize !> AuxField variable to read rho and vel from source elements real ( kind = rk ), intent ( inout ) :: sAuxField (:) !> State vector of TARGET GHOST elements real ( kind = rk ), intent ( inout ) :: tState (:) integer , intent ( in ) :: tNeigh (:) integer , intent ( in ) :: tnSize !> level descriptor on target level type ( tem_levelDesc_type ), intent ( in ) :: tLevelDesc !> the layout used type ( mus_scheme_layout_type ), intent ( in ) :: layout !> List of target elements ( their position in depSource list ) integer , intent ( in ) :: nTargets integer , intent ( in ) :: targetList ( nTargets ) !> physics type to convert lattice to physics SI unit and vice versa type ( mus_physics_type ), intent ( in ) :: physics !> time required to compute analytical solution for TGV case type ( tem_time_type ), intent ( in ) :: time !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of all derive variable in varSys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) end subroutine intpRoutine !> This is the interface for all interpolation methods that !  can be called from outside to interpolate arbitrary variable subroutine intpRoutine_arbitraryVal ( method , tLevelDesc , level , stencil , & & sVal , tVal , nTargets , targetList , & & nScalars ) import :: mus_interpolation_method_type , rk , tem_levelDesc_type , & & tem_stencilHeader_type class ( mus_interpolation_method_type ), intent ( inout ) :: method !> level descriptor on target level type ( tem_levelDesc_type ), intent ( in ) :: tLevelDesc !> my refinement level integer , intent ( in ) :: level !> stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> array of SOURCE elements real ( kind = rk ), intent ( in ) :: sVal (:) !> array of TARGET GHOST elements real ( kind = rk ), intent ( inout ) :: tVal (:) !> List of target elements ( their position in depSource list ) integer , intent ( in ) :: nTargets !> position in total list - offset integer , intent ( in ) :: targetList ( nTargets ) !> Number of scalars to interpolate integer , intent ( in ) :: nScalars end subroutine intpRoutine_arbitraryVal end interface ! ****************************************************************************** ! contains ! ****************************************************************************** ! !> Read in the type of interpolation scheme !! !!```lua !! interpolation_method = 'linear'               -- simple definition !! interpolation_method = {method ='debug', value = 1.} -- definition in a table !!``` !! subroutine mus_load_interpolate ( me , conf , parent ) ! --------------------------------------------------------------------------- !> interpolation type to load info to type ( mus_interpolation_config_type ), intent ( out ) :: me !> lua state to load from type ( flu_state ) :: conf !> optional parent table to load from integer , optional , intent ( in ) :: parent ! --------------------------------------------------------------------------- character ( len = 32 ) :: localKey integer :: iError , nEntries , intp_handle ! --------------------------------------------------------------------------- localKey = 'interpolation_method' ! if more than one variable is defined in a table then ! ref_value should also be a table with reference value for each variable ! defined in the variable table. if ( present ( parent )) then call aot_table_open ( L = conf , thandle = intp_handle , key = localKey , & & parent = parent ) else call aot_table_open ( L = conf , thandle = intp_handle , key = localKey ) endif ! not a table, just the name of the interpolation method if ( intp_handle == 0 ) then call aot_get_val ( L = conf , key = localKey , & & val = me % method , & & ErrCode = iError , default = 'quadratic' ) else ! interpolation is defined as a table with optional additional information ! Get size of table nEntries = aot_table_length ( L = conf , thandle = intp_handle ) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % method , ErrCode = iError , & & key = 'method' , default = 'quadratic' ) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % useComputeStencil , & & ErrCode = iError , & & key = 'use_compute_stencil' , & & default = . false . ) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % weights_method , & & ErrCode = iError , & & key = 'weights_method' , & & default = 'linear_distance' ) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % IDW_powerfac , & & ErrCode = iError , & & key = 'inverse_distance_powerfac' , & & default = 6 ) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % testInterpolation , ErrCode = iError , & & key = 'test' , default = . false .) if ( me % testInterpolation ) then write ( logUnit ( 1 ), * ) ' Activated the Interpolation test.' call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % testEachElement , ErrCode = iError , & & key = 'testEach' , default = . false .) if ( me % testEachElement ) then write ( logUnit ( 1 ), * ) ' Testing each element... ' end if call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % testFluids , ErrCode = iError , & & key = 'testFluids' , default = . false .) if ( me % testFluids ) then write ( logUnit ( 1 ), * ) ' Testing fluid element... ' end if end if call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % noIntpFromFiner , ErrCode = iError , & & key = 'noIntpFromFiner' , default = . false .) call aot_get_val ( L = conf , thandle = intp_handle , & & val = me % noIntpFromCoarser , ErrCode = iError , & & key = 'noIntpFromCoarser' , default = . false .) endif call aot_table_close ( L = conf , thandle = intp_handle ) ! set interpolation order for fillFinerFromMe select case ( trim ( me % method ) ) case ( 'weighted_average' ) me % order = weighted_average case ( 'linear' ) me % order = linear case ( 'quadratic' ) me % order = quadratic case ( 'none' ) me % order = no_intp case default call tem_abort ( 'From mus_load_interpolate: Unknown interpolation method' ) end select call interpolate_dump ( me , logUnit ( 1 ) ) end subroutine mus_load_interpolate ! ****************************************************************************** ! ! ****************************************************************************** ! subroutine mus_set_nSources ( me , nDims , QQ , layout ) ! --------------------------------------------------------------------------- type ( mus_interpolation_type ), intent ( inout ) :: me integer , intent ( in ) :: nDims , QQ character ( len =* ), intent ( in ) :: layout ! --------------------------------------------------------------------------- integer :: iOrder ! --------------------------------------------------------------------------- ! Set nSources for fillCoarse me % fillMineFromFiner % nMinSources = 1 select case ( nDims ) case ( 1 ) me % fillMineFromFiner % nMaxSources = 2 case ( 2 ) me % fillMineFromFiner % nMaxSources = 4 case ( 3 ) me % fillMineFromFiner % nMaxSources = 8 end select ! Set nSources for fillFiner if ( allocated ( me % fillFinerFromMe )) deallocate ( me % fillFinerFromMe ) allocate ( me % fillFinerFromMe ( 0 : me % config % order )) do iOrder = 0 , me % config % order select case ( iOrder ) case ( no_intp ) ! do nothing case ( weighted_average ) me % fillFinerFromMe ( iOrder )% nMinSources = 1 select case ( nDims ) case ( 1 ) me % fillFinerFromMe ( iOrder )% nMaxSources = 2 case ( 2 ) me % fillFinerFromMe ( iOrder )% nMaxSources = 4 if ( trim ( layout ) == 'd2q9' ) me % weightedAvgStencil % isActive = . true . case ( 3 ) select case ( trim ( layout )) case ( 'd3q19' ) me % fillFinerFromMe ( iOrder )% nMaxSources = 7 me % weightedAvgStencil % isActive = . true . case ( 'd3q27' ) me % fillFinerFromMe ( iOrder )% nMaxSources = 8 me % weightedAvgStencil % isActive = . true . case default me % fillFinerFromMe ( iOrder )% nMaxSources = QQ end select end select ! Use weighted average stencil only if QQ stencil is D2Q9, D3Q19 ! or D3Q27 ! else compute weight from all available sources if ( me % weightedAvgStencil % isActive ) then if ( allocated ( me % weightedAvgStencil % neighDir ) ) & & deallocate ( me % weightedAvgStencil % neighDir ) allocate ( me % weightedAvgStencil % neighDir ( me % fillFinerFromMe ( iOrder ) & & % nMaxSources , 8 )) me % weightedAvgStencil % neighDir & & = init_cxDirWeightedAvg ( QQ , me % fillFinerFromMe ( iOrder ) & & % nMaxSources ) end if case ( linear ) ! initialize least square matrix for linear interpolation call init ( me = me % fillFinerFromMe ( iOrder )% intpMat_forLSF , & & length = 1 , & & nDims = nDims , & & order = linear ) me % fillFinerFromMe ( iOrder )% nMinSources = me % fillFinerFromMe ( iOrder ) & & % intpMat_forLSF % nCoeffs ! Number of sources in weighted average stencil is enough for linear ! interpolation so use this stencil. Using weighted average stencil ! showed better result then using compute stencil if ( me % config % useComputeStencil ) then me % fillFinerFromMe ( iOrder )% nMaxSources = QQ me % weightedAvgStencil % isActive = . false . else select case ( nDims ) case ( 1 ) me % fillFinerFromMe ( iOrder )% nMaxSources = 2 case ( 2 ) me % fillFinerFromMe ( iOrder )% nMaxSources = 4 if ( trim ( layout ) == 'd2q9' ) me % weightedAvgStencil % isActive = . true . case ( 3 ) select case ( trim ( layout )) case ( 'd3q19' ) me % fillFinerFromMe ( iOrder )% nMaxSources = 7 me % weightedAvgStencil % isActive = . true . case ( 'd3q27' ) me % fillFinerFromMe ( iOrder )% nMaxSources = 8 me % weightedAvgStencil % isActive = . true . case default me % fillFinerFromMe ( iOrder )% nMaxSources = QQ end select end select end if case ( quadratic ) ! initialize least square matrix for quadratic interpolation call init ( me = me % fillFinerFromMe ( iOrder )% intpMat_forLSF , & & length = 1 , & & nDims = nDims , & & order = quadratic ) me % fillFinerFromMe ( iOrder )% nMinSources = me % fillFinerFromMe ( iOrder ) & & % intpMat_forLSF % nCoeffs me % fillFinerFromMe ( iOrder )% nMaxSources = QQ case default call tem_abort ( 'From mus_set_nSources: Unknown interpolation order' ) end select end do write ( logUnit ( 1 ), \"(A)\" ) 'Setting for interpolation scheme: ' & & // trim ( me % config % method ) write ( logUnit ( 3 ), \"(A)\" ) '  Number of sources from coarser: ' write ( logUnit ( 3 ), \"(A,I0)\" ) '     nMinSources: ' , & & me % fillMineFromFiner % nMinSources write ( logUnit ( 3 ), \"(A,I0)\" ) '     nMaxSources: ' , & & me % fillMineFromFiner % nMaxSources write ( logUnit ( 3 ), \"(A)\" ) '  Number of sources from finer: ' do iOrder = 0 , me % config % order write ( logUnit ( 3 ), \"(A,I0)\" ) '    order: ' , iOrder write ( logUnit ( 3 ), \"(A,I0)\" ) '      nMinSources: ' , & & me % fillFinerFromMe ( iOrder )% nMinSources write ( logUnit ( 3 ), \"(A,I0)\" ) '      nMaxSources: ' , & & me % fillFinerFromMe ( iOrder )% nMaxSources end do if ( me % weightedAvgStencil % isActive ) then write ( logUnit ( 3 ), \"(A)\" ) '  use WeightedAvg stencil: T' end if end subroutine mus_set_nSources ! ****************************************************************************** ! ! ****************************************************************************** ! !> Dump interpolation method to lua subroutine mus_interpolate_out ( me , conf ) ! --------------------------------------------------------------------------- !> interpolation type to dump info to type ( mus_interpolation_type ), intent ( in ) :: me !> aotus type handling the output to the file in lua format type ( aot_out_type ), optional , intent ( inout ) :: conf ! --------------------------------------------------------------------------- call aot_out_val ( put_conf = conf , vname = 'interpolation_method' , & & val = trim ( me % config % method ) ) end subroutine mus_interpolate_out ! ****************************************************************************** ! ! ****************************************************************************** ! !> Dump interpolation method to logUnit subroutine interpolate_dump ( me , outUnit ) ! --------------------------------------------------------------------------- !> interpolation type to dump info to type ( mus_interpolation_config_type ), intent ( in ) :: me !> File unit to write to integer , intent ( in ) :: outUnit ! --------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = outUnit ) write ( outUnit , \"(A)\" ) 'Interpolation:' write ( outUnit , \"(2A)\" ) '  method: ' , trim ( me % method ) write ( outUnit , \"(A,i2)\" ) '   order: ' , me % order write ( outUnit , \"(2A)\" ) '  weights_method: ' , trim ( me % weights_method ) write ( outUnit , \"(A,i2)\" ) '  inverse distance powefac: ' , & & me % IDW_powerfac call tem_horizontalSpacer ( fUnit = outUnit ) end subroutine interpolate_dump ! ****************************************************************************** ! ! ****************************************************************************** ! !> Initialize stencil for weighted average interpolation function init_cxDirWeightedAvg ( QQ , nSources ) result ( me ) ! --------------------------------------------------------------------------- integer , intent ( in ) :: QQ integer , intent ( in ) :: nSources integer :: me ( nSources , 8 ) ! --------------------------------------------------------------------------- integer :: iChild integer , parameter :: q000_19 = 19 !< rest density is last for d3q19 stencil ! --------------------------------------------------------------------------- select case ( QQ ) case ( 9 ) me (:,:) = reshape ( [ qNN , q0N , qN0 , q00 , & ! A & q0N , q1N , q00 , q10 , & ! B & qN0 , q00 , qN1 , q01 , & ! C & q00 , q10 , q01 , q11 , & ! D & qNN , q0N , qN0 , q00 , & ! A & q0N , q1N , q00 , q10 , & ! B & qN0 , q00 , qN1 , q01 , & ! C & q00 , q10 , q01 , q11 ], [ nSources , 8 ] ) ! D case ( 19 ) me (:,:) = reshape ( [ q000_19 , qN00 , q0N0 , q00N , qNN0 , qN0N , q0NN , & ! child 1 & q000_19 , q100 , q0N0 , q00N , q1N0 , q10N , q0NN , & ! child 2 & q000_19 , qN00 , q010 , q00N , qN10 , qN0N , q01N , & ! child 3 & q000_19 , q100 , q010 , q00N , q110 , q10N , q01N , & ! child 4 & q000_19 , qN00 , q0N0 , q001 , qNN0 , qN01 , q0N1 , & ! child 5 & q000_19 , q100 , q0N0 , q001 , q1N0 , q101 , q0N1 , & ! child 6 & q000_19 , qN00 , q010 , q001 , qN10 , qN01 , q011 , & ! child 7 & q000_19 , q100 , q010 , q001 , q110 , q101 , q011 ], & ! child 8 & [ nSources , 8 ]) case ( 27 ) me (:,:) = reshape ( [ q000 , qN00 , q0N0 , q00N , qNN0 , qN0N , q0NN , qNNN , & ! child 1 & q000 , q100 , q0N0 , q00N , q1N0 , q10N , q0NN , q1NN , & ! child 2 & q000 , qN00 , q010 , q00N , qN10 , qN0N , q01N , qN1N , & ! child 3 & q000 , q100 , q010 , q00N , q110 , q10N , q01N , q11N , & ! child 4 & q000 , qN00 , q0N0 , q001 , qNN0 , qN01 , q0N1 , qNN1 , & ! child 5 & q000 , q100 , q0N0 , q001 , q1N0 , q101 , q0N1 , q1N1 , & ! child 6 & q000 , qN00 , q010 , q001 , qN10 , qN01 , q011 , qN11 , & ! child 7 & q000 , q100 , q010 , q001 , q110 , q101 , q011 , q111 ],& ! child 8 & [ nSources , 8 ]) case default write ( logUnit ( 1 ), \"(A)\" ) 'Weighted average interpolation requires D2Q9, D3Q19 ' & & // 'or D3Q27!' call tem_abort () end select write ( dbgUnit ( 2 ), \"(A)\" ) '' write ( dbgUnit ( 2 ), \"(A)\" ) ' linear stencil dir ' do iChild = 1 , 8 ! me(1:3,iNeigh,iChild) = cxDir(1:3, dir(iNeigh, iChild) ) write ( dbgUnit ( 2 ), \"(A,I0,A,4I3)\" ) 'childNum: ' , iChild , & & ', dir: ' , me ( 1 : nSources , iChild ) end do write ( dbgUnit ( 2 ), \"(A)\" ) '' end function init_cxDirWeightedAvg ! ****************************************************************************** ! end module mus_interpolate_header_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_interpolate_header_module.f90.html"},{"title":"mus_initLBMPS_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initlbmps_module.f90~~EfferentGraph sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains routines which assigns compute kernel for passive scalar !! model module mus_initLBMPS_module ! include treelm modules use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_compute_passiveScalar_module , only : mus_advRel_kPS_rBGK_v1st_l , & & mus_advRel_kPS_rBGK_v2nd_l , & & mus_advRel_kPS_rTRT_vStdNoOpt_l use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_lbm_ps contains ! ****************************************************************************** ! !> Initialize the relaxation model for lbm passive scalar scheme kind subroutine mus_init_advRel_lbm_ps ( relaxation , layout , relaxation_variant , compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout character ( len = labelLen ), intent ( in ) :: relaxation_variant procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Choosing LBM Passive Scalar relaxation model: ' // & & trim ( relaxation ) select case ( trim ( relaxation ) ) case ( 'bgk' ) select case ( trim ( relaxation_variant ) ) case ( 'first' ) compute => mus_advRel_kPS_rBGK_v1st_l case ( 'second' ) compute => mus_advRel_kPS_rBGK_v2nd_l case default write ( logUnit ( 1 ), * ) 'relaxation_variant ' // trim ( relaxation_variant ) // & & ' is not supported yet!' call tem_abort () end select case ( 'trt' ) write ( logUnit ( 1 ), * ) 'Using trt_advRel scheme.' compute => mus_advRel_kPS_rTRT_vStdNoOpt_l case default write ( logUnit ( 1 ), * ) 'The selected relaxation model is not supported: ' // & & trim ( relaxation ) call tem_abort () end select end subroutine mus_init_advRel_lbm_ps ! ****************************************************************************** ! end module mus_initLBMPS_module","tags":"","loc":"sourcefile/mus_initlbmps_module.f90.html"},{"title":"mus_Vreman_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_vreman_module.f90~~EfferentGraph sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_vreman_module.f90~~AfferentGraph sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains function to compute eddy viscosity using !! Vreman LES turbulence model. !! Vreman, A. W. (2004). An eddy-viscosity subgrid-scale model for turbulent !! shear flow: Algebraic theory and applications. Physics of Fluids, 16(10), !! 3670–3681. !! model. !! author: Kannan Masilamani module mus_Vreman_module ! treelm modules use env_module , only : rk use tem_float_module , only : operator (. flt .) use tem_compileconf_module , only : vlen ! musubi modules use mus_turbulence_module , only : mus_turbulence_config_type use mus_gradData_module , only : mus_gradData_type , mus_Grad_type implicit none private public :: mus_turbVisc_Vreman_3D public :: mus_turbVisc_Vreman_2D contains ! ************************************************************************** ! !> Calculate eddy viscosity with Vreman model for 3D stencil !! Fortran implementation of this model: !! http://www.vremanresearch.nl/Vreman_Subgridmodel_Fortran.txt !! !! \\nu_{turb}=c_v (\\Delta_x)&#94;2 \\cdot !!            \\left( \\sqrt{\\frac{B_\\beta}{\\alpha_{ij}\\alpha{ij}}} \\right) !! with !!  c_v = 2.5*C_s&#94;2, C_s - Smagorinsky constant, !! !!  B_\\beta = \\beta_{11}\\beta_{22} - \\beta&#94;2_{12} + \\beta_{11}\\beta_{33} !!            - \\beta&#94;2_{13} + \\beta_{22}\\beta_{33} - \\beta&#94;2_{23} , !! !!  \\beta_{ij} = \\alpha_{mi}\\alpha_{mj}, !! !!  \\alpha_{ij} = \\frac{\\partial \\Bar{u}_j}{\\partial x_i} . !! \\alpha_{ij} - Resolved velocity gradient. subroutine mus_turbVisc_Vreman_3D ( turbVisc , turbConfig , gradData , auxField , & & velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> Contains turbulenct coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- real ( kind = rk ) :: b_11 , b_12 , b_13 , b_22 , b_23 , b_33 real ( kind = rk ) :: visc_coeff real ( kind = rk ) :: bbeta integer :: iElem , ndims !> gradient of velocity real ( kind = rk ) :: gradU ( 3 , 3 , vlen ) real ( kind = rk ) :: gradU_sqr integer :: nChunks , iChunks , nChunkElems , low_bound , elemPos ! -------------------------------------------------------------------------- ! viscosity coeff visc_coeff = turbConfig % coeff % C_v * dxL ** 2 ! TODO : AR vectorize !      gradU = getGradU(iElem, auxField, gradData, velPos, nAuxScalars, 3) ndims = 3 nChunks = ceiling ( real ( nSolve , kind = rk ) / real ( vlen , kind = rk )) do iChunks = 1 , nChunks ! calculate the end  number of iElem loop nChunkElems = min ( vlen , nSolve - (( iChunks - 1 ) * vlen )) low_bound = ( iChunks - 1 ) * vlen gradU (:,:, 1 : nChunkElems ) = Grad % U_ptr ( auxField = auxField , & & gradData = gradData , & & velPos = velPos , & & nAuxScalars = nAuxScalars , & & nDims = nDims , & & nSolve = nChunkElems , & & elemOffset = low_bound ) do iElem = 1 , nChunkElems ! beta_ij = gradU_ki gradU_kj ! beta = gradU&#94;T gradU b_11 = gradU ( 1 , 1 , iElem ) * gradU ( 1 , 1 , iElem ) & & + gradU ( 2 , 1 , iElem ) * gradU ( 2 , 1 , iElem ) & & + gradU ( 3 , 1 , iElem ) * gradU ( 3 , 1 , iElem ) b_12 = gradU ( 1 , 1 , iElem ) * gradU ( 1 , 2 , iElem ) & & + gradU ( 2 , 1 , iElem ) * gradU ( 2 , 2 , iElem ) & & + gradU ( 3 , 1 , iElem ) * gradU ( 3 , 2 , iElem ) b_13 = gradU ( 1 , 1 , iElem ) * gradU ( 1 , 3 , iElem ) & & + gradU ( 2 , 1 , iElem ) * gradU ( 2 , 3 , iElem ) & & + gradU ( 3 , 1 , iElem ) * gradU ( 3 , 3 , iElem ) b_22 = gradU ( 1 , 2 , iElem ) * gradU ( 1 , 2 , iElem ) & & + gradU ( 2 , 2 , iElem ) * gradU ( 2 , 2 , iElem ) & & + gradU ( 3 , 2 , iElem ) * gradU ( 3 , 2 , iElem ) b_23 = gradU ( 1 , 2 , iElem ) * gradU ( 1 , 3 , iElem ) & & + gradU ( 2 , 2 , iElem ) * gradU ( 2 , 3 , iElem ) & & + gradU ( 3 , 2 , iElem ) * gradU ( 3 , 3 , iElem ) b_33 = gradU ( 1 , 3 , iElem ) * gradU ( 1 , 3 , iElem ) & & + gradU ( 2 , 3 , iElem ) * gradU ( 2 , 3 , iElem ) & & + gradU ( 3 , 3 , iElem ) * gradU ( 3 , 3 , iElem ) ! double inner product of gradU gradU_sqr = gradU ( 1 , 1 , iElem ) ** 2 + gradU ( 1 , 2 , iElem ) ** 2 & & + gradU ( 1 , 3 , iElem ) ** 2 + gradU ( 2 , 1 , iElem ) ** 2 & & + gradU ( 2 , 2 , iElem ) ** 2 + gradU ( 2 , 3 , iElem ) ** 2 & & + gradU ( 3 , 1 , iElem ) ** 2 + gradU ( 3 , 2 , iElem ) ** 2 & & + gradU ( 3 , 3 , iElem ) ** 2 ! numerator Bbeta bbeta = b_11 * b_22 - ( b_12 ** 2 ) + b_11 * b_33 - ( b_13 ** 2 ) + b_22 * b_33 - ( b_23 ** 2 ) elemPos = low_bound + iElem if ( bbeta . flt . 1e-12_rk ) then turbVisc ( elemPos ) = 0.0_rk else turbVisc ( elemPos ) = visc_coeff * sqrt ( bbeta / gradU_sqr ) / dtL end if end do !iElem end do !iChunks end subroutine mus_turbVisc_Vreman_3D ! ************************************************************************** ! ! ************************************************************************** ! !> Calculate eddy viscosity with Vreman model for 2D stencil !! model !! \\todo add reference and formula subroutine mus_turbVisc_Vreman_2D ( turbVisc , turbConfig , gradData , auxField , & & velPos , nSolve , nAuxScalars , dxL , dtL , Grad ) ! -------------------------------------------------------------------------- !> output: turbulent viscosity real ( kind = rk ), intent ( out ) :: turbVisc (:) !> Contains turbulenct coefficients type ( mus_turbulence_config_type ), intent ( in ) :: turbConfig !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> position of velocity components in auxField integer , intent ( in ) :: velPos ( 3 ) !> Number of element to solve in this level integer , intent ( in ) :: nSolve !> number of scalars in auxField array integer , intent ( in ) :: nAuxScalars !> current level lattice element size real ( kind = rk ), intent ( in ) :: dxL !> current level lattice time step size real ( kind = rk ), intent ( in ) :: dtL !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------------- integer :: iElem , ndims real ( kind = rk ) :: b_11 , b_12 , b_22 real ( kind = rk ) :: gradU_sqr , visc_coeff real ( kind = rk ) :: bbeta !> gradient of velocity real ( kind = rk ) :: gradU ( 2 , 2 , vlen ) integer :: nChunks , iChunks , nChunkElems , low_bound , elemPos ! -------------------------------------------------------------------------- ! viscosity coeff visc_coeff = turbConfig % coeff % C_v * dxL ** 2 !  gradU = getGradU(iElem, auxField, gradData, velPos, nAuxScalars, 2) nDims = 2 nChunks = ceiling ( real ( nSolve , kind = rk ) / real ( vlen , kind = rk )) do iChunks = 1 , nChunks ! calculate the end  number of iElem loop nChunkElems = min ( vlen , nSolve - (( iChunks - 1 ) * vlen )) low_bound = ( iChunks - 1 ) * vlen gradU (:,:, 1 : nChunkElems ) = Grad % U_ptr ( auxField = auxField , & & gradData = gradData , & & velPos = velPos , & & nAuxScalars = nAuxScalars , & & nDims = nDims , & & nSolve = nChunkElems , & & elemOffset = low_bound ) ! beta_ij = gradU_ki gradU_kj ! beta = gradU&#94;T gradU do iElem = 1 , nChunkElems b_11 = gradU ( 1 , 1 , iElem ) * gradU ( 1 , 1 , iElem ) & & + gradU ( 2 , 1 , iElem ) * gradU ( 2 , 1 , iElem ) b_12 = gradU ( 1 , 1 , iElem ) * gradU ( 1 , 2 , iElem ) & & + gradU ( 2 , 1 , iElem ) * gradU ( 2 , 2 , iElem ) b_22 = gradU ( 1 , 2 , iElem ) * gradU ( 1 , 2 , iElem ) & & + gradU ( 2 , 2 , iElem ) * gradU ( 2 , 2 , iElem ) ! double inner product of gradU gradU_sqr = gradU ( 1 , 1 , iElem ) ** 2 + gradU ( 1 , 2 , iElem ) ** 2 & & + gradU ( 2 , 1 , iElem ) ** 2 + gradU ( 2 , 2 , iElem ) ** 2 ! numerator Bbeta bbeta = b_11 * b_22 - ( b_12 ** 2 ) elemPos = low_bound + iElem if ( bbeta . flt . 1e-12_rk ) then turbVisc ( elemPos ) = 0.0_rk else turbVisc ( elemPos ) = visc_coeff * sqrt ( bbeta / gradU_sqr ) / dtL end if end do end do end subroutine mus_turbVisc_Vreman_2D ! ************************************************************************** ! end module mus_Vreman_module","tags":"","loc":"sourcefile/mus_vreman_module.f90.html"},{"title":"mus_physics_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_physics_module.f90~~AfferentGraph sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2013-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! !! This module contains data type and modules related to musubi !! lattice to physical unit convertion and vice versa. !! physics data type is global for all schemes, it is defined !! in the following format: !! !!```lua !! physics = { dt = dt_phy, -- physical time step size !!             rho0 = rho0_phy, -- reference density !!             temp0 = t_phy -- reference temperature !!} !!``` !! !! Of these quantities, dt is mandetory for conversion. !! Others can be omitted, thus use default values. !! !! To add a new conversion factor, one has to do the following: !! !! 1. add this new factor into [mus_convertFac_type] !! 2. add the defination of factor inside routine [mus_set_convFac] !! 3. add this new factor into routine [mus_physics_out] !! module mus_physics_module ! include treelm modules use env_module , only : rk use tem_aux_module , only : tem_abort use treelmesh_module , only : treelmesh_type use tem_geometry_module , only : tem_ElemSizeLevel use tem_logging_module , only : logUnit , tem_toStr use tem_tools_module , only : tem_horizontalSpacer ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_Fatal , & & aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , aot_get_val use aot_out_module , only : aot_out_type , aot_out_open_table , & & aot_out_close_table , aot_out_val implicit none private !> Reference coulomb is set to fundamental electrical charge real ( kind = rk ), parameter , public :: coulomb_ref = 1.60217657e-19_rk !> Reference mole is set to inverse of Avogadro's constant real ( kind = rk ), parameter , public :: mole_ref = 1e-23_rk / 6.02214129 !> the boltzmann constant J K&#94;-1 real ( kind = rk ), parameter , public :: k_b = 1.38064852e-23_rk !> Faraday constant C/mol real ( kind = rk ), parameter , public :: faraday = 9648 5.3365_rk !> Ideal gas constant N m / (mol K) real ( kind = rk ), parameter , public :: gasConst_R = 8.3144621_rk public :: mus_physics_type public :: mus_load_physics public :: mus_create_funcStr public :: mus_physics_out public :: mus_physics_out_conv public :: mus_convertFac_type public :: mus_set_convFac public :: set_values_by_levels public :: mus_physics_dump2outUnit public :: mus_set_scaleFac !> This type contains the converstion factor for derived variables !! from lattice to physical. !! !! Their inverses can be used to convert physical to lattice units !! use reference density to parmeterize kg and reference mole density !! to parmeterize mol type mus_convertFac_type !> length (m) = dx real ( kind = rk ) :: length !> time (s) = dt real ( kind = rk ) :: time !> velocity(m/s) = dx/dt real ( kind = rk ) :: vel !> kinematic viscosity(m&#94;2/s) = dx&#94;2/dt real ( kind = rk ) :: visc !> Dynamic viscosity (Pa s) = kg/m/s real ( kind = rk ) :: viscDyna !> acceleration(m/s&#94;2) = dx/dt&#94;2 real ( kind = rk ) :: accel !> Force(N)(kg m/s&#94;2) = rho0*dx&#94;4/dt&#94;2 real ( kind = rk ) :: force !> Force per unit volume (N/m&#94;3)(kg/s&#94;2/m&#94;2) = rho0*dx/dt&#94;2 real ( kind = rk ) :: body_force !> Pressure(N/m&#94;2)(kg/m/s&#94;2) = rho0*dx&#94;2/dt&#94;2 real ( kind = rk ) :: press !> Strain Rate (1/s) = 1/dt real ( kind = rk ) :: strainRate !> Energy (N-m) (kg*m&#94;2/s&#94;2) = rho0*dx&#94;5/dt&#94;2 real ( kind = rk ) :: energy !> mole density(mol/m&#94;3) = mole0/dx&#94;3 !real(kind=rk) :: moleDens !> Charge density (C/m&#94;3) = Coulomb0/dx&#94;3 real ( kind = rk ) :: chargeDens !> Current density (C/s/m&#94;2) = Coulomb0/dt/dx&#94;2 real ( kind = rk ) :: currentDens !> mole flux(mol/m&#94;2/s) = moleDen0*dx/dt real ( kind = rk ) :: moleFlux !> mass flux(kg/m&#94;2/s) = rho0*dx/dt real ( kind = rk ) :: flux !> diffusivity(m&#94;2/s) = dx&#94;2/dt real ( kind = rk ) :: diffusivity !> faraday (C/mol) = coulomb0/moleDens0/dx&#94;3 real ( kind = rk ) :: faraday !> gas constant (J/mol/K) (N m/mol/K) (kg m&#94;2/s&#94;2/mol/K) !! = rho0*dx&#94;5/dt&#94;2/mole0/temp0 real ( kind = rk ) :: gasConst !> Potential (V) (kg m&#94;2/(C*S&#94;2)) real ( kind = rk ) :: potential end type mus_convertFac_type !> This type contains the reference values as defined in the physics !! table by the user !! !! They are used to convert lattice to physical unit and vice versa. !! keep reference mass density, mole density and molecular weight !! same for all levels. !! Use [mus_load_physics] to fill the datatype properly. type mus_physics_type !> needed to check if physics table is defined logical :: active = . false . !> reference length - discretization size of the coarsest level !! SI unit - meter real ( kind = rk ) :: dx = - 1.0_rk real ( kind = rk ), allocatable :: dxLvl (:) !> reference time - time discretization for discretization size !! of the coarsest level !! SI unit - seconds real ( kind = rk ) :: dt = - 1.0_rk real ( kind = rk ), allocatable :: dtLvl (:) !> reference physical mass density !! SI unit - kg/m&#94;3 real ( kind = rk ) :: rho0 = - 1.0_rk !> reference physical mole density !! SI unit - mol/m&#94;3 real ( kind = rk ) :: moleDens0 = - 1.0_rk !> reference molecular weight !! SI unit - kg/mol real ( kind = rk ) :: molWeight0 = - 1.0_rk !> reference temperature !! SI unit - Kelvin real ( kind = rk ) :: temp0 = - 1.0_rk !> reference fundamental electrical charge !! SI unit - Coulomb real ( kind = rk ) :: coulomb0 = - 1.0_rk !> mole is defined by inverse of Avogadro Constant !! Avogadro Constant = 6.02214129e23 [1/mol] real ( kind = rk ) :: mole0 = - 1.0_rk !> reference mass in kg derived from density or moleweight !! SI unit :: kg real ( kind = rk ) :: mass0 = - 1.0_rk !> Level-wise conversion factor for derived variables !! size: minLevel:maxLevel !! allocated in mus_load_physics !! \\todo KM: conversion factor should not be level-dependent. !! it should be same for all levels, the lattice dx and dt for each level !! must be considered to scale variables in multilevel. !! Implemented force, visc, etc using dtL according to formula !! Introduced lattice speed variable: dx/dt for each level !! it should be same for all level for acoustic scaling and different !! for diffusive scaling type ( mus_convertFac_type ), allocatable :: fac (:) !> Pressure (strain rate) over level scale factor. !! This factor is meant to convert pressure in LB unit on source level to !! the required pressure on target level. !! It is mainly used in interpolation routine. !! It is allocated as: allocate(pFac( minLevel:maxLevel, minLevel:maxLevel)) !! It is allocated and initialized in routine: mus_set_scaleFac !! How to use it in the code: !! pTargetLevel = pSourceLevel * pFac( sourceLevel, targetLevel ) real ( kind = rk ), allocatable :: pFac (:,:) !> Velocity over level scale factor !! Its usage is the same as pressure scale factor real ( kind = rk ), allocatable :: vFac (:,:) !> Strain rate over level scale factor !! Its usage is the same as pressure scale factor real ( kind = rk ), allocatable :: sFac (:,:) end type mus_physics_type contains ! ************************************************************************** ! !> This routine loads the physics table from musubi config file !! !! If no physics table is provided, the conversion factors default to !! 1, resulting in the lattice units being directly used. !! dx_ref and dt_ref are set according to the provided arguments, or if !! not provided default to 1. !! See the [mus_physics_type] for a description of the various factors that !! can be set here. subroutine mus_load_physics ( me , conf , tree , scaleFactor , dtRef , dxRef ) ! -------------------------------------------------------------------------- !> physics type type ( mus_physics_type ), intent ( out ) :: me !> flu state type ( flu_State ) :: conf !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> scaling factor: diffusive -> 4; acoustic -> 2 integer , intent ( in ) :: scaleFactor !> reference time step if none real ( kind = rk ), optional , intent ( in ) :: dtRef !> reference spacestep if none real ( kind = rk ), optional , intent ( in ) :: dxRef ! -------------------------------------------------------------------------- integer :: thandle integer :: iError real ( kind = rk ) :: dt_Ref , dx_ref ! reference step if none ! -------------------------------------------------------------------------- if ( present ( dtRef )) then dt_ref = dtRef else dt_ref = 1._rk end if if ( present ( dxRef )) then dx_ref = dxRef else dx_ref = 1._rk end if call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) ' Loading physics table ...' call aot_table_open ( L = conf , thandle = thandle , key = 'physics' ) if ( thandle > 0 ) then me % active = . true . ! Found a physics table. ! Activate the conversion write ( logUnit ( 1 ), * ) ' Physics table is defined.' write ( logUnit ( 5 ), * ) ' All values are expressed in physical units.' ! reference dx is always the coarsest level in the tree me % dx = tem_ElemSizeLevel ( tree , tree % global % minLevel ) ! load dt call aot_get_val ( L = conf , thandle = thandle , key = 'dt' , & & val = me % dt , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving dt.' if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'Time step definition not found. Setting to dt=1' me % dt = dt_ref end if if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' write ( logUnit ( 1 ), * ) 'STOPPING' call tem_abort () endif end if ! define mole before loading density because if molecular weight is ! defined to compute reference mass than we need reference mole. ! try to load reference mole density, if not defined then set reference ! mole to inverse of avogadro's constant call aot_get_val ( L = conf , thandle = thandle , key = 'moleDens0' , & & val = me % moleDens0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 7 ), * ) 'No value given for moleDens0.' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Error! moleDens0 has wrong type!' call tem_abort () end if end if ! reference mole density not defined so try to load reference mole if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 7 ), * ) 'WARNING: Reference moleDens0 is not found. ' write ( logUnit ( 7 ), * ) 'Loading reference mole0(mol):' call aot_get_val ( L = conf , thandle = thandle , key = 'mole0' , & & val = me % mole0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 7 ), * ) 'FATAL Error occured, while retrieving mole0.' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' call tem_abort () end if end if ! reference mole is also not defined set inverse of Avogadro's constant if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 7 ), * ) 'WARNING: Reference mole0 is not found. ' write ( logUnit ( 7 ), * ) \"Setting reference mole to inverse of Avogadro's\" & & // \"constant.\" me % mole0 = mole_ref endif ! derive moleDens0 from mole0 me % moleDens0 = me % mole0 / me % dx ** 3 else ! if defined moleDens0 derive mole from moledensity me % mole0 = me % moleDens0 * me % dx ** 3 endif ! try to load reference density, If not defined then try to load reference ! molecular weight, if not defined then try to load reference mass in 'kg' ! if that also is not defined prompt an error message ! load rho0 call aot_get_val ( L = conf , thandle = thandle , key = 'rho0' , & & val = me % rho0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'No value given for rho0.' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'rho0 has wrong type!' call tem_abort () end if end if ! reference mass density not defined so try to load reference ! molecular weight if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'WARNING: Reference mass density rho0 is not found.' write ( logUnit ( 1 ), * ) 'Loading reference molecular weight ' & & // 'molWeight0(kg/mol):' call aot_get_val ( L = conf , thandle = thandle , key = 'molWeight0' , & & val = me % molWeight0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'No value given for molWeight0.' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'molWeight has wrong type!' call tem_abort () end if end if ! if reference molecular weight is not defined than load reference mass if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 5 ), * ) 'WARNING: Reference molecular weight molWeight0 ' & & // 'is not found. ' write ( logUnit ( 5 ), * ) 'Loading reference mass0(kg):' call aot_get_val ( L = conf , thandle = thandle , key = 'mass0' , & & val = me % mass0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'No value given for mass0' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'Variable has wrong type!' call tem_abort () end if end if ! if reference mass is also not defined prompt an error message if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'ERROR: Unable to obtain reference mass0(kg)' write ( logUnit ( 1 ), * ) \"Solution: Provide reference density 'rho0' \" & & // \"in kg/m&#94;3\" write ( logUnit ( 1 ), * ) \"or reference molecular weight 'molWeight0' \" & & // \"in kg/mol\" write ( logUnit ( 1 ), * ) \"or reference mass 'mass0' in kg\" call tem_abort () else ! reference mass is defined derive density and molWeight0 me % rho0 = me % mass0 / me % dx ** 3 ! same as rho0/moleDens0 ! molecular Weight in independent of dx me % molWeight0 = me % mass0 / me % mole0 endif else ! reference molecular weight is defined derive mass and density me % mass0 = me % molWeight0 * me % mole0 me % rho0 = me % mass0 / me % dx ** 3 endif else ! reference density is defined derive mass and molWeigh me % mass0 = me % rho0 * me % dx ** 3 ! same as rho0/moleDens0 ! molecular Weight in independent of dx me % molWeight0 = me % mass0 / me % mole0 endif ! try to load coloumb, if not defined set to fundamental electrical charge call aot_get_val ( L = conf , thandle = thandle , key = 'coulomb0' , & & val = me % coulomb0 , ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 3 ), * ) 'No value given for coulomb0' if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'coulomb0 has wrong type!' call tem_abort () end if end if if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 4 ), * ) 'WARNING: Reference coulomb0 is not found. ' write ( logUnit ( 4 ), * ) \"Setting reference coulomb0 to fundamental\" & & // \" electrical charge.\" me % coulomb0 = coulomb_ref !me%coulomb0 = me%rho0*me%dx**5 / me%dt**2 endif ! load temp0 call aot_get_val ( L = conf , thandle = thandle , key = 'temp0' , & & val = me % temp0 , default = 1.0_rk , ErrCode = iError ) if ( btest ( iError , aoterr_WrongType )) then write ( logUnit ( 1 ), * ) 'temp0 has wrong type! Stopping!' call tem_abort () end if else ! No physics table defined. me % dt = dt_ref me % dx = dx_ref me % rho0 = 1._rk me % moleDens0 = 1._rk me % molWeight0 = 1._rk me % mass0 = 1._rk me % mole0 = 1._rk me % temp0 = 1._rk me % coulomb0 = 1._rk write ( logUnit ( 1 ), * ) ' Physics table is not defined.' write ( logUnit ( 5 ), * ) ' All values are expressed in Lattice Units.' end if call aot_table_close ( L = conf , thandle = thandle ) ! Assign dx and dt for each level allocate ( me % dxLvl ( tree % global % minLevel : tree % global % maxLevel )) allocate ( me % dtLvl ( tree % global % minLevel : tree % global % maxLevel )) allocate ( me % fac ( tree % global % minLevel : tree % global % maxLevel )) ! dx and dt is set according scaling type me % dxLvl ( tree % global % minLevel : tree % global % maxLevel ) = & & set_values_by_levels ( me % dx , tree % global % minLevel , & & tree % global % maxLevel , 2 ) me % dtLvl ( tree % global % minLevel : tree % global % maxLevel ) = & & set_values_by_levels ( me % dt , tree % global % minLevel , & & tree % global % maxLevel , scaleFactor ) ! compute and store conversion factors in converstionFac type call mus_set_convFac ( me = me , minLevel = tree % global % minLevel , & & maxLevel = tree % global % maxLevel ) ! set scale factor call mus_set_scaleFac ( me , tree % global % minLevel , tree % global % maxLevel ) call mus_physics_dump2outUnit ( me , logUnit ( 4 ), tree % global % minLevel , & & tree % global % maxLevel ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_physics ! **************************************************************************** ! ! **************************************************************************** ! !> This routine computed conversion factors for lattice to physical units. !! inverse of this factors can be used to convert from physical to lattice !! units.\\n !! use reference density to parmeterize kg and reference mole density !! to parmeterize mol.\\n !! Multiply these factors with the LB quantity to get the physical quantity !! Divide the physical quantity by these factors to get the LB units. subroutine mus_set_convFac ( me , minLevel , maxLevel ) ! -------------------------------------------------------------------------- type ( mus_physics_type ), intent ( inout ) :: me !< physics type integer , intent ( in ) :: minLevel integer , intent ( in ) :: maxLevel ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- do iLevel = minLevel , maxLevel ! length me % fac ( iLevel )% length = me % dxLvl ( iLevel ) ! time me % fac ( iLevel )% time = me % dtLvl ( iLevel ) ! velocity me % fac ( iLevel )% vel = me % dxLvl ( iLevel ) / me % dtLvl ( iLevel ) ! kinematic viscosity me % fac ( iLevel )% visc = me % dxLvl ( iLevel ) ** 2 / me % dtLvl ( iLevel ) ! dynamic viscosity me % fac ( iLevel )% viscDyna = me % rho0 * me % fac ( iLevel )% visc ! acceleration me % fac ( iLevel )% accel = me % dxLvl ( iLevel ) / me % dtLvl ( iLevel ) ** 2 ! force me % fac ( iLevel )% force = me % rho0 * me % dxLvl ( iLevel ) ** 4 & & / me % dtLvl ( iLevel ) ** 2 ! body_force me % fac ( iLevel )% body_force = me % rho0 * me % dxLvl ( iLevel ) & & / me % dtLvl ( iLevel ) ** 2 ! pressure or shear stress me % fac ( iLevel )% press = me % rho0 * me % dxLvl ( iLevel ) ** 2 & & / me % dtLvl ( iLevel ) ** 2 ! strain rate me % fac ( iLevel )% strainRate = 1._rk / me % dtLvl ( iLevel ) ! Energy me % fac ( iLevel )% energy = me % rho0 * me % dxLvl ( iLevel ) ** 5 & & / me % dtLvl ( iLevel ) ** 2 ! Mass !me%fac( iLevel )%mass = me%rho0*me%dxLvl( iLevel )**3 ! Molar mass or Molecular weight !me%fac( iLevel )%molWeigh = me%fac( iLevel )%mass/me%mole0 ! mole density !me%fac( iLevel )%moleDens = me%mole0/me%dxLvl( iLevel )**3 ! mole flux (mol/m&#94;2/s) (moleDens*velocity) me % fac ( iLevel )% moleFlux = me % moleDens0 * me % dxLvl ( iLevel ) & & / me % dtLvl ( iLevel ) ! Charge density (C/m&#94;3) = Coulomb0/dx&#94;3 me % fac ( iLevel )% chargeDens = me % coulomb0 / me % dxLvl ( iLevel ) ** 3 ! Current density (C/s/m&#94;2) = Coulomb0/dt/dx&#94;2 me % fac ( iLevel )% currentDens = me % coulomb0 / me % dxLvl ( iLevel ) ** 2 & & / me % dtLvl ( iLevel ) ! mass flux (kg/m&#94;2/s)  (density*velocity) me % fac ( iLevel )% flux = me % rho0 * me % dxLvl ( iLevel ) / me % dtLvl ( iLevel ) !diffusivity me % fac ( iLevel )% diffusivity = me % dxLvl ( iLevel ) ** 2 / me % dtLvl ( iLevel ) !faraday me % fac ( iLevel )% faraday = me % coulomb0 / me % mole0 !gas constant me % fac ( iLevel )% gasConst = me % rho0 * me % dxLvl ( iLevel ) ** 5 & & / me % dtLvl ( iLevel ) ** 2 / me % mole0 & & / me % temp0 ! Potential me % fac ( iLevel )% potential = me % rho0 * me % dxLvl ( iLevel ) ** 5 & & / me % dtLvl ( iLevel ) ** 2 / me % coulomb0 end do end subroutine mus_set_convFac ! **************************************************************************** ! ! **************************************************************************** ! !> This routine creates musubi specific lua function to compute dx and dt. !! subroutine mus_create_funcStr ( fun_str ) ! -------------------------------------------------------------------------- !> This string contains lua functions to compute dt from visocosity or !! velocity character ( len =* ) :: fun_str ! -------------------------------------------------------------------------- character ( len = 256 ) :: dtVel , dtOmega , dtVisc , dxLevel , dxnL , omega_dt , & & vel_dt ! -------------------------------------------------------------------------- write ( dxLevel , * ) 'function getdxFromLevel(t) ' // & & ' return t.len_bnd/2&#94;t.level end' write ( dxnL , * ) 'function getdxFromnL(t)' // & & ' return t.len_p/t.nL end' write ( dtVel , * ) 'function getdtFromVel(t) return t.dx*t.u_l/t.u_p end' write ( dtOmega , * ) 'function getdtFromOmega(t) ' // & & ' return ((1.0/t.omega - 0.5)/3.0)*t.dx*t.dx/t.nu_p end' write ( dtVisc , * ) ' function getdtFromVisc(t)' // & & ' return t.dx*t.dx*t.nu_l/t.nu_p end' write ( omega_dt , * ) 'function getOmegaFromdt(t) ' // & & ' return 1.0/(3.0*t.nu_p*t.dt/(t.dx*t.dx) + 0.5) end' write ( vel_dt , * ) 'function getVelFromdt(t) ' // & & ' return t.u_p*t.dt/t.dx end' write ( fun_str , * ) trim ( dtVel ) // ' ' // trim ( dtOmega ) // ' ' // trim ( dtVisc ) & & // ' ' // trim ( dxLevel ) // ' ' // trim ( dxnL ) // ' ' // trim ( omega_dt ) & & // ' ' // trim ( vel_dt ) end subroutine mus_create_funcStr ! **************************************************************************** ! ! **************************************************************************** ! !> This routine write reference physics parameters into solver specific !! string in lua format. !! !! This dumped table is loaded back using mus_load_physics subroutine mus_physics_out ( me , conf ) ! -------------------------------------------------------------------------- type ( mus_physics_type ), intent ( in ) :: me !< physics type type ( aot_out_type ) :: conf ! -------------------------------------------------------------------------- call aot_out_open_table ( put_conf = conf , tname = 'physics' ) call aot_out_val ( put_conf = conf , vname = 'dt' , val = me % dt ) call aot_out_val ( put_conf = conf , vname = 'rho0' , val = me % rho0 ) call aot_out_val ( put_conf = conf , vname = 'moleDens0' , val = me % moleDens0 ) call aot_out_val ( put_conf = conf , vname = 'molWeight0' , & & val = me % molWeight0 ) call aot_out_val ( put_conf = conf , vname = 'temp0' , val = me % temp0 ) call aot_out_val ( put_conf = conf , vname = 'coulomb0' , val = me % coulomb0 ) call aot_out_close_table ( put_conf = conf ) end subroutine mus_physics_out ! **************************************************************************** ! ! **************************************************************************** ! !> This routine write physics convert factor into solver specific string in !! lua format. !! use reference density to parmeterize kg and reference mole density !! to parmeterize mol. subroutine mus_physics_out_conv ( me , conf , minLevel , maxLevel ) ! -------------------------------------------------------------------------- type ( mus_physics_type ), intent ( in ) :: me !< physics type type ( aot_out_type ) :: conf integer , intent ( in ) :: minLevel integer , intent ( in ) :: maxLevel ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- call aot_out_open_table ( put_conf = conf , tname = 'physics' ) do iLevel = minLevel , maxLevel call aot_out_open_table ( put_conf = conf ) call aot_out_val ( put_conf = conf , vname = 'length' , & & val = me % fac ( iLevel )% length ) call aot_out_val ( put_conf = conf , vname = 'time' , & & val = me % fac ( iLevel )% time ) call aot_out_val ( put_conf = conf , vname = 'density' , & & val = me % rho0 ) call aot_out_val ( put_conf = conf , vname = 'vel' , & & val = me % fac ( iLevel )% vel ) call aot_out_val ( put_conf = conf , vname = 'visc' , & & val = me % fac ( iLevel )% visc ) call aot_out_val ( put_conf = conf , vname = 'viscDyna' , & & val = me % fac ( iLevel )% viscDyna ) call aot_out_val ( put_conf = conf , vname = 'accel' , & & val = me % fac ( iLevel )% accel ) call aot_out_val ( put_conf = conf , vname = 'force' , & & val = me % fac ( iLevel )% force ) call aot_out_val ( put_conf = conf , vname = 'body_force' , & & val = me % fac ( iLevel )% body_force ) call aot_out_val ( put_conf = conf , vname = 'press' , & & val = me % fac ( iLevel )% press ) call aot_out_val ( put_conf = conf , vname = 'strainRate' , & & val = me % fac ( iLevel )% strainRate ) call aot_out_val ( put_conf = conf , vname = 'energy' , & & val = me % fac ( iLevel )% energy ) call aot_out_val ( put_conf = conf , vname = 'temp' , & & val = me % temp0 ) call aot_out_val ( put_conf = conf , vname = 'moleDens' , & & val = me % moleDens0 ) call aot_out_val ( put_conf = conf , vname = 'molWeight' , & & val = me % molWeight0 ) call aot_out_val ( put_conf = conf , vname = 'coulomb' , & & val = me % coulomb0 ) call aot_out_val ( put_conf = conf , vname = 'moleFlux' , & & val = me % fac ( iLevel )% moleFlux ) call aot_out_val ( put_conf = conf , vname = 'chargeDens' , & & val = me % fac ( iLevel )% chargeDens ) call aot_out_val ( put_conf = conf , vname = 'currentDens' , & & val = me % fac ( iLevel )% currentDens ) call aot_out_val ( put_conf = conf , vname = 'flux' , & & val = me % fac ( iLevel )% flux ) call aot_out_val ( put_conf = conf , vname = 'diffusivity' , & & val = me % fac ( iLevel )% diffusivity ) call aot_out_val ( put_conf = conf , vname = 'faraday' , & & val = me % fac ( iLevel )% faraday ) call aot_out_val ( put_conf = conf , vname = 'gasConst' , & & val = me % fac ( iLevel )% gasConst ) call aot_out_close_table ( put_conf = conf ) end do call aot_out_close_table ( put_conf = conf ) end subroutine mus_physics_out_conv ! **************************************************************************** ! ! ************************************************************************** ! pure function set_values_by_levels ( valMinLevel , minLevel , maxLevel , & & scaleFac ) & & result ( values ) ! -------------------------------------------------------------------------- real ( kind = rk ), intent ( in ) :: valMinLevel !< value at min level integer , intent ( in ) :: minLevel integer , intent ( in ) :: maxLevel integer , intent ( in ) :: scaleFac !< scale factor between levels real ( kind = rk ) :: values ( minLevel : maxLevel ) !< return value ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- values ( minLevel : maxLevel ) = valMinLevel / & & real ([( scaleFac ** ( iLevel - minLevel ), iLevel = minLevel , maxLevel )], rk ) end function set_values_by_levels ! ************************************************************************** ! ! ************************************************************************** ! subroutine mus_physics_dump2outUnit ( me , outUnit , minLevel , maxLevel ) ! -------------------------------------------------------------------------- type ( mus_physics_type ), intent ( in ) :: me integer , intent ( in ) :: outUnit integer , intent ( in ) :: minLevel integer , intent ( in ) :: maxLevel ! -------------------------------------------------------------------------- integer :: iLevel write ( outUnit , '(A)' ) 'Reference physical quantities:' write ( outUnit , \"(A)\" ) '  rho0       = ' // trim ( tem_toStr ( me % rho0 )) write ( outUnit , \"(A)\" ) '  mass0      = ' // trim ( tem_toStr ( me % mass0 )) write ( outUnit , \"(A)\" ) '  mole0      = ' // trim ( tem_toStr ( me % mole0 )) write ( outUnit , \"(A)\" ) '  moleDens0  = ' // trim ( tem_toStr ( me % moleDens0 )) write ( outUnit , \"(A)\" ) '  molWeight0 = ' // trim ( tem_toStr ( me % molWeight0 )) write ( outUnit , \"(A)\" ) '  Temp0      = ' // trim ( tem_toStr ( me % temp0 )) write ( outUnit , \"(A)\" ) '  coulomb0   = ' // trim ( tem_toStr ( me % coulomb0 )) do iLevel = minLevel , maxLevel write ( outUnit , \"(A,I0)\" ) 'Conversion factors on level: ' , iLevel write ( outUnit , \"(A)\" ) '  dx            = ' & & // trim ( tem_toStr ( me % dxLvl ( iLevel ))) write ( outUnit , \"(A)\" ) '  dt            = ' & & // trim ( tem_toStr ( me % dtLvl ( iLevel ))) write ( outUnit , \"(A)\" ) '  pressure      = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% press )) write ( outUnit , \"(A)\" ) '  velocity      = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% vel )) write ( outUnit , \"(A)\" ) '  kine. visc.   = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% visc )) write ( outUnit , \"(A)\" ) '  dyn. visc.    = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% viscDyna )) write ( outUnit , \"(A)\" ) '  acceleration  = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% accel )) write ( outUnit , \"(A)\" ) '  force         = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% force )) write ( outUnit , \"(A)\" ) '  body force    = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% body_force )) write ( outUnit , \"(A)\" ) '  strain rate   = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% strainRate )) write ( outUnit , \"(A)\" ) '  energy        = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% energy )) write ( outUnit , \"(A)\" ) '  moleFlux      = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% moleFlux )) write ( outUnit , \"(A)\" ) '  chargeDens    = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% chargeDens )) write ( outUnit , \"(A)\" ) '  currentDens   = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% currentDens )) write ( outUnit , \"(A)\" ) '  massflux      = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% flux )) write ( outUnit , \"(A)\" ) '  diffusivity   = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% diffusivity )) write ( outUnit , \"(A)\" ) '  faraday       = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% faraday )) write ( outUnit , \"(A)\" ) '  gasConst      = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% gasConst )) write ( outUnit , \"(A)\" ) '  potential     = ' & & // trim ( tem_toStr ( me % fac ( iLevel )% potential )) write ( outUnit , \"(A)\" ) '' end do write ( outUnit , \"(A)\" ) 'Over level scale factor: ' do iLevel = minLevel , maxLevel write ( outUnit , \"(A)\" ) '    pressure: ' & & // trim ( tem_toStr ( me % pFac ( iLevel , & & minLevel : maxLevel ), ',' ) ) write ( outUnit , \"(A)\" ) '    velocity: ' & & // trim ( tem_toStr ( me % vFac ( iLevel , & & minLevel : maxLevel ), ',' ) ) write ( outUnit , \"(A)\" ) ' strain rate: ' & & // trim ( tem_toStr ( me % sFac ( iLevel , & & minLevel : maxLevel ), ',' ) ) end do end subroutine mus_physics_dump2outUnit ! ************************************************************************** ! ! ************************************************************************** ! subroutine mus_set_scaleFac ( me , minLevel , maxLevel ) ! -------------------------------------------------------------------------- type ( mus_physics_type ), intent ( inout ) :: me integer , intent ( in ) :: minLevel integer , intent ( in ) :: maxLevel ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- allocate ( me % pFac ( minLevel : maxLevel , minLevel : maxLevel ) ) allocate ( me % vFac ( minLevel : maxLevel , minLevel : maxLevel ) ) allocate ( me % sFac ( minLevel : maxLevel , minLevel : maxLevel ) ) do iLevel = minLevel , maxLevel me % pFac ( :, iLevel ) = me % fac (:)% press / me % fac ( iLevel )% press me % vFac ( :, iLevel ) = me % fac (:)% vel / me % fac ( iLevel )% vel me % sFac ( :, iLevel ) = me % fac (:)% strainRate / me % fac ( iLevel )% strainRate end do end subroutine mus_set_scaleFac ! ************************************************************************** ! end module mus_physics_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_physics_module.f90.html"},{"title":"musubi.f90 – Musubi","text":"This file depends on sourcefile~~musubi.f90~~EfferentGraph sourcefile~musubi.f90 musubi.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~musubi.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~musubi.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~musubi.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011 Konstantin Kleinheinz <k.kleinheinz@grs-sim.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2016, 2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011-2013, 2015 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2012 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012-2013, 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> M U S U B I !! The lattice Boltzmann solver within the APES suite !! (c) 2012 German Research School for Simulation Sciences GmbH !! (c) 2013 University of Siegen. !! !! For a documentation, run ./waf gendoxy and find the documentation at !! ./Documentation/html/index.html program musubi ! include treelm modules use mpi use tem_general_module , only : tem_start , tem_finalize use tem_adaptation_config_module , only : tem_adapt_type ! include musubi modules ! RESPECT THE ORDER !!!!!!!! use mus_aux_module , only : mus_banner use mus_config_module , only : mus_load_config use mus_scheme_type_module , only : mus_scheme_type use mus_param_module , only : mus_param_type use mus_timer_module , only : mus_init_mainTimer , & & mus_init_levelTimer , & & mus_init_bcTimer use mus_geom_module , only : mus_geom_type ! ESPECIALLY OF THE FOLLOWING MODULES use mus_control_module , only : mus_control_type use mus_program_module , only : mus_initialize , mus_solve , & & mus_finalize use mus_varSys_module , only : mus_varSys_solverData_type implicit none ! -------------------------------------------------------------------------- ! !> scheme types type ( mus_scheme_type ), target :: scheme type ( mus_geom_type ), target :: geometry type ( mus_param_type ), target :: params type ( mus_varSys_solverData_type ), target :: solverData type ( mus_control_type ) :: control type ( tem_adapt_type ) :: adapt integer :: ierr ! -------------------------------------------------------------------------- ! ! Initialize environment call tem_start ( codeName = 'Musubi' , & & version = params % version , & & general = params % general , & & simControl = params % general % simControl ) if ( params % general % proc % rank == 0 ) then call mus_banner ( solver = params % general % solver ) end if call mus_init_mainTimer () ! load configuration file call mus_load_config ( scheme = scheme , & & solverData = solverData , & & geometry = geometry , & & params = params , & & adapt = adapt ) ! KM: Do not move this init_levelTimer and init_bcTimer from here, ! Need to be here for apesmate call mus_init_levelTimer ( geometry % tree % global % minLevel , & & geometry % tree % global % maxLevel ) call mus_init_bcTimer ( geometry % boundary % nBCtypes ) ! initialize musubi call mus_initialize ( scheme = scheme , & & solverData = solverData , & & geometry = geometry , & & params = params , & & control = control ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) ! do main loop call mus_solve ( scheme = scheme , & & solverData = solverData , & & geometry = geometry , & & params = params , & & control = control , & & adapt = adapt ) ! finialize musubi call mus_finalize ( scheme = scheme , & & params = params , & & tree = geometry % tree , & & nBCs = geometry % boundary % nBCtypes , & & levelPointer = geometry % levelPointer , & & globIBM = geometry % globIBM ) ! finalize treelm function like print run time info and mpi call tem_finalize ( params % general ) end program musubi","tags":"","loc":"sourcefile/musubi.f90.html"},{"title":"mus_geomIncrHead_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_geomincrhead_module.f90~~EfferentGraph sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_geomincrhead_module.f90~~AfferentGraph sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_geom_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2013-2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Kartik Jain !! This module contains the datatypes for the geometry increase table within the !! lua configuration file. It also contains the routines to load various !! variables, parameters from the lua file which are then used in performing !! geometry changes !! module mus_geomIncrHead_module ! include treelm modules use env_module , only : labelLen use tem_timeControl_module , only : tem_timeControl_type , tem_timeControl_load use tem_tools_module , only : tem_horizontalSpacer use tem_depend_module , only : tem_load_depend , tem_depend_type use tem_logging_module , only : logUnit ! include aotus modules use aotus_module , only : flu_State , aot_get_val , & & aoterr_NonExistent , aoterr_Fatal , & & aoterr_WrongType use aot_table_module , only : aot_get_val , aot_table_open , aot_table_close , & & aot_table_length use aot_vector_module , only : aot_get_val ! include musubi modules use mus_param_module , only : mus_param_type implicit none private public :: mus_geomIncrHead_type public :: mus_geomIncrHead_load type mus_geomIncrHead_type logical :: active = . false . !< geometry increment active? logical :: solidify = . false . !< if true solidify, if false fluidify logical :: fluidify = . false . logical :: proximity = . false . !< Check proximity condition if true type ( tem_timeControl_type ) :: timeControl !> Name of the variable defined for condition varname in config file. !! Variable refered should return 0 for if condition is false and !  1 for true. !! If there are more than one condition variable required then they must !! be combined via variable definitions in config file. character ( len = labelLen ) :: cond_varName !> Position of variable defined for the condition varname in the varSys integer :: cond_varPos end type mus_geomIncrHead_type contains ! ****************************************************************************** ! !> Read all the necessary information for the geometry increase from the lua !! config file. This routine basically provides as a wrapper to the routine !! which reads single values !! !! Example to geomIncr table: !!```lua !! variable = { !!   { name = 'vel_threshold', !!     ncomponents = 1, !!     var_type = st_fun, !!     st_fun = 0.01 !!   }, !!   { name = 'incr_condition', !!     ncomponents = 1, !!     var_type = 'operation' , !!     operation = { !!       kind = '<', !!       input_varname = {'vel_mag','vel_threshold'} !!     } !!   }, !! } !! geomIncr = { !!  condition = 'incr_condition' !! } !!``` subroutine mus_geomIncrHead_load ( me , conf , parent , dynamicGeom ) ! --------------------------------------------------------------------------- type ( mus_geomIncrHead_type ), allocatable , intent ( inout ) :: me (:) type ( flu_state ) :: conf integer , optional , intent ( in ) :: parent logical , intent ( inout ) :: dynamicGeom ! --------------------------------------------------------------------------- integer :: tc_handle , sub_handle integer :: nGeomIncrs integer :: iGInc ! --------------------------------------------------------------------------- ! Attempt to open the geomIncr table (within another table, if a parent is ! given ) call aot_table_open ( L = conf , & & parent = parent , & & thandle = tc_handle , & & key = 'geomIncr' ) ! Check if geomIncr is actually defined if ( tc_handle /= 0 ) then ! Set the dynamicGeom flag to true dynamicGeom = . true . ! check whether there are other members inside geomIncr call aot_table_open ( L = conf , & & parent = tc_handle , & & thandle = sub_handle , & & pos = 1 ) ! If there is only one member in geomIncr, call the load routine once if ( sub_handle == 0 ) then allocate ( me ( 1 )) call aot_table_close ( L = conf , thandle = sub_handle ) call mus_geomIncrHead_load_single ( me = me ( 1 ), & & conf = conf , & & thandle = tc_handle ) else ! multiple definitions inside geomIncr call aot_table_close ( L = conf , thandle = sub_handle ) nGeomIncrs = aot_table_length ( L = conf , thandle = tc_handle ) allocate ( me ( nGeomIncrs )) ! Read the sub tables individually do iGInc = 1 , nGeomIncrs call aot_table_open ( L = conf , & & parent = tc_handle , & & thandle = sub_handle , & & pos = iGInc ) call mus_geomIncrHead_load_single ( me = me ( iGInc ), & & conf = conf , & & thandle = sub_handle ) end do end if else dynamicGeom = . false . end if call aot_table_close ( L = conf , thandle = tc_handle ) end subroutine mus_geomIncrHead_load ! ****************************************************************************** ! ! ****************************************************************************** ! !> Reads various parameters from the lua file defined for geometry increase !! This routine reads single values and is wrapped around in another function !! where it is called multiple times as required !! subroutine mus_geomIncrHead_load_single ( me , conf , thandle ) ! --------------------------------------------------------------------------- type ( mus_geomIncrHead_type ), intent ( inout ) :: me type ( flu_state ), intent ( in ) :: conf integer , intent ( in ) :: thandle ! --------------------------------------------------------------------------- integer :: iError ! --------------------------------------------------------------------------- me % active = . true . ! Read the solidify, fluidify and proximity flags call aot_get_val ( L = conf , & & thandle = thandle , & & val = me % solidify , & & ErrCode = iError , & & key = 'solidify' , & & default = . false . ) call aot_get_val ( L = conf , & & thandle = thandle , & & val = me % fluidify , & & ErrCode = iError , & & key = 'fluidify' , & & default = . false . ) call aot_get_val ( L = conf , & & thandle = thandle , & & val = me % proximity , & & ErrCode = iError , & & key = 'proximity' , & & default = . false . ) ! Load variable name for condition. ! This variable should be logical operation variable which ! returns 0 for false and 1 for true. call aot_get_val ( L = conf , & & thandle = thandle , & & val = me % cond_varName , & & ErrCode = iError , & & key = 'condition' ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'FATAL Error occured, while retrieving \"condition\" ' & & // 'variable name from operation table :' if ( btest ( iError , aotErr_NonExistent )) & & write ( logUnit ( 1 ), * ) 'Variable not existent!' if ( btest ( iError , aoterr_WrongType )) & & write ( logUnit ( 1 ), * ) 'Variable has wrong type!' end if ! load time control to perform geomIncr call tem_timeControl_load ( conf = conf , & & parent = thandle , & & me = me % timeControl ) ! If geomIncr is activited, output its configuration to console if ( me % active ) then write ( logUnit ( 1 ), * ) 'Geometry Increment ACTIVATED! ' if ( me % solidify ) then write ( logUnit ( 1 ), * ) '  Solidification is activited!' else write ( logUnit ( 1 ), * ) '  Fluidification is activited!' endif if ( me % proximity ) then write ( logUnit ( 1 ), * ) '  Proximity is activited.' else write ( logUnit ( 1 ), * ) '  Proximity is activited.' endif call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) endif end subroutine mus_geomIncrHead_load_single ! ****************************************************************************** ! end module mus_geomIncrHead_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_geomincrhead_module.f90.html"},{"title":"mus_wall_function_abstract_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_wall_function_abstract_module.f90~~AfferentGraph sourcefile~mus_wall_function_abstract_module.f90 mus_wall_function_abstract_module.f90 sourcefile~mus_turb_wallfunc_module.f90 mus_turb_wallFunc_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_musker_module.f90 mus_wall_function_musker_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_musker_module.f90 sourcefile~mus_wall_function_reichardt_module.f90 mus_wall_function_reichardt_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_reichardt_module.f90 sourcefile~mus_wall_function_schmitt_module.f90 mus_wall_function_schmitt_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_schmitt_module.f90 sourcefile~mus_wall_function_musker_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_reichardt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_schmitt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types, function and routines for wall function !! computations. !! !! author: Gregorio Gerardo Spinelli module mus_wall_function_abstract_module ! include treelm modules use env_module , only : rk implicit none !> collection of properties of the wall function type type , abstract :: mus_wall_function_type contains !> function to get uPlus procedure ( get_uPlus_interface ), deferred , nopass :: get_uPlus !> function to apply the newon method ! F = uPlus_n - uPlus_(n+1) ! here we compute the derivative of uPlus_(n+1) w.r.t. u_tau ! this function computes the derivative of uPlus with respect to uTau procedure ( get_d_uPlus_d_uTau_interface ), deferred , nopass :: get_d_uPlus_d_uTau end type mus_wall_function_type interface !> function interface to get u_Plus pure function get_uPlus_interface ( yPlus ) result ( uPlus ) import :: rk !> yPlus real ( kind = rk ), intent ( in ) :: yPlus !> output: uPlus real ( kind = rk ) :: uPlus end function get_uPlus_interface !> function interface to get the derivative of uPlus with respect to uTau pure function get_d_uPlus_d_uTau_interface ( y , uTau , nu ) result ( d_uPlus_d_uTau ) import :: rk !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> uTau at iteration n real ( kind = rk ), intent ( in ) :: uTau !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> output: derivative of uPlus with respect to uTau real ( kind = rk ) :: d_uPlus_d_uTau end function get_d_uPlus_d_uTau_interface end interface end module mus_wall_function_abstract_module","tags":"","loc":"sourcefile/mus_wall_function_abstract_module.f90.html"},{"title":"mus_relaxationParam_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_relaxationparam_module.f90~~EfferentGraph sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_relaxationparam_module.f90~~AfferentGraph sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2021 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2020-2021 Harald Klimach <harald.klimach@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains the data type for MRT. !! !! Also provides functions and routines to set relaxation parameters for !! single-component and multispecies. !! module mus_relaxationParam_module use mpi ! include treelm modules use env_module , only : rk , io_buffer_size , eps_single_k use tem_param_module , only : cs2inv , div2_3 use tem_time_module , only : tem_time_type use tem_temporal_module , only : tem_temporal_type , tem_temporal_for use tem_varSys_module , only : tem_varSys_type use tem_spacetime_fun_module , only : tem_spacetime_fun_type , tem_spacetime_for use tem_logging_module , only : logUnit use tem_aux_module , only : tem_abort use tem_grow_array_module , only : grw_realArray_type , init use tem_comm_env_module , only : tem_comm_env_type use tem_general_module , only : tem_general_type use tem_status_module , only : tem_stat_nonPhysical ! include musubi modules use mus_physics_module , only : mus_convertFac_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_moments_type_module , only : mus_moment_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_turbulence_module , only : mus_turbulence_type , mus_turb_calcVisc use mus_gradData_module , only : mus_gradData_type use mus_nonNewtonian_module , only : mus_nNwtn_type use mus_gradData_module , only : mus_Grad_type implicit none private public :: mus_viscosity_type public :: mus_update_viscKine public :: mus_update_relaxParamKine public :: mus_update_relaxParamFromViscSTfun public :: mus_init_relaxParam public :: mus_calcOmegaFromVisc public :: mus_check_omegaKine !> Contains relaxation parameter for a level type mus_relaxationParam_type !> Relaxation parameter computed from viscosity !! For kinematic viscosity, if turbulence is active, this omega refers to !! effective omega which is omega_bg + omega_turb !! size: nElems_solve real ( kind = rk ), allocatable :: val (:) end type mus_relaxationParam_type !> Contains STfun of viscosity variable and relaxation parameter for each !! level type mus_viscosity_type !> space-time function type ( tem_spacetime_fun_type ) :: STfun !> viscosity value evaluated from STfun type ( grw_realArray_type ), allocatable :: dataOnLvl (:) !> relaxation paramter omega for each level type ( mus_relaxationParam_type ), allocatable :: omLvl (:) end type mus_viscosity_type contains ! ------------------------------------------------------------------------ ! !> This routine initialize relaxation parameter subroutine mus_init_relaxParam ( omLvl , minLevel , maxLevel , nElems ) ! -------------------------------------------------------------------- ! !> relaxation paramter type ( mus_relaxationParam_type ), allocatable , intent ( out ) :: omLvl (:) !> minlevel and maxLevel integer , intent ( in ) :: minLevel , maxLevel !> number of local elements per level integer , intent ( in ) :: nElems ( minLevel : maxLevel ) ! -------------------------------------------------------------------- ! integer :: iLevel ! -------------------------------------------------------------------- ! allocate ( omLvl ( minLevel : maxLevel )) do iLevel = minLevel , maxLevel allocate ( omLvl ( iLevel )% val ( nElems ( iLevel ) ) ) omLvl ( iLevel )% val = - 10 0.0_rk end do end subroutine mus_init_relaxParam ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Update kinematic viscosity from STfun and calculate turbulent viscosity !! from velocity gradient or nonEqPDF !! Viscosity obtained from this routine are normalized to the level subroutine mus_update_viscKine ( viscKine , state , neigh , auxField , gradData , & & layout , baryOfTotal , tNow , nSize , nFluids , & & nGhostFromCoarser , nGhostFromFiner , nHalo , & & varSys , iLevel , convFac , dxL , dtL , & & derVarPos , turb , nNwtn , Grad ) ! ------------------------------------------------------------------------ ! !> Kinematic viscosity type ( mus_viscosity_type ), intent ( inout ) :: viscKine !> bary of treeID in total list real ( kind = rk ), intent ( in ) :: baryOfTotal (:,:) !> number of elements in state array integer , intent ( in ) :: nSize !> number of fluid elements in state array integer , intent ( in ) :: nFluids !> Number of ghostFromCoarser element in state array integer , intent ( in ) :: nGhostFromCoarser !> Number of ghostFromFiner element in state array integer , intent ( in ) :: nGhostFromFiner !> Number of halo element in state array integer , intent ( in ) :: nHalo !> state array real ( kind = rk ), intent ( in ) :: state (:) !> neighbor connectivity array integer , intent ( in ) :: neigh (:) !> Auxiliary field variable array real ( kind = rk ), intent ( in ) :: auxField (:) !> gradient data type ( mus_gradData_type ), intent ( in ) :: gradData !> stencil layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> current level integer , intent ( in ) :: iLevel !> current simulation time type ( tem_time_type ), intent ( in ) :: tNow !> reference physical conversion factors for current level type ( mus_convertFac_type ), intent ( in ) :: convFac !> lattice element size in current level real ( kind = rk ), intent ( in ) :: dxL !> lattice time step size in current level real ( kind = rk ), intent ( in ) :: dtL !> variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> contains position of in varSys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> turbulence type type ( mus_turbulence_type ), intent ( inout ) :: turb !> non-Newtonian type type ( mus_nNwtn_type ), intent ( in ) :: nNwtn !> Object that contains pointers to calculate gradients type ( mus_Grad_type ), intent ( in ) :: Grad ! -------------------------------------------------------------------- ! integer :: nScalars , nAuxScalars , nSolve , densPos , velPos ( 3 ) ! -------------------------------------------------------------------- ! nSolve = nFluids + nGhostFromCoarser + nGhostFromFiner + nHalo nScalars = varSys % nScalars nAuxScalars = varSys % nAuxScalars densPos = varSys % method % val ( derVarPos % density )% auxField_varPos ( 1 ) velPos = varSys % method % val ( derVarPos % velocity )% auxField_varPos (:) ! Update physical kinematic viscosity acccording to non-Newtonian model if ( nNwtn % active ) then ! calculate lattice kinemaic viscosity from local shear rate according to ! non-Newtonian model. ! Output of this routine is vL_l/dtL_l call nNwtn % calcVisc ( viscKine = viscKine % dataOnLvl ( iLevel ) & & % val ( 1 : nSolve ), & & omega = viscKine % omLvl ( iLevel ) & & % val ( 1 : nSolve ), & & state = state , & & neigh = neigh , & & auxField = auxField , & & densPos = densPos , & & velPos = velPos , & & nSize = nSize , & & nSolve = nSolve , & & nScalars = nScalars , & & nAuxScalars = nAuxScalars , & & layout = layout , & & convFac = convFac ) else ! background fluid kinematic viscosity for nFluid+nGhost viscKine % dataOnLvl ( iLevel )% val ( 1 : nSolve ) & & = tem_spacetime_for ( me = viscKine % STfun , & & coord = baryOfTotal ( 1 : nSolve ,:), & & time = tNow , & & n = nSolve ) ! convert physical viscosity to lattice unit ! convFac%visc is the reference physical viscosity on current level ! i.e. (dxP_l)&#94;2/dtP_l ! Dividing physical viscosity with the viscRef gives vL_l/dtL_l viscKine % dataOnLvl ( iLevel )% val (:) = viscKine % dataOnLvl ( iLevel )% val (:) & & / convFac % visc end if if ( turb % active ) then !> calculate turbulence viscosity for nFluids and ghostFromCoarser, !! for ghostFromFiner elements, turb visc is interpolated nSolve = nFluids + nGhostFromCoarser call mus_turb_calcVisc ( turbData = turb % dataOnLvl ( iLevel ), & & turbConfig = turb % config , & & calcTurbVisc = turb % calcVisc , & & state = state , & & neigh = neigh , & & auxField = auxField , & & gradData = gradData , & & densPos = densPos , & & velPos = velPos , & & nSize = nSize , & & nSolve = nSolve , & & nScalars = nScalars , & & nAuxScalars = nAuxScalars , & & layout = layout , & & viscKine = viscKine % dataOnLvl ( iLevel ) & & % val (:), & & dxL = dxL , & & dtL = dtL , & & Grad = Grad ) end if end subroutine mus_update_viscKine ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Update kinematic relaxation parameter from viscosity and check omega subroutine mus_update_relaxParamKine ( viscKine , turb , nSolve , iLevel ) ! -------------------------------------------------------------------- ! !> Kinematic viscosity type ( mus_viscosity_type ), intent ( inout ) :: viscKine !> Number of elements to solve in compute kernel integer , intent ( in ) :: nSolve !> turbulence type type ( mus_turbulence_type ), intent ( in ) :: turb !> current level integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------- ! integer :: iElem real ( kind = rk ) :: tot_visc ! -------------------------------------------------------------------- ! if ( turb % active ) then do iElem = 1 , nSolve ! total normalized viscosity tot_visc = viscKine % dataOnLvl ( iLevel )% val ( iElem ) & & + turb % dataOnLvl ( iLevel )% visc ( iElem ) ! compute omega viscKine % omLvl ( iLevel )% val ( iElem ) = 1.0_rk / ( cs2inv * tot_visc & & + 0.5_rk ) end do else ! compute omega from kinematic viscosity do iElem = 1 , nSolve viscKine % omLvl ( iLevel )% val ( iElem ) & & = 1.0_rk / ( cs2inv * viscKine % dataOnLvl ( iLevel )% val ( iElem ) & & + 0.5_rk ) end do end if end subroutine mus_update_relaxParamKine ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine is used to initialize relaxation paramter and update !! bulk viscosity at every time step !! Bulk visocisty is defined as space-time function to apply !! ramping and spatial sponge in bulk viscosity subroutine mus_update_relaxParamFromViscSTfun ( omega , visc , viscSTfun , & & nElems , baryOfTotal , tNow , & & viscRef ) ! -------------------------------------------------------------------- ! !> relaxation parameter real ( kind = rk ), intent ( inout ) :: omega (:) !> Kinematic viscosity real ( kind = rk ), intent ( inout ) :: visc (:) !> viscosity space-time function type ( tem_spacetime_fun_type ), intent ( in ) :: viscSTfun !> Number of local elements including halos integer , intent ( in ) :: nElems !> baryID of total list real ( kind = rk ), intent ( in ) :: baryOfTotal (:,:) !> current simulation time type ( tem_time_type ), intent ( in ) :: tNow !> reference physical viscosity on current level i.e. (dxP_l)&#94;2/dtP_l !! Dividing physical viscosity with the viscRef gives vL_l/dtL_l real ( kind = rk ), intent ( in ) :: viscRef !> lattice time step size in current level ! real(kind=rk), intent(in) :: dtL ! -------------------------------------------------------------------- ! ! viscosity values from space-time function integer :: iChunk , nChunks , nChunkElems , elemoff integer :: minBuf , maxBuf ! -------------------------------------------------------------------- ! !\\todo KM: 'Optimize this routine for constant viscosity' ! find chunksize and number of chunks required for initialzation nChunks = ceiling ( real ( nElems , rk ) / real ( io_buffer_size , rk ) ) do iChunk = 1 , nChunks ! Number of elements read so far in previous chunks. elemOff = ( ( iChunk - 1 ) * io_buffer_size ) nChunkElems = min ( io_buffer_size , nElems - elemOff ) minBuf = elemOff + 1 maxBuf = elemOff + nChunkElems ! background viscosity visc ( minBuf : maxBuf ) = tem_spacetime_for ( & & me = viscSTfun , & & coord = baryOfTotal ( minBuf : maxBuf , :), & & time = tNow , & & n = nChunkElems ) ! convert viscosity to lattice unit ! viscRef is scaled with current level dtL visc ( minBuf : maxBuf ) = visc ( minBuf : maxBuf ) / viscRef ! compute omega !do iElem = 1, nChunkElems !  omega(elemOff+iElem) = mus_calcOmegaFromVisc(visc(iElem)) !end do omega ( minBuf : maxBuf ) = mus_calcOmegaFromVisc ( visc ( minBuf : maxBuf )) end do end subroutine mus_update_relaxParamFromViscSTfun ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This function compute relaxation paramter omega from viscosity elemental function mus_calcOmegaFromVisc ( visc ) result ( omega ) ! -------------------------------------------------------------------- ! !> scaled lattice viscosity i.e vL_c/dtL real ( kind = rk ), intent ( in ) :: visc !> lattice time step size in current level !!real(kind=rk), intent(in) :: dtL !> output: relaxation parameter omega real ( kind = rk ) :: omega ! -------------------------------------------------------------------- ! !omega = 1.0_rk / ( cs2inv * visc / dtL + 0.5_rk ) omega = 1.0_rk / ( cs2inv * visc + 0.5_rk ) end function mus_calcOmegaFromVisc ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine checks whether omega is within the stability limit. !! If not it will terminate the simulation with error message. !! Using limits given in !! Tölke, J., Freudiger, S., & Krafczyk, M. (2006). An adaptive scheme using !! hierarchical grids for lattice Boltzmann multi-phase flow simulations. !! Computers & Fluids, 35(8–9), 820–830. !! For BGK: 2/3 < omega < 1.976 !! For MRT: 2/3 < omega < 1.999 subroutine mus_check_omegaKine ( schemeRelax , omLvlKine , nSolve , minLevel , & & maxLevel , general ) ! -------------------------------------------------------------------- ! !> minlevel and maxlevel integer , intent ( in ) :: minLevel , maxLevel !> scheme relaxation type character ( len =* ), intent ( in ) :: schemeRelax !> array of kinematic relaxation parameter on all levels type ( mus_relaxationParam_type ), intent ( in ) :: omLvlKine ( minLevel : maxLevel ) !> Number of elements to solve in compute kernel integer , intent ( in ) :: nSolve ( minLevel : maxLevel ) !> Contains proc, simControl, solveHead type ( tem_general_type ), intent ( inout ) :: general ! -------------------------------------------------------------------- ! integer :: iLevel , iError !> minimum omega real ( kind = rk ) :: om_min , om_max , glob_om_min , glob_om_max ! -------------------------------------------------------------------- ! do iLevel = minLevel , maxLevel ! minimum omega om_min = minval ( omLvlKine ( iLevel )% val ( 1 : nSolve ( iLevel ) ) ) ! maximum omega om_max = maxval ( omLvlKine ( iLevel )% val ( 1 : nSolve ( iLevel ) ) ) ! get global min and max omega call mpi_reduce ( om_min , glob_om_min , 1 , mpi_double_precision , & mpi_min , 0 , general % proc % comm , ierror ) call mpi_reduce ( om_max , glob_om_max , 1 , mpi_double_precision , & mpi_max , 0 , general % proc % comm , ierror ) if ( general % proc % isRoot ) then if ( glob_om_min < div2_3 ) then write ( logUnit ( 1 ), '(A,F10.5)' ) 'Error: Kinematic omega < 2/3:' , & & glob_om_min write ( logUnit ( 1 ), '(A,I0)' ) 'On level:' , iLevel write ( logUnit ( 1 ), * ) 'Solution: Decrease kinematic viscosity' general % simControl % status % bits ( tem_stat_nonPhysical ) = . true . end if select case ( trim ( schemeRelax )) case ( 'bgk' ) if ( glob_om_max > 1.976_rk ) then write ( logUnit ( 1 ), '(A,F10.5)' ) 'WARNING: Kinematic omega > 1.976:' , & & glob_om_max write ( logUnit ( 1 ), '(A,I0)' ) 'On level:' , iLevel write ( logUnit ( 1 ), * ) 'Solution: Increase kinematic viscosity,' write ( logUnit ( 1 ), * ) 'especially near BC and level jumps.' end if case ( 'mrt' , 'trt' , 'cumulant' , 'cumulant_extended' , 'hrr_bgk' , 'rr_bgk' , & & 'prr_bgk' , 'r_bgk' , 'drt_bgk' , 'rr_bgk_corrected' , & & 'cumulant_extended_generic' , 'hrr_bgk_corrected' , & & 'prr_bgk_corrected' ) if ( glob_om_max > 1.999_rk ) then write ( logUnit ( 1 ), '(A,F10.5)' ) 'WARNING: Kinematic omega > 1.999:' , & & glob_om_max write ( logUnit ( 1 ), '(A,I0)' ) 'On level:' , iLevel write ( logUnit ( 1 ), * ) 'Solution: Increase kinematic viscosity,' write ( logUnit ( 1 ), * ) 'especially near BC and level jumps.' end if case default call tem_abort ( 'Error: Unknown scheme relaxation in check omega' ) end select write ( logUnit ( 10 ), '(A,I0)' ) 'On level:' , iLevel write ( logUnit ( 10 ), '(A,F10.5,A,F10.5,A)' ) & & 'Kinematic omega (min,max):(' , glob_om_min , ',' , glob_om_max , ')' end if if ( any ( abs ( omLvlKine ( iLevel )% val ( 1 : nSolve ( iLevel )) - 1.0_rk ) & & < 1000 * eps_single_k ) ) then write ( * , \"(A,I0)\" ) ' Attention: Omega on level: ' , iLevel write ( * , \"(A)\" ) ' is chosen close to 1.0' write ( * , \"(A)\" ) ' This can cause program to crash ' & & // 'when it calculates strain rate or ' & & // 'shear stress.' end if end do end subroutine mus_check_omegaKine ! ------------------------------------------------------------------------ ! end module mus_relaxationParam_module","tags":"","loc":"sourcefile/mus_relaxationparam_module.f90.html"},{"title":"mus_control_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_control_module.f90~~EfferentGraph sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_timer_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_control_module.f90~~AfferentGraph sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2011-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011-2012, 2021 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2021 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> In this module, the control structure for computing each time step is !! established. !! !! Various different control structures can be defined and set by function !! pointers. !! The current main routine is recursive_multilevel which recursively computes !! the new time step for all the schemes defined on all levels, starting from !! the coarsest. !! module mus_control_module ! include treelm modules use env_module , only : rk , labelLen use tem_timer_module , only : tem_startTimer , tem_stopTimer use tem_general_module , only : tem_general_type use tem_debug_module , only : main_debug , dbgUnit use tem_time_module , only : tem_time_advance , tem_time_dump use tem_logging_module , only : logUnit use tem_varSys_module , only : tem_varSys_type use tem_stencil_module , only : tem_stencilHeader_type ! include musubi modules use mus_pdf_module , only : pdf_data_type , mus_swap_now_next use mus_param_module , only : mus_param_type use mus_geom_module , only : mus_geom_type use mus_bc_general_module , only : set_boundary use mus_aux_module , only : mus_update_relaxParams use mus_scheme_type_module , only : mus_scheme_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_field_module , only : mus_field_type use mus_source_module , only : mus_apply_sourceTerms , & & mus_update_sourceVars use mus_debug_module , only : dump_debug_Info use mus_IBM_module , only : mus_inamuro_IBM , mus_buildBuffIBM use mus_timer_module , only : mus_timerHandles , nStages use mus_physics_module , only : mus_convertFac_type use mus_auxField_module , only : mus_calcAuxFieldAndExchange , & & mus_intpAuxFieldCoarserAndExchange use mus_derVarPos_module , only : mus_derVarPos_type implicit none private public :: mus_control_type public :: mus_init_control !> Datatype containing mapping of control routines to function pointers type mus_control_type procedure ( computation ), pointer :: do_computation => null () end type mus_control_type abstract interface !> Interface describes the main control routine which does computation !! set boundary and check flow status subroutine computation ( me , scheme , geometry , params , iLevel ) import :: mus_scheme_type , mus_geom_type , mus_param_type , & & mus_control_type !> self control type class ( mus_control_type ) :: me !> container for the scheme type ( mus_scheme_type ), intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params !> Level counter variable integer , intent ( in ) :: iLevel end subroutine computation end interface integer , save :: iStage = 0 logical , save :: running = . false . contains ! ------------------------------------------------------------------------ ! !> This routines sets the function pointer to main control routine !! !! control routine is chosen based on the type of simulation. !! like single level, multi-level because multilevel requires !! recursive routine !! !! in the lua file you can now select !! `control_routine = '...'` !! where possible values are currently !! !! - `benchmark`: strongly reduced control routine with only single level, !!                no sources, etc. !! mainly for benchmarking !! !! - `multiLevel`: full multilevel, multiLevel routine !! - if nothing is given, the full multilevel, multiLevel routine is chosen subroutine mus_init_control ( controlRoutine , me , minLevel , maxLevel ) ! -------------------------------------------------------------------- ! character ( len = labelLen ), intent ( in ) :: controlRoutine !> contains function pointer to point control routine type ( mus_control_type ), intent ( out ) :: me integer , intent ( in ) :: minLevel , maxLevel ! -------------------------------------------------------------------- ! ! Select according to special need if ( trim ( controlRoutine ) == 'benchmark' ) then me % do_computation => do_benchmark write ( logUnit ( 5 ), \"(A)\" ) \"Select benchmark control routine.\" else if ( trim ( controlRoutine ) == 'debug' ) then ! me%do_computation => do_recursive_debug write ( logUnit ( 5 ), \"(A)\" ) \"Select debug recursive control routine.\" else ! No special requirement from user, then select by single or multi levels if ( minLevel == maxLevel ) then me % do_computation => do_fast_singleLevel write ( logUnit ( 5 ), \"(A)\" ) \"Select fast single level control routine.\" else me % do_computation => do_recursive_multiLevel write ( logUnit ( 5 ), \"(A)\" ) \"Select recursive multi level control routine.\" end if end if end subroutine mus_init_control ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Main control routine: Update the time step for all levels. !! Main steps: !!   * if iLevel < maxLevel do recursive at iLevel+1 !!   * do BC at iLevel !!   * do auxField calculation at iLevel !!   * do compute kernel at iLevel !!   * do apply source at iLevel !!   * do do_IntpFinerAndExchange at iLevel if iLevel < maxLevel !!     * intp My Coarser ghost (iLevel) from Finer (iLevel+1) !!     * do exchange bufferFromFiner at iLevel !!   * exchange buffer at iLevel !!   * exchange bufferFromCoarser at iLevel if iLevel > minLevel !!   * do do_intpCoarserAndExchange at iLevel if iLevel < maxLevel !!     * intp Finer Ghost (iLevel+1) from my coarser (iLevel) !!     * exchange bufferFromCoarser at iLevel+1 !! recursive subroutine do_recursive_multiLevel ( me , scheme , geometry , params , & & iLevel ) ! -------------------------------------------------------------------- ! !> self control type class ( mus_control_type ) :: me !> container for the scheme type ( mus_scheme_type ), intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params !> the current level integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------- ! integer :: now , next , iNestingLoop ! -------------------------------------------------------------------- ! ! ------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A,I0)\" ) 'Entering do_computation with iLevel: ' , iLevel ! Update auxField dependent source fields before adding source term to state ! and auxField such that both auxField and apply_source uses same source in ! one multilevel cycle. write ( logUnit ( 10 ), \"(A)\" ) 'Update source variables which depend on auxField' call mus_update_sourceVars ( nFields = scheme % nFields , & & field = scheme % field , & & globSrc = scheme % globSrc , & & varSys = scheme % varSys , & & iLevel = iLevel , & & auxField = scheme % auxField ( iLevel )% val , & & phyConvFac = params % physics % fac ( iLevel ), & & derVarPos = scheme % derVarPos ) ! when not on finest level, go to next level if ( iLevel < geometry % tree % global % maxLevel ) then ! Perform the number of nested time steps on the finer level L+1 ! according to scaling type : !   diffusive: nNesting = 4 !   acoustic:  nNesting = 2 do iNestingLoop = 1 , params % nNesting write ( logUnit ( 10 ), \"(A,I0)\" ) 'Nesting loop ' , iNestingloop call me % do_computation ( scheme , geometry , params , iLevel + 1 ) end do end if write ( logUnit ( 10 ), \"(A,I0)\" ) 'Compute on level: ' , iLevel call start_stageTimer () ! update the time counters. MH: checked. Please dont move ! Increasing with the smallest time step (maxLevel) ! KM: time is advanced here since new time is required to update sources. if ( iLevel == geometry % tree % global % maxLevel ) then write ( logUnit ( 10 ), \"(A)\" ) 'Advance time t+dt_maxLevel' call tem_time_advance ( me = params % general % simControl % now , & & sim_dt = params % physics % dtLvl ( geometry & & % tree % global % maxLevel ) ) endif write ( logUnit ( 10 ), \"(A)\" ) 'Set boundary condition' ! set boundary for each field in current scheme call set_boundary ( field = scheme % field , & & pdf = scheme % pdf ( iLevel ), & & state = scheme % state ( iLevel )% val , & & levelDesc = scheme % levelDesc ( iLevel ), & & tree = geometry % tree , & & iLevel = iLevel , & & nBCs = geometry % boundary % nBCtypes , & & params = params , & & layout = scheme % layout , & & physics = params % physics , & & varSys = scheme % varSys , & & mixture = scheme % mixture , & & derVarPos = scheme % derVarPos , & & globBC = scheme % globBC ) ! ------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Swap now and next' ! swap double buffer index for current level call mus_swap_now_next ( scheme % pdf ( iLevel ) ) now = scheme % pdf ( iLevel )% nNow next = scheme % pdf ( iLevel )% nNext ! -------------------------------------------------------------------------- ! Compute auxField from pre-collision state for fluid and ghostFromCoarser ! and exchange them if turbulence is active call tem_startTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) write ( logUnit ( 10 ), \"(A)\" ) 'Calculate auxField' call mus_calcAuxFieldAndExchange ( & & auxField = scheme % auxField ( iLevel ), & & calcAuxField = scheme % calcAuxField , & & state = scheme % state ( iLevel )% val (:, now ), & & pdfData = scheme % pdf ( iLevel ), & & nFields = scheme % nFields , & & field = scheme % field (:), & & globSrc = scheme % globSrc , & & stencil = scheme % layout % fStencil , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos , & & general = params % general , & & phyConvFac = params % physics % fac ( iLevel ), & & iLevel = iLevel , & & minLevel = geometry % tree % global % minLevel , & & schemeHeader = scheme % header , & & quantities = scheme % layout % quantities ) if ( iLevel < geometry % tree % global % maxLevel ) then write ( logUnit ( 10 ), \"(A)\" ) 'Interpolate and exchange auxField in ' & & // 'ghostFromFiner' call mus_intpAuxFieldCoarserAndExchange ( & & intp = scheme % intp , & & tAuxField = scheme % auxField ( iLevel ), & & sAuxField = scheme % auxField ( iLevel + 1 ), & & tLevelDesc = scheme % levelDesc ( iLevel ), & & stencil = scheme % layout % fStencil , & & iLevel = iLevel , & & nAuxScalars = scheme % varSys % nAuxScalars , & & general = params % general ) end if call tem_stopTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) ! -------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Update relaxparams' ! -------------------------------------------------------------------------- ! Update parameters, relaxation time .etc call tem_startTimer ( timerHandle = mus_timerHandles % relax ( iLevel ) ) call mus_update_relaxParams ( scheme = scheme , & & iLevel = iLevel , & & tNow = params % general % simControl % now , & & physics = params % physics , & & lattice = params % lattice , & & nBCs = geometry % boundary % nBCtypes ) call tem_stopTimer ( timerHandle = mus_timerHandles % relax ( iLevel ) ) ! -------------------------------------------------------------------------- ! ------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Stream and collide' ! Compute current scheme of current level call tem_startTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) !$omp parallel call scheme % compute ( & & fieldProp = scheme % field (:)% fieldProp , & & inState = scheme % state ( iLevel )% val (:, Now ), & & outState = scheme % state ( iLevel )% val (:, Next ), & & auxField = scheme % auxField ( ilevel )% val (:), & & neigh = scheme % pdf ( iLevel )% neigh (:), & & nElems = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & level = iLevel , & & layout = scheme % layout , & & params = params , & & derVarPos = scheme % derVarPos , & & varSys = scheme % varSys ) !$omp end parallel call tem_stopTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) ! ------------------------------------------------------------------------- ! -------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Apply source' call mus_apply_sourceTerms ( field = scheme % field (:), & & nFields = scheme % nFields , & & globSrc = scheme % globSrc , & & pdf = scheme % pdf ( iLevel ), & & varSys = scheme % varSys , & & iLevel = iLevel , & & time = params % general % simControl % now , & & state = scheme % state ( iLevel )% val , & & auxField = scheme % auxField ( iLevel )% val (:), & & derVarPos = scheme % derVarPos (:), & & phyConvFac = params % physics % fac ( iLevel ) ) ! -------------------------------------------------------------------------- ! ------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Communicate fluids' ! Communicate the halo elements of each scheme on current level call tem_startTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) ! communicate halo elements for Next call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel )% sendbuffer , & & recv = scheme % levelDesc ( iLevel )% recvbuffer , & & state = scheme % state ( iLevel )% val (:, Next ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) ! communicate turbulent viscosity, required for interpolation if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% recvbuffer , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% sendbuffer , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% visc (:), & & message_flag = iLevel + 100 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) ! ------------------------------------------------------------------------- ! ------------------------------------------------------------------------- ! communicate my finer ghost element from coarse level if ( iLevel > geometry % tree % global % minLevel ) then write ( logUnit ( 10 ), \"(A)\" ) 'Communicate ghostFromCoarser' call tem_startTimer ( timerHandle & & = mus_timerHandles % commFromCoarser ( iLevel ) ) call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel )% sendbufferFromCoarser , & & recv = scheme % levelDesc ( iLevel )% recvbufferFromCoarser , & & state = scheme % state ( iLevel )% val (:, Next ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) ! communicate turbulent viscosity, required for interpolation if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% recvBufferFromCoarser , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% sendBufferFromCoarser , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% visc (:), & & message_flag = iLevel + 200 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( timerHandle & & = mus_timerHandles % commFromCoarser ( iLevel ) ) end if ! -------------------------------------------------------------------------- call stop_stageTimer () ! Interpolate ghost elements if ( iLevel < geometry % tree % global % maxLevel ) then ! Fill my coarser element (L) from finer (L+1) call do_intpFinerAndExchange ( scheme , params , iLevel ) ! Interpolate the ghost elements on the finer level(L+1) with data provided ! from current level(L). call do_intpCoarserAndExchange ( scheme , params , iLevel ) end if ! if not on finest level ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- if ( iLevel == geometry % tree % global % minLevel ) then iStage = 0 running = . false . end if ! -------------------------------------------------------------------------- end subroutine do_recursive_multiLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine does: !! 1. interpolate my coarse ghost element (iLevel) from finer level (iLevel+1) !! 2. exchange the data of my coarse ghost elements between process subroutine do_intpFinerAndExchange ( scheme , params , iLevel ) ! -------------------------------------------------------------------- ! !> containers for the different schemes type ( mus_scheme_type ), intent ( inout ), target :: scheme !> global parameters type ( mus_param_type ), intent ( inout ) :: params integer , intent ( in ) :: iLevel !< Level counter variable ! -------------------------------------------------------------------- ! integer :: thisLevelNext , nextLevelNext ! -------------------------------------------------------------------- ! ! Interpolate my coarse ghost elements from the finer ones thisLevelNext = scheme % pdf ( iLevel )% nNext nextLevelNext = scheme % pdf ( iLevel + 1 )% nNext call start_stageTimer () ! write(logUnit(5), \"(A,I0)\") 'intpFromFiner on level: ', iLevel ! ------------------------------------------------------------------------- call tem_startTimer ( timerHandle = mus_timerHandles % intpFromFiner ( iLevel ) ) ! ------------------------------------------------------------------------- write ( logUnit ( 10 ), \"(A)\" ) 'Interpolate ghostFromFiner' !$omp parallel call scheme % intp % fillMineFromFiner % do_intp ( & & fieldProp = scheme % field (:)% fieldProp , & & sState = scheme % state ( iLevel + 1 )% val (:, nextLevelNext ), & & sNeigh = scheme % pdf ( iLevel + 1 )% Neigh , & & snSize = scheme % pdf ( iLevel + 1 )% nSize , & & sAuxField = scheme % auxField ( iLevel + 1 )% val (:), & & tnSize = scheme % pdf ( iLevel )% nSize , & & tState = scheme % state ( iLevel )% val (:, thisLevelNext ), & & tNeigh = scheme % pdf ( iLevel )% Neigh , & & tLevelDesc = scheme % levelDesc ( iLevel ), & & level = iLevel , & & nTargets = scheme % levelDesc ( iLevel )% intpFromFiner % nVals , & & targetList = scheme % levelDesc ( iLevel )% intpFromFiner % val , & & layout = scheme % layout , & & physics = params % physics , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos (:), & & time = params % general % simControl % now ) !$omp end parallel call tem_stopTimer ( timerHandle = mus_timerHandles % intpFromFiner ( iLevel ) ) ! ------------------------------------------------------------------------- ! if ( main_debug%checkEachAlgorithmicStep ) then !   buffer=' after fill Mine FromFiner       ' !   call dump_debug_info( buffer, scheme, params, iLevel, 1, & !     &                   pdf=scheme%pdf(iLevel)             ) ! end if call stop_stageTimer () write ( logUnit ( 10 ), \"(A)\" ) 'Communicate ghostFromFiner' ! ------------------------------------------------------------------------- ! Exchange the coarse ghost elements call tem_startTimer ( timerHandle = mus_timerHandles % commFromFiner ( iLevel ) ) call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel )% sendbufferFromFiner , & & recv = scheme % levelDesc ( iLevel )% recvbufferFromFiner , & & state = scheme % state ( iLevel )% val (:, thisLevelNext ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then ! communicate turbulent viscosity, required for interpolation call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% recvBufferFromFiner , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% sendBufferFromFiner , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% visc (:), & & message_flag = iLevel + 200 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( timerHandle = mus_timerHandles % commFromFiner ( iLevel ) ) ! ------------------------------------------------------------------------- ! if ( main_debug%checkEachAlgorithmicStep ) then !   buffer = ' after exch Mine FromFiner' !   call dump_debug_info( buffer, scheme, params, iLevel, 1, & !     &                   pdf=scheme%pdf(iLevel)             ) ! end if end subroutine do_intpFinerandExchange ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine utilizes fluid elements on my level (L) to fill finer !! ghost elements on next level (L+1). !! Then it exchanges the datas of finer ghost elements (L+1) between process. subroutine do_intpCoarserAndExchange ( scheme , params , iLevel ) ! -------------------------------------------------------------------- ! !> containers for the different schemes type ( mus_scheme_type ), target , intent ( inout ) :: scheme !> global parameters type ( mus_param_type ), intent ( in ) :: params !> Level counter variable integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------- ! integer :: thisLevelNext , nextLevelNext integer :: iOrder ! -------------------------------------------------------------------- ! thisLevelNext = scheme % pdf ( iLevel )% nNext nextLevelNext = scheme % pdf ( iLevel + 1 )% nNext call start_stageTimer () ! write(logUnit(5), \"(A,I0)\") 'intpFromCoarser on level: ', iLevel+1 ! Fill finer ghost elements (L+1) by low order interpolation call tem_startTimer ( & & timerHandle = mus_timerHandles % intpFromCoarser ( iLevel + 1 ) ) ! Fill finer ghost elements (L+1) by starting from lower order ! to higher order interpolation write ( logUnit ( 10 ), \"(A)\" ) 'Interpolate ghostFromCoarser iL+1' !$omp parallel do iOrder = 0 , scheme % intp % config % order call scheme % intp % fillFinerFromMe ( iOrder )% do_intp ( & & fieldProp = scheme % field (:)% fieldProp , & & sState = scheme % state ( iLevel )% val (:, thisLevelNext ), & & sNeigh = scheme % pdf ( iLevel )% Neigh , & & snSize = scheme % pdf ( iLevel )% nSize , & & sAuxField = scheme % auxField ( iLevel )% val (:), & & tnSize = scheme % pdf ( iLevel + 1 )% nSize , & & tState = scheme % state ( iLevel + 1 )% val (:, nextLevelNext ), & & tNeigh = scheme % pdf ( iLevel + 1 )% Neigh , & & tLevelDesc = scheme % levelDesc ( iLevel + 1 ), & & level = iLevel , & & nTargets = scheme % levelDesc ( iLevel + 1 ) & & % intpFromCoarser ( iOrder )% nVals , & & targetList = scheme % levelDesc ( iLevel + 1 ) & & % intpFromCoarser ( iOrder )% Val , & & layout = scheme % layout , & & physics = params % physics , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos (:), & & time = params % general % simControl % now ) end do !$omp end parallel call tem_stopTimer ( timerHandle & & = mus_timerHandles % intpFromCoarser ( iLevel + 1 ) ) ! Debug output ! if ( main_debug%checkEachAlgorithmicStep ) then !   buffer = ' after fillFinerFromMe' !   call dump_debug_info( buffer, scheme, params, iLevel, 1, & !     &                   pdf = scheme%pdf(iLevel)) ! end if call stop_stageTimer () ! Exchange the fine ghost elements write ( logUnit ( 10 ), \"(A)\" ) 'Communicate ghostFromCoarser iL+1' call tem_startTimer ( & & timerHandle = mus_timerHandles % commFromCoarser ( iLevel + 1 ) ) call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel + 1 )% SendBufferFromCoarser , & & recv = scheme % levelDesc ( iLevel + 1 )% RecvBufferFromCoarser , & & state = scheme % state ( iLevel + 1 )% val (:, nextLevelNext ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then ! communicate turbulent viscosity, required for interpolation call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel + 1 )% recvBufferFromCoarser , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel + 1 )% sendBufferFromCoarser , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel + 1 )% visc (:), & & message_flag = iLevel + 200 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( & & timerHandle = mus_timerHandles % commFromCoarser ( iLevel + 1 ) ) ! Debug output ! if ( main_debug%checkEachAlgorithmicStep ) then !   buffer = '  after exchFinerFromMe' !   call dump_debug_info( buffer, scheme, params, iLevel, 1, & !     &                   pdf = scheme%pdf(iLevel)           ) ! end if end subroutine do_intpCoarserandExchange ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Control routine for an optimized workflow with reduced functionality. !! !! No sources, no multilevel, no multiLevel. !! Use for benchmarking !! subroutine do_fast_singleLevel ( me , scheme , geometry , params , iLevel ) ! -------------------------------------------------------------------- ! !> self control type !! dummy variable in this routine, required by interface class ( mus_control_type ) :: me !> container for the scheme type ( mus_scheme_type ), intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params !> Level counter variable integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------- ! integer :: now , next ! -------------------------------------------------------------------- ! ! Update auxField dependent source fields before adding source term to state ! and auxField such that both auxField and apply_source uses same source. call mus_update_sourceVars ( nFields = scheme % nFields , & & field = scheme % field , & & globSrc = scheme % globSrc , & & varSys = scheme % varSys , & & iLevel = iLevel , & & auxField = scheme % auxField ( iLevel )% val , & & phyConvFac = params % physics % fac ( iLevel ), & & derVarPos = scheme % derVarPos ) ! ------------------------------------------------------------------------- ! Increasing with the smallest time step (maxLevel) ! KM: time is advanced here since new time is required to update sources and BCs call tem_time_advance ( me = params % general % simControl % now , & & sim_dt = params % physics % dtLvl ( iLevel )) ! -------------------------------------------------------------------------- !set boundary for each field in current scheme call set_boundary ( field = scheme % field , & & pdf = scheme % pdf ( iLevel ), & & state = scheme % state ( iLevel )% val , & & levelDesc = scheme % levelDesc ( iLevel ), & & tree = geometry % tree , & & iLevel = iLevel , & & nBCs = geometry % boundary % nBCtypes , & & params = params , & & layout = scheme % layout , & & physics = params % physics , & & varSys = scheme % varSys , & & mixture = scheme % mixture , & & derVarPos = scheme % derVarPos , & & globBC = scheme % globBC ) ! -------------------------------------------------------------------------- ! swap double buffer index for current level call mus_swap_now_next ( scheme % pdf ( iLevel ) ) now = scheme % pdf ( iLevel )% nNow next = scheme % pdf ( iLevel )% nNext ! -------------------------------------------------------------------------- ! Compute auxField from pre-collision state for fluid and ghostFromCoarser ! and exchange them if turbulence is active call tem_startTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) call mus_calcAuxFieldAndExchange ( & & auxField = scheme % auxField ( iLevel ), & & calcAuxField = scheme % calcAuxField , & & state = scheme % state ( iLevel )% val (:, now ), & & pdfData = scheme % pdf ( iLevel ), & & nFields = scheme % nFields , & & field = scheme % field (:), & & globSrc = scheme % globSrc , & & stencil = scheme % layout % fStencil , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos , & & general = params % general , & & phyConvFac = params % physics % fac ( iLevel ), & & iLevel = iLevel , & & minLevel = geometry % tree % global % minLevel , & & schemeHeader = scheme % header , & & quantities = scheme % layout % quantities ) call tem_stopTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- ! Update parameters, relaxation time .etc call tem_startTimer ( timerHandle = mus_timerHandles % relax ( iLevel ) ) call mus_update_relaxParams ( scheme = scheme , & & iLevel = iLevel , & & tNow = params % general % simControl % now , & & physics = params % physics , & & lattice = params % lattice , & & nBCs = geometry % boundary % nBCtypes ) call tem_stopTimer ( timerHandle = mus_timerHandles % relax ( iLevel ) ) ! -------------------------------------------------------------------------- ! ------------------------------------------------------------------------- ! Compute current scheme of current level call tem_startTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) !$omp parallel call scheme % compute ( & & fieldProp = scheme % field (:)% fieldProp , & & inState = scheme % state ( iLevel )% val (:, Now ), & & outState = scheme % state ( iLevel )% val (:, Next ), & & auxField = scheme % auxField ( ilevel )% val (:), & & neigh = scheme % pdf ( iLevel )% neigh (:), & & nElems = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & level = iLevel , & & layout = scheme % layout , & & params = params , & & derVarPos = scheme % derVarPos , & & varSys = scheme % varSys ) !$omp end parallel call tem_stopTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- call mus_apply_sourceTerms ( field = scheme % field (:), & & nFields = scheme % nFields , & & globSrc = scheme % globSrc , & & pdf = scheme % pdf ( iLevel ), & & varSys = scheme % varSys , & & iLevel = iLevel , & & time = params % general % simControl % now , & & state = scheme % state ( iLevel )% val , & & auxField = scheme % auxField ( iLevel )% val (:), & & derVarPos = scheme % derVarPos (:), & & phyConvFac = params % physics % fac ( iLevel ) ) ! ------------------------------------------------------------------------- ! Communicate the halo elements of each scheme on current level ! KM: Communicate post-collision before set_boundary because nonEq_expol ! BC depends on post-collision from neighbor at next time step call tem_startTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel )% sendbuffer , & & recv = scheme % levelDesc ( iLevel )% recvbuffer , & & state = scheme % state ( iLevel )% val (:, Next ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) ! communicate turbulent viscosity, required for interpolation if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% recvbuffer , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% sendbuffer , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% visc (:), & & message_flag = iLevel + 100 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) ! ... check if at least one of the IBMs is active if ( geometry % globIBM % nIBMs > 0 ) then call mus_buildBuffIBM ( & & me = geometry % globIBM % IBM , & & commPattern = params % general % commPattern , & & globTree = geometry % tree , & & params = params , & & layout = scheme % layout , & & levelDesc = scheme % levelDesc ( iLevel ), & & iLevel = iLevel ) end if ! update the immersed boundaries if available ! ... and over the schemes ! ... check if at least one of the IBMs is active if ( geometry % globIBM % nIBMs > 0 ) then call mus_inamuro_IBM ( & & me = geometry % globIBM % IBM , & & commPattern = params % general % commPattern , & & globTree = geometry % tree , & & general = params % general , & & pdf = scheme % pdf ( iLevel ), & & layout = scheme % layout , & & levelDesc = scheme % levelDesc ( iLevel ), & & globSys = scheme % varSys , & & stateVarMap = scheme % stateVarMap % varPos % val (:), & & convFac = params % physics % fac ( iLevel ), & & iField = 1 , & & state = scheme % state ( iLevel )% val , & & iLevel = iLevel ) end if ! ------------------------------------------------------------------------- end subroutine do_fast_singleLevel ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine do_benchmark ( me , scheme , geometry , params , iLevel ) ! -------------------------------------------------------------------- ! !> self control type !! dummy variable in this routine, required by interface class ( mus_control_type ) :: me !> containers for the different schemes type ( mus_scheme_type ), intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params !> Level counter variable integer , intent ( in ) :: iLevel ! -------------------------------------------------------------------- ! integer :: now , next ! -------------------------------------------------------------------- ! ! Update auxField dependent source fields before adding source term to state ! and auxField such that both auxField and apply_source uses same source. call mus_update_sourceVars ( nFields = scheme % nFields , & & field = scheme % field , & & globSrc = scheme % globSrc , & & varSys = scheme % varSys , & & iLevel = iLevel , & & auxField = scheme % auxField ( iLevel )% val , & & phyConvFac = params % physics % fac ( iLevel ), & & derVarPos = scheme % derVarPos ) ! Increasing with the smallest time step (maxLevel) call tem_time_advance ( me = params % general % simControl % now , & & sim_dt = params % physics % dtLvl ( iLevel )) ! -------------------------------------------------------------------------- !set boundary for each field in current scheme call set_boundary ( field = scheme % field , & & pdf = scheme % pdf ( iLevel ), & & state = scheme % state ( iLevel )% val , & & levelDesc = scheme % levelDesc ( iLevel ), & & tree = geometry % tree , & & iLevel = iLevel , & & nBCs = geometry % boundary % nBCtypes , & & params = params , & & layout = scheme % layout , & & physics = params % physics , & & varSys = scheme % varSys , & & mixture = scheme % mixture , & & derVarPos = scheme % derVarPos , & & globBC = scheme % globBC ) ! -------------------------------------------------------------------------- ! swap double buffer index for current level call mus_swap_now_next ( scheme % pdf ( iLevel ) ) now = scheme % pdf ( iLevel )% nNow next = scheme % pdf ( iLevel )% nNext ! -------------------------------------------------------------------------- ! Compute auxField from pre-collision state for fluid and ghostFromCoarser ! and exchange them if turbulence is active call tem_startTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) call mus_calcAuxFieldAndExchange ( & & auxField = scheme % auxField ( iLevel ), & & calcAuxField = scheme % calcAuxField , & & state = scheme % state ( iLevel )% val (:, now ), & & pdfData = scheme % pdf ( iLevel ), & & nFields = scheme % nFields , & & field = scheme % field (:), & & globSrc = scheme % globSrc , & & stencil = scheme % layout % fStencil , & & varSys = scheme % varSys , & & derVarPos = scheme % derVarPos , & & general = params % general , & & phyConvFac = params % physics % fac ( iLevel ), & & iLevel = iLevel , & & minLevel = geometry % tree % global % minLevel , & & schemeHeader = scheme % header , & & quantities = scheme % layout % quantities ) call tem_stopTimer ( timerHandle = mus_timerHandles % aux ( iLevel ) ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- ! Update parameters, relaxation time .etc call mus_update_relaxParams ( scheme = scheme , & & iLevel = iLevel , & & tNow = params % general % simControl % now , & & physics = params % physics , & & lattice = params % lattice , & & nBCs = geometry % boundary % nBCtypes ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- ! Compute current scheme of current level call tem_startTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) !$omp parallel call scheme % compute ( & & fieldProp = scheme % field (:)% fieldProp , & & inState = scheme % state ( iLevel )% val (:, Now ), & & outState = scheme % state ( iLevel )% val (:, Next ), & & auxField = scheme % auxField ( ilevel )% val (:), & & neigh = scheme % pdf ( iLevel )% neigh (:), & & nElems = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & level = iLevel , & & layout = scheme % layout , & & params = params , & & derVarPos = scheme % derVarPos , & & varSys = scheme % varSys ) !$omp end parallel call tem_stopTimer ( timerHandle = mus_timerHandles % compute ( iLevel ) ) ! -------------------------------------------------------------------------- ! -------------------------------------------------------------------------- call mus_apply_sourceTerms ( field = scheme % field (:), & & nFields = scheme % nFields , & & globSrc = scheme % globSrc , & & pdf = scheme % pdf ( iLevel ), & & varSys = scheme % varSys , & & iLevel = iLevel , & & time = params % general % simControl % now , & & state = scheme % state ( iLevel )% val , & & auxField = scheme % auxField ( iLevel )% val (:), & & derVarPos = scheme % derVarPos (:), & & phyConvFac = params % physics % fac ( iLevel ) ) ! -------------------------------------------------------------------------- ! Communicate the halo elements of each scheme on current level call tem_startTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) call params % general % commPattern % exchange_real ( & & send = scheme % levelDesc ( iLevel )% sendbuffer , & & recv = scheme % levelDesc ( iLevel )% recvbuffer , & & state = scheme % state ( iLevel )% val (:, Next ), & & message_flag = iLevel , & & comm = params % general % proc % comm ) ! communicate turbulent viscosity, required for interpolation if ( trim ( scheme % header % kind ) == 'fluid' . or . & & trim ( scheme % header % kind ) == 'fluid_incompressible' ) then if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active ) then call params % general % commPattern % exchange_real ( & & recv = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% recvbuffer , & & send = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% sendbuffer , & & state = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel )% visc (:), & & message_flag = iLevel + 100 , & & comm = params % general % proc % comm ) end if end if call tem_stopTimer ( timerHandle = mus_timerHandles % comm ( iLevel ) ) ! ------------------------------------------------------------------------- end subroutine do_benchmark ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine start_stageTimer ( ) if ( . not . running ) then iStage = mod ( iStage , nStages ) + 1 call tem_startTimer ( timerHandle = mus_timerHandles % stage ( iStage ) ) running = . true . end if end subroutine start_stageTimer ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine stop_stageTimer ( ) if ( running ) then call tem_stopTimer ( timerHandle = mus_timerHandles % stage ( iStage ) ) running = . false . end if end subroutine stop_stageTimer ! ------------------------------------------------------------------------ ! end module mus_control_module ! ***************************************************************************** !","tags":"","loc":"sourcefile/mus_control_module.f90.html"},{"title":"mus_scheme_type_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_scheme_type_module.f90~~EfferentGraph sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_scheme_type_module.f90~~AfferentGraph sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012, 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012-2017, 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2014-2017 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Simon Zimny !! author: Kartik Jain !! This module contains the type definition(s) required in the scheme routines !! In addition depend type and condition type for geometry increase routine !! are defined. Compute kernel definition is also defined in this module !! module mus_scheme_type_module ! include treelm modules use env_module , only : rk use tem_tracking_module , only : tem_tracking_type use tem_varSys_module , only : tem_varSys_type use tem_variable_module , only : tem_variable_type use tem_varMap_module , only : tem_varMap_type , & & tem_possible_variable_type use tem_spacetime_fun_module , only : tem_st_fun_linkedList_type use tem_construction_module , only : tem_levelDesc_type ! include musubi modules use mus_bc_header_module , only : glob_boundary_type use mus_source_type_module , only : mus_source_type use mus_field_module , only : mus_field_type use mus_field_prop_module , only : mus_field_prop_type use mus_pdf_module , only : pdf_data_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_param_module , only : mus_param_type use mus_mixture_module , only : mus_mixture_type use mus_interpolate_header_module , only : mus_interpolation_type use mus_transport_var_module , only : mus_transport_var_type use mus_nernstPlanck_module , only : mus_nernstPlanck_type use mus_auxField_module , only : mus_auxFieldVar_type , & & mus_proc_calcAuxField use mus_gradData_module , only : mus_gradData_type , mus_Grad_type implicit none private public :: mus_scheme_type public :: kernel public :: array2D_type type array2D_type !! To allow Intel AVX SIMD streaming store instructions, !! the array must be aligned at 32 bytes real ( kind = rk ), allocatable , dimension (:,:) :: val !dir$ attributes align : 32 :: val end type array2D_type !> Datatype containing all information on the scheme. !! !! The mus_scheme_type contains of all information that are needed !! to run a simulation (including informations on the: fluid, boundary !! conditions, levelDescriptor, state vector, layout, diffusion info, !! tracking). type mus_scheme_type !> Interpolation description for each scheme to do its own interpolation type ( mus_interpolation_type ) :: intp !> contains mixture information for multispecies type ( mus_mixture_type ) :: mixture !. Contains information for nernst-planck type ( mus_nernstPlanck_type ) :: nernstPlanck !> number of fields in the current scheme integer :: nFields = 0 !> array of field type for each field type ( mus_field_type ), allocatable :: field (:) !> array of boundary types contains elems of each boundary type ( glob_boundary_type ), allocatable :: globBC (:) !> global source applied to all fields type ( mus_source_type ) :: globSrc !> possible source variables depends on scheme kind type ( tem_possible_variable_type ) :: poss_srcVar !> transport variables type ( mus_transport_var_type ) :: transVar !> possible transport variables depends on scheme kind !! This variables might be used in compute kernel type ( tem_possible_variable_type ) :: poss_transVar !> identifier of the scheme type ( mus_scheme_header_type ) :: header type ( tem_levelDesc_type ), allocatable :: levelDesc (:) !> pdf_data_types for every level !! size: minLevel:maxLevel type ( pdf_data_type ), allocatable :: pdf (:) !> Data vector containing the pdf state !! allocated in routine: mus_construct !! size: minLevel:maxLevel type ( array2D_type ), allocatable :: state (:) !> the scheme representation used in this scheme type ( mus_scheme_layout_type ) :: layout !> function pointer to compute kernel procedure ( kernel ), pointer , nopass :: compute => null () !> Contains trackingControl, config and instances type ( tem_tracking_type ) :: track !> Position of reduction transient variable in varSys type ( tem_varMap_type ) :: redTransVarMap !> store position of derived variable each field and total field !! in the global system type ( mus_derVarPos_type ), allocatable :: derVarPos (:) !> global variable system definition type ( tem_varSys_type ) :: varSys !> Variables defined in the lua file type ( tem_variable_type ), allocatable :: luaVar (:) !> state variable position in the global varSys type ( tem_varMap_type ) :: stateVarMap !> contains spacetime functions defined for lua variables type ( tem_st_fun_linkedList_type ) :: st_funList !> Used in mus_harvesting to check whether variables loaded from !! restart file has pdf variable logical :: readVarIsPdf !> stores auxField variable values and function pointer to compute !! auxiliary field !! Size: minlevel:maxLevel type ( mus_auxFieldVar_type ), allocatable :: auxField (:) !> Contains direct neighbor position in the state and !! finite difference coefficients to compute gradient type ( mus_gradData_type ), allocatable :: gradData (:) !> Function pointer to evaluate auxilary variable procedure ( mus_proc_calcAuxField ), pointer , nopass :: calcAuxField => null () !> Contains the different pointers to calculate the gradients type ( mus_Grad_type ) :: Grad end type mus_scheme_type !> What does the kernel interface look like? !! Every kernel's argument list must correspond to this one. !! !! Adhere to the below naming convection for the kernel names !! !! mus_advRel_k<kind>_r<relaxation>_v<variant>_l<layout> !! !! Examples: !!   mus_advRel_kFluid_rBGK_vStd_lD3Q19 !!   mus_advRel_kFluidIncomp_rBGK_vStd_lD3Q19 !!   mus_advRel_kFluid_rBGK_vHRR_lD3Q19 !! !! For non-specific implementation leave names out. !! So we do not use generic keyword in the kernel names anymore. !! Examples: !!   mus_advRel_kFluid_rBGK_vStd_l !!   mus_advRel_kMsLiquid_rBGK_vStd_l !! abstract interface !> The common subroutine interface for compute kernels. All kernels have to !! implement this interface in order to be callable via !! mus_scheme_type%compute function pointer. subroutine kernel ( fieldProp , inState , outState , auxField , neigh , nElems , & & nSolve , level , layout , params , varSys , derVarPos ) import :: rk , mus_field_prop_type , mus_scheme_layout_type , & & mus_scheme_type , tem_varSys_type , mus_param_type , & & mus_derVarPos_type ! ---------------------------------------------------------------- ! !> Array of field properties (fluid or species) type ( mus_field_prop_type ), intent ( in ) :: fieldProp (:) !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> current layout type ( mus_scheme_layout_type ), intent ( in ) :: layout !> number of elements in state Array integer , intent ( in ) :: nElems !> input  pdf vector real ( kind = rk ), intent ( in ) :: inState ( nElems * varSys % nScalars ) !> output pdf vector real ( kind = rk ), intent ( out ) :: outState ( nElems * varSys % nScalars ) !> Auxiliary field computed from pre-collision state !! Is updated with correct velocity field for multicomponent models real ( kind = rk ), intent ( inout ) :: auxField ( nElems * varSys % nAuxScalars ) !> connectivity vector integer , intent ( in ) :: neigh ( nElems * layout % fStencil % QQ ) !> number of elements solved in kernel integer , intent ( in ) :: nSolve !> current level integer , intent ( in ) :: level !> global parameters type ( mus_param_type ), intent ( in ) :: params !> position of derived quantities in varsys for all fields type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) end subroutine kernel end interface end module mus_scheme_type_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_scheme_type_module.f90.html"},{"title":"mus_tracking_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_tracking_module.f90~~EfferentGraph sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_timer_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_tracking_module.f90~~AfferentGraph sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2015-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! This module provides the MUSUBI subroutines needed for the tracking !! functionality. !! module mus_tracking_module ! include treelm modules use tem_logging_module , only : logUnit use tem_tracking_module , only : tem_init_tracker , tem_tracker , & & tem_init_tracker_subTree use tem_debug_module , only : dbgUnit ! include musubi modules use mus_scheme_type_module , only : mus_scheme_type use mus_param_module , only : mus_param_type use mus_geom_module , only : mus_geom_type use mus_tools_module , only : mus_writeSolverSpecInfo use mus_time_module , only : mus_timeControl_homogenize ! include libharvester modules use hvs_output_module , only : hvs_Internal implicit none private public :: mus_init_tracker contains ! **************************************************************************** ! !> This routine initialize tracking subTree to remove empty tracking objects. !! On active tracking objects: Homogenize time control, write solver speific !! info for harvester output format and initialize output using !! tem_init_tracker subroutine mus_init_tracker ( scheme , geometry , params ) ! -------------------------------------------------------------------------- !> scheme type type ( mus_scheme_type ), intent ( inout ) :: scheme !> Treelmesh data type ( mus_geom_type ), intent ( in ) :: geometry !> Global parameters type ( mus_param_type ), intent ( in ) :: params ! -------------------------------------------------------------------------- integer :: iTrack , iConfig ! -------------------------------------------------------------------------- write ( dbgUnit ( 1 ), * ) 'Enter mus_init_tracker' write ( dbgUnit ( 1 ), * ) 'Tracking control active is: ' , & & scheme % track % control % active flush ( dbgUnit ( 1 )) if ( . not . scheme % track % control % active ) return ! tracking objects write ( logUnit ( 1 ), * ) 'Initializing tracker...' write ( dbgUnit ( 1 ), * ) 'init tracker subTree' flush ( dbgUnit ( 1 )) ! Initialize tracker subTree to remove empty tracking objects call tem_init_tracker_subTree ( & & me = scheme % track , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil , & & solver = params % general % solver ) write ( dbgUnit ( 1 ), * ) 'homogenize track time' flush ( dbgUnit ( 1 )) do iTrack = 1 , scheme % track % control % nActive iConfig = scheme % track % instance ( iTrack )% pntConfig call mus_timeControl_homogenize ( & & me = scheme % track % config ( iConfig )% timeControl , & & dt = params % physics & & % dtLvl ( geometry % tree % global % maxLevel ), & & reqInt = params % reqInterval ) end do !iTrack write ( dbgUnit ( 1 ), * ) 'to call tem init tracker' flush ( dbgUnit ( 1 )) ! Creating tracking varMap with variable position in varSys and init ! output call tem_init_tracker ( me = scheme % track , & & tree = geometry % tree , & & globProc = params % general % proc , & & solver = params % general % solver , & & varSys = scheme % varSys ) end subroutine mus_init_tracker ! **************************************************************************** ! end module mus_tracking_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_tracking_module.f90.html"},{"title":"mus_initMultispecies_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_initmultispecies_module.f90~~EfferentGraph sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013-2014, 2017 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2015 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module contains routines which initiliaze advection relaxation and !! flow field for multispecies lbm gas model and liquid model. module mus_initMultispecies_module ! include treelm modules use env_module , only : labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include musubi modules use mus_MSGas_module , only : bgk_advRel_MSGas_generic , & & bgk_advRel_d3q19f3_MSGas use mus_MSLiquid_module , only : bgk_advRel_MSLiquid_generic , & & bgk_advRel_MSLiquid_generic_WTDF , & & bgk_advRel_d3q19f3_MSLiquid , & & bgk_advRel_d3q19f3_MSLiquid_WTDF , & & bgk_forcing_advRel_MSLiquid_generic , & & mrt_advRel_MSLiquid_generic , & & mrt_advRel_MSLiquid_generic_WTDF , & & mrt_advRel_d3q19f3_MSLiquid , & & mrt_advRel_d3q19f3_MSLiquid_WTDF use mus_scheme_type_module , only : kernel implicit none private public :: mus_init_advRel_multispecies_gas public :: mus_init_advRel_multispecies_liquid contains ! ****************************************************************************** ! !> Initialize the relaxation model for multispecies gas model subroutine mus_init_advRel_multispecies_gas ( relaxation , layout , nFields , & & compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout integer , intent ( in ) :: nFields procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- select case ( trim ( relaxation ) ) case ( 'bgk' ) select case ( trim ( layout ) ) case ( 'd3q19' ) if ( nFields == 3 ) then write ( logUnit ( 1 ), * ) 'Choosen optimized d3q19f3 multispecies ' // & & 'gas kernel' compute => bgk_advRel_d3q19f3_MSGas else write ( logUnit ( 1 ), * ) 'Choosen testing multispecies gas kernel' compute => bgk_advRel_MSGas_generic end if case ( 'd2q9' ) write ( logUnit ( 1 ), * ) 'Choosen testing multispecies gas kernel' compute => bgk_advRel_MSGas_generic case default write ( logUnit ( 1 ), * ) 'Stencil ' // trim ( layout ) // ' is not supported yet!' call tem_abort () end select ! layout case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select ! relaxation end subroutine mus_init_advRel_multispecies_gas ! ****************************************************************************** ! ! ****************************************************************************** ! !> Initialize the relaxation model for multispecies liquid model subroutine mus_init_advRel_multispecies_liquid ( relaxation , layout , nFields , & & compute ) ! --------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: relaxation character ( len = labelLen ), intent ( in ) :: layout integer , intent ( in ) :: nFields procedure ( kernel ), pointer , intent ( out ) :: compute ! --------------------------------------------------------------------------- select case ( trim ( relaxation ) ) case ( 'bgk' ) if ( ( trim ( layout ) == 'd3q19' ) . and . ( nFields == 3 ) ) then write ( logUnit ( 1 ), * ) 'Choosen optimized d3q19f3 multispecies ' & & // 'liquid kernel' compute => bgk_advRel_d3q19f3_MSLiquid else write ( logUnit ( 1 ), * ) 'Choosen generic generic multispecies ' & & // 'liquid kernel' compute => bgk_advRel_MSLiquid_generic end if case ( 'mrt' ) if ( ( trim ( layout ) == 'd3q19' ) . and . ( nFields == 3 ) ) then write ( logUnit ( 1 ), * ) 'Choosen optimized mrt d3q19f3 multispecies ' // & & 'liquid kernel' compute => mrt_advRel_d3q19f3_MSLiquid else write ( logUnit ( 1 ), * ) 'Choosen generic mrt multispecies liquid ' // & & 'kernel' compute => mrt_advRel_MSLiquid_generic end if case ( 'bgk_forcing' ) write ( logUnit ( 1 ), * ) 'Choosen generic bgk forcing multispecies ' // & & 'liquid kernel' compute => bgk_forcing_advRel_MSLiquid_generic case ( 'bgk_withthermodynfac' ) if ( ( trim ( layout ) == 'd3q19' ) . and . ( nFields == 3 ) ) then write ( logUnit ( 1 ), * ) 'Choosen optimized d3q19f3 multispecies ' & & // 'liquid kernel' compute => bgk_advRel_d3q19f3_MSLiquid_WTDF else write ( logUnit ( 1 ), * ) 'Choosen generic bgk with thermodynamic ' // & & 'factor multispecies liquid kernel' compute => bgk_advRel_MSLiquid_generic_WTDF end if case ( 'mrt_withthermodynfac' ) if ( ( trim ( layout ) == 'd3q19' ) . and . ( nFields == 3 ) ) then write ( logUnit ( 1 ), * ) 'Choosen optimized d3q19f3 multispecies ' & & // 'liquid kernel' compute => mrt_advRel_d3q19f3_MSLiquid_WTDF else write ( logUnit ( 1 ), * ) 'Choosen generic mrt multispecies liquid ' // & & 'kernel with thermodynamic factor' compute => mrt_advRel_MSLiquid_generic_WTDF end if case default write ( logUnit ( 1 ), * ) 'Relaxation ' // trim ( relaxation ) // ' is not supported!' call tem_abort () end select ! relaxation end subroutine mus_init_advRel_multispecies_liquid ! ****************************************************************************** ! end module mus_initMultispecies_module","tags":"","loc":"sourcefile/mus_initmultispecies_module.f90.html"},{"title":"mus_variable_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_variable_module.f90~~EfferentGraph sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_turbchanforce_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_variable_module.f90~~AfferentGraph sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2013 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2013-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2013-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2013-2015 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Verena Krupp <verena.krupp@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Philipp Otte <otte@mathcces.rwth-aachen.de> ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2017, 2020 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> This module provides all possible 'pure variables' (= no prefixes) for a !!  given kind of simulation. !! !! IMPORTANT NOTE: When you create a new variable, do not forget to add this !! variable !! name into [[mus_append_auxField]], [[mus_store_derVarPos]] and also in !! [[mus_store_bcVarPos]] routine. !! module mus_variable_module use iso_c_binding , only : c_loc ! include treelm modules use env_module , only : rk , long_k , labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_debug_module , only : dbgUnit use tem_varSys_module , only : tem_varSys_type , & & tem_varSys_append_stateVar , & & tem_varSys_append_derVar , & & tem_varSys_append_auxFieldVar , & & tem_varSys_proc_point , & & tem_varSys_proc_element , & & tem_varSys_proc_setParams , & & tem_varSys_proc_getParams , & & tem_varSys_proc_setupIndices , & & tem_varSys_proc_getValOfIndex , & & tem_varSys_solverData_evalElem_type , & & tem_varSys_dump , & & tem_varSys_getPoint_dummy , & & tem_varSys_getElement_dummy , & & tem_varSys_setupIndices_dummy , & & tem_varSys_getValOfIndex_dummy , & & tem_varSys_setParams_dummy , & & tem_varSys_getParams_dummy use tem_varMap_module , only : tem_varMap_type , & & tem_possible_variable_type use tem_variable_module , only : tem_variable_type use tem_dyn_array_module , only : dyn_labelArray_type , init , append , & & PositionOfVal use tem_grow_array_module , only : grw_labelarray_type , init , append , & & truncate use tem_derived_module , only : tem_varSys_append_luaVar use tem_stencil_module , only : tem_stencilHeader_type use tem_meshInfo_module , only : tem_varSys_append_meshInfoVar use tem_spacetime_fun_module , only : tem_st_fun_linkedList_type ! include musubi modules use mus_scheme_header_module , only : mus_scheme_header_type use mus_varSys_module , only : mus_varSys_solverData_type , & & mus_get_new_solver_ptr , & & mus_deriveVar_ForPoint , & & mus_generic_varFromPDF_fromIndex ,& & mus_set_stFun_getElement use mus_stateVar_module , only : mus_access_state_ForElement , & & mus_stateVar_forPoint , & & mus_accessVar_setupIndices , & & mus_stateVar_fromIndex use mus_source_type_module , only : mus_source_type , & & mus_applySrc_dummy , & & mus_updateSrcVar_dummy use mus_source_type_module , only : mus_addSrcToAuxField_dummy use mus_source_var_module , only : mus_updateSrcVar_dynSponFld use mus_source_var_turbChanForce_module , only : mus_updateSrcVar_turbChanForce use mus_field_module , only : mus_field_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_derVarPos_module , only : mus_derVarPos_type , & & mus_derive_FromMacro_dummy , & & mus_derive_FromState_dummy , & & mus_derive_FromPreColState_dummy use mus_derQuan_module , only : mus_append_derVar_fluid , & & deriveEquil_FromMacro , & & deriveVel_FromState , & & deriveVel_FromPreColState , & & deriveEq_FromState , & & deriveAux_fromState , & & deriveEquil_fromAux , & & derive_absorbLayer , & & derive_force_MRT , & & derive_force1stOrd , & & derive_HRRCorrection_d2q9 , & & derive_HRRCorrection_d3q19 , & & derive_HRRCorrection_d3q27 , & & applySrc_absorbLayer , & & applySrc_absorbLayer_MRT , & & applySrc_absorbLayerDyn , & & applySrc_absorbLayerDyn_MRT , & & applySrc_force , & & applySrc_force_MRT , & & applySrc_force_MRT_d2q9 , & & applySrc_force_MRT_d3q19 , & & applySrc_force_MRT_d3q27 , & & applySrc_turbChanForce , & & applySrc_turbChanForce_MRT , & & applySrc_turbChanForce_MRT_d2q9 , & & applySrc_turbChanForce_MRT_d3q19 , & & applySrc_turbChanForce_MRT_d3q27 , & & applySrc_force1stOrd use mus_derQuanIncomp_module , only : mus_append_derVar_fluidIncomp , & & derive_absorbLayerIncomp , & & applySrc_absorbLayerIncomp use mus_derQuanPS_module , only : mus_append_derVar_lbmPS , & & deriveEquilPS_FromMacro , & & deriveEquilPS2ndOrder_FromMacro , & & derive_equalInjectionPS , & & deriveAuxPS_fromState , & & deriveEquilPS_fromAux , & & derive_injectionPS , & & applySrc_injectionPS , & & applySrc_equalInjectionPS use mus_derQuanMSGas_module , only : mus_append_derVar_MSGas , & & deriveAuxMSGas_fromState , & & deriveEquilMSGas_fromAux , & & deriveEquilMSGas_FromMacro , & & deriveVelMSGas_FromState , & & deriveMomMSGas_FromState , & & deriveVelocitiesMSGas_FromState , & & deriveMomentaMSGas_FromState , & & deriveEqMSGas_FromState use mus_derQuanMSLiquid_module , only : mus_append_derVar_MSLiquid , & & mus_append_derMixVar_MS , & & deriveEquilMSLiquid_FromMacro , & & deriveVelMSLiquid_FromState , & & deriveMomMSLiquid_FromState , & & deriveVelocitiesMSLiquid_FromState , & & deriveMomentaMSLiquid_FromState , & & deriveEqMSLiquid_FromState , & & deriveAuxMSLiquid_fromState , & & deriveAuxMSLiquid_fromState_WTDF , & & deriveEquilMSLiquid_fromAux , & & applySrc_electricMSLiquid_1stOrd , & & applySrc_forceMSLiquid_1stOrd , & & applySrc_electricMSLiquid_1stOrd_WTDF , & & applySrc_forceMSLiquid_1stOrd_WTDF , & & applySrc_electricMSLiquid_2ndOrd , & & applySrc_forceMSLiquid_2ndOrd , & & applySrc_electricMSLiquid_2ndOrd_WTDF , & & applySrc_forceMSLiquid_2ndOrd_WTDF use mus_derQuanPoisson_module , only : mus_append_derVar_poisson , & & applySrc_chargeDensity_2ndOrd , & & applySrc_chargeDensity_1stOrd , & & deriveSrc_chargeDensity , & & deriveAuxPoisson_fromState , & & deriveEquilPoisson_fromAux use mus_derQuanNernstPlanck_module , only : applySrc_electricFieldNP , & & deriveAuxNP_fromState , & & deriveEquilNP_fromAux use mus_derQuanPhysics_module , only : mus_append_derVar_physics use mus_derQuanIsothermAcEq_module , only : & & mus_append_derVar_isotherm_acEq , & & deriveEquil_FromMacro_IsothermAcEq , & & deriveEq_FromState_IsothermAcEq , & & deriveEquilIsoThermAcEq_fromAux , & & deriveVelocity_FromState_IsothermAcEq use mus_operation_var_module , only : mus_opVar_setupIndices , & & mus_set_opVar_getElement use mus_auxFieldVar_module , only : mus_addForceToAuxField_fluid , & & mus_addForceToAuxField_fluidIncomp , & & mus_addForceToAuxField_MSL , & & mus_addForceToAuxField_MSL_WTDF , & & mus_addElectricToAuxField_MSL , & & mus_addElectricToAuxField_MSL_WTDF , & & mus_addSrcToAuxField_poisson , & & mus_addSponFldToAuxField_fluid , & & mus_addDynSponFldToAuxField_fluid , & & mus_access_auxFieldVar_forElement , & & mus_auxFieldVar_forPoint , & & mus_auxFieldVar_fromIndex , & & mus_addTurbChanForceToAuxField_fluid ,& & mus_addHRRCorrToAuxField_fluid_2D , & & mus_addHRRCorrToAuxField_fluid_3D use mus_turbulence_var_module , only : mus_append_turbVar use mus_material_var_module , only : mus_append_materialVar use mus_bc_var_module , only : mus_append_bcVar implicit none private public :: mus_build_varSys public :: mus_append_stateVar public :: mus_append_auxField public :: mus_store_derVarPos public :: mus_append_readVarAsStateVar contains ! **************************************************************************** ! !> Build global variable system for Musubi subroutine mus_build_varSys ( varSys , solverData , schemeHeader , stencil , & & nFields , derVarPos , luaVar , field , globSrc , & & poss_srcVar , st_funList ) ! --------------------------------------------------------------------------- !> global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> Compute stencil header type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> number of fields integer , intent ( in ) :: nFields !> store position of each variable for each field and mixture !! size: nFields+1 type ( mus_derVarPos_type ), allocatable , intent ( out ) :: derVarPos (:) !> additional variable defined in the lua file. !! Function pointer for this variables depends on its varType. type ( tem_variable_type ), allocatable , intent ( in ) :: luaVar (:) !> Field contains sources and boundary infos !KM: Passed complete field array as work around for GNU compiler !bug type ( mus_field_type ), intent ( inout ) :: field (:) !type(mus_source_type), intent(inout) :: fldSrc(:) !> global source type ( mus_source_type ), intent ( inout ) :: globSrc !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: poss_srcVar !> contains spacetime functions of all variables type ( tem_st_fun_linkedList_type ), intent ( out ) :: st_funList ! --------------------------------------------------------------------------- integer :: nVars , iField , iWave , iDerVP ! array of derive variable names depends on scheme kind type ( grw_labelarray_type ) :: derVarName type ( tem_varSys_solverData_evalElem_type ) :: solverData_evalElem ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Building variable system for scheme ' & & // 'kind: ' // trim ( schemeHeader % kind ) ! nFields > 1 only scheme kind multispecies if ( nFields > 1 ) then allocate ( derVarPos ( nFields + 1 )) else allocate ( derVarPos ( nFields )) end if ! initialize derVarname list call init ( me = derVarName , length = nFields ) ! assign default to dummy pointers do iDerVP = 1 , size ( derVarPos ) derVarPos ( iDerVP )% equilFromMacro => mus_derive_FromMacro_dummy derVarPos ( iDerVP )% velFromState => mus_derive_FromState_dummy derVarPos ( iDerVP )% velFromPreColState => mus_derive_FromPreColState_dummy derVarPos ( iDerVP )% momFromState => mus_derive_FromState_dummy derVarPos ( iDerVP )% equilFromState => mus_derive_FromState_dummy derVarPos ( iDerVP )% velocitiesFromState => mus_derive_FromState_dummy derVarPos ( iDerVP )% MomentaFromState => mus_derive_FromState_dummy end do ! append auxField variable depending on scheme kinds call mus_append_auxField ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & nFields = nFields , & & fldLabel = field (:)% label , & & derVarName = derVarName ) ! do append variables until all variables with dependent variable ! are added recursively. With this variables with dependent variable ! can be appended in arbitrary order nVars = 0 iWave = 0 do if ( nVars == varSys % varname % nVals ) EXIT iWave = iWave + 1 nVars = varSys % varname % nVals write ( logUnit ( 5 ), * ) 'Current append variable wave loop: ' , iWave write ( logUnit ( 5 ), * ) 'Append derive variables to varSys' ! append derive vars depends on scheme kind select case ( trim ( schemeHeader % kind ) ) case ( 'fluid' ) ! append derived variables call mus_append_derVar_fluid ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & stencil = stencil , & & fldLabel = field ( 1 )% label , & & derVarname = derVarname ) derVarPos ( 1 )% equilFromMacro => deriveEquil_FromMacro derVarPos ( 1 )% velFromState => deriveVel_fromState derVarPos ( 1 )% velFromPreColState => deriveVel_FromPreColState derVarPos ( 1 )% equilFromState => deriveEq_fromState derVarPos ( 1 )% equilFromAux => deriveEquil_fromAux derVarPos ( 1 )% auxFieldFromState => deriveAux_fromState ! append turbulence variable if turbulence is active if ( field ( 1 )% fieldProp % fluid % turbulence % active ) then call mus_append_turbVar ( & & varSys = varSys , & & solverData = solverData , & & derVarName = derVarName , & & turbConfig = field ( 1 )% fieldProp % fluid % turbulence % config ) end if case ( 'fluid_incompressible' ) ! append derived variables call mus_append_derVar_fluidIncomp ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & stencil = stencil , & & fldLabel = field ( 1 )% label , & & derVarname = derVarname ) derVarPos ( 1 )% equilFromState => deriveEq_FromState derVarPos ( 1 )% velFromPreColState => deriveVel_FromPreColState derVarPos ( 1 )% velFromState => deriveVel_fromState derVarPos ( 1 )% equilFromMacro => deriveEquil_FromMacro derVarPos ( 1 )% auxFieldFromState => deriveAux_fromState derVarPos ( 1 )% equilFromAux => deriveEquil_fromAux ! append turbulence variable if turbulence is active if ( field ( 1 )% fieldProp % fluid % turbulence % active ) then call mus_append_turbVar ( & & varSys = varSys , & & solverData = solverData , & & derVarName = derVarName , & & turbConfig = field ( 1 )% fieldProp % fluid % turbulence % config ) end if case ( 'passive_scalar' ) call mus_append_derVar_lbmPS ( varSys = varSys , & & solverData = solverData , & & fldLabel = field ( 1 )% label , & & derVarname = derVarname ) select case ( trim ( schemeHeader % relaxHeader % variant )) case ( 'first' ) derVarPos ( 1 )% equilFromMacro => deriveEquilPS_FromMacro case ( 'second' ) derVarPos ( 1 )% equilFromMacro => deriveEquilPS2ndOrder_FromMacro case default derVarPos ( 1 )% equilFromMacro => deriveEquilPS2ndOrder_FromMacro end select derVarPos ( 1 )% auxFieldFromState => deriveAuxPS_fromState derVarPos ( 1 )% equilFromAux => deriveEquilPS_fromAux case ( 'poisson' , 'poisson_boltzmann_linear' , & & 'poisson_boltzmann_nonlinear' ) call mus_append_derVar_poisson ( varSys = varSys , & & solverData = solverData , & & fldLabel = field ( 1 )% label , & & stencil = stencil , & & derVarname = derVarname , & & schemeKind = schemeHeader % kind ) derVarPos ( 1 )% auxFieldFromState => deriveAuxPoisson_fromState derVarPos ( 1 )% equilFromAux => deriveEquilPoisson_fromAux case ( 'nernst_planck' ) ! Nernst_planck model has only mole_density as derived variable ! and this variable is append to varSys as auxField derVarPos ( 1 )% auxFieldFromState => deriveAuxNP_fromState derVarPos ( 1 )% equilFromAux => deriveEquilNP_fromAux case ( 'multispecies_gas' ) call mus_append_derVar_MSGas ( varSys = varSys , & & solverData = solverData , & & stencil = stencil , & & nFields = nFields , & & fldLabel = field (:)% label , & & derVarname = derVarname ) do iField = 1 , nFields derVarPos ( iField )% equilFromMacro => deriveEquilMSGas_FromMacro derVarPos ( iField )% velFromState => deriveVelMSGas_fromState derVarPos ( iField )% momFromState => deriveMomMSGas_fromState derVarPos ( iField )% equilFromState => deriveEqMSGas_fromState derVarPos ( iField )% momentaFromState => deriveMomentaMSGas_fromState derVarPos ( iField )% velocitiesFromState & & => deriveVelocitiesMSGas_fromState derVarPos ( iField )% auxFieldFromState => deriveAuxMSGas_fromState derVarPos ( iField )% equilFromAux => deriveEquilMSGas_fromAux end do case ( 'multispecies_liquid' ) call mus_append_derVar_MSLiquid ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & stencil = stencil , & & nFields = nFields , & & fldLabel = field (:)% label , & & derVarname = derVarname ) do iField = 1 , nFields derVarPos ( iField )% equilFromMacro => deriveEquilMSLiquid_FromMacro derVarPos ( iField )% velFromState => deriveVelMSLiquid_fromState derVarPos ( iField )% momFromState => deriveMomMSLiquid_fromState derVarPos ( iField )% momentaFromState => deriveMomentaMSLiquid_fromState derVarPos ( iField )% velocitiesFromState & & => deriveVelocitiesMSLiquid_fromState derVarPos ( iField )% equilFromState => deriveEqMSLiquid_fromState derVarPos ( iField )% equilFromAux => deriveEquilMSLiquid_fromAux select case ( trim ( schemeHeader % relaxation )) case ( 'bgk_withthermodynfac' , 'mrt_withthermodynfac' ) derVarPos ( iField )% auxFieldFromState => deriveAuxMSLiquid_fromState_WTDF case default derVarPos ( iField )% auxFieldFromState => deriveAuxMSLiquid_fromState end select end do case ( 'isotherm_acEq' ) call mus_append_derVar_isotherm_acEq ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & stencil = stencil , & & fldLabel = field ( 1 )% label , & & derVarname = derVarname ) derVarPos ( 1 )% equilFromMacro => deriveEquil_FromMacro_IsothermAcEq derVarPos ( 1 )% velFromState => deriveVelocity_FromState_IsothermAcEq derVarPos ( 1 )% equilFromState => deriveEq_FromState_IsothermAcEq derVarPos ( 1 )% auxFieldFromState => deriveAux_fromState derVarPos ( 1 )% equilFromAux => deriveEquilIsoThermAcEq_fromAux case default write ( logUnit ( 1 ), * ) ' The selecited scheme kind is unknown ' // & & trim ( schemeHeader % kind ) call tem_abort () end select ! append boundary variables call mus_append_bcVar ( varSys = varSys , & & solverData = solverData , & & derVarName = derVarName , & & nFields = nFields , & & field = field , & & stencil = stencil ) ! append material variable call mus_append_materialVar ( varSys = varSys , & & solverData = solverData , & & schemeHeader = schemeHeader , & & derVarName = derVarName ) ! append physical variable ! get the list of physical variable labels from scheme specific ! mus_append_derVar_<schemeKind> routine call mus_append_dervar_physics ( derVarname = derVarname , & & varSys = varSys , & & solverData = solverData , & & nFields = nFields , & & fldLabel = field (:)% label ) ! append extra variables defined in lua file solverData_evalElem % solver_bundle = c_loc ( solverData ) solverData_evalElem % stFun_setter => mus_set_stfun_getElement solverData_evalElem % opVar_setter => mus_set_opVar_getElement if ( allocated ( luaVar )) then call tem_varSys_append_luaVar ( & & luaVar = luaVar , & & varSys = varSys , & & st_funList = st_funList , & & solverData_evalElem = solverData_evalElem ) end if ! append mesh info variables call tem_varSys_append_meshInfoVar ( varSys = varSys ) ! append field source variable to varSys and store position in varSys in ! mus_source_op_type do iField = 1 , nFields write ( logUnit ( 10 ), * ) 'Append field source: iField ' , iField call mus_append_sourceVar ( me = field ( iField )% source , & & solverData = solverData , & & schemeHeader = schemeHeader , & & varSys = varSys , & & nFields = nFields , & & stencil = stencil , & & poss_srcVar = poss_srcVar , & & fldLabel = field ( iField )% label ) write ( logUnit ( 10 ), * ) 'Append internal field source: iField ' , iField call mus_append_sourceVar ( me = field ( iField )% internalSource , & & solverData = solverData , & & schemeHeader = schemeHeader , & & varSys = varSys , & & nFields = nFields , & & stencil = stencil , & & poss_srcVar = poss_srcVar , & & fldLabel = field ( iField )% label ) end do ! append global source variable to varSys and store position in varSys in ! mus_source_op_type write ( logUnit ( 10 ), * ) 'Append global source' call mus_append_sourceVar ( me = globSrc , & & solverData = solverData , & & schemeHeader = schemeHeader , & & varSys = varSys , & & nFields = nFields , & & stencil = stencil , & & poss_srcVar = poss_srcVar ) end do write ( logUnit ( 1 ), * ) 'Done appending variables to varSys' call tem_varSys_dump ( varSys , dbgUnit ( 10 ) ) ! store derVarPos call mus_store_derVarPos ( derVarPos = derVarPos , & & derVarname = derVarname , & & varSys = varSys , & & nFields = nFields , & & fldLabel = field (:)% label ) ! Store boundary variable position call mus_store_bcVarPos ( field = field , & & nFields = nFields , & & varSys = varSys ) end subroutine mus_build_varSys ! **************************************************************************** ! ! **************************************************************************** ! !> Append variable read from restart file as state variables subroutine mus_append_readVarAsStateVar ( varSys , readVarIsPdf , read_varSys , & & stateVarMap , solverData , nFields , & & fldLabel ) ! --------------------------------------------------------------------------- !> global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Is true if read_varSys has pdf variable logical , intent ( out ) :: readVarIsPdf !> Variable system loaded from restart header file type ( tem_varSys_type ), intent ( in ) :: read_varSys !> Store position of state variable in global varSys type ( tem_varMap_type ), intent ( out ) :: stateVarMap !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> number of fields integer , intent ( in ) :: nFields !> array of field label prefix. Size=nFields character ( len =* ), intent ( in ) :: fldLabel (:) ! --------------------------------------------------------------------------- character ( len = labelLen ) :: varname integer :: nComponents integer :: iVar , addedPos logical :: wasAdded procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_setParams ), pointer :: set_params => null () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => null () procedure ( tem_varSys_proc_setupIndices ), pointer :: & & setup_indices => null () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: & & get_valOfIndex => null () ! --------------------------------------------------------------------------- nullify ( get_point , get_element , set_params , get_params , setup_indices , & & get_valOfIndex ) write ( logUnit ( 1 ), * ) 'Appending state variables read from restart file' ! Determine variables read from restart file are pdf variable ! or derived variable. ! Derived variable requires different treatment in mus_construction ! to create communication buffer and interpolation routines. ! ! Input to mus_harvesting can have either only pdf or derived variable ! not combination of both call check_varSys_forPdfVar ( readVarIsPdf = readVarIsPdf , & & varSys = read_varSys , & & nFields = nFields , & & fldLabel = fldLabel ) ! get all state variable using access_state get_element => mus_access_state_ForElement get_point => mus_stateVar_forPoint setup_indices => mus_accessVar_setupIndices get_valOfIndex => mus_stateVar_fromIndex ! initialize state varMap call init ( stateVarMap % varName ) call init ( stateVarMap % varPos ) do iVar = 1 , read_varSys % varname % nVals varname = trim ( read_varSys % varname % val ( iVar )) nComponents = read_varSys % method % val ( iVar )% nComponents call tem_varSys_append_stateVar ( & & me = varSys , & & varName = varname , & & nComponents = nComponents , & & method_data = mus_get_new_solver_ptr ( solverData ), & & get_point = get_point , & & get_element = get_element , & & set_params = set_params , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valOfIndex = get_valOfIndex , & & pos = addedPos , & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logUnit ( 10 ), * ) 'Appended state variable: ' // trim ( varname ) call append ( me = stateVarMap % varPos , val = addedPos ) call append ( me = stateVarMap % varname , val = varname ) else write ( logUnit ( 1 ), * ) 'Error: State variable ' // trim ( varname ) // & & ' is not added to variable system' call tem_abort () end if end do stateVarMap % nScalars = varSys % nScalars call truncate ( me = stateVarMap % varPos ) call truncate ( me = stateVarMap % varname ) ! debug output write ( logUnit ( 10 ), * ) '  nStateVars in varSys: ' , varSys % nStateVars write ( logUnit ( 10 ), * ) '  nScalars in varSys: ' , varSys % nScalars end subroutine mus_append_readVarAsStateVar ! **************************************************************************** ! ! **************************************************************************** ! !> Append state variable depends on the scheme kind !! !! allocate function pointers, and append pdf to scheme%varSys subroutine mus_append_stateVar ( varSys , stateVarMap , solverData , & & schemeHeader , stencil , nFields , fldLabel ) ! --------------------------------------------------------------------------- !> global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Store position of state variable in global varSys type ( tem_varMap_type ), intent ( out ) :: stateVarMap !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> compute stencil defintion type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> number of fields integer , intent ( in ) :: nFields !> array of field label prefix. Size=nFields character ( len =* ), intent ( in ) :: fldLabel (:) ! --------------------------------------------------------------------------- integer :: iField , addedPos logical :: wasAdded procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_setParams ), pointer :: set_params => null () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => null () procedure ( tem_varSys_proc_setupIndices ), pointer :: & & setup_indices => null () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: & & get_valOfIndex => null () character ( len = labelLen ) :: varname ! --------------------------------------------------------------------------- nullify ( get_point , get_element , set_params , get_params , setup_indices , & & get_valOfIndex ) write ( logUnit ( 1 ), * ) 'Appending state variables ' ! check there no variables added to varSys before state variable if ( varSys % varName % nVals /= 0 ) then write ( logUnit ( 1 ), * ) 'Error: Found variables before state variables' call tem_abort () end if ! get all state variable using access_state get_element => mus_access_state_ForElement get_point => mus_stateVar_forPoint setup_indices => mus_accessVar_setupIndices get_valOfIndex => mus_stateVar_fromIndex ! initialize state varMap call init ( stateVarMap % varName ) call init ( stateVarMap % varPos ) ! append pdf for each field do iField = 1 , nFields write ( varname , '(a)' ) trim ( fldLabel ( iField ) ) // 'pdf' call tem_varSys_append_stateVar ( & & me = varSys , & & varName = varname , & & nComponents = stencil % QQ , & & method_data = mus_get_new_solver_ptr ( solverData ), & & get_point = get_point , & & get_element = get_element , & & set_params = set_params , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valOfIndex = get_valOfIndex , & & pos = addedPos , & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logUnit ( 10 ), * ) 'Appended state variable: ' // trim ( varname ) call append ( me = stateVarMap % varPos , val = addedPos ) call append ( me = stateVarMap % varname , val = varname ) else write ( logUnit ( 1 ), * ) 'Error: State variable ' // trim ( varname ) // & & ' is not added to variable system' call tem_abort () end if end do stateVarMap % nScalars = varSys % nScalars call truncate ( me = stateVarMap % varPos ) call truncate ( me = stateVarMap % varname ) ! debug output write ( logUnit ( 10 ), \"(A,I0)\" ) '  nStateVars in varSys: ' , varSys % nStateVars write ( logUnit ( 10 ), \"(A,I0)\" ) '  nScalars   in varSys: ' , varSys % nScalars end subroutine mus_append_stateVar ! **************************************************************************** ! ! *************************************************************************** ! !> Append auxiliary variables which are computed from state and stored !! in auxField array using calcAuxField function subroutine mus_append_auxField ( varSys , solverData , schemeHeader , nFields , & & fldLabel , derVarname ) ! --------------------------------------------------------------------------- !> global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> number of fields integer , intent ( in ) :: nFields !> array of field label prefix. Size=nFields character ( len =* ), intent ( in ) :: fldLabel (:) !> array of derive physical variables type ( grw_labelarray_type ), intent ( inout ) :: derVarName ! --------------------------------------------------------------------------- integer :: iVar , iField , addedPos , nComponents , nDerVars logical :: wasAdded procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_setParams ), pointer :: set_params => null () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => null () procedure ( tem_varSys_proc_setupIndices ), pointer :: & & setup_indices => null () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: & & get_valOfIndex => null () character ( len = labelLen ) :: varname character ( len = labelLen ), allocatable :: derVarName_loc (:) ! --------------------------------------------------------------------------- ! Initialize variables nDerVars = 0 write ( logUnit ( 1 ), * ) 'Appending auxiliary variables ' select case ( trim ( schemeHeader % kind )) case ( 'fluid' , 'fluid_incompressible' ) ! auxiliary variable for incompressible is same as compressible model ! append density and velocity as auxField variables nDerVars = 2 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'density ' , 'velocity' ] case ( 'passive_scalar' ) ! append density as auxField variable nDerVars = 1 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'density' ] case ( 'poisson' , 'poisson_boltzmann_linear' , & & 'poisson_boltzmann_nonlinear' ) ! append potential as auxField variable nDerVars = 1 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'potential' ] case ( 'nernst_planck' ) ! append mole density as auxField variable nDerVars = 1 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'mole_density' ] case ( 'multispecies_gas' , 'multispecies_liquid' ) ! append density and velocity of species as auxField variable ! mixture density and velocity are appended later are derive variable nDerVars = 2 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'density ' , 'momentum' ] case ( 'isotherm_acEq' ) ! auxiliary variable for isotherm_acEq is same as incompressible model ! append density and velocity as auxField variables nDerVars = 2 allocate ( derVarName_loc ( nDerVars )) derVarName_loc = [ 'density ' , 'velocity' ] case default write ( logUnit ( 1 ), * ) ' The selected scheme kind is unknown ' // & & trim ( schemeHeader % kind ) call tem_abort () end select ! get all auxField variable uses same access routines. auxField_varPos ! is used to access exact variable get_element => mus_access_auxFieldVar_forElement get_point => mus_auxFieldVar_forPoint setup_indices => mus_accessVar_setupIndices get_valOfIndex => mus_auxFieldVar_fromIndex set_params => tem_varSys_setParams_dummy get_params => tem_varSys_getParams_dummy ! append dervarnames to growing array to create physics variable do iVar = 1 , nDerVars call append ( derVarName , derVarName_loc ( iVar )) end do do iField = 1 , nFields do iVar = 1 , nDerVars select case ( trim ( adjustl ( derVarName_loc ( iVar )))) case ( 'density' , 'mole_density' , 'potential' ) nComponents = 1 case ( 'velocity' , 'momentum' ) nComponents = 3 !case ('grad_velocity') !  nComponents = 9 case default write ( logUnit ( 1 ), * ) 'WARNING: Unknown variable: ' // & & trim ( derVarName_loc ( iVar )) cycle !go to next variable end select write ( varname , '(a)' ) trim ( fldLabel ( iField )) & & // trim ( adjustl ( derVarName_loc ( ivar ))) call tem_varSys_append_auxFieldVar ( & & me = varSys , & & varName = varname , & & nComponents = nComponents , & & method_data = mus_get_new_solver_ptr ( solverData ), & & get_point = get_point , & & get_element = get_element , & & set_params = set_params , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valOfIndex = get_valOfIndex , & & pos = addedPos , & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logUnit ( 10 ), * ) 'Appended auxField variable: ' // trim ( varname ) else if ( addedPos < 1 ) then write ( logUnit ( 1 ), * ) 'Error: AuxField variable ' // trim ( varname ) // & & ' is not added to variable system' call tem_abort () end if end do !iVar end do !iField ! debug output write ( logUnit ( 10 ), \"(A,I0)\" ) '  nAuxVars in varSys: ' , varSys % nAuxVars write ( logUnit ( 10 ), \"(A,I0)\" ) '  nAuxScalars in varSys: ' , varSys % nAuxScalars end subroutine mus_append_auxField ! *************************************************************************** ! ! *************************************************************************** ! !> Build a variable system of all possible source terms for the given !! schemeKind subroutine mus_append_sourceVar ( me , solverData , schemeHeader , varSys , & & nFields , stencil , poss_srcVar , fldLabel ) ! -------------------------------------------------------------------------- !> Contains source function pointer, !! source variable definition from lua and !! mapping of source variable in global varSys type ( mus_source_type ), intent ( inout ) :: me !> Contains pointer to solver data types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData !> Identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> Global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> number of fields integer , intent ( in ) :: nFields !> compute stencil defintion type ( tem_stencilHeader_type ), intent ( in ) :: stencil !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: poss_srcVar !> array of field label prefix required only for field source. !! If not present, it is assumed as global source character ( len =* ), optional , intent ( in ) :: fldLabel ! -------------------------------------------------------------------------- logical :: wasAdded character ( len = labelLen ), allocatable :: input_varname (:) character ( len = labelLen ) :: varName , fldLabel_loc procedure ( tem_varSys_proc_point ), pointer :: get_point => NULL () procedure ( tem_varSys_proc_element ), pointer :: get_element => NULL () procedure ( tem_varSys_proc_setParams ), pointer :: set_params => null () procedure ( tem_varSys_proc_getParams ), pointer :: get_params => null () procedure ( tem_varSys_proc_setupIndices ), pointer :: & & setup_indices => null () procedure ( tem_varSys_proc_getValOfIndex ), pointer :: & & get_valOfIndex => null () integer :: iSrc , dataVar_InInVar , nSrcVars , nComponents integer :: addedPos , iField integer :: nComp_defined , nComp_expected , data_varPos , possSrc_varPos ! -------------------------------------------------------------------------- nullify ( get_point , get_element , set_params , get_params , setup_indices , & & get_valOfIndex ) get_element => tem_varSys_getElement_dummy get_point => mus_deriveVar_ForPoint setup_indices => mus_opVar_setupIndices get_valOfIndex => tem_varSys_getValOfIndex_dummy nSrcVars = me % varDict % nVals ! do nothing if there no source variable defined in lua file if ( nSrcVars == 0 ) return ! if present then it is field source else global source. ! If field source then inputs for source variable are ! field pdf and source spacetime function. ! Else global source then inputs for source variable are ! all fields pdf and source spacetime function. if ( present ( fldLabel )) then fldLabel_loc = trim ( fldLabel ) allocate ( input_varname ( 2 )) input_varname ( 1 ) = trim ( fldLabel ) // 'pdf' dataVar_InInVar = 2 ! use stencil%QQ since source variable return value which is ! added to state as source term so both state and source should ! have same nComponents nComponents = stencil % QQ else fldLabel_loc = '' allocate ( input_varname ( nFields + 1 )) do iField = 1 , nFields input_varname ( iField ) = trim ( varSys % varname % val ( iField )) end do dataVar_InInVar = nFields + 1 ! mixture source: return source value for all species nComponents = stencil % QQ * nFields end if srcLoop : do iSrc = 1 , nSrcVars input_varname ( dataVar_InInVar ) = trim ( me % varDict % val ( iSrc )% value ) ! get actual source variable name from temSource varname ! which stores the name as defined in possible sources varname = trim ( me % varDict % val ( iSrc )% key ) me % method ( iSrc )% varname = trim ( varname ) ! Check number of components expected by possible variable is ! same as number of components defined by space time function variable data_varPos = PositionOfVal ( me = varSys % varname , & & val = trim ( input_varname ( dataVar_InInVar )) ) if ( data_varPos > 0 ) then ! position of variable name in possible variable list possSrc_varPos = PositionOfVal ( me = poss_srcVar % varname , & & val = trim ( varname ) ) nComp_defined = varSys % method % val ( data_varPos )% nComponents nComp_expected = poss_srcVar % nComponents % val ( possSrc_varPos ) if ( nComp_defined /= nComp_expected ) then write ( logUnit ( 1 ), '(a)' ) 'Error: Appending source variable' write ( logUnit ( 1 ), '(a,i0)' ) 'nComponent of defined variable: \"' // & & trim ( input_varname ( dataVar_InInVar )) // '\"= ' , nComp_defined write ( logUnit ( 1 ), '(a,i0)' ) '/= nComponent of expected variable: \"' // & & trim ( varname ) // '\"= ' , nComp_expected call tem_abort () end if else ! user st_fun variable is not found in varSys write ( logUnit ( 1 ), * ) 'Error: User defined space-time function variable' write ( logUnit ( 1 ), * ) '\"' // trim ( input_varName ( dataVar_InInVar )) // & & '\" not found in varSys' call tem_abort () end if ! set to default to dummy routine which does noting to auxField me % method ( iSrc )% applySrc => mus_applySrc_dummy me % method ( iSrc )% addSrcToAuxField => mus_addSrcToAuxField_dummy me % method ( iSrc )% updateSourceVar => mus_updateSrcVar_dummy ! choose appropriate function pointer ! select get_element, applySrc and addSrcToAuxField according to scheme ! kind select case ( trim ( schemeHeader % kind )) case ( 'fluid' , 'fluid_incompressible' ) select case ( trim ( varname )) case ( 'force' ) ! select pointer according to order if ( me % method ( iSrc )% order == 2 ) then select case ( trim ( schemeHeader % relaxation )) case ( 'mrt' ) ! get_element and applySrc are same of fluid and ! fluid_incompressible get_element => derive_force_MRT select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) me % method ( iSrc )% applySrc => applySrc_force_MRT_d2q9 case ( 'd3q19' ) me % method ( iSrc )% applySrc => applySrc_force_MRT_d3q19 case ( 'd3q27' ) me % method ( iSrc )% applySrc => applySrc_force_MRT_d3q27 case default me % method ( iSrc )% applySrc => applySrc_force_MRT end select case default me % method ( iSrc )% applySrc => applySrc_force end select ! select addSrcToAuxField according to scheme kind select case ( trim ( schemeHeader % kind )) case ( 'fluid' ) me % method ( iSrc )% addSrcToAuxField => mus_addForceToAuxField_fluid case ( 'fluid_incompressible' ) me % method ( iSrc )% addSrcToAuxField & & => mus_addForceToAuxField_fluidIncomp end select else ! 1st order ! addSrcToAuxField is not required for force1stOrd 1st order get_element => derive_force1stOrd me % method ( iSrc )% applySrc => applySrc_force1stOrd end if case ( 'turb_channel_force_accel' ) ! Select apply force according to scheme kind. select case ( trim ( schemeHeader % kind )) case ( 'fluid' ) select case ( trim ( schemeHeader % relaxation )) case ( 'mrt' ) select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) me % method ( iSrc )% applySrc => applySrc_turbChanForce_MRT_d2q9 case ( 'd3q19' ) me % method ( iSrc )% applySrc => applySrc_turbChanForce_MRT_d3q19 case ( 'd3q27' ) me % method ( iSrc )% applySrc => applySrc_turbChanForce_MRT_d3q27 case default me % method ( iSrc )% applySrc => applySrc_turbChanForce_MRT end select case default me % method ( iSrc )% applySrc => applySrc_turbChanForce end select case ( 'fluid_incompressible' ) call tem_abort ( 'TurbChannel only implemented for fluid scheme' ) end select ! Add force acceleration to velocity field. ! It is same for both fluid and fluid_incompressible. me % method ( iSrc )% addSrcToAuxField & & => mus_addTurbChanForceToAuxField_fluid me % method ( iSrc )% updateSourceVar => mus_updateSrcVar_turbChanForce case ( 'absorb_layer' , 'absorb_layer_inlet' , 'absorb_layer_outlet' ) ! Absorb layer is dependent of collision but independent on ! scheme kind. So implemented seperate routine for MRT. ! select addSrcToAuxField according to scheme relaxation. ! Use time average quantities if pressure or velocity is defined ! as dynamic. if ( me % method ( iSrc )% absLayer % config % isPressDyn & & . or . me % method ( iSrc )% absLayer % config % isVelDyn ) then ! \\todo KM: 20210301 Implement seperate routine for ! absorb_layer_inlet and absorb_layer_outlet when target_velocity ! and target_pressure respectively are defined as stFun. me % method ( iSrc )% addSrcToAuxField & & => mus_addDynSponFldToAuxField_fluid me % method ( iSrc )% updateSourceVar => mus_updateSrcVar_dynSponFld select case ( trim ( schemeHeader % relaxation )) case ( 'mrt' ) ! KM: \\todo 25012021 Implement optimized routine for d3q19 me % method ( iSrc )% applySrc => applySrc_absorbLayerDyn_MRT case default me % method ( iSrc )% applySrc => applySrc_absorbLayerDyn end select else me % method ( iSrc )% addSrcToAuxField => mus_addSponFldToAuxField_fluid select case ( trim ( schemeHeader % relaxation )) case ( 'mrt' ) ! KM: \\todo 25012021 Implement optimized routine for d3q19 me % method ( iSrc )% applySrc => applySrc_absorbLayer_MRT case default me % method ( iSrc )% applySrc => applySrc_absorbLayer end select end if case ( 'hrr_correction' ) if ( trim ( schemeHeader % kind ) == 'fluid' ) then ! get_element and applySrc are same of fluid and fluid_incompressible ! select pointer according to order select case ( trim ( schemeHeader % relaxation )) case ( 'hrr_bgk_corrected' , 'prr_bgk_corrected' , 'rr_bgk_corrected' ) me % method ( iSrc )% applySrc => mus_applySrc_dummy case default call tem_abort ( 'HRR Correction not supported for ' & & // trim ( schemeHeader % relaxation ) ) end select ! select addSrcToAuxField  and get_element according to scheme kind select case ( trim ( schemeHeader % layout )) case ( 'd2q9' ) me % method ( iSrc )% addSrcToAuxField => mus_addHRRCorrToAuxField_fluid_2D get_element => derive_HRRCorrection_d2q9 case ( 'd3q19' ) me % method ( iSrc )% addSrcToAuxField => mus_addHRRCorrToAuxField_fluid_3D get_element => derive_HRRCorrection_d3q19 case ( 'd3q27' ) me % method ( iSrc )% addSrcToAuxField => mus_addHRRCorrToAuxField_fluid_3D get_element => derive_HRRCorrection_d3q27 case default call tem_abort ( 'HRR Correction not supported for ' & & // trim ( schemeHeader % layout ) ) end select else call tem_abort ( 'HRR Correction not supported for ' & & // trim ( schemeHeader % kind ) ) end if case default call tem_abort ( 'Unknown source variable for ' & & // trim ( schemeHeader % kind ) ) end select case ( 'multispecies_liquid' ) select case ( trim ( varname )) case ( 'force' ) ! select pointer according to order if ( me % method ( iSrc )% order == 2 ) then select case ( trim ( schemeHeader % relaxation )) case ( 'bgk_withthermodynfac' , 'mrt_withthermodynfac' ) me % method ( iSrc )% addSrcToAuxField & & => mus_addForceToAuxField_MSL_WTDF me % method ( iSrc )% applySrc => applySrc_forceMSLiquid_2ndOrd_WTDF case default me % method ( iSrc )% addSrcToAuxField => mus_addForceToAuxField_MSL me % method ( iSrc )% applySrc => applySrc_forceMSLiquid_2ndOrd end select else ! 1st order select case ( trim ( schemeHeader % relaxation )) case ( 'bgk_withthermodynfac' , 'mrt_withthermodynfac' ) me % method ( iSrc )% applySrc => applySrc_forceMSLiquid_1stOrd_WTDF case default me % method ( iSrc )% applySrc => applySrc_forceMSLiquid_1stOrd end select end if case ( 'electric_field' ) ! select pointer according to order if ( me % method ( iSrc )% order == 2 ) then select case ( trim ( schemeHeader % relaxation )) case ( 'bgk_withthermodynfac' , 'mrt_withthermodynfac' ) me % method ( iSrc )% addSrcToAuxField & & => mus_addElectricToAuxField_MSL_WTDF me % method ( iSrc )% applySrc => applySrc_electricMSLiquid_2ndOrd_WTDF case default me % method ( iSrc )% addSrcToAuxField => mus_addElectricToAuxField_MSL me % method ( iSrc )% applySrc => applySrc_electricMSLiquid_2ndOrd end select else ! 1st order select case ( trim ( schemeHeader % relaxation )) case ( 'bgk_withthermodynfac' , 'mrt_withthermodynfac' ) me % method ( iSrc )% applySrc => applySrc_electricMSLiquid_1stOrd_WTDF case default me % method ( iSrc )% applySrc => applySrc_electricMSLiquid_1stOrd end select end if case default call tem_abort ( 'Unknown source variable for ' & & // trim ( schemeHeader % kind ) ) end select case ( 'nernst_planck' ) select case ( trim ( varname )) case ( 'electric_field' ) me % method ( iSrc )% applySrc => applySrc_electricFieldNP case default call tem_abort ( 'Unknown source variable for ' & & // trim ( schemeHeader % kind ) ) end select case ( 'passive_scalar' ) select case ( trim ( varname )) case ( 'injection' ) if ( solverData % scheme % transVar % varDict % nVals > 0 ) then if ( trim ( solverData % scheme % transVar % varDict % val ( 1 )% key ) & & /= 'transport_velocity' ) then write ( logUnit ( 1 ), * ) 'Error: transport_velocity variable required ' & & // 'for injection source is not defined' call tem_abort () end if else write ( logUnit ( 1 ), * ) 'Error: injection source requires ' & & // 'transport_velocity variable' call tem_abort () end if get_element => derive_injectionPS me % method ( iSrc )% applySrc => applySrc_injectionPS case ( 'equal_injection' ) get_element => derive_equalInjectionPS me % method ( iSrc )% applySrc => applySrc_equalInjectionPS case default call tem_abort ( 'Unknown source variable for ' & & // trim ( schemeHeader % kind ) ) end select case ( 'poisson' ) select case ( trim ( varname )) case ( 'charge_density' ) ! select pointer according to order if ( me % method ( iSrc )% order == 2 ) then me % method ( iSrc )% addSrcToAuxField => mus_addSrcToAuxField_poisson get_element => deriveSrc_chargeDensity me % method ( iSrc )% applySrc => applySrc_chargeDensity_2ndOrd else ! 1st order get_element => deriveSrc_chargeDensity me % method ( iSrc )% applySrc => applySrc_chargeDensity_1stOrd end if case default call tem_abort ( 'Unknown source variable for ' & & // trim ( schemeHeader % kind ) ) end select case default write ( logUnit ( 1 ), * ) 'ERROR: Scheme kind: ' // trim ( schemeHeader % kind ) & & // 'does not support source variable: ' & & // trim ( varname ) call tem_abort () end select varname = trim ( fldLabel ) // 'src_' // trim ( varname ) ! append variable to varSys call tem_varSys_append_derVar ( & & me = varSys , & & varName = trim ( varname ), & & nComponents = nComponents , & & input_varname = input_varname , & & method_data = mus_get_new_solver_ptr ( solverData ), & & get_point = get_point , & & get_element = get_element , & & set_params = set_params , & & get_params = get_params , & & setup_indices = setup_indices , & & get_valOfIndex = get_valOfIndex , & & pos = addedPos , & & wasAdded = wasAdded ) if ( wasAdded ) then write ( logUnit ( 10 ), * ) ' Appended variable:' // trim ( varname ) me % method ( iSrc )% srcTerm_varPos = addedPos me % method ( iSrc )% data_varPos = varSys % method % val ( addedPos ) & & % input_varPos ( dataVar_InInVar ) else if ( addedpos < 1 ) then write ( logUnit ( 1 ), * ) 'Error: variable ' // trim ( varname ) // & & ' is not added to variable system' call tem_abort () end if end do srcLoop ! debug output call tem_varSys_dump ( varSys , dbgUnit ( 10 ), me % method (:)% srcTerm_varPos ) end subroutine mus_append_sourceVar ! *************************************************************************** ! ! *************************************************************************** ! !> Store the position of each variable in the global system in the derVarPos !! This function is also called in Harvester. subroutine mus_store_derVarPos ( derVarPos , derVarname , varSys , nFields , & & fldLabel ) ! --------------------------------------------------------------------------- !> Position of derived variables type ( mus_derVarPos_type ), intent ( inout ) :: derVarPos (:) !> array of derive physical variables type ( grw_labelarray_type ), intent ( in ) :: derVarName !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> number of fields integer , intent ( in ) :: nFields !> array of field label prefix. Size=nFields character ( len =* ), intent ( in ) :: fldLabel (:) ! ------------------------------------------------------------------------ integer :: iField , iVar , nFields_loc , varPos , nDerVars character ( len = labelLen ) :: varName ! ------------------------------------------------------------------------ nDerVars = derVarname % nVals if ( nFields > 1 ) then nFields_loc = nFields + 1 ! nSpecies + 1 mixture else nFields_loc = 1 end if write ( logUnit ( 1 ), * ) 'Storing state variable position ' do iField = 1 , nFields ! store pdf pos varname = trim ( fldLabel ( iField )) // 'pdf' varPos = PositionOfVal ( me = varSys % varname , val = trim ( varname ) ) derVarPos ( iField )% pdf = varPos ! store omega pos varname = trim ( fldLabel ( iField )) // 'omega' varPos = PositionOfVal ( me = varSys % varname , val = trim ( varname ) ) derVarPos ( iField )% omega = varPos end do write ( logUnit ( 1 ), * ) 'Storing derive variable position ' do iField = 1 , nFields_loc do iVar = 1 , nDerVars if ( iField > nFields ) then ! mixture varname = trim ( adjustl ( derVarName % val ( iVar ))) else varname = trim ( fldLabel ( iField )) // trim ( adjustl ( derVarName % val ( iVar ))) end if varPos = PositionOfVal ( me = varSys % varname , val = trim ( varname ) ) select case ( trim ( adjustl ( derVarName % val ( iVar )))) case ( 'pdf' ) derVarPos ( iField )% pdf = varPos case ( 'fetch_pdf' ) derVarPos ( iField )% fetch_pdf = varPos case ( 'density' ) derVarPos ( iField )% density = varPos case ( 'mole_density' ) derVarPos ( iField )% moleDensity = varPos case ( 'pressure' ) derVarPos ( iField )% pressure = varPos case ( 'kinematic_pressure' ) derVarPos ( iField )% kinePress = varPos case ( 'velocity' ) derVarPos ( iField )% velocity = varPos !case ('grad_velocity') !  derVarPos(iField)%grad_velocity = varPos case ( 'vel_mag' ) derVarPos ( iField )% velMag = varPos case ( 'momentum' ) derVarPos ( iField )% momentum = varPos case ( 'shear_stress' ) derVarPos ( iField )% shearStress = varPos case ( 'wss' ) derVarPos ( iField )% wss = varPos case ( 'shear_mag' ) derVarPos ( iField )% shearMag = varPos case ( 'strain_rate' ) derVarPos ( iField )% strainRate = varPos case ( 'shear_rate' ) derVarPos ( iField )% shearRate = varPos case ( 'kinetic_energy' ) derVarPos ( iField )% kineticEnergy = varPos case ( 'temperature' ) derVarPos ( iField )% temperature = varPos case ( 'mole_fraction' ) derVarPos ( iField )% moleFrac = varPos case ( 'mass_fraction' ) derVarPos ( iField )% massFrac = varPos case ( 'mole_flux' ) derVarPos ( iField )% moleFlux = varPos case ( 'equilibrium' ) derVarPos ( iField )% equilibrium = varPos case ( 'non_equilibrium' ) derVarPos ( iField )% nonEquilibrium = varPos case ( 'equilibrium_vel' ) derVarPos ( iField )% equilibriumVel = varPos case ( 'potential' ) derVarPos ( iField )% potential = varPos case default write ( logUnit ( 10 ), * ) 'WARNING: Unknown variable: ' // trim ( varname ) !write(*,*) 'derVarName ', derVarName%val(iVar) cycle !go to next variable end select enddo end do end subroutine mus_store_derVarPos ! ****************************************************************************** ! ! *************************************************************************** ! !> Store the position of each boundary variable in the global varSys !! in the field%bc%varPos%<variable>. !! This routine also checks if boundary variable defined in config file !! has same number of components as expected. subroutine mus_store_bcVarPos ( field , nFields , varSys ) ! --------------------------------------------------------------------------- !> Field containing boundary infos type ( mus_field_type ), intent ( inout ) :: field (:) !> number of fields integer , intent ( in ) :: nFields !> global variable system type ( tem_varSys_type ), intent ( in ) :: varSys ! ------------------------------------------------------------------------ integer :: iField , iBC , iVar , defVar_pos character ( len = labelLen ) :: def_varName , bc_varName integer :: nComp_defined , nComp_expected ! ------------------------------------------------------------------------ write ( logUnit ( 10 ), * ) 'Storing boundary variable position in varSys' do iField = 1 , nFields do iBC = 1 , size ( field ( iField )% bc ) do iVar = 1 , field ( iField )% bc ( iBC )% varDict % nVals ! Variable name loaded from boundary table def_varName = trim ( field ( iField )% bc ( iBC )% varDict % val ( iVar )% value ) ! position of boundary variable in varSys defVar_pos = PositionOfVal ( me = varSys % varName , & & val = trim ( def_varName ) ) ! continue only if this variable exist in varSys if ( defVar_pos > 0 ) then nComp_defined = varSys % method % val ( defVar_pos )% nComponents ! check number of components defined for the variable is ! same as expected, if so store the position if boundary type bc_varName = trim ( field ( iField )% bc ( iBC )% varDict % val ( iVar )% key ) select case ( trim ( bc_varName )) case ( 'velocity' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % velocity % nComponents field ( iField )% bc ( iBC )% bc_states % velocity % varPos = defVar_pos case ( 'pdf' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % pdf % nComponents field ( iField )% bc ( iBC )% bc_states % pdf % varPos = defVar_pos case ( 'pressure' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % pressure % nComponents field ( iField )% bc ( iBC )% bc_states % pressure % varPos = defVar_pos case ( 'mass_flowrate' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % massFlowRate % nComponents field ( iField )% bc ( iBC )% bc_states % massFlowRate % varPos = defVar_pos case ( 'mole_fraction' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % moleFrac % nComponents field ( iField )% bc ( iBC )% bc_states % moleFrac % varPos = defVar_pos case ( 'mole_density' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % moleDens % nComponents field ( iField )% bc ( iBC )% bc_states % moleDens % varPos = defVar_pos case ( 'mole_flux' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % moleFlux % nComponents field ( iField )% bc ( iBC )% bc_states % moleFlux % varPos = defVar_pos case ( 'mole_diff_flux' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % moleDiff_flux % nComponents field ( iField )% bc ( iBC )% bc_states % moleDiff_flux % varPos = defVar_pos case ( 'potential' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % potential % nComponents field ( iField )% bc ( iBC )% bc_states % potential % varPos = defVar_pos case ( 'surface_charge_density' ) nComp_expected = field ( iField )% bc ( iBC )% bc_states & & % surChargeDens % nComponents field ( iField )% bc ( iBC )% bc_states % surChargeDens % varPos = defVar_pos case default write ( logUnit ( 1 ), * ) 'Error: Unknown boundary variable: \"' // & & trim ( bc_varName ) // '\"' call tem_abort () end select if ( nComp_defined /= nComp_expected ) then write ( logUnit ( 1 ), * ) 'Error: Storing boundary variable position' write ( logUnit ( 1 ), '(a,i0)' ) 'nComponent of defined variable: \"' // & & trim ( def_varName ) // '\"= ' , nComp_defined write ( logUnit ( 1 ), '(a,i0)' ) '/= nComponent of expected ' // & & 'variable: \"' // trim ( bc_varName ) // '\"= ' , nComp_expected call tem_abort () end if else write ( logUnit ( 1 ), * ) 'Error: User defined space-time function ' write ( logUnit ( 1 ), * ) 'or reference to varName for boundary variable' write ( logUnit ( 1 ), * ) '\"' // trim ( def_varName ) // '\" not found in varSys' call tem_abort () end if !defVar_pos end do !iVar end do !iiBC end do !iField end subroutine mus_store_bcVarPos ! **************************************************************************** ! ! **************************************************************************** ! !> This function runs over all variable loaded from restart file check if !! variables loaded are pdf variable or derive variable !! !! Variable read from restart file can have variables other than pdf but pdf !! must be the 1st variable if not stateVarIsPdf will be false subroutine check_varSys_forPdfVar ( readVarIsPdf , varSys , nFields , fldLabel ) ! --------------------------------------------------------------------------- !> return true if variable read from restart file has pdf logical , intent ( out ) :: readVarIsPdf !> variable system loaded from restart file type ( tem_varSys_type ), intent ( in ) :: varSys !> number of fields integer , intent ( in ) :: nFields !> array of field label prefix. Size=nFields character ( len =* ), intent ( in ) :: fldLabel (:) ! --------------------------------------------------------------------------- integer :: iField character ( len = labelLen ) :: buffer ! --------------------------------------------------------------------------- readVarIsPdf = . true . do iField = 1 , nFields write ( buffer , '(a)' ) trim ( fldLabel ( iField ) ) // 'pdf' if ( trim ( buffer ) /= varSys % varName % val ( iField ) ) then readVarIsPdf = . false . write ( logUnit ( 1 ), * ) 'WARNING: Variable loaded from restart file does' write ( logUnit ( 1 ), * ) '         not have pdf as 1st variables.' write ( logUnit ( 1 ), * ) '         Following are deactivated:' write ( logUnit ( 1 ), * ) '           * Connectivity neigh array' write ( logUnit ( 1 ), * ) '           * Interpolation of pdf for multilevel' exit end if end do end subroutine check_varSys_forPdfVar ! ****************************************************************************** ! end module mus_variable_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_variable_module.f90.html"},{"title":"mus_param_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_param_module.f90~~EfferentGraph sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_param_module.f90~~AfferentGraph sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_param_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011, 2013, 2015, 2021 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011 Konstantin Kleinheinz <k.kleinheinz@grs-sim.de> ! Copyright (c) 2011-2016, 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012, 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012 Nikhil Anand <n.anand@grs-sim.de> ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module provides the definition and methods for !! boundarys. module mus_param_module ! include musubi modules use mus_physics_module , only : mus_physics_type , set_values_by_levels use mus_abortCriteria_module , only : mus_abortCriteria_type ! include treelm modules use env_module , only : labelLen , rk , globalMaxLevels use tem_logging_module , only : logUnit use tem_general_module , only : tem_general_type use tem_tools_module , only : tem_horizontalSpacer ! include aotus modules use aotus_module , only : flu_state , aot_get_val use aot_out_module , only : aot_out_type , aot_out_val implicit none private public :: mus_param_type public :: mus_load_param public :: mus_param_out public :: mus_init_latticeUnit public :: mus_latticeUnit_type integer , parameter :: block_size = 576 !> lattice dx and dt on each level type mus_latticeUnit_type !> dt in LB unit, dtLvl(minLevel) = 1.0 real ( kind = rk ), allocatable :: dtLvl (:) !> dx in LB unit, dxLvl(minLevel) = 1.0 real ( kind = rk ), allocatable :: dxLvl (:) end type mus_latticeUnit_type !> Global parameter type definition, filled with type mus_param_type !> Treelm param parameter type type ( tem_general_type ) :: general !> Musubi specific abort criteria type ( mus_abortCriteria_type ) :: mus_Aborts !> Lattice dx and dt on each level type ( mus_latticeUnit_type ) :: lattice !> contains basic SI units to convert from lattice to physical and !! vice versa type ( mus_physics_type ) :: physics !> type of the control routine character ( len = labelLen ) :: controlRoutine !> initialize all elements with valid entries? !! This should only be activated for debugging, !! as it needs to be ensured that all helper elements !! are filled by communication and interpolation instead !! of filling initial values (consider restart!) logical :: init_allElems = . false . !> type of the scaling: !! * acoustic !! * diffusive character ( len = labelLen ) :: scaling !> Temporal scaling factor for the scaling. Acoustic = 2, Diffusive = 4 integer :: scaleFactor !> Nesting: 2: acoustic, 4: diffusive !! To calculate turbulent viscosity, velocity on buffer ghost elements !! should be valid to nesting is set to same as scaling Factor integer :: nNesting = 2 !> Required interval, in which the update MUST occur. !! This is required for the musubi multilevel, where the time step should !! only be determined active, when the end of the largest cycle is reached. integer :: reqInterval logical :: comm_reduced = . true . !< Communicate all links? !> need to set solver version in  general%solver%version character ( len = labelLen ) :: version = 'v2.0' !> active when restart is triggered by restart timeControl !! dump restart when simulation reached end only when !! restart is not triggered by its timeControl before logical :: restart_triggered = . false . !> remove solid from BC list logical :: remove_solid = . true . !> Block size for compute kernel integer :: block = block_size !> Initial balance logical :: initial_balance = . false . !> scratch file unit contains solver specific info in dump in restart header !! This file should contain the information in form of a Lua script. !! KM: Not required anymore. Load config file name from restart header !! integer :: solSpec_unit = -1 !> Dump level timing logical :: dump_level_timing = . false . !> Dump linear partition logical :: dump_linear_partition = . false . !> Dump computation and bc timing information for all ranks logical :: dump_bc_timing = . false . end type mus_param_type contains ! **************************************************************************** ! !> load global parameter from conf subroutine mus_load_param ( params , conf ) ! -------------------------------------------------------------------------- !> global parameter info type ( mus_param_type ), intent ( inout ) :: params !> lua state type ( flu_state ) :: conf ! -------------------------------------------------------------------------- integer :: iError ! -------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Loading general solver params: ' ! Load the control routine call aot_get_val ( L = conf , & & key = 'control_routine' , & & val = params % controlRoutine , & & ErrCode = iError , & & default = 'standard' ) write ( logUnit ( 1 ), * ) 'Choosing Control Routine: ' , trim ( params % controlRoutine ) ! load scaling type ! KM: @todo move scaling inside physics table because for lbm ! default scaling is acoustic and for multispecies default is diffusive call aot_get_val ( L = conf , & & key = 'scaling' , & & val = params % scaling , & & ErrCode = iError , & & default = 'acoustic' ) write ( logUnit ( 1 ), * ) 'Setting SCALING to:' , trim ( params % scaling ) ! Set acoustic or diffusive scaling parameters !! KM: To calculate turbulent viscosity, velocity on buffer ghost elements !! should be valid to nesting is set to same as scaling Factor select case ( trim ( params % scaling )) case ( 'acoustic' ) params % nNesting = 2 params % scaleFactor = 2 case ( 'diffusive' ) params % nNesting = 4 params % scaleFactor = 4 end select ! Communicate reduced set of links only? call aot_get_val ( L = conf , & & key = 'comm_reduced' , & & val = params % comm_reduced , & & ErrCode = iError , & & default = . true .) ! initialize all elements? this includes not only fluid but also ghost and ! halo call aot_get_val ( L = conf , & & key = 'init_allElems' , & & val = params % init_allElems , & & ErrCode = iError , & & default = . false .) if ( params % init_allElems ) then write ( logUnit ( 1 ), * ) 'WARNING: Initializing all (including helper ' // & & 'elements) with valid data' end if call aot_get_val ( L = conf , & & key = 'remove_solid' , & & val = params % remove_solid , & & ErrCode = iError , & & default = . true .) if ( params % remove_solid ) then write ( logUnit ( 1 ), \"(A)\" ) 'Solid elements will be removed from BC list' end if call aot_get_val ( L = conf , & & key = 'initial_balance' , & & val = params % initial_balance , & & ErrCode = iError , & & default = . false .) call aot_get_val ( L = conf , & & key = 'dump_level_timing' , & & val = params % dump_level_timing , & & ErrCode = iError , & & default = . false . ) call aot_get_val ( L = conf , & & key = 'dump_bc_timing' , & & val = params % dump_bc_timing , & & ErrCode = iError , & & default = . false . ) call aot_get_val ( L = conf , & & key = 'dump_linear_partition' , & & val = params % dump_linear_partition , & & ErrCode = iError , & & default = . false . ) call aot_get_val ( L = conf , & & key = 'block' , & & val = params % block , & & ErrCode = iError , & & default = block_size ) write ( logUnit ( 1 ), \"(A,I0)\" ) 'Block size (elements): ' , params % block call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_param ! **************************************************************************** ! ! **************************************************************************** ! !> This routine writes global parameter into solver specific string in lua !! format subroutine mus_param_out ( me , conf ) ! -------------------------------------------------------------------------- type ( mus_param_type ), intent ( in ) :: me !< params type ( aot_out_type ) :: conf ! -------------------------------------------------------------------------- call aot_out_val ( put_conf = conf , vname = 'scaling' , & & val = trim ( me % scaling ) ) end subroutine mus_param_out ! **************************************************************************** ! ! **************************************************************************** ! !> This routine initialize lattice dx and dt subroutine mus_init_latticeUnit ( lattice , minLevel , maxLevel , scaleFactor ) ! ------------------------------------------------------------------------- !> Lattice unit type ( mus_latticeUnit_type ), intent ( out ) :: lattice !> minlevel and maxlevel integer , intent ( in ) :: minLevel , maxLevel !> scaleFactor depending on acoustic or diffusive scaling integer , intent ( in ) :: scaleFactor ! -------------------------------------------------------------------------- integer :: iLevel ! -------------------------------------------------------------------------- allocate ( lattice % dxLvl ( minLevel : maxLevel )) allocate ( lattice % dtLvl ( minLevel : maxLevel )) lattice % dxLvl ( minLevel : maxLevel ) = & & set_values_by_levels ( 1.0_rk , minLevel , maxLevel , 2 ) lattice % dtLvl ( minLevel : maxLevel ) = & & set_values_by_levels ( 1.0_rk , minLevel , maxLevel , scaleFactor ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), '(A)' ) 'Lattice dx and dt on each level' do iLevel = minLevel , maxLevel write ( logUnit ( 1 ), '(A,I0,A,F10.5,A,F10.5)' ) 'level=' , iLevel , & & ', dxL=' , lattice % dxLvl ( iLevel ), ', dtL=' , lattice % dtLvl ( iLevel ) end do call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_init_latticeUnit ! **************************************************************************** ! end module mus_param_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_param_module.f90.html"},{"title":"mus_scheme_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_scheme_module.f90~~EfferentGraph sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_directions_module.f90 mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_directions_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_mrtinit_module.f90 mus_mrtInit_module.f90 sourcefile~mus_moments_module.f90->sourcefile~mus_mrtinit_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_transport_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_turbchanforce_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_scheme_module.f90~~AfferentGraph sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012-2015 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012-2013, 2015 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2022-2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ******************************************************************************! !> author: Simon Zimny !! author: Kannan Masilamani !! Definition of the datatypes for the scheme implementation. !! !! For a detailed description see !! [Scheme Implementation](../page/features/scheme.html). !! module mus_scheme_module ! include treelm modules use env_module , only : rk , newUnit , LabelLen , PathLen use tem_aux_module , only : tem_checkLabel , tem_abort use treelmesh_module , only : treelmesh_type ! use tem_bc_prop_module,    only: tem_bc_prop_type use tem_tools_module , only : tem_horizontalSpacer use tem_tracking_module , only : tem_load_tracking , tem_tracking_config_type use tem_variable_module , only : tem_variable_load use tem_stencil_module , only : tem_stencil_map_ToTreelmDef , & & tem_treelmDef_map_toStencil , & & init , append , destroy use tem_logging_module , only : logUnit use tem_dyn_array_module , only : append , destroy use tem_varSys_module , only : tem_varSys_init use tem_debug_module , only : dbgUnit use tem_spacetime_fun_module , only : tem_destroy_subTree_of_st_funList ! include musubi modules use mus_param_module , only : mus_param_type use mus_scheme_layout_module , only : mus_load_newLayout , & & mus_define_layout , & & mus_init_layout use mus_scheme_header_module , only : mus_load_scheme_header , & & mus_scheme_header_out use mus_scheme_type_module , only : mus_scheme_type use mus_moments_module , only : mus_init_moments use mus_field_module , only : mus_load_fields , mus_fields_out , & & mus_load_fieldBaseInfos , mus_field_cleanup use mus_mixture_module , only : mus_mixture_out use mus_variable_module , only : mus_build_varSys , & & mus_append_stateVar , & & mus_append_readVarAsStateVar use mus_source_type_module , only : mus_source_cleanup , & & mus_load_source_var , & & mus_create_poss_srcVar use mus_varSys_module , only : mus_varSys_solverData_type , & & mus_init_varSys_solverData use mus_interpolate_header_module , only : mus_load_interpolate , & & mus_set_nSources , & & mus_interpolate_out use mus_geom_module , only : mus_geom_type use mus_transport_var_module , only : mus_create_poss_transVar , & & mus_load_transport_var use mus_auxFieldVar_module , only : mus_assign_calcAuxField_ptr use mus_gradData_module , only : mus_assign_GradCalculation_ptr use mus_scheme_derived_quantities_module , only : mus_assign_derived_functions_ptr ! include aotus modules use aotus_module , only : flu_state , aot_get_val use aot_table_module , only : aot_table_open , aot_table_close , & & aot_table_length use aot_out_module , only : aot_out_type , aot_out_open_table , & & aot_out_close_table , aot_out_open , aot_out_close implicit none private public :: mus_load_scheme public :: mus_scheme_out public :: mus_init_scheme public :: mus_scheme_cleanup contains ! ****************************************************************************** ! !> load single scheme defined in lua file with or without scheme handle !! !! This routines checks whether schemes table !!```lua !! boundary_conditions = {...}, !!``` !! is defined. If yes then it will !! load schemes table and set mus_scheme_type. !! If no special scheme table is defined, default tables are loaded from the !! root level of the lua file !! fluid, boundary conditions and initial condiitions !!```lua !! fluid = { ... } !! boundary_conditions = {...} !! initial_conditions = {...} !!``` !! !! subroutine mus_load_scheme ( me , solverData , geometry , conf , params , & & parent , isMusHvs ) ! --------------------------------------------------------------------------- !> scheme type type ( mus_scheme_type ), target , intent ( inout ) :: me !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target :: solverData !> geometry information like tree and boundary type ( mus_geom_type ), intent ( in ), target :: geometry !> global parameter type type ( mus_param_type ), target , intent ( inout ) :: params !> flu state type ( flu_State ) :: conf !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> Logic to not to load tracking and variable table if this routine !! is called from mus_hvs_config_load. !! Default is False logical , optional , intent ( in ) :: isMusHvs ! --------------------------------------------------------------------------- integer , allocatable :: varErr (:) logical :: isMusHvs_loc ! --------------------------------------------------------------------------- if ( present ( isMusHvs )) then isMusHvs_loc = isMusHvs else isMusHvs_loc = . false . end if ! Set solverData pointer for variable method data call mus_init_varSys_solverData ( me = solverData , & & scheme = me , & & physics = params % physics , & & geometry = geometry ) ! load scheme identifier table call mus_load_scheme_header ( me = me % header , & & conf = conf , & & parent = parent , & & scaling = params % scaling ) ! initialize scheme layout here to append state variable to varSys ! call mus_init_layout( layout   = me%layout ) ! create fStencil if ( trim ( me % header % layout ) == 'new_stencil' ) then call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'Reading the new layout...' call mus_load_newLayout ( me = me % layout , & & parent_handle = parent , & & conf = conf ) else ! create fStencil call mus_define_layout ( layout = me % layout , & & stencilName = me % header % layout , & & nElems = geometry % tree % nElems ) end if ! Allocate field array and load field lables. ! it must be loaded before to append state variables call mus_load_fieldBaseInfos ( me = me % field , & & nFields = me % nFields , & & parent = parent , & & conf = conf ) ! Variable system must be initialized here so annouymous source and ! boundary variables can be appended to variable system during ! loading write ( logUnit ( 1 ), * ) 'Initializing global variable system for scheme ' & & // 'kind: ' // trim ( me % header % kind ) call tem_varSys_init ( me = me % varSys , & & systemName = trim ( me % header % kind ), & & length = 8 ) ! if load scheme is called from harvesting then append variable loaded ! for restart file as state variables if ( isMusHvs_loc ) then ! Append variables loaded from restart header as state variables ! with get_element pointing to access_state call mus_append_readVarAsStateVar ( & & varSys = me % varSys , & & readVarIsPdf = me % readVarIsPdf , & & read_varSys = params % general % restart & & % header % varSys , & & stateVarMap = me % stateVarMap , & & solverData = solverData , & & nFields = me % nFields , & & fldLabel = me % field (:)% label ) else me % readVarIsPdf = . true . ! append state variable depends on scheme kind call mus_append_stateVar ( varSys = me % varSys , & & stateVarMap = me % stateVarMap , & & solverData = solverData , & & schemeHeader = me % header , & & stencil = me % layout % fstencil , & & nFields = me % nFields , & & fldLabel = me % field (:)% label ) end if ! load interpolation parameters call mus_load_interpolate ( me = me % intp % config , & & parent = parent , & & conf = conf ) ! create possible source variables depends on scheme kind call mus_create_poss_srcVar ( poss_srcVar = me % poss_srcVar , & & schemeHeader = me % header ) ! create possible transport variables depends on scheme kind call mus_create_poss_transVar ( poss_transVar = me % poss_transVar , & & schemeHeader = me % header ) ! load fields from parent, including possible sources for each field call mus_load_fields ( me = me % field , & & varSys = me % varSys , & & nFields = me % nFields , & & mixture = me % mixture , & & nernstPlanck = me % nernstPlanck , & & bc_prop = geometry % boundary , & & conf = conf , & & minLevel = geometry % tree % global % minLevel , & & maxLevel = geometry % tree % global % maxLevel , & & parent = parent , & & schemeHeader = me % header , & & poss_srcVar = me % poss_srcVar , & & physics = params % physics , & & scaling = params % scaling , & & layout = me % layout , & & isMusHvs = isMusHvs ) ! load tracking and variable from conf only if it is not called from ! mus_hvs_config_load if (. not . isMusHvs_loc ) then ! load source variables call mus_load_source_var ( me = me % globSrc , & & possVars = me % poss_srcVar , & & conf = conf , & & parent = parent , & & key = 'glob_source' , & & varSys = me % varSys ) ! load transport variables call mus_load_transport_var ( me = me % transVar , & & possVars = me % poss_transVar , & & conf = conf , & & parent = parent , & & varSys = me % varSys , & & schemeHeader = me % header ) end if ! add analytical function loaded from lua file ! and in the end add error variable without dependency call tem_variable_load ( me = me % luaVar , & & conf = conf , & & parent = parent , & & key = 'variable' , & & vError = varErr ) ! load tracking call tem_load_tracking ( me = me % track , & & conf = conf , & & parent = parent ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_scheme ! ****************************************************************************** ! ! ****************************************************************************** ! !> Initialize single scheme stencil and variable system subroutine mus_init_scheme ( me , tree , solverData ) ! --------------------------------------------------------------------------- !> single scheme to initialize type ( mus_scheme_type ), intent ( inout ) :: me !> global treelm mesh type ( treelmesh_type ), intent ( in ) :: tree !> contains pointer to scheme, physics types type ( mus_varSys_solverData_type ), target , intent ( in ) :: solverData ! --------------------------------------------------------------------------- ! --------------------------------------------------------------------------- write ( logUnit ( 1 ), * ) 'Initializing the scheme ...' write ( logUnit ( 1 ), * ) 'Map stencil to treelm definition and vice versa ...' ! map the stencil offsets to the treelm definitions ! required to map boundary ID direction defined by treeLM directions ! from fluid stencil directions call tem_stencil_map_toTreelmDef ( me % layout % fStencil ) ! map the stencil offsets to the treelm definitions call tem_treelmDef_map_toStencil ( me % layout % fStencil ) ! append fluid stencil as 1st stencil in growing array of stencil call append ( me = me % layout % grwStencil , & & val = me % layout % fStencil ) ! append fluid stencil label call append ( me = me % layout % stencil_labels , & & val = me % layout % fStencil % label , & & pos = me % layout % fStencil_pos ) ! initialize the moments matrix call mus_init_moments ( me = me % layout % moment , & & QQ = me % layout % fStencil % QQ , & & cxDir = me % layout % fStencil % cxDir , & & label = me % layout % fStencil % label , & & schemeHeader = me % header ) if ( tree % global % minLevel /= tree % global % maxLevel ) then ! set number of sources required by interpolation call mus_set_nSources ( me = me % intp , & & nDims = me % layout % fStencil % nDims , & & QQ = me % layout % fStencil % QQ , & & layout = me % header % layout ) end if ! build variable system only if read var from restart is PDF if ( me % readVarIsPDF ) then call mus_build_varSys ( varSys = me % varSys , & & solverData = solverData , & & schemeHeader = me % header , & & stencil = me % layout % fStencil , & & nFields = me % nFields , & & derVarPos = me % derVarPos , & & luaVar = me % luaVar , & & field = me % field (:), & & globSrc = me % globSrc , & & poss_srcVar = me % poss_srcVar , & & st_funList = me % st_funList ) end if ! assign function pointer to compute auxFieldVar call mus_assign_calcAuxField_ptr ( me % header , me % calcAuxField ) ! Initialize gradients pointers me % Grad = mus_assign_GradCalculation_ptr ( label = me % layout % fStencil % label ) ! Initialize quantities type in the layout class me % layout % quantities = mus_assign_derived_functions_ptr ( & & label_stencil = me % layout % fStencil % label , & & label_fluid = me % header % kind ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_init_scheme ! ****************************************************************************** ! ! ****************************************************************************** ! !> Dump single scheme info into restart solver specific conf to dump !! solver specific information in restart header file subroutine mus_scheme_out ( me , conf ) ! --------------------------------------------------------------------------- !> schemes to dump to restart header file type ( mus_scheme_type ), intent ( in ) :: me !> aotus type handling the output to the file in lua format type ( aot_out_type ), optional , intent ( inout ) :: conf ! --------------------------------------------------------------------------- ! Dump scheme identify table call mus_scheme_header_out ( me % header , conf ) ! \\todo KM Dump: 1. stencil !                2. Interpolation select case ( trim ( me % header % layout ) ) case ( 'new_stencil' ) write ( logUnit ( 1 ), * ) 'WARNING: New stencil is not dumped in solver ' // & & 'specific unit. So cannot use mus_harvesting' end select ! Dump interpolation call mus_interpolate_out ( me = me % intp , & & conf = conf ) ! Dump mixture info for multi-scheme call mus_mixture_out ( me = me % mixture , & & conf = conf , & & schemeHeader = me % header ) ! Dump field info call mus_fields_out ( me % field , conf , me % header ) end subroutine mus_scheme_out ! ****************************************************************************** ! ! ****************************************************************************** ! !> This subroutine acts as a destructor for the construct routine subroutine mus_scheme_cleanup ( me , minLevel , maxLevel , nBCs ) ! --------------------------------------------------------------------------- !> scheme information including fluid, boundary and flow information type ( mus_scheme_type ), intent ( inout ) :: me !> minlevel integer , intent ( in ) :: minLevel !> maxlevel integer , intent ( in ) :: maxLevel !> Number of boundary conditions integer , intent ( in ) :: nBCs ! --------------------------------------------------------------------------- write ( dbgUnit ( 1 ), * ) \"Enter mus_scheme_cleanup\" ! ... deallocate the globBC array if ( allocated ( me % globBC )) then deallocate ( me % globBC ) end if deallocate ( me % pdf ) deallocate ( me % state ) if ( me % track % control % active ) then deallocate ( me % track % instance ) allocate ( me % track % instance ( me % track % control % nDefined ) ) end if ! ... deallocate the level descriptor array if ( allocated ( me % levelDesc )) then deallocate ( me % levelDesc ) end if ! ... loop over all stencils and ... if ( allocated ( me % layout % stencil ) ) then deallocate ( me % layout % stencil ) end if call destroy ( me % layout % grwStencil ) call destroy ( me % layout % stencil_labels ) ! ... deallcoate the auxField if ( allocated ( me % auxField ) ) then deallocate ( me % auxField ) end if ! ... deallocate gradData if ( allocated ( me % gradData ) ) then deallocate ( me % gradData ) end if ! ... deallocate viscosity and omega array in fluid type ! and arrays allocated in field BC type ! KM: DO NOT DESTROY FIELD ARRAY AS IT CONTAINS ALL CONFIG INFO call mus_field_cleanup ( me % field , me % header , minLevel , maxLevel , nBCs , & & me % nFields ) ! ... destroy glob source info call mus_source_cleanup ( me % globSrc ) ! ... destroy space-time function in stFun_list call tem_destroy_subTree_of_st_funList ( me = me % st_funList ) write ( dbgUnit ( 1 ), * ) \"Done!\" end subroutine mus_scheme_cleanup ! ****************************************************************************** ! end module mus_scheme_module ! ****************************************************************************** ! ! ****************************************************************************** ! !> \\page scheme_implementation Scheme Implementation !! The concept of schemes provides the user with a bigger flexibility. It is now !! possible to run multiple simulations with different layouts on the same mesh. !! This is the basis for LBM passive scalar transport simulations in MUSUBI. !! In general the scheme implementation is able to run on old and new lua files. !! !! \\subsection scheme_definition Scheme Definition !! !! The scheme is part of the individual solvers and contains all information about !! initial conditions, boundary conditions, the \\ref mus_scheme_layout_module !! \"Scheme Layout\", fluid and flow properties. !! !! \\subsection scheme_usage Usage !! !! To start a flow simulation one can either use the 'old' lua files or add the !! table species with the following quantities: !! !! - the scheme identifier which include label, kind, relaxation, layout !! - the initial conditions !! - the boundary conditions !! - the fluid quantities !! !!```lua !! -- Sample Flow Scheme Definition !!identify = { !!   kind = 'fluid', !!   relaxation = 'bgk', !!   layout = 'd3q19', !! } -- identify table !! !!-- Initial condition !!initial_condition = { !!  density = 1.0, !!  velocityX = 0.0, !!  velocityY = 0.0, !!  velocityZ = 0.0, !!  Sxx = 0.0, Syy = 0.0, Szz = 0.0, Sxy = 0.0, Syz = 0.0, Sxz = 0.0, !!} !! !!-- Boundary conditions !!boundary_condition = { !!{ label = 'wall', !!  kind = 'velocity_bounceback', !!  velocity = {0.03, 0.0, 0.0 } !!}, !!{ label = 'wall', !!  kind = 'wall', !!} -- boundary table !! !!fluid = { !!   omega = 1.8, !!   rho0 = 1.0 !!} -- fluid table !!``` !! !! Full example:","tags":"","loc":"sourcefile/mus_scheme_module.f90.html"},{"title":"mus_field_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_field_module.f90~~EfferentGraph sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_nernstplanck_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_field_module.f90~~AfferentGraph sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012, 2015 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2013 Jens Zudrop <j.zudrop@grs-sim.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Philipp Otte <otte@mathcces.rwth-aachen.de> ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! author: Simon Zimny !! This module contains information about all fields like fluid, !! species, temperature etc. This field type will be used for !! multispecies and passive scalar transport. !! !! [mus_field_prop]: @ref mus_field_prop_module \"mus_field_prop_module\" !! module mus_field_module ! include treelm modules use env_module , only : labelLen , rk use tem_param_module , only : cs2inv , cs2 , div1_2 use tem_math_module , only : invert_matrix use tem_time_module , only : tem_time_type use tem_bc_prop_module , only : tem_bc_prop_type use tem_debug_module , only : dbgUnit use tem_tools_module , only : tem_horizontalSpacer use tem_aux_module , only : tem_abort , tem_CheckLabel use tem_ini_condition_module , only : tem_ini_condition_type , tem_load_ic use tem_varSys_module , only : tem_varSys_type use tem_varMap_module , only : tem_possible_variable_type use tem_restart_module , only : tem_restart_type use tem_logging_module , only : logUnit use tem_temporal_module , only : tem_temporal_for use tem_construction_module , only : tem_levelDesc_type use tem_stencil_module , only : tem_stencilHeader_type use tem_stringKeyValuePair_module , only : init , truncate ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_NonExistent use aot_table_module , only : aot_table_open , aot_table_close , aot_table_length use aot_out_module , only : aot_out_type , aot_out_open_table , & & aot_out_close_table , aot_out_val ! include musubi modules use mus_bc_header_module , only : boundary_type , mus_load_bc , & & glob_boundary_type , & & check_solid_in_bc , rearrange_bc_elems , & & mus_fieldBC_cleanup use mus_scheme_header_module , only : mus_scheme_header_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_field_prop_module , only : mus_field_prop_type , mus_field_prop_out , & & mus_load_field_prop use mus_fluid_module , only : mus_fluid_cleanup use mus_species_module , only : compute_molWeightRatio , & & compute_bulkViscOmega use mus_physics_module , only : mus_physics_type use mus_mixture_module , only : mus_mixture_type , mus_load_mixture use mus_source_type_module , only : mus_source_type , & & mus_load_source_var , & & mus_source_cleanup use mus_source_var_module , only : mus_add_internal_source_var use mus_nernstPlanck_module , only : mus_nernstPlanck_type , & & mus_load_nernstPlanck implicit none private public :: mus_field_type public :: mus_load_fields , mus_fields_out public :: mus_load_fieldBaseInfos public :: setParameters_multispecies public :: remove_solid_in_bc public :: mus_check_allWall public :: mus_field_getSymmetricBCs public :: mus_field_cleanup !> This type contains all information on fields with ic and bc !! Example fields: fluid, species etc. !! Each field contains one initial condition and array of !! boundary conditions !! type mus_field_type !> field label. Should be unique for each field character ( len = labelLen ) :: label !> physics parameters (fluid and species) for field type ( mus_field_prop_type ) :: fieldProp !> array of field boundary types for each field !! size: #BCs in the boundary_condition table !! allocated in mus_load_bc type ( boundary_type ), allocatable :: bc (:) !> initialization case, one initial condition for each field type ( tem_ini_condition_type ) :: ic !> field source applied only to current field type ( mus_source_type ) :: source !> field internal source applied only to current field !! not needed input from musubi.lua !! used only for HRR correction at the moment type ( mus_source_type ) :: internalSource !> An instance of restart type type ( tem_restart_type ) :: restart end type mus_field_type !> Interface for dumping a single field or a set of fields in a file in lua !! format. !! interface mus_fields_out module procedure mus_fields_out_vec module procedure mus_field_out_scal end interface mus_fields_out contains ! **************************************************************************** ! !> Subroutine to load the field table from the lua configuration file. !! !! If field table is not defined than load bc, ic, fluid, species from scheme !! table. If scheme table is not defined than load field variables from !! config parent. !! subroutine mus_load_fields ( me , varSys , nFields , mixture , nernstPlanck , & & bc_prop , conf , parent , minLevel , maxLevel , & & schemeHeader , poss_srcVar , physics , scaling , & & layout , isMusHvs ) ! -------------------------------------------------------------------------- !> array of field type type ( mus_field_type ), intent ( inout ) :: me (:) !> Global variable system required to append annoymous source and !! boundary variables type ( tem_varSys_type ), intent ( inout ) :: varSys integer , intent ( in ) :: nFields !< number of fields defined in lua file !> contains mixture information type ( mus_mixture_type ), intent ( out ) :: mixture !> contains solvent information type ( mus_nernstPlanck_type ), intent ( out ) :: nernstPlanck !> boundary data from mesh type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> flu state type ( flu_State ), intent ( inout ) :: conf !> global pdf info integer , intent ( in ) :: minLevel , maxLevel !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: poss_srcVar !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> scaling type character ( len = labelLen ), intent ( in ) :: scaling !> fluid stencil info type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Logic to not to load tracking and variable table if this routine !! is called from mus_hvs_config_load. !! Default is False logical , optional , intent ( in ) :: isMusHvs ! -------------------------------------------------------------------------- ! counter variables integer :: iField ! aotus handles integer :: field_handle , field_sub_handle ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'Loading the fields ...' write ( logUnit ( 1 ), * ) 'Number of fields to load: ' , nFields call aot_table_open ( L = conf , & & parent = parent , & & thandle = field_handle , & & key = 'field' ) if ( field_handle == 0 ) then if ( present ( parent )) then ! field table is not defined load field variable from scheme write ( logUnit ( 1 ), * ) 'No field table defined.' & & // 'Loading field data from scheme' call mus_load_field_single ( me = me ( 1 ), & & varSys = varSys , & & nFields = nFields , & & bc_prop = bc_prop , & & conf = conf , & & minLevel = minLevel , & & maxLevel = maxLevel , & & parent = parent , & & poss_srcVar = poss_srcVar , & & physics = physics , & & schemeHeader = schemeHeader , & & scaling = scaling , & & layout = layout , & & isMusHvs = isMusHvs ) ! scheme table is not defined load field variable from config else write ( logUnit ( 1 ), * ) 'No field table and scheme table are defined.' & & // 'Loading field data from config' call mus_load_field_single ( me = me ( 1 ), & & varSys = varSys , & & nFields = nFields , & & bc_prop = bc_prop , & & conf = conf , & & minLevel = minLevel , & & maxLevel = maxLevel , & & poss_srcVar = poss_srcVar , & & physics = physics , & & schemeHeader = schemeHeader , & & scaling = scaling , & & layout = layout , & & isMusHvs = isMusHvs ) endif ! present parent? else ! check whether field is a single table or multiple table call aot_table_open ( L = conf , & & parent = field_handle , & & thandle = field_sub_handle , & & pos = 1 ) if ( field_sub_handle == 0 ) then ! field is a single table call aot_table_close ( L = conf , thandle = field_sub_handle ) write ( logUnit ( 1 ), * ) 'Field is a single table' call mus_load_field_single ( me = me ( 1 ), & & varSys = varSys , & & nFields = nFields , & & bc_prop = bc_prop , & & conf = conf , & & parent = field_handle , & & minLevel = minLevel , & & maxLevel = maxLevel , & & poss_srcVar = poss_srcVar , & & physics = physics , & & schemeHeader = schemeHeader , & & scaling = scaling , & & layout = layout , & & isMusHvs = isMusHvs ) else ! field is multiple table call aot_table_close ( L = conf , thandle = field_sub_handle ) write ( logUnit ( 1 ), * ) 'Field is a multiple table' do iField = 1 , nFields call aot_table_open ( L = conf , & & parent = field_handle , & & thandle = field_sub_handle , & & pos = iField ) write ( logUnit ( 1 ), * ) 'Properties for Field ' , iField call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) call mus_load_field_single ( me = me ( iField ), & & varSys = varSys , & & nFields = nFields , & & bc_prop = bc_prop , & & conf = conf , & & minLevel = minLevel , & & maxLevel = maxLevel , & & parent = field_sub_handle , & & poss_srcVar = poss_srcVar , & & physics = physics , & & schemeHeader = schemeHeader , & & scaling = scaling , & & layout = layout , & & isMusHvs = isMusHvs ) call aot_table_close ( L = conf , thandle = field_sub_handle ) end do ! number of fields end if ! if field table is present end if call aot_table_close ( L = conf , thandle = field_handle ) !load scheme specific field select case ( trim ( schemeHeader % kind )) case ( 'fluid' , 'fluid_incompressible' , 'passive_scalar' , 'isotherm_acEq' , & & 'poisson' , 'poisson_boltzmann_linear' , 'poisson_boltzmann_nonlinear' ) !nFields must be = 1 scheme other than multispecies and nernst_planck if ( nFields > 1 ) then write ( logUnit ( 1 ), * ) ' ERROR: Number of fields defined for ' write ( logUnit ( 1 ), * ) '        ' // trim ( schemeHeader % kind ) // ' scheme: >1. ' write ( logUnit ( 1 ), * ) '        Specify only one field. Aborting' call tem_abort () endif case ( 'multispecies_gas' , 'multispecies_liquid' ) !nFields must be > 1 for multispecies if ( nFields == 1 ) then write ( logUnit ( 1 ), * ) ' ERROR: Number of fields(species) defined for ' write ( logUnit ( 1 ), * ) '        multispecies scheme = 1. ' write ( logUnit ( 1 ), * ) '        Specify nFields > 1. Aborting' call tem_abort () endif !compute molecular weight ratios incase of multispecies simulation call compute_molWeightRatio ( & & molWeights = me (:)% fieldProp % species % molWeight , & & molWeigRatios = me (:)% fieldProp % species % molWeigRatio ) !load mixture table and set bulk viscosity relaxation time ! for each species which is depends on molecular weight ratios call mus_load_mixture ( me = mixture , & & conf = conf , & & parent = parent , & & schemeHeader = schemeHeader , & & minLevel = minLevel , & & maxLevel = maxLevel , & & physics = physics , & & nFields = nFields ) !compute bulk viscosity omega for each field write ( logUnit ( 1 ), * ) '  Bulk omega for each species:' do iField = 1 , nFields write ( logUnit ( 1 ), * ) '   species ' , iField call compute_bulkViscOmega ( species = me ( iField )% fieldProp % species , & & bulkvisc = mixture % bulk_viscosityLB , & & bulkviscLvl = mixture % relaxLvl (:)% bulkVisc ,& & minLevel = minLevel , & & maxLevel = maxLevel ) end do case ( 'nernst_planck' ) write ( logUnit ( 1 ), \"(A)\" ) ' Loading properties for nersnt_planck:' call mus_load_nernstPlanck ( me = nernstPlanck , & & conf = conf , & & parent = parent , & & physics = physics ) case default write ( logUnit ( 1 ), * ) 'The selected scheme kind is unknown ' // & & trim ( schemeHeader % kind ) call tem_abort () end select end subroutine mus_load_fields ! **************************************************************************** ! ! **************************************************************************** ! !> load a single field table !! In includes: !!   load field property !!   load source variables !!   load boundary defination !!   load immersed boundary method !!   load initial condition defination and its property !! subroutine mus_load_field_single ( me , varSys , nFields , bc_prop , conf , & & parent , minLevel , maxLevel , poss_srcVar , & & physics , schemeHeader , scaling , layout , & & isMusHvs ) ! -------------------------------------------------------------------------- !> field type type ( mus_field_type ), intent ( inout ) :: me !> Global variable system required to append annoymous source and !! boundary variables type ( tem_varSys_type ), intent ( inout ) :: varSys !> number of fields defined in lua file integer , intent ( in ) :: nFields !> boundary data from mesh type ( tem_bc_prop_type ), intent ( in ) :: bc_prop !> flu state type ( flu_State ), intent ( inout ) :: conf !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> global pdf info integer , intent ( in ) :: minLevel , maxLevel !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: poss_srcVar !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> scaling type character ( len = labelLen ), intent ( in ) :: scaling !> fluid stencil info type ( mus_scheme_layout_type ), intent ( in ) :: layout !> Logic to not to load tracking and variable table if this routine !! is called from mus_hvs_config_load. !! Default is False logical , optional , intent ( in ) :: isMusHvs ! -------------------------------------------------------------------------- character ( len = labelLen ), allocatable :: ic_states (:) logical :: isMusHvs_loc integer :: IC_nVars !> Error code of loading ic variables integer , allocatable :: iError (:) ! -------------------------------------------------------------------------- if ( present ( isMusHvs )) then isMusHvs_loc = isMusHvs else isMusHvs_loc = . false . end if write ( logUnit ( 1 ), \"(A)\" ) ' Loading field: ' // trim ( me % label ) ! load field properties call mus_load_field_prop ( me = me % fieldProp , & & nFields = nFields , & & conf = conf , & & minLevel = minLevel , & & parent = parent , & & physics = physics , & & cs_lattice = layout % cs , & & schemeHeader = schemeHeader ) ! Load Boundary, initial condition only for solver if (. not . isMusHvs_loc ) then ! Read initial condition call mus_set_ic_states ( schemeHeader % kind , ic_states , IC_nVars ) allocate ( iError ( size ( ic_states ) ) ) call tem_load_ic ( me = me % ic , & & conf = conf , & & parent = parent , & & key = 'initial_condition' , & & ErrCode = iError , & & StateName = ic_states ) if ( any ( iError ( 1 : IC_nVars ) /= 0 ) ) then write ( logUnit ( 1 ), \"(A)\" ) \" Not all the KEY variables in initial \" & & // \"condition are well defined!\" call tem_abort () end if deallocate ( ic_states ) deallocate ( iError ) end if ! load boundary call mus_load_bc ( me = me % bc , & & bc_prop = bc_prop , & & conf = conf , & & parent = parent , & & varSys = varSys , & & stencil = layout % fStencil ) ! load the field specific source variables call mus_load_source_var ( me = me % source , & & possVars = poss_srcVar , & & conf = conf , & & parent = parent , & & key = 'source' , & & varSys = varSys ) call mus_add_internal_source_var ( me = me % internalSource , & & possVars = poss_srcVar , & & varSys = varSys , & & schemeHeader = schemeHeader ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_field_single ! **************************************************************************** ! ! ************************************************************************ ! !> This routine returns nFields and field labels from config file. !! It is required to initialize variable system. !! labels are loaded only if field table is present else default !! is set to empty string. subroutine mus_load_fieldBaseInfos ( me , nFields , parent , conf ) ! -------------------------------------------------------------------------- !> array of field type type ( mus_field_type ), allocatable , intent ( out ) :: me (:) !> number of fields defined in lua file integer , intent ( out ) :: nFields !> parent handle if scheme table is defined integer , intent ( in ), optional :: parent !> flu state type ( flu_State ), intent ( inout ) :: conf ! -------------------------------------------------------------------------- integer :: iError , iField integer :: field_handle , field_sub_handle ! -------------------------------------------------------------------------- call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) write ( logUnit ( 1 ), * ) 'Loading the field base info ...' call aot_table_open ( L = conf , & & parent = parent , & & thandle = field_handle , & & key = 'field' ) ! allocate the fields nFields = 1 allocate ( me ( nFields )) me ( nFields )% label = '' ! load label only if field table is present if ( field_handle /= 0 ) then ! check whether field is a single table or multiple table call aot_table_open ( L = conf , & & parent = field_handle , & & thandle = field_sub_handle , & & pos = 1 ) if ( field_sub_handle == 0 ) then ! field is a single table call aot_get_val ( L = conf , & & thandle = field_handle , & & key = 'label' , & & val = me ( 1 )% label , & & default = '' , & & ErrCode = iError ) if ( trim ( me ( 1 )% label ) /= '' ) & & me ( 1 )% label = trim ( me ( 1 )% label ) // '_' write ( logUnit ( 1 ), * ) 'Field label: ' , trim ( me ( 1 )% label ) else ! field is multiple table call aot_table_close ( L = conf , thandle = field_sub_handle ) nFields = aot_table_length ( L = conf , thandle = field_handle ) write ( logUnit ( 1 ), * ) 'Number of fields: ' , nFields ! reallocate the fields deallocate ( me ) allocate ( me ( nFields )) do iField = 1 , nFields call aot_table_open ( L = conf , & & parent = field_handle , & & thandle = field_sub_handle , & & pos = iField ) call aot_get_val ( L = conf , & & thandle = field_sub_handle , & & key = 'label' , & & val = me ( iField )% label , & & default = '' , & & ErrCode = iError ) if ( btest ( iError , aoterr_NonExistent )) then write ( logUnit ( 1 ), * ) 'Error: field label is not specified' write ( logUnit ( 1 ), * ) 'field label is neccessary when nFields>1' call tem_abort () end if ! add underscore here to differentiate state variables and derived ! variables of each field if ( trim ( me ( iField )% label ) /= '' ) & & me ( iField )% label = trim ( me ( iField )% label ) // '_' ! Check, if the names of the fields are unique. If not, add an ! increasing number call tem_checkLabel ( label = me (:)% label , nLabels = iField ) call aot_table_close ( L = conf , thandle = field_sub_handle ) write ( logUnit ( 1 ), * ) iField , 'Field label: ' , trim ( me ( iField )% label ) end do !number of fields end if ! single field else write ( logUnit ( 1 ), * ) 'No field table defined.' write ( logUnit ( 1 ), * ) 'Assuming single field and label = \"\".' end if call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) end subroutine mus_load_fieldBaseInfos ! ************************************************************************ ! ! **************************************************************************** ! !> write array of fields into a lua file !! subroutine mus_fields_out_vec ( me , conf , schemeHeader ) ! -------------------------------------------------------------------------- !> array of field type type ( mus_field_type ), intent ( in ) :: me (:) !> aotus out type type ( aot_out_type ), intent ( inout ) :: conf !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! -------------------------------------------------------------------------- integer :: iField ! counter variable ! -------------------------------------------------------------------------- call aot_out_val ( put_conf = conf , & & val = size ( me ), & & vname = 'nFields' ) if ( size ( me ) > 1 ) then call aot_out_open_table ( put_conf = conf , tname = 'field' ) do iField = 1 , size ( me ) call mus_field_out_scal ( me = me ( iField ), & & conf = conf , & & schemeHeader = schemeHeader , & & level = 1 ) end do call aot_out_close_table ( put_conf = conf ) else call mus_field_out_scal ( me = me ( 1 ), & & conf = conf , & & schemeHeader = schemeHeader , & & level = 0 ) end if end subroutine mus_fields_out_vec ! **************************************************************************** ! ! **************************************************************************** ! !> write single field into a lua file !! subroutine mus_field_out_scal ( me , conf , schemeHeader , level ) ! -------------------------------------------------------------------------- !> single field type type ( mus_field_type ), intent ( in ) :: me !> aotus out type type ( aot_out_type ), intent ( inout ) :: conf !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> To dump field with or without key integer , optional , intent ( in ) :: level ! -------------------------------------------------------------------------- integer :: level_loc , pos ! -------------------------------------------------------------------------- if ( present ( level )) then level_loc = level else level_loc = 0 end if if ( level_loc == 0 ) then call aot_out_open_table ( put_conf = conf , tname = 'field' ) else call aot_out_open_table ( put_conf = conf ) end if if ( len ( trim ( me % label )) > 0 ) then ! Remove underscore from field name before dumping pos = INDEX ( trim ( me % label ), '_' , back = . true .) call aot_out_val ( put_conf = conf , & & vname = 'label' , & & val = trim ( me % label ( 1 : pos - 1 )) ) end if call mus_field_prop_out ( me = me % fieldProp , & & conf = conf , & & schemeHeader = schemeHeader ) call aot_out_close_table ( put_conf = conf ) end subroutine mus_field_out_scal ! **************************************************************************** ! ! **************************************************************************** ! !> Set ic states labels by scheme kind !! subroutine mus_set_ic_states ( scheme_kind , ic_states , IC_nVars ) ! -------------------------------------------------------------------------- character ( len = labelLen ), intent ( in ) :: scheme_kind character ( len = labelLen ), allocatable :: ic_states (:) !> Number of initial condition variables required to initialize state integer , intent ( out ) :: IC_nVars ! -------------------------------------------------------------------------- ! load scheme specific field select case ( trim ( scheme_kind ) ) case ( 'fluid' , 'fluid_incompressible' ) IC_nVars = 4 allocate ( ic_states ( 10 )) ic_states = ( / 'pressure ' , 'velocityX' , 'velocityY' , 'velocityZ' , & & 'Sxx      ' , 'Syy      ' , 'Szz      ' , 'Sxy      ' , & & 'Syz      ' , 'Sxz      ' / ) case ( 'passive_scalar' ) IC_nVars = 4 allocate ( ic_states ( 4 )) ic_states = ( / 'pressure ' , 'velocityX' , 'velocityY' , 'velocityZ' / ) case ( 'multispecies_gas' ) IC_nVars = 4 allocate ( ic_states ( 4 ) ) ic_states = ( / 'pressure ' , 'velocityX' , 'velocityY' , & & 'velocityZ' / ) case ( 'multispecies_liquid' , 'nernst_planck' ) IC_nVars = 4 allocate ( ic_states ( 4 ) ) ic_states = ( / 'mole_fraction' , 'velocityX    ' , 'velocityY    ' , & & 'velocityZ    ' / ) case ( 'isotherm_acEq' ) IC_nVars = 4 allocate ( ic_states ( 10 )) ic_states = ( / 'pressure ' , 'velocityX' , 'velocityY' , 'velocityZ' , & & 'Sxx      ' , 'Syy      ' , 'Szz      ' , 'Sxy      ' , & & 'Syz      ' , 'Sxz      ' / ) case ( 'poisson' , 'poisson_boltzmann_linear' , 'poisson_boltzmann_nonlinear' ) IC_nVars = 1 allocate ( ic_states ( 1 )) ic_states = ( / 'potential' / ) case default write ( logUnit ( 1 ), * ) 'The selected scheme kind model is not ' & & // 'supported to initialize ic state names: ' & & // trim ( scheme_kind ) call tem_abort () end select end subroutine mus_set_ic_states ! **************************************************************************** ! ! **************************************************************************** ! !> Set parameters for multispecies subroutine setParameters_multispecies ( field , nFields , mixture , header , & & layout , iLevel , tNow ) ! -------------------------------------------------------------------------- integer , intent ( in ) :: nFields type ( mus_field_type ), intent ( inout ) :: field ( nFields ) type ( mus_scheme_layout_type ), intent ( in ) :: layout type ( mus_scheme_header_type ), intent ( in ) :: header type ( mus_mixture_type ), intent ( inout ) :: mixture integer , intent ( in ) :: iLevel !> solver general info type ( tem_time_type ), intent ( in ) :: tNow ! -------------------------------------------------------------------------- real ( kind = rk ) :: omega_diff ! diffusive relaxation parameter real ( kind = rk ) :: omega_kine ! kinematic shear relaxation parameter real ( kind = rk ) :: omega_bulk ! bulk relaxation parameter real ( kind = rk ) :: fac ! ramping multiplication factor integer :: iField , iDir real ( kind = rk ), dimension ( layout % fStencil % QQ , layout % fStencil % QQ ) :: & & identity , tmpMatrix , tmpMatrixInv ! -------------------------------------------------------------------------- !write(dbgUnit,*) 'setting omega paramter for multispecies' ! get the temporal multiplication factor fac = tem_temporal_for ( temporal = mixture % omega_ramping , & & time = tNow ) !! Relaxation parameter for each level !! kine_viscosity = dt*c&#94;2*(1/omega - 0.5) !!    =>   omega = dt / (viscosity/c&#94;2 + dt/2) !! omega for each level is stored at fluid%omLvl omega_diff = fac * mixture % relaxLvl ( iLevel )% paramB * cs2 !write(dbgUnit,*) 'omega_diff ', omega_diff mixture % relaxLvl ( iLevel )% omega_diff = omega_diff ! if relaxation is mrt set kinematic and bulk viscosity omega if ( header % relaxation ( 1 : 3 ) == 'mrt' ) then do iField = 1 , nFields if ( . not . allocated ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% s_mrt )) & & allocate ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% s_mrt ( layout % fStencil % QQ , & & layout % fStencil % QQ )) if ( . not . allocated ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% omegaMoments )) & & allocate ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% omegaMoments ( layout % fStencil % QQ , & & layout % fStencil % QQ ) ) if ( . not . allocated ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% omegaMomForce )) & & allocate ( field ( iField )% fieldProp % species & & % mrt ( iLevel )% omegaMomForce ( layout % fStencil % QQ , & & layout % fStencil % QQ ) ) field ( iField )% fieldProp % species % mrt ( iLevel ) & & % omegaMoments = 0.0_rk field ( iField )% fieldProp % species % mrt ( iLevel ) & & % omegaMomForce = 0.0_rk tmpMatrix = 0.0_rk tmpMatrixInv = 0.0_rk Identity = 0.0_rk do iDir = 1 , layout % fStencil % QQ Identity ( iDir , iDir ) = 1.0_rk end do ! viscous omega omega_kine = mixture % relaxLvl ( iLevel )% omega_kine * fac ! bulk omega omega_bulk = field ( iField )% fieldProp % species % omBulkLvl ( iLevel ) & & * fac !write(*,*) 'omega_diff ', omega_diff !write(*,*) 'omega_kine ', omega_kine !write(*,*) 'omega_bulk ', omega_bulk ! Set the relaxation parameters (only the non-relaxing modes) ! \\ref Multiple-relaxation-time lattice Boltzmann scheme for !      homogeneous mixture flows with external force- Pietro Asinari ! \\ref Jens ICCMES paper ! initialize all entries in relaxation matrix field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt (:,:) = 0.0_rk select case ( trim ( header % layout )) case ( 'd2q9' ) !write(*,*) 'omega_diaCenter ', (omega_bulk + omega_kine )/2.0_rk !write(*,*) 'omega_nondia ', (omega_bulk - omega_kine )/2.0_rk ! diffusivity omegas do iDir = 2 , 3 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = omega_diff end do do iDir = 4 , 5 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = ( omega_bulk + omega_kine ) * div1_2 end do field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( 5 , 4 ) = ( omega_bulk - omega_kine ) * div1_2 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( 4 , 5 ) = ( omega_bulk - omega_kine ) * div1_2 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( 6 , 6 ) = omega_kine do iDir = 7 , 9 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = mixture % omega_hom end do case ( 'd3q19' ) !write(*,*) 'omega_diaCenter ', (omega_bulk + 2.0_rk * omega_kine )/3.0_rk !write(*,*) 'omega_nondia ', (omega_bulk - omega_kine )/3.0_rk do iDir = 2 , 4 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = omega_diff end do do iDir = 5 , 7 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = ( omega_bulk + 2.0_rk * omega_kine ) & & / 3.0_rk end do field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 5 , 6 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 5 , 7 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 6 , 5 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 6 , 7 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 7 , 5 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ( 7 , 6 ) & & = ( omega_bulk - omega_kine ) / 3.0_rk do iDir = 8 , 10 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = omega_kine end do do iDir = 11 , 19 field ( iField )% fieldProp % species % mrt ( iLevel ) & & % s_mrt ( iDir , iDir ) = mixture % omega_hom end do end select !omega moments = (M&#94;-1 RelaxMat M)*(I+(M&#94;-1 RelMat M)/2)&#94;-1 tmpMatrix = matmul ( matmul ( layout % moment % toPdf % A , & & field ( iField )% fieldProp % species % mrt ( iLevel )% s_mrt ), & & layout % moment % toMoments % A ) tmpMatrixInv = invert_matrix ( Identity + tmpMatrix * 0.5_rk ) field ( iField )% fieldProp % species % mrt ( iLevel )% omegaMoments = & & matmul ( tmpMatrix , tmpMatrixInv ) field ( iField )% fieldProp % species % mrt ( iLevel ) & & % omegaMomForce = tmpMatrixInv end do ! iField end if ! mrt? end subroutine setParameters_multispecies ! **************************************************************************** ! ! **************************************************************************** ! !> First check count number of valid elements (non-solid) in each BC. !! Then rearrange BC elements list so it contains only valid elements. !! Update fields%bc%elemLvl%stencilPos fields%bc%elemLvl%posInNghElems !! accordingly. !! subroutine remove_solid_in_bc ( minLevel , maxLevel , nBCs , nFields , & & levelPointer , levelDesc , globBC , fields ) ! -------------------------------------------------------------------------- integer , intent ( in ) :: minLevel , maxLevel , nBCs , nFields !> Level pointer integer , intent ( in ) :: levelPointer (:) !> Level Descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc ( minLevel : maxLevel ) !> type ( glob_boundary_type ) :: globBC ( nBCs ) !> type ( mus_field_type ) :: fields ( nFields ) ! -------------------------------------------------------------------------- !> number of valid BC elements integer :: nValid ( minLevel : maxLevel ) !> positions of only valid elements (non-solid) in bc_elems_type integer , allocatable :: posInBCElem (:,:) integer :: iBC , iField , iLevel , iElem logical :: allWall ! -------------------------------------------------------------------------- write ( dbgUnit ( 3 ), * ) 'Get into remove_solid_in_bc routine' do iBC = 1 , nBCs !! \\todo: do this for both SBB and LIBB? allWall = . true . do iField = 1 , nFields if ( fields ( iField )% bc ( iBC )% BC_kind ( 1 : 4 ) /= 'wall' ) then ! if( trim(fields(iField)%bc(iBC)%BC_kind) /= 'wall' ) then allWall = . false . exit end if end do if ( . not . allWall ) then write ( logUnit ( 3 ), \"(A)\" ) 'Try to remove solid from BC: ' & & // trim ( globBC ( iBC )% label ) ! ---------------------------------------------------------------------- allocate ( posInBCElem ( maxval ( globBC ( iBC )% nElems ), minLevel : maxLevel ) ) ! check number of valid elements in each BC call check_solid_in_bc ( minLevel , maxLevel , levelPointer , levelDesc , & & globBC ( iBC )% nElems , globBC ( iBC )% elemLvl , & & nValid , posInBCElem ) ! remove solid in globBC%elemLvl call rearrange_bc_elems ( minLevel , maxLevel , nValid , posInBCElem , & & globBC ( iBC )% nElems , globBC ( iBC )% elemLvl ) globBC ( iBC )% nElems (:) = nValid (:) do iField = 1 , nFields ! re-arrange stencilPos, posInNghElems only if this BC requires ! neighbors if ( fields ( iField )% bc ( iBC )% nNeighs > 0 ) then do iLevel = minLevel , maxLevel ! ---------------------------------------------------------------- do iElem = 1 , nValid ( iLevel ) fields ( iField )% bc ( iBC )% elemLvl ( iLevel )% stencilPos ( iElem ) & & = fields ( iField )% bc ( iBC )% elemLvl ( iLevel ) & & % stencilPos ( posInBCElem ( iElem , iLevel ) ) fields ( iField )% bc ( iBC )% elemLvl ( iLevel )% posInNghElems ( iElem ) & & = fields ( iField )% bc ( iBC )% elemLvl ( iLevel ) & & % posInNghElems ( posInBCElem ( iElem , iLevel ) ) end do ! iElem = 1, nValid ! ---------------------------------------------------------------- end do ! iLevel end if ! nNeighs > 0 end do ! iField deallocate ( posInBCElem ) end if ! not allWall end do ! iBC write ( dbgUnit ( 3 ), * ) 'Leave out of remove_solid_in_bc routine' write ( dbgUnit ( 3 ), * ) '' end subroutine remove_solid_in_bc ! **************************************************************************** ! ! **************************************************************************** ! !> Check if a BC is wall or symmetry for all fields pure function mus_check_allWall ( nFields , fields , iBC ) result ( allWall ) ! -------------------------------------------------------------------------- integer , intent ( in ) :: iBC , nFields type ( mus_field_type ), intent ( in ) :: fields ( nFields ) logical :: allWall ! -------------------------------------------------------------------------- integer :: iField ! -------------------------------------------------------------------------- allWall = . true . do iField = 1 , nFields if ( trim ( fields ( iField )% bc ( iBC )% BC_kind ) /= 'wall' . or . & & trim ( fields ( iField )% bc ( iBC )% BC_kind ) /= 'symmetry' ) then allWall = . false . exit end if ! not wall end do ! iField end function mus_check_allWall ! **************************************************************************** ! ! **************************************************************************** ! !> This routine checks for the existence of symmetric boundaries and !! returns the boundary IDs which are defined as symmetry subroutine mus_field_getSymmetricBCs ( symmetricBCs , nSymBCs , nBCs , nFields , & & field ) ! -------------------------------------------------------------------------- !> number of boundary conditions integer , intent ( in ) :: nBCs !> Symmetric boundary ids integer , intent ( out ) :: symmetricBCs ( nBCs ) !> Number of symmetric boundary conditions integer , intent ( out ) :: nSymBCs !> number of fields integer , intent ( in ) :: nFields !> all fields to access their boundary definitions type ( mus_field_type ), intent ( in ) :: field ( nFields ) ! -------------------------------------------------------------------------- integer :: iField , iBC logical :: isSymmetry ( nFields ) ! -------------------------------------------------------------------------- nSymBCs = 0 do iBC = 1 , nBCs isSymmetry = . false . do iField = 1 , nFields if ( trim ( field ( iField )% bc ( iBC )% BC_kind ) == 'symmetry' ) then isSymmetry ( iField ) = . true . end if if ( any ( isSymmetry ) ) then if (. not . all ( isSymmetry ) ) then call tem_abort ( 'Error: Not all fields boundary label:' & & // trim ( field ( iField )% bc ( iBC )% label ) // ' are symmetry!' ) end if nSymBCs = nSymBCs + 1 symmetricBCs ( nSymBCs ) = iBC end if end do end do end subroutine mus_field_getSymmetricBCs ! **************************************************************************** ! ! ************************************************************************** ! !> This routines act as a destructor for field type. !! Only allocatable arrays which are allocated in mus_construct routine !! are deallocated. !! KM: DO NOT DESTROY FIELD ARRAY AS IT CONTAINS ALL CONFIG INFO subroutine mus_field_cleanup ( me , schemeHeader , minLevel , maxLevel , nBCs , & & nFields ) ! -------------------------------------------------------------------------- !> single field type type ( mus_field_type ), intent ( inout ) :: me (:) !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> minlevel integer , intent ( in ) :: minLevel !> maxlevel integer , intent ( in ) :: maxLevel !> Number of boundary conditions integer , intent ( in ) :: nBCs !> Number of fields integer , intent ( in ) :: nFields ! -------------------------------------------------------------------------- integer :: iFld ! -------------------------------------------------------------------------- write ( dbgUnit ( 1 ), \"(A)\" ) 'Enter mus_field_cleanup' ! Cleanup allocatable arrays in field properties select case ( trim ( schemeHeader % kind ) ) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) call mus_fluid_cleanup ( me ( 1 )% fieldProp % fluid ) end select ! Cleanup field source write ( dbgUnit ( 1 ), \"(A)\" ) 'Enter mus_field_cleanup' do iFld = 1 , nFields call mus_source_cleanup ( me ( iFld )% source ) end do ! Cleanup field boundary do iFld = 1 , nFields write ( dbgUnit ( 3 ), * ) \"Cleanup BC: iField=\" , iFld call mus_fieldBC_cleanup ( me = me ( iFld )% bc , & & nBCs = nBCs , & & minLevel = minLevel , & & maxLevel = maxLevel ) end do end subroutine mus_field_cleanup ! ************************************************************************** ! end module mus_field_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_field_module.f90.html"},{"title":"mus_source_var_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_source_var_module.f90~~EfferentGraph sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_source_var_module.f90~~AfferentGraph sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016-2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2021-2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ***************************************************************************** ! !> author: Kannan Masilamani !! Module containing subroutines for building MUSUBI specific source !! variables !! module mus_source_var_module ! include treelm modules use mpi use env_module , only : rk use tem_param_module , only : rho0 , cs2 , cs2inv use tem_varSys_module , only : tem_varSys_type use tem_varMap_module , only : tem_possible_variable_type , & & init , append , truncate use tem_stringKeyValuePair_module , only : init , truncate , & & tem_stringKeyValuePair_type use tem_time_module , only : tem_time_type use tem_spacetime_fun_module , only : tem_spacetime_fun_type use tem_spacetime_var_module , only : tem_varSys_append_stFun use tem_dyn_array_module , only : PositionOfVal ! include musubi modules use mus_physics_module , only : mus_convertFac_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_source_type_module , only : mus_source_op_type , & mus_source_type use mus_scheme_header_module , only : mus_scheme_header_type implicit none private ! update auxField dependent source variables public :: mus_updateSrcVar_dynSponFld public :: mus_add_internal_source_var contains ! ************************************************************************** ! !> Compute density and velocity in sponge layer for dynamic sponge subroutine mus_updateSrcVar_dynSponFld ( fun , auxField , iLevel , varSys , & & phyConvFac , derVarPos ) ! ------------------------------------------------------------------------ ! !> Description of method to update source class ( mus_source_op_type ), intent ( inout ) :: fun !> input auxField array on current level real ( kind = rk ), intent ( in ) :: auxField (:) !> current level integer , intent ( in ) :: iLevel !> variable system definition type ( tem_varSys_type ), intent ( in ) :: varSys !> Physics conversion factor on current level type ( mus_convertFac_type ), intent ( in ) :: phyConvFac !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos (:) ! -------------------------------------------------------------------------- integer :: dens_pos , vel_pos ( 3 ) integer :: iElem , nElems , elemOff real ( kind = rk ) :: dens , vel ( 3 ) real ( kind = rk ) :: smoothFac real ( kind = rk ) :: inv_rho_phy , inv_vel_phy real ( kind = rk ) :: dens_ref , vel_ref ( 3 ) ! -------------------------------------------------------------------------- ! position of density and velocity field in auxField dens_pos = varSys % method % val ( derVarPos ( 1 )% density )% auxField_varPos ( 1 ) vel_pos = varSys % method % val ( derVarPos ( 1 )% velocity )% auxField_varPos ( 1 : 3 ) inv_rho_phy = 1.0_rk / phyConvFac % press * cs2inv inv_vel_phy = 1.0_rk / phyConvFac % vel ! Number of elements to apply source terms nElems = fun % elemLvl ( iLevel )% nElems ! Calculate time average value ! Set initial density and velocity if no initialized associate ( dynAvg => fun % elemLvl ( iLevel )% dynAvg , & & posInTotal => fun % elemLvl ( iLevel )% posInTotal ) ! Do Exponential moving average over nRecord window ! P_n = P_{n-1} + smoothFac * (P - P_{n-1}) smoothFac = fun % absLayer % smoothFac ! DO time average for density if ( fun % absLayer % config % isPressDyn ) then if ( dynAvg % isInitDens ) then dynAvg % isInitDens = . false . ! Initialize dynAvg%dens with initialize density do iElem = 1 , nElems ! element offset elemoff = ( posInTotal ( iElem ) - 1 ) * varSys % nAuxScalars dynAvg % dens ( iElem ) = auxField ( elemOff + dens_pos ) end do else do iElem = 1 , nElems ! element offset elemoff = ( posInTotal ( iElem ) - 1 ) * varSys % nAuxScalars ! Local density and velocity dens = auxField ( elemOff + dens_pos ) ! New average dynAvg % dens ( iElem ) = dynAvg % dens ( iElem ) & & + smoothFac * ( dens - dynAvg % dens ( iElem ) ) end do end if else ! target pressure in lattice unit dens_ref = fun % absLayer % config % target_pressure * inv_rho_phy dynAvg % dens (:) = dens_ref end if ! DO time average for velocity if ( fun % absLayer % config % isVelDyn ) then if ( dynAvg % isInitVel ) then dynAvg % isInitVel = . false . ! Initialize dynAvg%vel with initialize velocity do iElem = 1 , nElems ! element offset elemoff = ( posInTotal ( iElem ) - 1 ) * varSys % nAuxScalars dynAvg % velX ( iElem ) = auxField ( elemOff + vel_pos ( 1 )) dynAvg % velY ( iElem ) = auxField ( elemOff + vel_pos ( 2 )) dynAvg % velZ ( iElem ) = auxField ( elemOff + vel_pos ( 3 )) end do else do iElem = 1 , nElems ! element offset elemoff = ( posInTotal ( iElem ) - 1 ) * varSys % nAuxScalars ! Local velocity vel ( 1 ) = auxField ( elemOff + vel_pos ( 1 )) vel ( 2 ) = auxField ( elemOff + vel_pos ( 2 )) vel ( 3 ) = auxField ( elemOff + vel_pos ( 3 )) ! New average dynAvg % velX ( iElem ) = dynAvg % velX ( iElem ) & & + smoothFac * ( vel ( 1 ) - dynAvg % velX ( iElem ) ) dynAvg % velY ( iElem ) = dynAvg % velY ( iElem ) & & + smoothFac * ( vel ( 2 ) - dynAvg % velY ( iElem ) ) dynAvg % velZ ( iElem ) = dynAvg % velZ ( iElem ) & & + smoothFac * ( vel ( 3 ) - dynAvg % velZ ( iElem ) ) end do end if else ! target velocity in lattice unit vel_ref ( 1 : 3 ) = fun % absLayer % config % target_velocity ( 1 : 3 ) * inv_vel_phy dynAvg % velX (:) = vel_ref ( 1 ) dynAvg % velY (:) = vel_ref ( 2 ) dynAvg % velZ (:) = vel_ref ( 3 ) end if end associate end subroutine mus_updateSrcVar_dynSponFld ! ************************************************************************** ! ! ***************************************************************************! !> Routine load musubi source terms for given key. !! key is glob_source or source subroutine mus_add_internal_source_var ( me , possVars , varSys , schemeHeader ) ! --------------------------------------------------------------------------! !> Source variable type to initialize type ( mus_source_type ), intent ( out ) :: me !> possible source variables type ( tem_possible_variable_type ), intent ( in ) :: possVars !> Global variable system type ( tem_varSys_type ), intent ( inout ) :: varSys !> Identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader ! --------------------------------------------------------------------------! integer :: hrrCorr_varPOS type ( tem_stringKeyValuePair_type ) :: kvp type ( tem_spacetime_fun_type ), pointer :: stfun (:) ! --------------------------------------------------------------------------! ! initialize growing array stringKeyValuePair call init ( me = me % varDict ) if ( trim ( schemeHeader % relaxation ) == 'hrr_bgk_corrected' . or . & & trim ( schemeHeader % relaxation ) == 'prr_bgk_corrected' . or . & & trim ( schemeHeader % relaxation ) == 'rr_bgk_corrected' ) then kvp % value = 'hrr_correction' kvp % key = 'hrr_correction' allocate ( stfun ( 1 )) ! use global mesh for anonymous variable stfun ( 1 )% subTree % useGlobalMesh = . true . hrrCorr_varPOS = PositionOfVal ( me = possVars % varName , & & val = trim ( kvp % key ) ) stfun ( 1 )% nComps = possVars % nComponents % val ( hrrCorr_varPOS ) allocate ( stfun ( 1 )% const ( stfun ( 1 )% nComps )) stfun ( 1 )% const (:) = 0._rk call tem_varSys_append_stFun ( & & varSys = varSys , & & stfun = stfun , & & varname = kvp % value , & & nComp = stfun ( 1 )% nComps , & & evalType = 'firstonly_asglobal' ) call append ( me = me % varDict , val = kvp ) endif ! truncate varDict call truncate ( me = me % varDict ) if ( me % varDict % nVals > 0 ) then ! allocate source method allocate ( me % method ( me % varDict % nVals )) else allocate ( me % method ( 0 )) end if end subroutine mus_add_internal_source_var ! ***************************************************************************! end module mus_source_var_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_source_var_module.f90.html"},{"title":"mus_scheme_derived_quantities_type_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_scheme_derived_quantities_type_module.f90~~AfferentGraph sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hrrinit_module.f90 mus_hrrInit_module.f90 sourcefile~mus_hrrinit_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types, function and routines for gradient !! computation. !! !! author: Gregorio Gerardo Spinelli module mus_scheme_derived_quantities_module ! include treelm modules use env_module , only : labelLen , rk use tem_aux_module , only : tem_abort use tem_param_module , only : div1_3 , div1_9 , div1_36 , div4_9 , rho0 , & & div1_18 , div2_27 , div1_54 , div1_216 , & & div8_27 , cs2inv , cs4inv , rho0Inv use tem_compileconf_module , only : vlen use tem_logging_module , only : logUnit implicit none private public :: mus_scheme_derived_quantities_type public :: mus_assign_derived_functions_ptr !> collection of properties of the scheme derived quantities type type mus_scheme_derived_quantities_type !> function pointer to get pdf equilibrium from vel and density procedure ( get_pdfEq ), nopass , pointer :: pdfEq_ptr => null () !> function pointer to get pdf equilibrium in a specific direction procedure ( get_pdfEq_iDir ), nopass , pointer :: pdfEq_iDir_ptr => null () !> function pointer to get velocities from pdf procedure ( get_vel_from_pdf ), nopass , pointer :: vel_from_pdf_ptr => null () !> function pointer to get velocities from pdf VECTORIZED procedure ( get_vel_from_pdf_vectorized ), nopass , pointer :: vel_from_pdf_vectorized_ptr => null () !> function pointer to get momentum procedure ( get_vector_from_vel_dens ), nopass , pointer :: momentum_from_vel_dens_ptr => null () !> function pointer to get kinetic energy procedure ( get_scalar_from_vel_dens ), nopass , pointer :: kineticEnergy_from_vel_dens_ptr => null () !> function pointer to get 1/rho as a mask regardless incompressibility procedure ( get_rho0Inv ), nopass , pointer :: rho0Inv_ptr => null () end type mus_scheme_derived_quantities_type abstract interface !> function pointer to get pdf equilibrium from vel and density pure function get_pdfEq ( rho , vel , QQ , cxDirRK , weight ) result ( fEq ) import :: rk !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the stencil integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) end function get_pdfEq !> function pointer to get pdf equilibrium from vel and density along a !  specific direction pure function get_pdfEq_iDir ( rho , vel , iDir , cxDirRK , weight ) result ( fEq ) import :: rk !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> direction of the pdf integer , intent ( in ) :: iDir !> velocity streaming normal along iDir real ( kind = rk ), intent ( in ) :: cxDirRK ( 3 ) !> weight along iDir real ( kind = rk ), intent ( in ) :: weight !> output: equilibrium pdf real ( kind = rk ) :: fEq end function get_pdfEq_iDir !> function pointer to get pdf equilibrium from vel and density pure function get_vel_from_pdf ( pdf , dens , cxDirRK ) result ( vel ) import :: rk !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) end function get_vel_from_pdf !> function pointer to get pdf equilibrium from vel and density VECTORIZED pure function get_vel_from_pdf_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) import :: rk , vlen !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) end function get_vel_from_pdf_vectorized !> function pointer to get pdf equilibrium from vel and density pure function get_vector_from_vel_dens ( vel , dens ) result ( vector ) import :: rk !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> momentum real ( kind = rk ) :: vector ( 3 ) end function get_vector_from_vel_dens !> function pointer to get pdf equilibrium from vel and density pure function get_scalar_from_vel_dens ( vel , dens ) result ( scalar ) import :: rk !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> momentum real ( kind = rk ) :: scalar end function get_scalar_from_vel_dens !> function pointer to get 1/rho as a mask regardless incompressibility pure function get_rho0Inv ( dens ) result ( inv_rho0 ) import :: rk !> density real ( kind = rk ), intent ( in ) :: dens !> inverse of density regardless compressibility real ( kind = rk ) :: inv_rho0 end function get_rho0Inv end interface contains ! ************************************************************************** ! !> This function assigns the pointers for the respective derived function in !  terms of stencil and fluid type function mus_assign_derived_functions_ptr ( label_stencil , label_fluid ) result ( getQuantities ) ! -------------------------------------------------------------------------- !> Scheme header information character ( len = labelLen ), intent ( in ) :: label_stencil !> Fluid label information character ( len = labelLen ), intent ( in ) :: label_fluid !> getQuantities function type ( mus_scheme_derived_quantities_type ) :: getQuantities ! -------------------------------------------------------------------------- getQuantities % pdfEq_ptr => null () getQuantities % pdfEq_iDir_ptr => null () getQuantities % vel_from_pdf_ptr => null () getQuantities % vel_from_pdf_vectorized_ptr => null () getQuantities % momentum_from_vel_dens_ptr => null () getQuantities % kineticEnergy_from_vel_dens_ptr => null () getQuantities % rho0Inv_ptr => null () if ( trim ( label_fluid ) == 'fluid' ) then getQuantities % pdfEq_iDir_ptr => get_pdfEq_compressible_iDir getQuantities % momentum_from_vel_dens_ptr => get_momentum_from_vel_dens_compressible getQuantities % kineticEnergy_from_vel_dens_ptr => get_kineticEnergy_from_vel_dens_compressible getQuantities % rho0Inv_ptr => get_rho0Inv_compressible else if ( trim ( label_fluid ) == 'fluid_incompressible' ) then getQuantities % pdfEq_iDir_ptr => get_pdfEq_incompressible_iDir getQuantities % momentum_from_vel_dens_ptr => get_momentum_from_vel_dens_incompressible getQuantities % kineticEnergy_from_vel_dens_ptr => get_kineticEnergy_from_vel_dens_incompressible getQuantities % rho0Inv_ptr => get_rho0Inv_incompressible else write ( logUnit ( 1 ), * ) 'fluid type = \"' , trim ( label_fluid ), '\"' write ( logUnit ( 1 ), * ) \"Warning: get_pdfEq_iDir not set for fluid type\" end if select case ( trim ( label_stencil )) case ( 'd2q9' ) if ( trim ( label_fluid ) == 'fluid' ) then getQuantities % pdfEq_ptr => get_pdfEq_d2q9 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d2q9 getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d2q9_vectorized else if ( trim ( label_fluid ) == 'fluid_incompressible' ) then getQuantities % pdfEq_ptr => get_pdfEq_incomp_d2q9 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d2q9_incompressible getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d2q9_vectorized_incompressible else write ( logUnit ( 1 ), * ) 'stencil label = \"' , trim ( label_stencil ), '\"' write ( logUnit ( 1 ), * ) 'fluid type = \"' , trim ( label_fluid ), '\"' write ( logUnit ( 1 ), * ) \"Warning: get_pdfEq not set for fluid type\" end if case ( 'd3q19' ) if ( trim ( label_fluid ) == 'fluid' ) then getQuantities % pdfEq_ptr => get_pdfEq_d3q19 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d3q19 getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d3q19_vectorized elseif ( trim ( label_fluid ) == 'fluid_incompressible' ) then getQuantities % pdfEq_ptr => get_pdfEq_incomp_d3q19 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d3q19_incompressible getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d3q19_vectorized_incompressible else write ( logUnit ( 1 ), * ) 'stencil label = \"' , trim ( label_stencil ), '\"' write ( logUnit ( 1 ), * ) 'fluid type = \"' , trim ( label_fluid ), '\"' write ( logUnit ( 1 ), * ) \"Warning: get_pdfEq not set for fluid type\" end if case ( 'd3q27' ) if ( trim ( label_fluid ) == 'fluid' ) then getQuantities % pdfEq_ptr => get_pdfEq_d3q27 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d3q27 getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d3q27_vectorized elseif ( trim ( label_fluid ) == 'fluid_incompressible' ) then getQuantities % pdfEq_ptr => get_pdfEq_incomp_d3q27 getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_d3q27_incompressible getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_d3q27_vectorized_incompressible else write ( logUnit ( 1 ), * ) 'stencil label = \"' , trim ( label_stencil ), '\"' write ( logUnit ( 1 ), * ) 'fluid type = \"' , trim ( label_fluid ), '\"' write ( logUnit ( 1 ), * ) \"Warning: get_pdfEq not set for fluid type\" end if case default if ( trim ( label_fluid ) == 'fluid' ) then getQuantities % pdfEq_ptr => get_pdfEq_compressible getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_compressible getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_compressible_vectorized elseif ( trim ( label_fluid ) == 'fluid_incompressible' ) then getQuantities % pdfEq_ptr => get_pdfEq_incompressible getQuantities % vel_from_pdf_ptr => get_vel_from_pdf_incompressible getQuantities % vel_from_pdf_vectorized_ptr => get_vel_from_pdf_incompressible_vectorized else write ( logUnit ( 1 ), * ) 'stencil label = \"' , trim ( label_stencil ), '\"' write ( logUnit ( 1 ), * ) 'fluid type = \"' , trim ( label_fluid ), '\"' write ( logUnit ( 1 ), * ) \"Warning: get_pdfEq not set for fluid type\" end if end select end function mus_assign_derived_functions_ptr ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density along a !  specific direction pure function get_pdfEq_incompressible_iDir ( rho , vel , iDir , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> direction of the pdf integer , intent ( in ) :: iDir !> velocity streaming normal along iDir real ( kind = rk ), intent ( in ) :: cxDirRK ( 3 ) !> weight along iDir real ( kind = rk ), intent ( in ) :: weight !> output: equilibrium pdf real ( kind = rk ) :: fEq ! -------------------------------------------------------------------------- fEq = weight * ( rho + rho0 * ( cs2inv * sum ( cxDirRK (:) * vel (:)) & & + ( sum ( cxDirRK (:) * vel (:)) * sum ( cxDirRK (:) * vel (:)) ) & & * cs4inv * 0.5_rk - sum ( vel (:) * vel (:)) * 0.5_rk * cs2inv ) ) end function get_pdfEq_incompressible_iDir ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density along a !  specific direction pure function get_pdfEq_compressible_iDir ( rho , vel , iDir , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> direction of the pdf integer , intent ( in ) :: iDir !> velocity streaming normal along iDir real ( kind = rk ), intent ( in ) :: cxDirRK ( 3 ) !> weight along iDir real ( kind = rk ), intent ( in ) :: weight !> output: equilibrium pdf real ( kind = rk ) :: fEq ! -------------------------------------------------------------------------- fEq = weight * rho * ( 1._rk + ( cs2inv * sum ( cxDirRK (:) * vel (:)) & & + ( sum ( cxDirRK (:) * vel (:)) * sum ( cxDirRK (:) * vel (:)) ) & & * cs4inv * 0.5_rk - sum ( vel (:) * vel (:)) * 0.5_rk * cs2inv ) ) end function get_pdfEq_compressible_iDir ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density along a !  specific direction pure function get_pdfEq_incompressible ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- integer :: iDir ! -------------------------------------------------------------------------- do iDir = 1 , QQ fEq ( iDir ) = weight ( iDir ) * ( rho + rho0 * ( cs2inv * sum ( cxDirRK (:, iDir ) * vel (:)) & & + ( sum ( cxDirRK (:, iDir ) * vel (:)) * sum ( cxDirRK (:, iDir ) * vel (:)) ) & & * cs4inv * 0.5_rk - sum ( vel (:) * vel (:)) * 0.5_rk * cs2inv ) ) end do end function get_pdfEq_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density along a !  specific direction pure function get_pdfEq_compressible ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- integer :: iDir ! -------------------------------------------------------------------------- do iDir = 1 , QQ fEq = weight ( iDir ) * rho * ( 1._rk + ( cs2inv * sum ( cxDirRK (:, iDir ) * vel (:)) & & + ( sum ( cxDirRK (:, iDir ) * vel (:)) * sum ( cxDirRK (:, iDir ) * vel (:)) ) & & * cs4inv * 0.5_rk - sum ( vel (:) * vel (:)) * 0.5_rk * cs2inv ) ) end do end function get_pdfEq_compressible ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the sigma vector necessary to get the !  equilibrium pdf from velocity and density for d2q9 stencil. pure function get_sigma_d2q9 ( vel ) result ( sigma ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> output: sigma vector real ( kind = rk ) :: sigma ( 9 ) ! -------------------------------------------------------------------------- sigma ( 9 ) = vel ( 1 ) + vel ( 2 ) sigma ( 8 ) = vel ( 1 ) - vel ( 2 ) sigma ( 7 ) = 3._rk * sigma ( 9 ) sigma ( 6 ) = 3._rk * sigma ( 8 ) sigma ( 5 ) = 4.5_rk * sigma ( 9 ) ** 2 sigma ( 4 ) = 4.5_rk * sigma ( 8 ) ** 2 sigma ( 3 ) = 4.5_rk * vel ( 1 ) ** 2 sigma ( 2 ) = 4.5_rk * vel ( 2 ) ** 2 sigma ( 1 ) = div1_3 * ( sigma ( 2 ) + sigma ( 3 ) ) end function get_sigma_d2q9 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the equilibrium pdf from velocity !  and density for d2q9 stencil. pure function get_pdfEq_d2q9 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 9 ), rho_div_9 , rho_div_36 ! -------------------------------------------------------------------------- sigma = get_sigma_d2q9 ( vel ) rho_div_9 = div1_9 * rho rho_div_36 = div1_36 * rho fEq ( 1 ) = ( - rho_div_9 * ( sigma ( 1 ) + 3._rk * vel ( 1 ) - sigma ( 3 ) - 1._rk ) ) fEq ( 2 ) = ( - rho_div_9 * ( sigma ( 1 ) + 3._rk * vel ( 2 ) - sigma ( 2 ) - 1._rk ) ) fEq ( 3 ) = ( rho_div_9 * ( 3._rk * vel ( 1 ) - sigma ( 1 ) + sigma ( 3 ) + 1._rk ) ) fEq ( 4 ) = ( rho_div_9 * ( 3._rk * vel ( 2 ) - sigma ( 1 ) + sigma ( 2 ) + 1._rk ) ) fEq ( 5 ) = ( - rho_div_36 * ( sigma ( 1 ) - sigma ( 5 ) + sigma ( 7 ) - 1._rk ) ) fEq ( 6 ) = ( - rho_div_36 * ( sigma ( 1 ) - sigma ( 4 ) + sigma ( 6 ) - 1._rk ) ) fEq ( 7 ) = ( rho_div_36 * ( sigma ( 4 ) - sigma ( 1 ) + sigma ( 6 ) + 1._rk ) ) fEq ( 8 ) = ( rho_div_36 * ( sigma ( 5 ) - sigma ( 1 ) + sigma ( 7 ) + 1._rk ) ) fEq ( 9 ) = ( - div4_9 * rho * ( sigma ( 1 ) - 1._rk ) ) end function get_pdfEq_d2q9 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the incompressible equilibrium pdf from velocity !  and density for d2q9 stencil. pure function get_pdfEq_incomp_d2q9 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 9 ), rho_div_9 , rho_div_36 , rho0_div_9 , rho0_div_36 ! -------------------------------------------------------------------------- sigma = get_sigma_d2q9 ( vel ) rho_div_9 = div1_9 * rho rho_div_36 = div1_36 * rho rho0_div_9 = div1_9 * rho0 rho0_div_36 = div1_36 * rho0 fEq ( 1 ) = ( rho_div_9 - rho0_div_9 * ( sigma ( 1 ) + 3._rk * vel ( 1 ) - sigma ( 3 ) ) ) fEq ( 2 ) = ( rho_div_9 - rho0_div_9 * ( sigma ( 1 ) + 3._rk * vel ( 2 ) - sigma ( 2 ) ) ) fEq ( 3 ) = ( rho_div_9 + rho0_div_9 * ( 3._rk * vel ( 1 ) - sigma ( 1 ) + sigma ( 3 ) ) ) fEq ( 4 ) = ( rho_div_9 + rho0_div_9 * ( 3._rk * vel ( 2 ) - sigma ( 1 ) + sigma ( 2 ) ) ) fEq ( 5 ) = ( rho_div_36 - rho0_div_36 * ( sigma ( 1 ) - sigma ( 5 ) + sigma ( 7 ) ) ) fEq ( 6 ) = ( rho_div_36 - rho0_div_36 * ( sigma ( 1 ) - sigma ( 4 ) + sigma ( 6 ) ) ) fEq ( 7 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 4 ) - sigma ( 1 ) + sigma ( 6 ) ) ) fEq ( 8 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 5 ) - sigma ( 1 ) + sigma ( 7 ) ) ) fEq ( 9 ) = ( div4_9 * rho - div4_9 * rho0 * sigma ( 1 ) ) end function get_pdfEq_incomp_d2q9 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the sigma vector necessary to get the !  equilibrium pdf from velocity and density for d3q19 stencil. pure function get_sigma_d3q19 ( vel ) result ( sigma ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> output: sigma vector real ( kind = rk ) :: sigma ( 22 ) ! -------------------------------------------------------------------------- sigma ( 22 ) = vel ( 1 ) + vel ( 2 ) sigma ( 21 ) = vel ( 1 ) - vel ( 2 ) sigma ( 20 ) = vel ( 1 ) + vel ( 3 ) sigma ( 19 ) = vel ( 1 ) - vel ( 3 ) sigma ( 18 ) = vel ( 2 ) + vel ( 3 ) sigma ( 17 ) = vel ( 2 ) - vel ( 3 ) sigma ( 16 ) = 3._rk * sigma ( 22 ) sigma ( 15 ) = 3._rk * sigma ( 21 ) sigma ( 14 ) = 3._rk * sigma ( 20 ) sigma ( 13 ) = 3._rk * sigma ( 19 ) sigma ( 12 ) = 3._rk * sigma ( 18 ) sigma ( 11 ) = 3._rk * sigma ( 17 ) sigma ( 10 ) = 4.5_rk * sigma ( 22 ) ** 2 sigma ( 9 ) = 4.5_rk * sigma ( 21 ) ** 2 sigma ( 8 ) = 4.5_rk * sigma ( 20 ) ** 2 sigma ( 7 ) = 4.5_rk * sigma ( 19 ) ** 2 sigma ( 6 ) = 4.5_rk * sigma ( 18 ) ** 2 sigma ( 5 ) = 4.5_rk * sigma ( 17 ) ** 2 sigma ( 4 ) = 4.5_rk * vel ( 1 ) ** 2 sigma ( 3 ) = 4.5_rk * vel ( 2 ) ** 2 sigma ( 2 ) = 4.5_rk * vel ( 3 ) ** 2 sigma ( 1 ) = div1_3 * ( sigma ( 2 ) + sigma ( 3 ) + sigma ( 4 ) ) end function get_sigma_d3q19 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the equilibrium pdf from velocity !  and density for d3q19 stencil. pure function get_pdfEq_d3q19 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 22 ), rho_div_18 , rho_div_36 ! -------------------------------------------------------------------------- sigma = get_sigma_d3q19 ( vel ) rho_div_18 = div1_18 * rho rho_div_36 = div1_36 * rho fEq ( 1 ) = ( - rho_div_18 * ( 3._rk * vel ( 1 ) - sigma ( 4 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 2 ) = ( - rho_div_18 * ( 3._rk * vel ( 2 ) - sigma ( 3 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 3 ) = ( - rho_div_18 * ( 3._rk * vel ( 3 ) - sigma ( 2 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 4 ) = ( rho_div_18 * ( 3._rk * vel ( 1 ) + sigma ( 4 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 5 ) = ( rho_div_18 * ( 3._rk * vel ( 2 ) + sigma ( 3 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 6 ) = ( rho_div_18 * ( 3._rk * vel ( 3 ) + sigma ( 2 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 7 ) = ( rho_div_36 * ( sigma ( 6 ) - sigma ( 12 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 8 ) = ( rho_div_36 * ( sigma ( 5 ) - sigma ( 11 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 9 ) = ( rho_div_36 * ( sigma ( 5 ) + sigma ( 11 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 10 ) = ( rho_div_36 * ( sigma ( 6 ) + sigma ( 12 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 11 ) = ( rho_div_36 * ( sigma ( 8 ) - sigma ( 14 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 12 ) = ( rho_div_36 * ( sigma ( 7 ) + sigma ( 13 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 13 ) = ( rho_div_36 * ( sigma ( 7 ) - sigma ( 13 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 14 ) = ( rho_div_36 * ( sigma ( 8 ) + sigma ( 14 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 15 ) = ( rho_div_36 * ( sigma ( 10 ) - sigma ( 16 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 16 ) = ( rho_div_36 * ( sigma ( 9 ) - sigma ( 15 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 17 ) = ( rho_div_36 * ( sigma ( 9 ) + sigma ( 15 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 18 ) = ( rho_div_36 * ( sigma ( 10 ) + sigma ( 16 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 19 ) = ( - div1_3 * rho * ( sigma ( 1 ) - 1._rk ) ) end function get_pdfEq_d3q19 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the incompressible equilibrium pdf from velocity !  and density for d3q19 stencil. pure function get_pdfEq_incomp_d3q19 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 22 ), rho_div_18 , rho_div_36 , rho0_div_18 , rho0_div_36 ! -------------------------------------------------------------------------- sigma = get_sigma_d3q19 ( vel ) rho_div_18 = div1_18 * rho rho_div_36 = div1_36 * rho rho0_div_18 = div1_18 * rho0 rho0_div_36 = div1_36 * rho0 fEq ( 1 ) = ( rho_div_18 - rho0_div_18 * ( 3._rk * vel ( 1 ) - sigma ( 4 ) + sigma ( 1 ) ) ) fEq ( 2 ) = ( rho_div_18 - rho0_div_18 * ( 3._rk * vel ( 2 ) - sigma ( 3 ) + sigma ( 1 ) ) ) fEq ( 3 ) = ( rho_div_18 - rho0_div_18 * ( 3._rk * vel ( 3 ) - sigma ( 2 ) + sigma ( 1 ) ) ) fEq ( 4 ) = ( rho_div_18 + rho0_div_18 * ( 3._rk * vel ( 1 ) + sigma ( 4 ) - sigma ( 1 ) ) ) fEq ( 5 ) = ( rho_div_18 + rho0_div_18 * ( 3._rk * vel ( 2 ) + sigma ( 3 ) - sigma ( 1 ) ) ) fEq ( 6 ) = ( rho_div_18 + rho0_div_18 * ( 3._rk * vel ( 3 ) + sigma ( 2 ) - sigma ( 1 ) ) ) fEq ( 7 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 6 ) - sigma ( 12 ) - sigma ( 1 ) ) ) fEq ( 8 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 5 ) - sigma ( 11 ) - sigma ( 1 ) ) ) fEq ( 9 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 5 ) + sigma ( 11 ) - sigma ( 1 ) ) ) fEq ( 10 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 6 ) + sigma ( 12 ) - sigma ( 1 ) ) ) fEq ( 11 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 8 ) - sigma ( 14 ) - sigma ( 1 ) ) ) fEq ( 12 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 7 ) + sigma ( 13 ) - sigma ( 1 ) ) ) fEq ( 13 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 7 ) - sigma ( 13 ) - sigma ( 1 ) ) ) fEq ( 14 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 8 ) + sigma ( 14 ) - sigma ( 1 ) ) ) fEq ( 15 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 10 ) - sigma ( 16 ) - sigma ( 1 ) ) ) fEq ( 16 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 9 ) - sigma ( 15 ) - sigma ( 1 ) ) ) fEq ( 17 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 9 ) + sigma ( 15 ) - sigma ( 1 ) ) ) fEq ( 18 ) = ( rho_div_36 + rho0_div_36 * ( sigma ( 10 ) + sigma ( 16 ) - sigma ( 1 ) ) ) fEq ( 19 ) = ( div1_3 * rho - div1_3 * rho0 * sigma ( 1 ) ) end function get_pdfEq_incomp_d3q19 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the sigma vector necessary to get the !  equilibrium pdf from velocity and density for d3q27 stencil. pure function get_sigma_d3q27 ( vel ) result ( sigma ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> output: sigma vector real ( kind = rk ) :: sigma ( 34 ) ! -------------------------------------------------------------------------- sigma ( 34 ) = vel ( 1 ) + vel ( 2 ) sigma ( 33 ) = vel ( 1 ) - vel ( 2 ) sigma ( 32 ) = vel ( 1 ) + vel ( 3 ) sigma ( 31 ) = vel ( 1 ) - vel ( 3 ) sigma ( 30 ) = vel ( 2 ) + vel ( 3 ) sigma ( 29 ) = vel ( 2 ) - vel ( 3 ) sigma ( 28 ) = vel ( 1 ) + vel ( 2 ) + vel ( 3 ) sigma ( 27 ) = vel ( 1 ) + vel ( 2 ) - vel ( 3 ) sigma ( 26 ) = vel ( 1 ) - vel ( 2 ) + vel ( 3 ) sigma ( 25 ) = vel ( 2 ) - vel ( 1 ) + vel ( 3 ) sigma ( 24 ) = 3._rk * sigma ( 34 ) sigma ( 23 ) = 3._rk * sigma ( 33 ) sigma ( 22 ) = 3._rk * sigma ( 32 ) sigma ( 21 ) = 3._rk * sigma ( 31 ) sigma ( 20 ) = 3._rk * sigma ( 30 ) sigma ( 19 ) = 3._rk * sigma ( 29 ) sigma ( 18 ) = 3._rk * sigma ( 28 ) sigma ( 17 ) = 3._rk * sigma ( 27 ) sigma ( 16 ) = 3._rk * sigma ( 26 ) sigma ( 15 ) = 3._rk * sigma ( 25 ) sigma ( 14 ) = 4.5_rk * sigma ( 34 ) ** 2 sigma ( 13 ) = 4.5_rk * sigma ( 33 ) ** 2 sigma ( 12 ) = 4.5_rk * sigma ( 32 ) ** 2 sigma ( 11 ) = 4.5_rk * sigma ( 31 ) ** 2 sigma ( 10 ) = 4.5_rk * sigma ( 30 ) ** 2 sigma ( 9 ) = 4.5_rk * sigma ( 29 ) ** 2 sigma ( 8 ) = 4.5_rk * sigma ( 28 ) ** 2 sigma ( 7 ) = 4.5_rk * sigma ( 27 ) ** 2 sigma ( 6 ) = 4.5_rk * sigma ( 26 ) ** 2 sigma ( 5 ) = 4.5_rk * sigma ( 25 ) ** 2 sigma ( 4 ) = 4.5_rk * vel ( 1 ) ** 2 sigma ( 3 ) = 4.5_rk * vel ( 2 ) ** 2 sigma ( 2 ) = 4.5_rk * vel ( 3 ) ** 2 sigma ( 1 ) = div1_3 * ( sigma ( 2 ) + sigma ( 3 ) + sigma ( 4 ) ) end function get_sigma_d3q27 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the equilibrium pdf from velocity !  and density for d3q27 stencil. pure function get_pdfEq_d3q27 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 34 ), rho_div2_27 , rho_div_54 , rho_div_216 ! -------------------------------------------------------------------------- sigma = get_sigma_d3q27 ( vel ) rho_div2_27 = div2_27 * rho rho_div_54 = div1_54 * rho rho_div_216 = div1_216 * rho fEq ( 1 ) = ( - rho_div2_27 * ( 3._rk * vel ( 1 ) - sigma ( 4 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 2 ) = ( - rho_div2_27 * ( 3._rk * vel ( 2 ) - sigma ( 3 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 3 ) = ( - rho_div2_27 * ( 3._rk * vel ( 3 ) - sigma ( 2 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 4 ) = ( rho_div2_27 * ( 3._rk * vel ( 1 ) + sigma ( 4 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 5 ) = ( rho_div2_27 * ( 3._rk * vel ( 2 ) + sigma ( 3 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 6 ) = ( rho_div2_27 * ( 3._rk * vel ( 3 ) + sigma ( 2 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 7 ) = ( rho_div_54 * ( sigma ( 10 ) - sigma ( 20 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 8 ) = ( rho_div_54 * ( sigma ( 9 ) - sigma ( 19 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 9 ) = ( rho_div_54 * ( sigma ( 9 ) + sigma ( 19 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 10 ) = ( rho_div_54 * ( sigma ( 10 ) + sigma ( 20 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 11 ) = ( rho_div_54 * ( sigma ( 12 ) - sigma ( 22 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 12 ) = ( rho_div_54 * ( sigma ( 11 ) + sigma ( 21 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 13 ) = ( rho_div_54 * ( sigma ( 11 ) - sigma ( 21 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 14 ) = ( rho_div_54 * ( sigma ( 12 ) + sigma ( 22 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 15 ) = ( rho_div_54 * ( sigma ( 14 ) - sigma ( 24 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 16 ) = ( rho_div_54 * ( sigma ( 13 ) - sigma ( 23 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 17 ) = ( rho_div_54 * ( sigma ( 13 ) + sigma ( 23 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 18 ) = ( rho_div_54 * ( sigma ( 14 ) + sigma ( 24 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 19 ) = ( - rho_div_216 * ( sigma ( 18 ) - sigma ( 8 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 20 ) = ( - rho_div_216 * ( sigma ( 17 ) - sigma ( 7 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 21 ) = ( - rho_div_216 * ( sigma ( 16 ) - sigma ( 6 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 22 ) = ( rho_div_216 * ( sigma ( 15 ) + sigma ( 5 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 23 ) = ( - rho_div_216 * ( sigma ( 15 ) - sigma ( 5 ) + sigma ( 1 ) - 1._rk ) ) fEq ( 24 ) = ( rho_div_216 * ( sigma ( 16 ) + sigma ( 6 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 25 ) = ( rho_div_216 * ( sigma ( 17 ) + sigma ( 7 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 26 ) = ( rho_div_216 * ( sigma ( 18 ) + sigma ( 8 ) - sigma ( 1 ) + 1._rk ) ) fEq ( 27 ) = ( - div8_27 * rho * ( sigma ( 1 ) - 1._rk ) ) end function get_pdfEq_d3q27 ! ************************************************************************** ! ! ************************************************************************** ! !> This function computes the incompressible equilibrium pdf from velocity !  and density for d3q27 stencil. pure function get_pdfEq_incomp_d3q27 ( rho , vel , QQ , cxDirRK , weight ) & & result ( fEq ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: rho !> velocity real ( kind = rk ), intent ( in ) :: vel ( 3 ) !> size of the pdf integer , intent ( in ) :: QQ !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> weight along iDir real ( kind = rk ), optional , intent ( in ) :: weight (:) !> output: equilibrium pdf real ( kind = rk ) :: fEq ( QQ ) ! -------------------------------------------------------------------------- real ( kind = rk ) :: sigma ( 34 ), rho_div2_27 , rho_div_54 , rho_div_216 real ( kind = rk ) :: rho0_div2_27 , rho0_div_54 , rho0_div_216 ! -------------------------------------------------------------------------- sigma = get_sigma_d3q27 ( vel ) rho_div2_27 = div2_27 * rho rho_div_54 = div1_54 * rho rho_div_216 = div1_216 * rho rho0_div2_27 = div2_27 * rho0 rho0_div_54 = div1_54 * rho0 rho0_div_216 = div1_216 * rho0 fEq ( 1 ) = ( rho_div2_27 - rho0_div2_27 * ( 3._rk * vel ( 1 ) - sigma ( 4 ) + sigma ( 1 ) ) ) fEq ( 2 ) = ( rho_div2_27 - rho0_div2_27 * ( 3._rk * vel ( 2 ) - sigma ( 3 ) + sigma ( 1 ) ) ) fEq ( 3 ) = ( rho_div2_27 - rho0_div2_27 * ( 3._rk * vel ( 3 ) - sigma ( 2 ) + sigma ( 1 ) ) ) fEq ( 4 ) = ( rho_div2_27 + rho0_div2_27 * ( 3._rk * vel ( 1 ) + sigma ( 4 ) - sigma ( 1 ) ) ) fEq ( 5 ) = ( rho_div2_27 + rho0_div2_27 * ( 3._rk * vel ( 2 ) + sigma ( 3 ) - sigma ( 1 ) ) ) fEq ( 6 ) = ( rho_div2_27 + rho0_div2_27 * ( 3._rk * vel ( 3 ) + sigma ( 2 ) - sigma ( 1 ) ) ) fEq ( 7 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 10 ) - sigma ( 20 ) - sigma ( 1 ) ) ) fEq ( 8 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 9 ) - sigma ( 19 ) - sigma ( 1 ) ) ) fEq ( 9 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 9 ) + sigma ( 19 ) - sigma ( 1 ) ) ) fEq ( 10 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 10 ) + sigma ( 20 ) - sigma ( 1 ) ) ) fEq ( 11 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 12 ) - sigma ( 22 ) - sigma ( 1 ) ) ) fEq ( 12 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 11 ) + sigma ( 21 ) - sigma ( 1 ) ) ) fEq ( 13 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 11 ) - sigma ( 21 ) - sigma ( 1 ) ) ) fEq ( 14 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 12 ) + sigma ( 22 ) - sigma ( 1 ) ) ) fEq ( 15 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 14 ) - sigma ( 24 ) - sigma ( 1 ) ) ) fEq ( 16 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 13 ) - sigma ( 23 ) - sigma ( 1 ) ) ) fEq ( 17 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 13 ) + sigma ( 23 ) - sigma ( 1 ) ) ) fEq ( 18 ) = ( rho_div_54 + rho0_div_54 * ( sigma ( 14 ) + sigma ( 24 ) - sigma ( 1 ) ) ) fEq ( 19 ) = ( rho_div_216 - rho0_div_216 * ( sigma ( 18 ) - sigma ( 8 ) + sigma ( 1 ) ) ) fEq ( 20 ) = ( rho_div_216 - rho0_div_216 * ( sigma ( 17 ) - sigma ( 7 ) + sigma ( 1 ) ) ) fEq ( 21 ) = ( rho_div_216 - rho0_div_216 * ( sigma ( 16 ) - sigma ( 6 ) + sigma ( 1 ) ) ) fEq ( 22 ) = ( rho_div_216 + rho0_div_216 * ( sigma ( 15 ) + sigma ( 5 ) - sigma ( 1 ) ) ) fEq ( 23 ) = ( rho_div_216 - rho0_div_216 * ( sigma ( 15 ) - sigma ( 5 ) + sigma ( 1 ) ) ) fEq ( 24 ) = ( rho_div_216 + rho0_div_216 * ( sigma ( 16 ) + sigma ( 6 ) - sigma ( 1 ) ) ) fEq ( 25 ) = ( rho_div_216 + rho0_div_216 * ( sigma ( 17 ) + sigma ( 7 ) - sigma ( 1 ) ) ) fEq ( 26 ) = ( rho_div_216 + rho0_div_216 * ( sigma ( 18 ) + sigma ( 8 ) - sigma ( 1 ) ) ) fEq ( 27 ) = ( div8_27 * rho - div8_27 * rho0 * sigma ( 1 ) ) end function get_pdfEq_incomp_d3q27 ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_compressible ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = sum ( pdf * cxDirRK ( 1 ,:) ) vel ( 2 ) = sum ( pdf * cxDirRK ( 2 ,:) ) vel ( 3 ) = sum ( pdf * cxDirRK ( 3 ,:) ) vel = vel / dens end function get_vel_from_pdf_compressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_compressible_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_compressible ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_compressible_vectorized ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_incompressible ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = sum ( pdf * cxDirRK ( 1 ,:) ) vel ( 2 ) = sum ( pdf * cxDirRK ( 2 ,:) ) vel ( 3 ) = sum ( pdf * cxDirRK ( 3 ,:) ) vel = vel * rho0Inv end function get_vel_from_pdf_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_incompressible_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_incompressible ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_incompressible_vectorized ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d2q9 stencil pure function get_vel_from_pdf_d2q9 ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 3 ) - pdf ( 1 ) - pdf ( 5 ) - pdf ( 6 ) + pdf ( 7 ) + pdf ( 8 ) vel ( 2 ) = pdf ( 4 ) - pdf ( 2 ) - pdf ( 5 ) + pdf ( 6 ) - pdf ( 7 ) + pdf ( 8 ) vel ( 3 ) = 0._rk vel = vel / dens end function get_vel_from_pdf_d2q9 ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d2q9_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d2q9 ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d2q9_vectorized ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d2q9 stencil pure function get_vel_from_pdf_d2q9_incompressible ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 3 ) - pdf ( 1 ) - pdf ( 5 ) - pdf ( 6 ) + pdf ( 7 ) + pdf ( 8 ) vel ( 2 ) = pdf ( 4 ) - pdf ( 2 ) - pdf ( 5 ) + pdf ( 6 ) - pdf ( 7 ) + pdf ( 8 ) vel ( 3 ) = 0._rk vel = vel * rho0Inv end function get_vel_from_pdf_d2q9_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d2q9_vectorized_incompressible ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d2q9_incompressible ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d2q9_vectorized_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d3q19 stencil pure function get_vel_from_pdf_d3q19 ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 4 ) - pdf ( 1 ) - pdf ( 11 ) + pdf ( 12 ) - pdf ( 13 ) + pdf ( 14 ) - pdf ( 15 ) & & - pdf ( 16 ) + pdf ( 17 ) + pdf ( 18 ) vel ( 2 ) = pdf ( 5 ) - pdf ( 2 ) - pdf ( 7 ) - pdf ( 8 ) + pdf ( 9 ) + pdf ( 10 ) - pdf ( 15 ) & & + pdf ( 16 ) - pdf ( 17 ) + pdf ( 18 ) vel ( 3 ) = pdf ( 6 ) - pdf ( 3 ) - pdf ( 7 ) + pdf ( 8 ) - pdf ( 9 ) + pdf ( 10 ) - pdf ( 11 ) & & - pdf ( 12 ) + pdf ( 13 ) + pdf ( 14 ) vel = vel / dens end function get_vel_from_pdf_d3q19 ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d3q19_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d3q19 ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d3q19_vectorized ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d3q19 stencil pure function get_vel_from_pdf_d3q19_incompressible ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 4 ) - pdf ( 1 ) - pdf ( 11 ) + pdf ( 12 ) - pdf ( 13 ) + pdf ( 14 ) - pdf ( 15 ) & & - pdf ( 16 ) + pdf ( 17 ) + pdf ( 18 ) vel ( 2 ) = pdf ( 5 ) - pdf ( 2 ) - pdf ( 7 ) - pdf ( 8 ) + pdf ( 9 ) + pdf ( 10 ) - pdf ( 15 ) & & + pdf ( 16 ) - pdf ( 17 ) + pdf ( 18 ) vel ( 3 ) = pdf ( 6 ) - pdf ( 3 ) - pdf ( 7 ) + pdf ( 8 ) - pdf ( 9 ) + pdf ( 10 ) - pdf ( 11 ) & & - pdf ( 12 ) + pdf ( 13 ) + pdf ( 14 ) vel = vel * rho0Inv end function get_vel_from_pdf_d3q19_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d3q19_vectorized_incompressible ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d3q19_incompressible ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d3q19_vectorized_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d3q27 stencil pure function get_vel_from_pdf_d3q27 ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 4 ) - pdf ( 1 ) - pdf ( 11 ) + pdf ( 12 ) - pdf ( 13 ) + pdf ( 14 ) - pdf ( 15 ) & & - pdf ( 16 ) + pdf ( 17 ) + pdf ( 18 ) - pdf ( 19 ) - pdf ( 20 ) - pdf ( 21 ) & & - pdf ( 22 ) + pdf ( 23 ) + pdf ( 24 ) + pdf ( 25 ) + pdf ( 26 ) vel ( 2 ) = pdf ( 5 ) - pdf ( 2 ) - pdf ( 7 ) - pdf ( 8 ) + pdf ( 9 ) + pdf ( 10 ) - pdf ( 15 ) & & + pdf ( 16 ) - pdf ( 17 ) + pdf ( 18 ) - pdf ( 19 ) - pdf ( 20 ) + pdf ( 21 ) & & + pdf ( 22 ) - pdf ( 23 ) - pdf ( 24 ) + pdf ( 25 ) + pdf ( 26 ) vel ( 3 ) = pdf ( 6 ) - pdf ( 3 ) - pdf ( 7 ) + pdf ( 8 ) - pdf ( 9 ) + pdf ( 10 ) - pdf ( 11 ) & & - pdf ( 12 ) + pdf ( 13 ) + pdf ( 14 ) - pdf ( 19 ) + pdf ( 20 ) - pdf ( 21 ) & & + pdf ( 22 ) - pdf ( 23 ) + pdf ( 24 ) - pdf ( 25 ) + pdf ( 26 ) vel = vel / dens end function get_vel_from_pdf_d3q27 ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d3q27_vectorized ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d3q27 ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d3q27_vectorized ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for d3q27 stencil pure function get_vel_from_pdf_d3q27_incompressible ( pdf , dens , cxDirRK ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:) !> density real ( kind = rk ), intent ( in ) :: dens !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> velocity real ( kind = rk ) :: vel ( 3 ) ! -------------------------------------------------------------------------- vel ( 1 ) = pdf ( 4 ) - pdf ( 1 ) - pdf ( 11 ) + pdf ( 12 ) - pdf ( 13 ) + pdf ( 14 ) - pdf ( 15 ) & & - pdf ( 16 ) + pdf ( 17 ) + pdf ( 18 ) - pdf ( 19 ) - pdf ( 20 ) - pdf ( 21 ) & & - pdf ( 22 ) + pdf ( 23 ) + pdf ( 24 ) + pdf ( 25 ) + pdf ( 26 ) vel ( 2 ) = pdf ( 5 ) - pdf ( 2 ) - pdf ( 7 ) - pdf ( 8 ) + pdf ( 9 ) + pdf ( 10 ) - pdf ( 15 ) & & + pdf ( 16 ) - pdf ( 17 ) + pdf ( 18 ) - pdf ( 19 ) - pdf ( 20 ) + pdf ( 21 ) & & + pdf ( 22 ) - pdf ( 23 ) - pdf ( 24 ) + pdf ( 25 ) + pdf ( 26 ) vel ( 3 ) = pdf ( 6 ) - pdf ( 3 ) - pdf ( 7 ) + pdf ( 8 ) - pdf ( 9 ) + pdf ( 10 ) - pdf ( 11 ) & & - pdf ( 12 ) + pdf ( 13 ) + pdf ( 14 ) - pdf ( 19 ) + pdf ( 20 ) - pdf ( 21 ) & & + pdf ( 22 ) - pdf ( 23 ) + pdf ( 24 ) - pdf ( 25 ) + pdf ( 26 ) vel = vel * rho0Inv end function get_vel_from_pdf_d3q27_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get pdf equilibrium from vel and density for any stencil pure function get_vel_from_pdf_d3q27_vectorized_incompressible ( pdf , dens , cxDirRK , nSolve ) result ( vel ) ! -------------------------------------------------------------------------- !> pdf real ( kind = rk ), intent ( in ) :: pdf (:,:) !> density real ( kind = rk ), intent ( in ) :: dens (:) !> velocity streaming normal along iDir real ( kind = rk ), optional , intent ( in ) :: cxDirRK (:,:) !> number of element to compute integer , intent ( in ) :: nSolve !> velocity real ( kind = rk ) :: vel ( 3 , vlen ) ! -------------------------------------------------------------------------- integer :: iSolve ! -------------------------------------------------------------------------- do iSolve = 1 , nSolve vel (:, iSolve ) = get_vel_from_pdf_d3q27_incompressible ( pdf = pdf (:, iSolve ), & & dens = dens ( iSolve ), & & cxDirRK = cxDirRK ) end do end function get_vel_from_pdf_d3q27_vectorized_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get momentum from vel and density for any stencil pure function get_momentum_from_vel_dens_compressible ( vel , dens ) result ( vector ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> momentum real ( kind = rk ) :: vector ( 3 ) ! -------------------------------------------------------------------------- vector = vel * dens end function get_momentum_from_vel_dens_compressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get momentum from vel and density for any stencil pure function get_momentum_from_vel_dens_incompressible ( vel , dens ) result ( vector ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> momentum real ( kind = rk ) :: vector ( 3 ) ! -------------------------------------------------------------------------- vector = vel * rho0 end function get_momentum_from_vel_dens_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get kineticEnergy from vel and density for any stencil pure function get_kineticEnergy_from_vel_dens_compressible ( vel , dens ) result ( scalar ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> kineticEnergy real ( kind = rk ) :: scalar ! -------------------------------------------------------------------------- scalar = sum ( vel (:) * vel (:) ) * 0.5_rk * dens end function get_kineticEnergy_from_vel_dens_compressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get kineticEnergy from vel and density for any stencil pure function get_kineticEnergy_from_vel_dens_incompressible ( vel , dens ) result ( scalar ) ! -------------------------------------------------------------------------- !> velocity real ( kind = rk ), intent ( in ) :: vel (:) !> density real ( kind = rk ), intent ( in ) :: dens !> kineticEnergy real ( kind = rk ) :: scalar ! -------------------------------------------------------------------------- scalar = sum ( vel (:) * vel (:) ) * 0.5_rk * rho0 end function get_kineticEnergy_from_vel_dens_incompressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get kineticEnergy from vel and density for any stencil pure function get_rho0Inv_compressible ( dens ) result ( inv_rho0 ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: dens !> kineticEnergy real ( kind = rk ) :: inv_rho0 ! -------------------------------------------------------------------------- inv_rho0 = 1._rk / dens end function get_rho0Inv_compressible ! ************************************************************************** ! ! ************************************************************************** ! !> function pointer to get kineticEnergy from vel and density for any stencil pure function get_rho0Inv_incompressible ( dens ) result ( inv_rho0 ) ! -------------------------------------------------------------------------- !> density real ( kind = rk ), intent ( in ) :: dens !> kineticEnergy real ( kind = rk ) :: inv_rho0 ! -------------------------------------------------------------------------- inv_rho0 = rho0Inv end function get_rho0Inv_incompressible ! ************************************************************************** ! end module mus_scheme_derived_quantities_module","tags":"","loc":"sourcefile/mus_scheme_derived_quantities_type_module.f90.html"},{"title":"mus_abortCriteria_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_abortcriteria_module.f90~~AfferentGraph sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geomincrhead_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_param_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2021 Harald Klimach <harald.klimach@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! ! !> Musubi specific criteria to abort the simulation. !> !! This module provies the [[mus_abortCriteria_type]] that holds parameters for !! simulation aborts. !! The configuration parameters are read from the `abort_criteria` table in !! `sim_control`, see also [[tem_simControl_module]]. !! !! Additional parameters for Musubi in the `abort_criteria` table: !! !! * velocity_lat_max: The maximal lattice velocity that may appear in the !!                     domain. Defaults to 0.15. !!                     Lattice velocities larger than 0.1 are considered to !!                     produce large errors. !! !! A simple complete example for the Musubi `abort_criteria` table within the !! `sim_control` table is: !! !!```lua !!    abort_criteria = { !!      stop_file = 'stop', !!      velocity_lat_max = 0.15 -- Maximum lattice velocity for Musubi !!    } !!``` !! module mus_abortCriteria_module use aotus_module , only : flu_state , aot_get_val use env_module , only : rk use tem_abortCriteria_module , only : tem_solverAborts_type implicit none private !> Musubi specific abort criteria. type , public , extends ( tem_solverAborts_type ) :: mus_abortCriteria_type !> Maximal lattice velocity that will be tolerated in the simulation. !! The lattice velocity should usually be smaller than 0.1. real ( kind = rk ) :: velLat_max = 0.15_rk contains procedure :: load => mus_abortCriteria_load end type mus_abortCriteria_type contains ! ------------------------------------------------------------------------ ! !> Loading Musubi specific abort criteria from the `abort_criteria` table. !! !! This routine is passed to the loading of abort criteria in !! [[tem_abortcriteria_module:tem_abortcriteria_load]]. subroutine mus_abortCriteria_load ( me , conf , abort_table ) ! -------------------------------------------------------------------- ! !> Object to hold the solver specific configuration parameters. class ( mus_abortCriteria_type ), intent ( inout ) :: me !> Handle to the Lua script with the configuration. type ( flu_state ), intent ( in ) :: conf !> Handle to the opened `abort_criteria` table that holds the !! abort parameters to load. integer , intent ( in ) :: abort_table ! -------------------------------------------------------------------- ! integer :: iErr ! -------------------------------------------------------------------- ! call aot_get_val ( L = conf , & & thandle = abort_table , & & val = me % velLat_max , & & key = 'velocity_lat_max' , & & default = 0.15_rk , & & ErrCode = iErr ) end subroutine mus_abortCriteria_load ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! end module mus_abortCriteria_module","tags":"","loc":"sourcefile/mus_abortcriteria_module.f90.html"},{"title":"mus_bc_poisson_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_bc_poisson_module.f90~~EfferentGraph sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_enrtl_module.f90 mus_eNRTL_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_enrtl_module.f90 sourcefile~mus_mixture_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2017-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2018 Jana Gericke <jana.gericke@uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> Boundary condition treatment routines for Poisson equation !! !! A detailed description on the implementation details are given in !! boundary_implementation !! module mus_bc_poisson_module ! include treelm modules use env_module , only : rk , eps use tem_time_module , only : tem_time_type use treelmesh_module , only : treelmesh_type use tem_varSys_module , only : tem_varSys_type use tem_construction_module , only : tem_levelDesc_type use tem_debug_module , only : dbgUnit ! include musubi modules use mus_bc_header_module , only : boundary_type , glob_boundary_type use mus_scheme_layout_module , only : mus_scheme_layout_type use mus_field_prop_module , only : mus_field_prop_type use mus_derVarPos_module , only : mus_derVarPos_type use mus_param_module , only : mus_param_type use mus_physics_module , only : mus_physics_type use mus_mixture_module , only : mus_mixture_type implicit none private public :: potential_nonEqExpol public :: potential_nonEqExpol_curved public :: potential_neumann public :: potential_neumann_curved contains ! ****************************************************************************** ! !> Linkwise Dirichlet potential non-equilibrium boundary condition for curved !> and straight walls. For straight wall, physical boundary overlaps with !! boundary node i.e. qVal=0.0. !! !! The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part: !! f = f_eq(x_b,t) + f_neq(x_f,t) !! !! Usage !! ----- !!```lua !!boundary_condition = { !!  { label = 'inner', !!    kind = 'potential_noneq_expol', !!    potential = pot_inner, !!  } !!} !!``` !! For straight boundaries, qVal=1.0: !! Luo, K., Wu, J., Yi, H., & Tan, H. (2016). Lattice Boltzmann model for !! Coulomb-driven flows in dielectric liquids dielectric liquids. !! Physical Review E, 23309(93), 1–11. !! http://doi.org/10.1103/PhysRevE.93.023309 ! subroutine potential_nonEqExpol !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine potential_nonEqExpol ( me , state , bcBuffer , globBC , levelDesc , & & tree , nSize , iLevel , sim_time , neigh , & & layout , fieldProp , varPos , nScalars , & & varSys , derVarPos , physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> iLevel descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! also determined in mus_bc_header_module integer :: iDir ! variables for fictious boundary element real ( kind = rk ) :: feq_b ! variables for fluid element real ( kind = rk ) :: feq_ff , pot_f , pot_ff , pot_b real ( kind = rk ) :: inv_pot ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdf_f ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! potential on surface (link-wise) real ( kind = rk ) :: pot_w ( globBC % nElems ( iLevel )) integer :: bcPot_pos , iLink , QQ , QQN ! --------------------------------------------------------------------------- QQ = layout % fstencil % QQ QQN = layout % fstencil % QQN inv_pot = 1._rk / physics % fac ( iLevel )% potential ! position of boundary potential in varSys bcPot_pos = me % bc_states % potential % varPos ! Get potential_phy on boundary call varSys % method % val ( bcPot_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % potential & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : globBC % nElems ( iLevel )), & & nVals = globBC % nElems ( iLevel ), & & res = pot_w ) ! convert physical potential into LB potential pot_w = pot_w * inv_pot associate ( neighBufferPost => me % neigh ( iLevel )% neighBufferPost , & & posInNeighBuf => me % nonEqExpol ( iLevel )% posInNeighBuf , & & posInBCelems => me % nonEqExpol ( iLevel )% posInBCelems , & & posInBuffer => me % nonEqExpol ( iLevel )% posInBuffer ) do iLink = 1 , me % links ( iLevel )% nVals ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) pdf_f ( 1 : QQ ) = bcBuffer ( ( posInBuffer ( iLink ) - 1 ) * nScalars + varPos ( 1 ) & & : ( posInBuffer ( iLink ) - 1 ) * nScalars + varPos ( QQ ) ) pot_f = sum ( pdf_f ) ! determine needed quantities of the overnext fluid neighbor element ! x_ff pdf_ff = neighBufferPost ( 1 , ( posInNeighBuf ( iLink ) - 1 ) * QQ + 1 & & : ( posInNeighBuf ( iLink ) - 1 ) * QQ + QQ ) pot_ff = sum ( pdf_ff ) ! fEq_loc is local element value feq_ff = layout % weight ( iDir ) * pot_ff ! compute potential on boundary (eq.18) pot_b = 3.0_rk * pot_w ( posInBCelems ( iLink )) - pot_f - pot_ff ! compute equlibrium (according to eq.17) ! fEq_b is on boundary node feq_b = layout % weight ( iDir ) * pot_b ! write into state ! feq_b + fneq_ff ! fneq is computed from post-collision pdf so no need to multiply ! (1-omega) as in the literature state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + ( pdf_ff ( iDir ) - feq_ff ) end do !iLink end associate end subroutine potential_nonEqExpol ! ****************************************************************************** ! ! ****************************************************************************** ! !> Linkwise Dirichlet potential non-equilibrium boundary condition for curved !! wall !! !! The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part: !! f = f_eq + f_neq !! - f_eq is calculated by weighting a fictitious potential, which is obtained !!   by an extrapolation using the fluid neighbor(s) !! - f_neq is approximated by second-order extrapolation using the fluid !!   neighbor(s) !! - for qVal < 0.75 even the second neighbor is used for the extrapolations !! - Dirichlet: potential on wall is directly known !! - Linkwise: as much as possible is outsourced to the subroutine !!             \"mus_set_nonEqExpol\" !! !! Usage !! ----- !!```lua !!boundary_condition = { !!  { label = 'inner', !!    kind = 'potential_noneq_expol', !!    potential = pot_inner, !!    curved = true !!  } !!} !!``` !! This is described in the paper: !! Luo, K.; Wu, J.; Yi HL. & Tan HP. (2016). A lattice Boltzmann method for !! electric field-space charge coupled problems. !! Proceedings of the 2016 Electrostatics Joint Conference (June 2016). !! ! subroutine potential_nonEqExpol !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine potential_nonEqExpol_curved ( me , state , bcBuffer , globBC , & & levelDesc , tree , nSize , iLevel , & & sim_time , neigh , layout , fieldProp , & & varPos , nScalars , varSys , derVarPos , & & physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> iLevel descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! coefficients which are calculated in mus_bc_header_module real ( kind = rk ) :: c_w , c_f , c_ff , c_neq_f , c_neq_ff ! also determined in mus_bc_header_module integer :: iDir , posInBuffer , posInNeighBuf ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , pot_b ! variables for fluid element real ( kind = rk ) :: feq_f , fneq_f , pot_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , pot_ff real ( kind = rk ) :: inv_pot ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdf_f ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! potential on surface (link-wise) real ( kind = rk ) :: pot_w ( me % links ( iLevel )% nVals ) integer :: bcPot_pos , iLink , QQ , QQN ! --------------------------------------------------------------------------- QQ = layout % fstencil % QQ QQN = layout % fstencil % QQN inv_pot = 1._rk / physics % fac ( iLevel )% potential ! position of boundary potential in varSys bcPot_pos = me % bc_states % potential % varPos ! Get potential_phy on boundary call varSys % method % val ( bcPot_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % potential & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = pot_w ) ! convert physical potential into LB potential pot_w = pot_w * inv_pot do iLink = 1 , me % links ( iLevel )% nVals ! load coefficients c_w = me % nonEqExpol ( iLevel )% c_w ( iLink ) c_f = me % nonEqExpol ( iLevel )% c_f ( iLink ) c_ff = me % nonEqExpol ( iLevel )% c_ff ( iLink ) c_neq_f = me % nonEqExpol ( iLevel )% c_neq_f ( iLink ) c_neq_ff = me % nonEqExpol ( iLevel )% c_neq_ff ( iLink ) ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdf_f ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) pot_f = sum ( pdf_f ) ! calulate potential of the overnext fluid neighbor element (_ff) posInNeighBuf = me % nonEqExpol ( iLevel )% posInNeighBuf ( iLink ) pdf_ff = me % neigh ( iLevel )% neighBufferPost ( 1 , & & ( posInNeighBuf - 1 ) * QQ + 1 : ( posInNeighBuf - 1 ) * QQ + QQ ) pot_ff = sum ( pdf_ff ) ! compute potential on boundary (eq.18) pot_b = c_w * pot_w ( iLink ) + c_f * pot_f + c_ff * pot_ff ! compute equlibrium (according to eq.17) ! fEq_b is on boundary node feq_b = layout % weight ( iDir ) * pot_b ! fEq_loc is local element value feq_f = layout % weight ( iDir ) * pot_f ! feq_ff is of overnext fluid feq_ff = layout % weight ( iDir ) * pot_ff ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdf_f ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff fneq_b = c_nEq_f * fneq_f + c_nEq_ff * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end subroutine potential_nonEqExpol_curved ! ****************************************************************************** ! ! ****************************************************************************** ! !> Linkwise neumann potential non-equilibrium boundary condition for curved !> and straight walls (zero gradient). !! For straight wall, values are extrapolated along !! boundary normal instead of along the link. The accuracy of straight wall !! depends on the qVal defined in config file and default is set to 0.5 !! !! The pdf is decomposed into equilibrium (eq) and non-equilibrium (neq) part: !! - f_eq is calculated by weighting a fictitious potential, which is obtained !!   by an extrapolation using the fluid neighbor(s) !! - f_neq is approximated by second-order extrapolation using the fluid !!   neighbor(s) !! - for qVal < 0.75 even the second neighbor is used for the extrapolations !! - boundary potential (pot_b) has to be extrapolated using two fluid neighb: !!   pot_b = (4*pot_f - pot_ff)/3 (typo in paper) !! - Linkwise: as much as possible is outsourced to the subroutine !!             \"mus_set_nonEqExpol\" !! !! NOTE: - possibility to extend the equation to extraplotate pot_b by a !!         gradient if a non-zero one is desired !!         (see: Huang H, Lee T S, and Shu C. “Thermal curved boundary !!               treatment for the thermal lattice Boltzmann equation,” !!               Int. J. Mod. Phys. C, vol. 17(05), pp. 631-643, 2006) !!       - more accurate schemes to determine pot_b can be found in: !!         Chen Q, Zhang X, and Zhang J. “Improved treatments for general !!         boundary conditions in the lattice Boltzmann method for convection- !!         diffusion and heat transfer processes,” Phys Rev E, vol. 88(3), !!         033304, 2013 !! !! Usage !! ----- !!```lua !!boundary_condition = { !!  { label = 'outer', !!    kind = 'potential_neumann_link', !!    curved = true !!  } !!} !!``` !! This is described in the paper: !! Luo, K.; Wu, J.; Yi HL. & Tan HP. (2016). A lattice Boltzmann method for !! electric field-space charge coupled problems. !! Proceedings of the 2016 Electrostatics Joint Conference (June 2016). !! ! subroutine potential_neumann !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine potential_neumann ( me , state , bcBuffer , globBC , levelDesc , tree , & & nSize , iLevel , sim_time , neigh , layout , & & fieldProp , varPos , nScalars , varSys , & & derVarPos , physics , iField , mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> iLevel descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! also determined in mus_bc_header_module integer :: iDir ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , pot_b ! variables for fluid element real ( kind = rk ) :: feq_f , fneq_f , pot_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , pot_ff ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdf_f ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! surface charge density on surface (link-wise) real ( kind = rk ) :: surChargeDens_w ( me % links ( iLevel )% nVals ) integer :: iLink , QQ integer :: bcSCD_pos real ( kind = rk ) :: inv_permittivity real ( kind = rk ) :: normal ( 3 ), surChargeDens_fac ! --------------------------------------------------------------------------- !write(*,*) 'bclabel ', trim(me%label) QQ = layout % fStencil % QQ ! position of boundary surface charge density variable in varSys bcSCD_pos = me % bc_states % surChargeDens % varPos ! Get potential_phy on boundary call varSys % method % val ( bcSCD_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % surChargeDens & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = surChargeDens_w ) ! convert physical surface charge density into Lattice unit surChargeDens_w = surChargeDens_w * physics % dxLvl ( iLevel ) ** 2 & & / physics % coulomb0 inv_permittivity = 1.0_rk / fieldProp % poisson % permittivity associate ( neighBufferPost => me % neigh ( iLevel )% neighBufferPost , & & posInNeighBuf => me % nonEqExpol ( iLevel )% posInNeighBuf , & & posInBCelems => me % nonEqExpol ( iLevel )% posInBCelems , & & posInBuffer => me % nonEqExpol ( iLevel )% posInBuffer ) do iLink = 1 , me % links ( iLevel )% nVals ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) pdf_f ( 1 : QQ ) = bcBuffer ( ( posInBuffer ( iLink ) - 1 ) * nScalars + varPos ( 1 ) & & : ( posInBuffer ( iLink ) - 1 ) * nScalars + varPos ( QQ ) ) pot_f = sum ( pdf_f ) ! calulate potential of the overnext fluid neighbor element (_ff) pdf_ff = neighBufferPost ( 1 , ( posInNeighBuf ( iLink ) - 1 ) * QQ + 1 & & : ( posInNeighBuf ( iLink ) - 1 ) * QQ + QQ ) pot_ff = sum ( pdf_ff ) normal = globBC % elemLvl ( iLevel )% normal & & % val (:, me % nonEqExpol ( iLevel )% posInBCelems ( iLink )) surChargeDens_fac = - surChargeDens_w ( iLink ) & & * inv_permittivity & & * dot_product ( layout % fStencil % cxDirRK (:, iDir ), & & normal ) ! calulate potential on boundary pot_b = ( 4.0_rk * pot_f - pot_ff - 2.0_rk * surChargeDens_fac ) / 3.0_rk ! compute equlibrium (according to eq.17) ! fEq_b is on boundary feq_b = layout % weight ( iDir ) * pot_b ! fEq_loc is local element value feq_f = layout % weight ( iDir ) * pot_f ! feq is of overnext fluid fEq_ff = layout % weight ( iDir ) * pot_ff ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdf_f ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff ! KM: For straight boundary, qVal is 0.5 in consistent with ! second order extrapolation of potential fneq_b = 0.5_rk * fneq_f + 0.5_rk * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end associate end subroutine potential_neumann ! ****************************************************************************** ! ! ****************************************************************************** ! !> No comment yet! !! !! @TODO add comment !! !! This subroutine's interface must match the abstract interface definition !! [[boundaryRoutine]] in bc/[[mus_bc_header_module]].f90 in order to be !! callable via [[boundary_type:fnct]] function pointer. subroutine potential_neumann_curved ( me , state , bcBuffer , globBC , levelDesc , & & tree , nSize , iLevel , sim_time , neigh , & & layout , fieldProp , varPos , nScalars , & & varSys , derVarPos , physics , iField , & & mixture ) ! -------------------------------------------------------------------- ! !> global boundary type class ( boundary_type ) :: me !> Current state vector of iLevel real ( kind = rk ), intent ( inout ) :: state (:) !> size of state array ( in terms of elements ) integer , intent ( in ) :: nSize !> state values of boundary elements of all fields of iLevel real ( kind = rk ), intent ( in ) :: bcBuffer (:) !> iLevel descriptor type ( tem_levelDesc_type ), intent ( in ) :: levelDesc !> Treelm Mesh type ( treelmesh_type ), intent ( in ) :: tree !> fluid parameters and properties type ( mus_field_prop_type ), intent ( in ) :: fieldProp !> stencil layout information type ( mus_scheme_layout_type ), intent ( in ) :: layout !> the level On which this boundary was invoked integer , intent ( in ) :: iLevel !> connectivity array corresponding to state vector integer , intent ( in ) :: neigh (:) !> global time information type ( tem_time_type ), intent ( in ) :: sim_time !> pointer to field variable in the state vector integer , intent ( in ) :: varPos (:) !> number of Scalars in the scheme var system integer , intent ( in ) :: nScalars !> scheme variable system type ( tem_varSys_type ), intent ( in ) :: varSys !> position of derived quantities in varsys type ( mus_derVarPos_type ), intent ( in ) :: derVarPos !> scheme global boundary type type ( glob_boundary_type ), intent ( in ) :: globBC !> scheme global boundary type type ( mus_physics_type ), intent ( in ) :: physics !> current field integer , intent ( in ) :: iField !> mixture info type ( mus_mixture_type ), intent ( in ) :: mixture ! -------------------------------------------------------------------- ! ! coefficients which are calculated in mus_bc_header_module real ( kind = rk ) :: c_neq_f , c_neq_ff ! also determined in mus_bc_header_module integer :: iDir , posInBuffer , posInNeighBuf ! variables for fictious boundary element real ( kind = rk ) :: feq_b , fneq_b , pot_b ! variables for fluid element real ( kind = rk ) :: feq_f , fneq_f , pot_f ! variables for overnext fluid element real ( kind = rk ) :: feq_ff , fneq_ff , pot_ff ! temporary local pdf values and the ones of overnext fluid real ( kind = rk ) :: pdf_f ( layout % fStencil % QQ ) real ( kind = rk ) :: pdf_ff ( layout % fStencil % QQ ) ! surface charge density on surface (link-wise) real ( kind = rk ) :: surChargeDens_w ( me % links ( iLevel )% nVals ) integer :: iLink , QQ integer :: bcSCD_pos real ( kind = rk ) :: inv_permittivity real ( kind = rk ) :: normal ( 3 ), surChargeDens_fac ! --------------------------------------------------------------------------- !write(*,*) 'bclabel ', trim(me%label) QQ = layout % fStencil % QQ ! position of boundary surface charge density variable in varSys bcSCD_pos = me % bc_states % surChargeDens % varPos ! Get potential_phy on boundary call varSys % method % val ( bcSCD_pos )% get_valOfIndex ( & & varSys = varSys , & & time = sim_time , & & iLevel = iLevel , & & idx = me % bc_states % surChargeDens & & % pntIndex % indexLvl ( ilevel ) & & % val ( 1 : me % links ( iLevel )% nVals ), & & nVals = me % links ( iLevel )% nVals , & & res = surChargeDens_w ) ! convert physical surface charge density into Lattice unit surChargeDens_w = surChargeDens_w * physics % dxLvl ( iLevel ) ** 2 & & / physics % coulomb0 inv_permittivity = 1.0_rk / fieldProp % poisson % permittivity do iLink = 1 , me % links ( iLevel )% nVals ! load coefficients c_neq_f = me % nonEqExpol ( iLevel )% c_neq_f ( iLink ) c_neq_ff = me % nonEqExpol ( iLevel )% c_neq_ff ( iLink ) ! link-wise direction iDir = me % nonEqExpol ( iLevel )% iDir ( iLink ) ! calulate potential of the current element (_f) posInBuffer = me % nonEqExpol ( iLevel )% posInBuffer ( iLink ) pdf_f ( 1 : QQ ) = bcBuffer ( ( posInBuffer - 1 ) * nScalars + varPos ( 1 ) : & & ( posInBuffer - 1 ) * nScalars + varPos ( QQ ) ) pot_f = sum ( pdf_f ) ! calulate potential of the overnext fluid neighbor element (_ff) posInNeighBuf = me % nonEqExpol ( iLevel )% posInNeighBuf ( iLink ) pdf_ff = me % neigh ( iLevel )% neighBufferPost ( 1 , & & ( posInNeighBuf - 1 ) * QQ + 1 : ( posInNeighBuf - 1 ) * QQ + QQ ) pot_ff = sum ( pdf_ff ) !write(*,*) 'normal ', globBC%elemLvl(iLevel)%normal%val(:, me%nonEqExpol(iLevel)%posInBCelems(iLink)) !write(*,*) 'normal Ind', globBC%elemLvl(iLevel)%normalInd%val(me%nonEqExpol(iLevel)%posInBCelems(iLink)) normal = globBC % elemLvl ( iLevel )% normal & & % val (:, me % nonEqExpol ( iLevel )% posInBCelems ( iLink )) surChargeDens_fac = - surChargeDens_w ( iLink ) * inv_permittivity & & * dot_product ( layout % fStencil % cxDirRK (:, iDir ), normal ) ! calulate potential on boundary pot_b = ( 4.0_rk * pot_f - pot_ff - 2.0_rk * surChargeDens_fac ) / 3.0_rk ! compute equlibrium (according to eq.17) ! fEq_b is on boundary fEq_b = layout % weight ( iDir ) * pot_b ! fEq_loc is local element value fEq_f = layout % weight ( iDir ) * pot_f ! feq is of overnext fluid fEq_ff = layout % weight ( iDir ) * pot_ff ! use pdf_b = fEq_b + fneq_b (eq.16) to determine ! non-equilibrium components (eq.19) fneq_f = pdf_f ( iDir ) - feq_f fneq_ff = pdf_ff ( iDir ) - feq_ff fneq_b = c_nEq_f * fneq_f + c_nEq_ff * fneq_ff state ( me % links ( iLevel )% val ( iLink ) ) = feq_b + fneq_b end do !iLink end subroutine potential_neumann_curved ! ****************************************************************************** ! end module mus_bc_poisson_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_bc_poisson_module.f90.html"},{"title":"mus_absorbLayer_module.f90 – Musubi","text":"Files dependent on this one sourcefile~~mus_absorblayer_module.f90~~AfferentGraph sourcefile~mus_absorblayer_module.f90 mus_absorbLayer_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_source_type_module.f90->sourcefile~mus_absorblayer_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_module.f90 mus_source_var_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_source_var_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90 mus_source_var_turbChanForce_module.f90 sourcefile~mus_source_var_turbchanforce_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_source_var_turbchanforce_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2021 Kannan Masilamani <kannan.masilamani@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> author: Kannan Masilamani !! Module containing subroutines for building MUSUBI specific absorbLayer source !! variables !! module mus_absorbLayer_module ! include treelm modules use env_module , only : rk , labelLen use tem_tools_module , only : upper_to_lower use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit use tem_tools_module , only : tem_horizontalSpacer ! include aotus modules use aotus_module , only : flu_State , aot_get_val , aoterr_Fatal , & & aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_table_open , aot_table_close , aot_get_val implicit none private public :: mus_absorbLayer_type public :: mus_absorbLayer_dynAvg_type public :: mus_load_absorbLayer public :: mus_init_absorbLayer ! ************************************************************************** ! !! Make target_pressure and target_velocity as stFun. !> Contains additional information for absorblayer source type absorbLayer_config_type !> target pressure real ( kind = rk ) :: target_pressure !> target velocityX, velocityY and velocityZ real ( kind = rk ) :: target_velocity ( 3 ) !> Use time average for pressure. Default: false. logical :: isPressDyn = . false . !> Use time average for Velocity. Default: false. logical :: isVelDyn = . false . !> Number of iterations to record for time-averaging integer :: nRecord = 100 end type absorbLayer_config_type ! ************************************************************************** ! ! ************************************************************************** ! !> Stores time average values of density and velocity for dynamic absorbLayer type mus_absorbLayer_dynAvg_type !> density time average in lattice unit real ( kind = rk ), allocatable :: dens (:) !> velocity time average in lattice unit real ( kind = rk ), allocatable :: velX (:) real ( kind = rk ), allocatable :: velY (:) real ( kind = rk ), allocatable :: velZ (:) !> It is used to initialiye dynamic average density with initial condition logical :: isInitDens = . true . !> It is used to initialiye dynamic average velocity with initial condition logical :: isInitVel = . true . end type mus_absorbLayer_dynAvg_type ! ************************************************************************** ! ! ************************************************************************** ! !> Contains information for absorblayer type mus_absorbLayer_type !> Information loaded from configuration file type ( absorbLayer_config_type ) :: config !> Smoothing factor for expoential moving average !! = 2 / (nRecord+1) real ( kind = rk ) :: smoothFac end type mus_absorbLayer_type ! ************************************************************************** ! contains ! ************************************************************************** ! !> This routine load additional information for absorblayer subroutine mus_load_absorbLayer ( me , conf , key , parent , loadPres , loadVel ) ! -------------------------------------------------------------------------! !> Absorb layer type ( absorbLayer_config_type ), intent ( out ) :: me !> flu state type ( flu_State ) :: conf !> Table name to load target states character ( len =* ), intent ( in ) :: key !> parent source handle integer , intent ( in ) :: parent !> Load pressure if true else set to dynamic logical , intent ( in ) :: loadPres !> Load velocity if true else set to dynamic logical , intent ( in ) :: loadVel ! -------------------------------------------------------------------------! integer :: target_handle , iError , vError ( 3 ), errFatal ( 3 ) character ( len = labelLen ) :: tarStateAsStr ! -------------------------------------------------------------------------! errfatal = aotErr_Fatal call aot_table_open ( L = conf , & & parent = parent , & & thandle = target_handle , & & key = trim ( key ) ) ! Load target pressure and velocity only for static absorblayer write ( logUnit ( 1 ), * ) ' * Target state:' ! target state: pressure if ( loadPres ) then call aot_get_val ( L = conf , & & thandle = target_handle , & & key = 'pressure' , & & val = me % target_pressure , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading target pressure as value' write ( logUnit ( 5 ), * ) 'Trying to load as string' call aot_get_val ( L = conf , & & thandle = target_handle , & & key = 'pressure' , & & val = tarStateAsStr , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading target pressure as string' call tem_abort () end if if ( upper_to_lower ( trim ( tarStateAsStr )) == 'dynamic' ) then me % isPressDyn = . true . me % target_pressure = 0.0_rk write ( logUnit ( 1 ), * ) \"    pressure = dynamic'\" else call tem_abort ( 'Target pressure is neither value or string \"dynamic\"' ) end if else write ( logUnit ( 1 ), * ) '    pressure =' , me % target_pressure end if else me % isPressDyn = . true . me % target_pressure = 0.0_rk write ( logUnit ( 1 ), * ) \"    pressure = 'dynamic'\" end if ! target state: velocity if ( loadVel ) then call aot_get_val ( L = conf , & & thandle = target_handle , & & key = 'velocity' , & & val = me % target_velocity , & & ErrCode = vError ) if ( any ( btest ( vError , errFatal )) ) then write ( logUnit ( 1 ), * ) 'Error loading target velocity as table' write ( logUnit ( 5 ), * ) 'Trying to load as string' call aot_get_val ( L = conf , & & thandle = target_handle , & & key = 'velocity' , & & val = tarStateAsStr , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( logUnit ( 1 ), * ) 'Error loading target velocity as string' call tem_abort () end if if ( upper_to_lower ( trim ( tarStateAsStr )) == 'dynamic' ) then me % isVelDyn = . true . me % target_velocity = 0.0_rk write ( logUnit ( 1 ), * ) \"    velocity = dynamic'\" else call tem_abort ( 'Target velocity is neither value or string \"dynamic\"' ) end if else write ( logUnit ( 1 ), * ) '    velocity =' , me % target_velocity ( 1 : 3 ) end if else me % isVelDyn = . true . me % target_velocity = 0.0_rk write ( logUnit ( 1 ), * ) \"    velocity = 'dynamic'\" end if ! Load nRecord for time averaging if ( me % isPressDyn . or . me % isVelDyn ) then call aot_get_val ( L = conf , & & thandle = target_handle , & & key = 'nrecord' , & & val = me % nRecord , & & ErrCode = iError ) if ( btest ( iError , aoterr_Fatal )) then write ( * , * ) 'FATAL Error occured, when loading nrecord for absorb layer' call tem_abort () end if write ( logUnit ( 1 ), * ) '    nRecord =' , me % nRecord end if call aot_table_close ( conf , target_handle ) end subroutine mus_load_absorbLayer ! ************************************************************************** ! ! ************************************************************************** ! !> Initialize arrays to store time average density and velocity for !! dynamic absorbing layer. !! \\todo KM: 20210301 Allocate only pressure or velocity depending on !! absorb_layer_inlet or absorb_layer_outlet subroutine mus_init_absorbLayer ( absLayer , dynAvg , nElems ) ! -------------------------------------------------------------------------- !> Absorblayer type type ( mus_absorbLayer_type ), intent ( inout ) :: absLayer !> Contains dynamic average density and velocity for absorblayer type ( mus_absorbLayer_dynAvg_type ), intent ( inout ) :: dynAvg !> Number of source elements integer , intent ( in ) :: nElems ! -------------------------------------------------------------------------- if ( absLayer % config % isPressDyn . or . absLayer % config % isVelDyn ) then allocate ( dynAvg % dens ( nElems )) allocate ( dynAvg % velX ( nElems )) allocate ( dynAvg % velY ( nElems )) allocate ( dynAvg % velZ ( nElems )) dynAvg % dens (:) = 0.0_rk dynAvg % velX (:) = 0.0_rk dynAvg % velY (:) = 0.0_rk dynAvg % velZ (:) = 0.0_rk dynAvg % isInitDens = . true . dynAvg % isInitVel = . true . ! smooth factor for expontential average absLayer % smoothFac = 2.0_rk / ( absLayer % config % nRecord + 1.0_rk ) end if end subroutine mus_init_absorbLayer ! ************************************************************************** ! end module mus_absorbLayer_module","tags":"","loc":"sourcefile/mus_absorblayer_module.f90.html"},{"title":"mus_aux_module.f90 – Musubi","text":"Auxiliary functions to maintain the simulation This file depends on sourcefile~~mus_aux_module.f90~~EfferentGraph sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_turbulence_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_aux_module.f90~~AfferentGraph sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2022 Kannan Masilamani <kannan.masilamani@dlr.de> ! Copyright (c) 2011-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2011-2013,2020-2021 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2012-2015 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2012 Sathish Krishnan P S <s.krishnan@grs-sim.de> ! Copyright (c) 2012 Khaled Ibrahim <k.ibrahim@grs-sim.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! Copyright (c) 2022 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !! Auxiliary functions to maintain the simulation !! module mus_aux_module ! include musubi modules use mus_abortCriteria_module , only : mus_abortCriteria_type use mus_param_module , only : mus_param_type , mus_latticeUnit_type use mus_geom_module , only : mus_geom_type use mus_tools_module , only : perform_checks , & & check_streaming_layout use mus_interpolate_module , only : mus_init_interpolate use mus_source_module , only : mus_init_sourceTerms use mus_transport_var_module , only : mus_init_transport_var use mus_scheme_type_module , only : mus_scheme_type use mus_geomIncr_module , only : mus_geomIncr , mus_init_geomIncr use mus_interpolate_tools_module , only : debug_dependencies , dump_intpLists use mus_time_module , only : mus_time_homogenize , & & mus_timeControl_homogenize use mus_IBM_module , only : mus_IBM_setParentIDs , & & mus_IBM_globType use mus_fluid_module , only : mus_init_fluid use mus_gradData_module , only : mus_init_gradData use mus_relaxationParam_module , only : mus_update_relaxParamKine , & & mus_update_viscKine , & & mus_update_relaxParamFromViscSTfun use mus_turbulence_module , only : mus_turb_updateViscOfTurbWall use mus_field_module , only : setParameters_multispecies use mus_tracking_module , only : mus_init_tracker use mus_restart_module , only : mus_writeRestart use mus_timer_module , only : mus_timerHandles use mus_physics_module , only : mus_physics_type use mus_ppInfo_module , only : mus_print_ppInfo use mus_bndForce_module , only : mus_init_bndForce , mus_calcBndForce ! include treelm modules use env_module , only : rk , PathLen , pathSep , long_k use treelmesh_module , only : treelmesh_type use tem_aux_module , only : tem_print_execInfo , utc_date_string , & & tem_abort use tem_debug_module , only : dbgUnit use tem_restart_module , only : tem_init_restart use tem_tools_module , only : tem_horizontalSpacer use tem_tracking_module , only : tem_tracker use tem_convergence_module , only : tem_convergence_check , & & tem_init_convergence use tem_timeControl_module , only : tem_timeControl_check , & & tem_timeControl_update use tem_simControl_module , only : tem_simControl_syncUpdate use tem_time_module , only : tem_time_dump , tem_time_type use tem_debug_module , only : main_debug use tem_solveHead_module , only : tem_solveHead_type use tem_logging_module , only : logUnit use tem_global_module , only : tem_global_type use tem_depend_module , only : tem_init_depend use tem_spacetime_fun_module , only : tem_create_subTree_of_st_funList use tem_dyn_array_module , only : dyn_intArray_type use tem_timer_module , only : tem_getTimerVal use tem_general_module , only : tem_general_type use tem_operation_var_module , only : tem_opVar_reduction_transient_update implicit none private public :: check_flow_status public :: mus_init_aux public :: mus_update_relaxParams public :: mus_banner public :: mus_dumpData contains ! ------------------------------------------------------------------------ ! !> This routine performs several tasks: geometry increment, time updating, !! tracking, density checking, restart subroutine check_flow_status ( scheme , geometry , general , physics , mus_aborts ,& & restart_triggered ) ! -------------------------------------------------------------------- ! !> containers for the different schemes type ( mus_scheme_type ), target , intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> Global parameters type ( tem_general_type ), intent ( inout ) :: general !> physics conversion tyoe type ( mus_physics_type ), intent ( in ) :: physics type ( mus_abortCriteria_type ), intent ( in ) :: mus_aborts !> Indication whether a restart output was triggered logical , intent ( inout ) :: restart_triggered ! -------------------------------------------------------------------- ! ! -------------------------------------------------------------------- ! ! Force on boundary elements are computed from post-collision so calculate ! here after apply source and before tracking output write ( logUnit ( 10 ), \"(A)\" ) 'Calculated force on boundary elements' call mus_calcBndForce ( bndForce = geometry % bndForce , & & bndMoment = geometry % bndMoment , & & posInBndID = geometry % posInBndID , & & nBCs = geometry % boundary % nBCtypes , & & field = scheme % field , & & globBC = scheme % globBC , & & minLevel = geometry % tree % global % minLevel , & & maxLevel = geometry % tree % global % maxLevel , & & state = scheme % state , & & pdf = scheme % pdf , & & levelDesc = scheme % levelDesc , & & layout = scheme % layout , & & varSys = scheme % varSys , & & physics = physics ) ! Call the geometry increment module which  performs solidification ! or liquification based on certain criteria defined by the user if ( geometry % dynamicGeom ) then call mus_geomIncr ( & & geometry = geometry , scheme = scheme , & & commPattern = general % commPattern , & & general = general ) end if ! Perform run-time checks to ensure we did not encounter some unphysical ! state. call perform_checks ( & & scheme = scheme , & & minLevel = geometry % tree % global % minLevel , & & maxLevel = geometry % tree % global % maxLevel , & & general = general , & & mus_aborts = mus_aborts , & & initCheck = . false . ) ! check for convergence only if abortCriteria is set for steady_state if ( general % simControl % abortCriteria % steady_state ) then ! check for steady state convergence based on convergence criteria ! defined in convergence table call tem_convergence_check ( & & me = general % simControl % abortCriteria & & % convergence , & & time = general % simControl % now , & & status = general % simControl % status , & & varSys = scheme % varSys , & & tree = geometry % tree ) end if ! Update time reduction variables if there are any if ( scheme % redTransVarMap % varPos % nVals > 0 ) then call tem_opVar_reduction_transient_update ( & & redTransVarPos = scheme % redTransVarMap % varPos & & % val ( 1 : scheme % redTransVarMap % varPos % nVals ), & & varSys = scheme % varSys , & & tree = geometry % tree , & & time = general % simControl % now ) end if ! in musubi, advance time step separtely in control_routine so no need ! to pass dt to syncUpdate ! This sync update: check for stop file and time ! control interval trigger, communicate status bits and update timeControl call tem_simControl_syncUpdate ( me = general % simControl , & & proc = general % proc ) ! Dump tracking and restart if they are active call mus_dumpData ( & & scheme = scheme , & & tree = geometry % tree , & & restart_triggered = restart_triggered , & & general = general , & & levelPointer = geometry % levelPointer ) end subroutine check_flow_status ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Initialize musubi solverHead and print musubi banner to screen subroutine mus_banner ( solver ) ! -------------------------------------------------------------------- ! !> solver definition type ( tem_solveHead_type ), intent ( in ) :: solver ! -------------------------------------------------------------------- ! character ( len = 26 ) :: dat_string ! -------------------------------------------------------------------- ! write ( logUnit ( 1 ), \"(A)\" ) '' write ( logUnit ( 1 ), \"(A)\" ) \" .___  ___.  __    __       _______. __    __  .______    __  \" write ( logUnit ( 1 ), \"(A)\" ) \" |   \\/   | |  |  |  |     /       ||  |  |  | |   _  \\  |  | \" write ( logUnit ( 1 ), \"(A)\" ) \" |  \\  /  | |  |  |  |    |   (----`|  |  |  | |  |_)  | |  | \" write ( logUnit ( 1 ), \"(A)\" ) \" |  |\\/|  | |  |  |  |     \\   \\    |  |  |  | |   _  <  |  | \" write ( logUnit ( 1 ), \"(A)\" ) \" |  |  |  | |  `--'  | .----)   |   |  `--'  | |  |_)  | |  | \" write ( logUnit ( 1 ), \"(A)\" ) \" |__|  |__|  \\______/  |_______/     \\______/  |______/  |_\" & & // trim ( solver % version ) write ( logUnit ( 1 ), \"(A)\" ) '' write ( logUnit ( 1 ), \"(A)\" ) \" (C) 2012 German Research School\" & & // \" for Simulation Sciences\" write ( logUnit ( 1 ), \"(A)\" ) \" (C) 2013-2020 University Siegen\" write ( logUnit ( 1 ), \"(A)\" ) \" (C) 2021 German Aerospace Center (DLR) -\" write ( logUnit ( 1 ), \"(A)\" ) \"          Institute of Software Methods\" & & // \" for Product Virtualization\" write ( logUnit ( 1 ), \"(A)\" ) \" \" call tem_print_execInfo () call mus_print_ppInfo () write ( logUnit ( 1 ), \"(A)\" ) '' dat_string = utc_date_string () write ( logUnit ( 1 ), \"(A)\" ) \"Run at: \" // trim ( dat_string ) write ( logUnit ( 1 ), \"(A)\" ) '' end subroutine mus_banner ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Init auxiliary features such as interpolation boundaries, restart and !! the tracker subroutine mus_init_aux ( scheme , geometry , params ) ! -------------------------------------------------------------------- ! !> containers for the different schemes type ( mus_scheme_type ), target , intent ( inout ) :: scheme !> geometry information type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params ! -------------------------------------------------------------------- ! integer :: iConv integer :: iLevel , minLevel , maxLevel ! -------------------------------------------------------------------- ! minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel ! When the restart is read from separate restart table, we start the ! simulation from the time step given in restart file. In the case, ! when restart is read from initial condition table, the simulation start ! time step is taken as the one defined in configuration file call mus_time_homogenize ( & & me = params % general % simControl % now , & & dt = params % physics % dtLvl ( maxLevel ), & & readRestart = params % general % restart % controller & & % readRestart ) call mus_timeControl_homogenize ( & & me = params % general % simControl % timeControl , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) !> initialize fluid type which contains relaxation parameter !! and function pointers to get mrt paramter and nonEqScaling factor !! for interpolation select case ( trim ( scheme % header % kind ) ) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) if ( scheme % nFields > 1 ) then call tem_abort ( 'chosen scheme kind supports only one field' ) end if ! initialize fluid viscosity relaxation paramters call mus_init_fluid ( & & me = scheme % field ( 1 )% fieldProp % fluid , & & physics = params % physics , & & schemeHeader = scheme % header , & & minLevel = minLevel , & & maxLevel = maxLevel , & & levelDesc = scheme % levelDesc , & & pdf = scheme % pdf , & & stencil = scheme % layout % fStencil , & & general = params % general , & & tNow = params % general % simControl % now ) end select ! Initialize gradient data. Required for LES turbulent and evaluating ! gradient of a variable allocate ( scheme % gradData ( minLevel : maxLevel )) do iLevel = minLevel , maxLevel call mus_init_gradData ( & & me = scheme % gradData ( iLevel ), & & neigh = scheme % pdf ( iLevel )% neigh , & !&    levelDesc = scheme%levelDesc(iLevel),        & & stencil = scheme % layout % fStencil , & & nSize = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & nScalars = scheme % varSys % nScalars ) end do ! create subTree for all spacetime function in the linked list of ! spacetime function call tem_create_subTree_of_st_funList ( & & me = scheme % st_funList , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil ) ! initialize the source terms for all fields and global source call mus_init_sourceTerms ( & & field = scheme % field , & & nFields = scheme % nFields , & & globSrc = scheme % globSrc , & & varSys = scheme % varSys , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & nElems_solve = scheme % pdf (:)% nElems_solve , & & levelDesc = scheme % levelDesc , & & stencil = scheme % layout % fStencil ) ! initialize transport variables like velocity for passive scalar call mus_init_transport_var ( & & me = scheme % transVar , & & varSys = scheme % varSys , & & tree = geometry % tree , & & nElems_solve = scheme % pdf (:)% nElems_solve , & & levelDesc = scheme % levelDesc ) ! verify correct settings for the streaming layout call check_streaming_layout ( minLevel , maxLevel ) ! dynamic load balance time control homogenize if ( params % general % balance % dynamic ) then call mus_timeControl_homogenize ( & & me = params % general % balance % timeControl , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) endif if ( ( params % general % restart % controller % writeRestart . or . & & params % general % restart % controller % readRestart ) ) then ! initialize the restart write ( logUnit ( 1 ), * ) 'Initializing restart...' call tem_init_restart ( & & me = params % general % restart , & & solver = params % general % solver , & & varMap = scheme % stateVarMap , & & tree = geometry % tree ) call mus_timeControl_homogenize ( & & me = params % general % restart % controller % timeControl , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) end if ! initialize tracking objects. call mus_init_tracker ( & & scheme = scheme , & & geometry = geometry , & & params = params ) ! convergence objects if ( params % general % simControl % abortCriteria % steady_state ) then write ( logUnit ( 1 ), * ) 'Initializing convergence...' do iConv = 1 , size ( params % general % simControl % abortCriteria % convergence ) call mus_timeControl_homogenize ( & & me = params % general % simControl % abortCriteria & & % convergence ( iConv )% header % timeControl , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) end do call tem_init_convergence ( & & me = params % general % simControl & & % abortCriteria % convergence ,& & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil , & & globProc = params % general % proc , & & varSys = scheme % varSys ) end if if ( minLevel /= maxlevel ) then write ( logUnit ( 1 ), \"(A)\" ) 'Initializing interpolation...' ! initialize the interpolation call mus_init_interpolate ( & & intp = scheme % intp , & & levelDesc = scheme % levelDesc , & & schemeHeader = scheme % header , & & stencil = scheme % layout % fStencil , & & minLevel = minLevel , & & maxLevel = maxLevel , & & fieldProp = scheme % field (:)% fieldProp ) end if if ( main_debug % debugDependencies ) then call debug_dependencies ( scheme % intp , scheme % levelDesc , & & geometry % tree , params % general % proc % rank ) call dump_intpLists ( minLevel , maxLevel , scheme % intp % config % order , & & scheme % levelDesc , params % general % proc % rank ) end if ! Boundary force calculation is valid only for single field schemes ! like fluid and fluid_incompressible so initialize only if nFields = 1 if ( geometry % boundary % nBCtypes > 0 . and . scheme % nFields == 1 ) then call mus_init_bndForce ( bndForce = geometry % bndForce , & & bndMoment = geometry % bndMoment , & & bc_prop = geometry % boundary , & & schemeHeader = scheme % header , & & bc = scheme % field ( 1 )% bc ) end if ! initialize the surface data for the immersed boundary method write ( logUnit ( 1 ), * ) 'Initializing IBM surface data' call mus_IBM_setParentIDs ( & & nIBMs = geometry % globIBM % nIBMs , & & me = geometry % globIBM % ibm , & & levelDesc = scheme % levelDesc , & & tree = geometry % tree ) if ( geometry % dynamicGeom ) then write ( logUnit ( 1 ), * ) 'Initializing geomIncr ...' call mus_init_geomIncr ( & & me = geometry % geomIncr , & & varSys = scheme % varSys , & & dt = params % physics % dtLvl ( maxLevel ), & & reqInt = params % reqInterval ) write ( logUnit ( 1 ), * ) 'Done initializing geomIncr.' end if ! Time for geom incr call tem_horizontalSpacer ( after = 1 , fUnit = logUnit ( 1 ) ) end subroutine mus_init_aux ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Set relaxation parameters for MRT !! subroutine mus_update_relaxParams ( scheme , iLevel , tNow , physics , lattice , & & nBCs ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( inout ) :: scheme !> level integer , intent ( in ) :: iLevel !> global parameters type ( tem_time_type ), intent ( in ) :: tNow !> contains factors to convert physical to lattice unit and vice versa type ( mus_physics_type ), intent ( in ) :: physics !> contains lattice dx and dt type ( mus_latticeUnit_type ), intent ( in ) :: lattice !> Number of boundaries integer , intent ( in ) :: nBCs ! -------------------------------------------------------------------- ! integer :: iBnd ! -------------------------------------------------------------------- ! select case ( trim ( scheme % header % kind )) case ( 'fluid' , 'fluid_incompressible' ) ! Update kinematic viscosity from STfun and calculate turbulent viscosity ! from velocity gradient or nonEqPDF call mus_update_viscKine ( & & viscKine = scheme % field ( 1 )% fieldProp % fluid % viscKine , & & state = scheme % state ( iLevel )% val (:, & & scheme % pdf ( iLevel )% nNow ), & & neigh = scheme % pdf ( iLevel )% neigh , & & auxField = scheme % auxField ( iLevel )% val , & & gradData = scheme % gradData ( iLevel ), & & nSize = scheme % pdf ( iLevel )% nSize , & & nFluids = scheme % pdf ( iLevel )% nElems_fluid , & & nGhostFromCoarser = scheme % pdf ( iLevel )% nElems_ghostFromCoarser , & & nGhostFromFiner = scheme % pdf ( iLevel )% nElems_ghostFromFiner , & & nHalo = scheme % pdf ( iLevel )% nElems_halo , & & baryOfTotal = scheme % levelDesc ( iLevel )% baryOfTotal , & & varSys = scheme % varSys , & & iLevel = iLevel , & & layout = scheme % layout , & & tNow = tnow , & & convFac = physics % fac ( iLevel ), & & dxL = lattice % dxLvl ( iLevel ), & & dtL = lattice % dtLvl ( iLevel ), & & derVarPos = scheme % derVarPos ( 1 ), & & turb = scheme % field ( 1 )% fieldProp % fluid % turbulence , & & nNwtn = scheme % field ( 1 )% fieldProp % fluid % nNwtn , & & Grad = scheme % Grad ) ! Update turbulent viscosity for boundary elements of turbulent wall ! only for smagorinsky if ( scheme % field ( 1 )% fieldProp % fluid % turbulence % active . and . & & trim ( scheme % field ( 1 )% fieldProp % fluid % turbulence % config % model ) & & == 'smagorinsky' ) then do iBnd = 1 , nBCs select case ( trim ( scheme % field ( 1 )% bc ( iBnd )% BC_kind )) case ( 'turbulent_wall' , 'turbulent_wall_noneq_expol' , & & 'turbulent_wall_eq' ) call mus_turb_updateViscOfTurbWall ( & & turbData = scheme % field ( 1 )% fieldProp % fluid % turbulence & & % dataOnLvl ( iLevel ), & & viscTurbWall = scheme % field ( 1 )% bc ( iBnd )% turbwallFunc & & % dataOnLvl ( iLevel )% tVisc (:), & & nElems_bnd = scheme % globBC ( iBnd )% nElems ( iLevel ), & & elemPos = scheme % globBC ( iBnd )% elemLvl ( iLevel )% elem & & % val (:) ) end select end do end if ! update fluid relaxation parameter omega kine call mus_update_relaxParamKine ( & & viscKine = scheme % field ( 1 )% fieldProp % fluid % viscKine , & & turb = scheme % field ( 1 )% fieldProp % fluid % turbulence , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & iLevel = iLevel ) case ( 'multispecies_gas' , 'multispecies_liquid' ) call setParameters_multispecies ( & & field = scheme % field , & & nFields = scheme % nFields , & & mixture = scheme % mixture , & & header = scheme % header , & & layout = scheme % layout , & & iLevel = iLevel , & & tNow = tNow ) end select end subroutine mus_update_relaxParams ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine dumps tracking and restart when timeControl is active subroutine mus_dumpData ( scheme , tree , levelPointer , general , & & restart_triggered ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( inout ) :: scheme !> Treelmesh data type ( treelmesh_type ), intent ( in ) :: tree !> Level Pointer integer , intent ( in ) :: levelPointer (:) !> Global parameters type ( tem_general_type ), intent ( inout ) :: general !> logical , intent ( inout ) :: restart_triggered ! -------------------------------------------------------------------- ! if ( scheme % track % control % active ) then call tem_tracker ( & & track = scheme % track , & & simControl = general % simControl , & & tree = tree , & & varSys = scheme % varSys ) end if if ( general % restart % controller % writeRestart ) then ! check time control and update it if triggered call tem_timeControl_check ( & & me = general % restart % controller % timeControl , & & now = general % simControl % now , & & comm = general % proc % comm , & & triggered = restart_triggered ) if ( restart_triggered ) then if ( general % restart % lastWritten % iter & & == general % simControl % now % iter ) then write ( logUnit ( 1 ), * ) ' Restart file already written for current' & & // ' point in time!' else write ( logUnit ( 1 ), * ) ' Writing restart at:' call tem_time_dump ( general % simControl % now , logUnit ( 1 ) ) call mus_writeRestart ( levelPointer = levelPointer , & & restart = general % restart , & & scheme = scheme , & & tree = tree , & & timing = general % simControl % now , & & timerHandle = mus_timerHandles % wRestart ) write ( logUnit ( 1 ), * ) 'Done writing' end if end if end if end subroutine mus_dumpData ! ------------------------------------------------------------------------ ! end module mus_aux_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_aux_module.f90.html"},{"title":"mus_field_prop_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_field_prop_module.f90~~EfferentGraph sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_poisson_module.f90 mus_poisson_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_poisson_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_species_module.f90 mus_species_module.f90 sourcefile~mus_field_prop_module.f90->sourcefile~mus_species_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_poisson_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_species_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_vreman_module.f90 mus_Vreman_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_vreman_module.f90 sourcefile~mus_wale_module.f90 mus_WALE_module.f90 sourcefile~mus_turb_viscosity_module.f90->sourcefile~mus_wale_module.f90 sourcefile~mus_turbulence_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_dervarpos_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_layout_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_vreman_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_wale_module.f90->sourcefile~mus_turbulence_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_field_prop_module.f90~~AfferentGraph sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_bc_nernstplanck_module.f90 mus_bc_nernstPlanck_module.f90 sourcefile~mus_bc_nernstplanck_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_bc_poisson_module.f90 mus_bc_poisson_module.f90 sourcefile~mus_bc_poisson_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_field_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_interpolate_header_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90 mus_restart_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_source_module.f90 mus_source_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_auxfield_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_bc_var_module.f90 mus_bc_var_module.f90 sourcefile~mus_bc_var_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_source_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_construction_module.f90 mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_construction_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_restart_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_hvs_construction_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluid_module.f90 mus_initFluid_module.f90 sourcefile~mus_initfluid_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initfluidincomp_module.f90 mus_initFluidIncomp_module.f90 sourcefile~mus_initfluidincomp_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initisothermaceq_module.f90 mus_initIsothermAcEq_module.f90 sourcefile~mus_initisothermaceq_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initlbmps_module.f90 mus_initLBMPS_module.f90 sourcefile~mus_initlbmps_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initmultispecies_module.f90 mus_initMultispecies_module.f90 sourcefile~mus_initmultispecies_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initnernstplanck_module.f90 mus_initNernstPlanck_module.f90 sourcefile~mus_initnernstplanck_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_initpoisson_module.f90 mus_initPoisson_module.f90 sourcefile~mus_initpoisson_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_mesh_adaptation_module.f90 mus_mesh_adaptation_module.f90 sourcefile~mus_mesh_adaptation_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_restart_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_source_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_variable_module.f90->sourcefile~mus_bc_var_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016-2017, 2019-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2013 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2014 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2016 Philipp Otte <otte@mathcces.rwth-aachen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2017 Sindhuja Budaraju <nagasai.budaraju@student.uni-siegen.de> ! Copyright (c) 2019 Seyfettin Bilgi <seyfettin.bilgi@student.uni-siegen.de> ! Copyright (c) 2020 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! See copyright notice in he COPYRIGHT file. ! **************************************************************************** ! !> This module contains mus_field_prop_type and modules related !! to fiels properties. !! !! \\author Kannan Masilamani, Simon Zimny !! module mus_field_prop_module ! include treelm modules use env_module , only : rk , labelLen use tem_aux_module , only : tem_abort use tem_logging_module , only : logUnit ! include aotus modules use flu_binding , only : flu_State use aot_out_module , only : aot_out_type ! include musubi modules use mus_poisson_module , only : mus_load_poisson , & & mus_poisson_type use mus_scheme_header_module , only : mus_scheme_header_type use mus_fluid_module , only : mus_fluid_type , mus_load_fluid , & & mus_fluid_save2lua use mus_species_module , only : mus_species_type , mus_load_species , & & mus_species_out use mus_physics_module , only : mus_physics_type implicit none private public :: mus_field_prop_type public :: mus_load_field_prop public :: mus_field_prop_out !> This type contains parameter needed for field type mus_field_prop_type !> contains fluid information type ( mus_fluid_type ) :: fluid !> contains species information type ( mus_species_type ) :: species !> Contains information for poisson equation type ( mus_poisson_type ) :: poisson end type mus_field_prop_type contains ! **************************************************************************** ! !> load fluid properties like fluid and species table from !! lua file based on the scheme kind subroutine mus_load_field_prop ( me , conf , parent , minLevel , & & schemeHeader , nFields , physics , & & cs_lattice ) ! -------------------------------------------------------------------------- !> field property type type ( mus_field_prop_type ), intent ( out ) :: me !> number of fields defined in lua file integer , intent ( in ) :: nFields !> flu state type ( flu_State ), intent ( inout ) :: conf !> parent lua handle integer , intent ( in ), optional :: parent integer , intent ( in ) :: minLevel !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> physics type to convert physics to lattice unit or vice versa type ( mus_physics_type ), intent ( in ) :: physics !> lattice speed of sound calculated for defined stencil layout real ( kind = rk ), intent ( in ) :: cs_lattice ! -------------------------------------------------------------------------- ! load fluid info select case ( trim ( schemeHeader % kind ) ) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) write ( logUnit ( 1 ), \"(A)\" ) ' Loading the fluid properties.' call mus_load_fluid ( me = me % fluid , & & conf = conf , & & parent = parent , & & minLevel = minLevel , & & physics = physics , & & schemeHeader = schemeHeader ) case ( 'poisson' , 'poisson_boltzmann_linear' , 'poisson_boltzmann_nonlinear' ) write ( logUnit ( 1 ), \"(A)\" ) ' Loading properties for poisson Eq:' call mus_load_poisson ( me = me % poisson , & & conf = conf , & & parent = parent , & & minLevel = minLevel , & & cs_lattice = cs_lattice , & & physics = physics , & & schemeKind = trim ( schemeHeader % kind ) ) case ( 'passive_scalar' ) write ( logUnit ( 1 ), \"(A)\" ) ' Loading properties for passive scalar:' call mus_load_species ( me = me % species , conf = conf , parent = parent , & & minLevel = minLevel , nFields = nFields , & & physics = physics , cs_lattice = cs_lattice ) case ( 'multispecies_gas' , 'multispecies_liquid' , 'nernst_planck' ) write ( logUnit ( 1 ), \"(A)\" ) ' Loading properties for multispecies:' call mus_load_species ( me = me % species , conf = conf , parent = parent , & & minLevel = minLevel , nFields = nFields , & & physics = physics , cs_lattice = cs_lattice ) case default write ( logUnit ( 1 ), * ) 'The selected scheme kind is unknown ' // & & trim ( schemeHeader % kind ) call tem_abort () end select end subroutine mus_load_field_prop ! **************************************************************************** ! ! **************************************************************************** ! !> write field prop into a lua file !! subroutine mus_field_prop_out ( me , conf , schemeHeader ) ! -------------------------------------------------------------------------- !> single field type type ( mus_field_prop_type ), intent ( in ) :: me !> identifier of the scheme type ( mus_scheme_header_type ), intent ( in ) :: schemeHeader !> aotus out type type ( aot_out_type ), intent ( inout ) :: conf ! -------------------------------------------------------------------------- select case ( trim ( schemeHeader % kind ) ) case ( 'fluid' , 'fluid_incompressible' ) call mus_fluid_save2lua ( me = me % fluid , conf = conf ) case ( 'passive_scalar' , 'multispecies_gas' , & & 'multispecies_liquid' ) call mus_species_out ( me = me % species , conf = conf ) end select end subroutine mus_field_prop_out ! **************************************************************************** ! end module mus_field_prop_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_field_prop_module.f90.html"},{"title":"mus_hvs_aux_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_hvs_aux_module.f90~~EfferentGraph sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_fluid_module.f90 mus_fluid_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_fluid_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_time_module.f90 mus_time_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_cumulantinit_module.f90 mus_cumulantInit_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_cumulantinit_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_turb_viscosity_module.f90 mus_turb_viscosity_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turb_viscosity_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_fluid_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_geomincrhead_module.f90 mus_geomIncrHead_module.f90 sourcefile~mus_geom_module.f90->sourcefile~mus_geomincrhead_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_time_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_hvs_aux_module.f90~~AfferentGraph sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2015-2016, 2018-2020 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ****************************************************************************** ! !> author: Kannan Masilamani !! Auxiliary functionality for musubi harvesting !! module mus_hvs_aux_module ! include musubi modules use tem_aux_module , only : tem_abort use mus_param_module , only : mus_param_type use mus_geom_module , only : mus_geom_type use mus_tools_module , only : check_streaming_layout use mus_interpolate_module , only : mus_init_interpolate use mus_scheme_type_module , only : mus_scheme_type use mus_interpolate_tools_module , only : debug_dependencies , dump_intpLists use mus_time_module , only : mus_time_homogenize use mus_fluid_module , only : mus_init_fluid use mus_gradData_module , only : mus_init_gradData use mus_tracking_module , only : mus_init_tracker use mus_bndForce_module , only : mus_init_BndForce ! include treelm modules use tem_debug_module , only : dbgUnit use tem_restart_module , only : tem_init_restart use tem_tools_module , only : tem_horizontalSpacer use tem_tracking_module , only : tem_tracker use tem_debug_module , only : main_debug use tem_logging_module , only : logUnit use tem_spacetime_fun_module , only : tem_create_subTree_of_st_funList implicit none private public :: mus_hvs_init_aux contains ! ****************************************************************************** ! !> Init auxiliary features such as interpolation boundaries, restart and !! the tracker subroutine mus_hvs_init_aux ( scheme , geometry , params ) ! --------------------------------------------------------------------------- !> container for the scheme type ( mus_scheme_type ), target , intent ( inout ) :: scheme !> geometry infomation type ( mus_geom_type ), intent ( inout ) :: geometry !> global parameters type ( mus_param_type ), intent ( inout ) :: params ! --------------------------------------------------------------------------- integer :: iLevel , minLevel , maxLevel ! --------------------------------------------------------------------------- minLevel = geometry % tree % global % minLevel maxLevel = geometry % tree % global % maxLevel ! create subTree for all spacetime function in the linked list of ! spacetime function call tem_create_subTree_of_st_funList ( & & me = scheme % st_funList , & & tree = geometry % tree , & & bc_prop = geometry % boundary , & & stencil = scheme % layout % fStencil ) call tem_horizontalSpacer ( fUnit = logUnit ( 1 )) ! verify correct settings for the streaming layout call check_streaming_layout ( minLevel , maxLevel ) ! When the restart is read from separate restart table, we start the ! simulation from the time step given in restart file. In the case, ! when restart is read from initial condition table, the simulation start ! time step is taken as the one defined in configuration file call mus_time_homogenize ( me = params % general % simControl % now , & & dt = params % physics % dtLvl ( maxLevel ), & & readRestart = params % general % restart % controller & & % readRestart ) ! initialize the restart write ( logUnit ( 1 ), * ) 'Initializing restart...' call tem_init_restart ( me = params % general % restart , & & solver = params % general % solver , & ! &                    varSys       = scheme%varSys,          & & varMap = scheme % stateVarMap , & & tree = geometry % tree ) ! scheme loop to initialize tracking, boundary, interpolation and output !> initialize fluid type which contains relaxation parameter !! and function pointers to get mrt paramter and nonEqScaling factor !! for interpolation select case ( trim ( scheme % header % kind ) ) case ( 'fluid' , 'fluid_incompressible' , 'isotherm_acEq' ) if ( scheme % nFields > 1 ) then call tem_abort ( 'chosen scheme kind supports only one field' ) end if ! initialize fluid viscosity relaxation paramters call mus_init_fluid ( & & me = scheme % field ( 1 )% fieldProp % fluid , & & physics = params % physics , & & schemeHeader = scheme % header , & & minLevel = minLevel , & & maxLevel = maxLevel , & & levelDesc = scheme % levelDesc (:), & & pdf = scheme % pdf (:), & & stencil = scheme % layout % fStencil , & & general = params % general , & & tNow = params % general % simControl % now ) end select ! Initialize gradient data. Required for LES tuburbulent and evaluating ! gradient of a variable if ( scheme % readVarIsPdf ) then allocate ( scheme % gradData ( minLevel : maxLevel )) do iLevel = minLevel , maxLevel call mus_init_gradData ( me = scheme % gradData ( iLevel ), & & neigh = scheme % pdf ( iLevel )% neigh (:), & !&                     levelDesc = scheme%levelDesc(iLevel),        & & stencil = scheme % layout % fStencil , & & nSize = scheme % pdf ( iLevel )% nSize , & & nSolve = scheme % pdf ( iLevel )% nElems_solve , & & nScalars = scheme % varSys % nScalars ) end do end if ! initialize tracking objects. call mus_init_tracker ( scheme = scheme , & & geometry = geometry , & & params = params ) if ( minLevel /= maxlevel ) then write ( logUnit ( 1 ), * ) 'Initializing interpolation...' ! initialize the interpolation call mus_init_interpolate ( & & intp = scheme % intp , & & leveldesc = scheme % leveldesc , & & schemeHeader = scheme % header , & & stencil = scheme % layout % fStencil , & & minLevel = minLevel , & & maxLevel = maxLevel , & & fieldProp = scheme % field (:)% fieldProp ) end if if ( main_debug % debugDependencies ) then call debug_dependencies ( scheme % intp , scheme % levelDesc , & & geometry % tree , params % general % proc % rank ) call dump_intpLists ( minLevel , maxLevel , scheme % intp % config % order , & & scheme % levelDesc , params % general % proc % rank ) end if ! Boundary force calculation is valid only for single field schemes ! like fluid and fluid_incompressible so initialize only if nFields = 1 if ( geometry % boundary % nBCtypes > 0 . and . scheme % nFields == 1 ) then call mus_init_bndForce ( bndForce = geometry % bndForce , & & bndMoment = geometry % bndMoment , & & bc_prop = geometry % boundary , & & schemeHeader = scheme % header , & & bc = scheme % field ( 1 )% bc ) end if call tem_horizontalSpacer ( after = 1 , fUnit = logUnit ( 1 ) ) end subroutine mus_hvs_init_aux ! ****************************************************************************** ! end module mus_hvs_aux_module ! ****************************************************************************** !","tags":"","loc":"sourcefile/mus_hvs_aux_module.f90.html"},{"title":"mus_wall_function_musker_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_wall_function_musker_module.f90~~EfferentGraph sourcefile~mus_wall_function_musker_module.f90 mus_wall_function_musker_module.f90 sourcefile~mus_wall_function_abstract_module.f90 mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_musker_module.f90->sourcefile~mus_wall_function_abstract_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_wall_function_musker_module.f90~~AfferentGraph sourcefile~mus_wall_function_musker_module.f90 mus_wall_function_musker_module.f90 sourcefile~mus_turb_wallfunc_module.f90 mus_turb_wallFunc_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_musker_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types, function and routines for wall function !! computations relative to Musker profile. !! Haussmann, Marc; BARRETO, Alejandro CLARO; KOUYI, Gislain LIPEME; !! Rivière, Nicolas; Nirschl, Hermann; Krause, Mathias J. (2019): !! Large-eddy simulation coupled with wall models for turbulent channel !! flows at high Reynolds numbers with a lattice Boltzmann method !! — Application to Coriolis mass flowmeter. In Computers & Mathematics !! with Applications 78 (10), pp. 3285–3302. DOI: 10.1016/j.camwa.2019.04.033. !! !! author: Gregorio Gerardo Spinelli module mus_wall_function_musker_module ! include treelm modules use env_module , only : rk use mus_wall_function_abstract_module , only : mus_wall_function_type implicit none private public :: mus_wall_function_musker_type !> extend the abstract subclass mus_wall_function_type type , extends ( mus_wall_function_type ) :: mus_wall_function_musker_type contains !> function to get uPlus procedure , nopass :: get_uPlus !> function to apply the newon method ! F = uPlus_n - uPlus_(n+1) ! here we compute the derivative of uPlus_(n+1) w.r.t. u_tau ! this function computes the derivative of uPlus with respect to uTau procedure , nopass :: get_d_uPlus_d_uTau end type mus_wall_function_musker_type contains !> function to get uPlus pure function get_uPlus ( yPlus ) result ( uPlus ) !> yPlus real ( kind = rk ), intent ( in ) :: yPlus !> output: uPlus real ( kind = rk ) :: uPlus !uPlus = ( 5.424_rk * atan((2.0_rk*yPlus - 8.15_rk)/16.7_rk) & !  &        + log10( (yPlus + 10.6_rk)**9.6_rk               & !  &            / ( yPlus**2.0_rk - 8.15_rk*yPlus            & !  &                + 86.0_rk)**2.0_rk ) - 3.5072790194_rk   ) ! above expression simplified with sympy in python uPlus = 0.434294481903252_rk * log ( ( 0.0943396226415094_rk * yPlus + 1._rk ) ** 9.6_rk / & & ( 0.0116279069767442_rk * yPlus ** 2 - 0.0947674418604651_rk * yPlus + 1_rk ) ** 2 ) & & + 5.424_rk * atan ( 0.119760479041916_rk * yPlus - 0.488023952095808_rk ) & & + 2.46666038465466_rk end function get_uPlus !> function to get the derivative of uPlus with respect to uTau pure function get_d_uPlus_d_uTau ( y , uTau , nu ) result ( d_uPlus_d_uTau ) !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> uTau at iteration n real ( kind = rk ), intent ( in ) :: uTau !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> output: derivative of uPlus with respect to uTau real ( kind = rk ) :: d_uPlus_d_uTau ! ------------------------------------------------------------------------------ real ( kind = rk ) :: uTau_y , yPlus , nu_sqr , uTau_y_sqr , nu_uTau_y , A , B , C , D , E uTau_y = uTau * y nu_uTau_y = uTau_y * nu yPlus = uTau_y / nu nu_sqr = nu ** 2 uTau_y_sqr = uTau_y ** 2 A = ( 1._rk + 0.0943396226415094_rk * yPlus ) B = nu_sqr - 0.0947674418604651_rk * nu_uTau_y + 0.0116279069767442_rk * uTau_y_sqr C = ( nu - 0.245398773006135_rk * uTau_y ) ** 2 D = nu_sqr + 0.238167377819212_rk * C E = A ** 9.6_rk ! obtained as diff from sympy in python d_uPlus_d_uTau = 0.434294481903252_rk * y * ( 1.49571515501793_rk * nu_sqr & & * E * B + D * ( nu * E * ( 0.18953488372093_rk * nu & & - 0.0465116279069767_rk * uTau_y ) + 0.905660377358491_rk * A ** 8.6_rk * B ) ) & & / ( nu * E * D * B ) end function get_d_uPlus_d_uTau end module mus_wall_function_musker_module","tags":"","loc":"sourcefile/mus_wall_function_musker_module.f90.html"},{"title":"mus_tools_module.f90 – Musubi","text":"* * * * * * * * * * * ! This file depends on sourcefile~~mus_tools_module.f90~~EfferentGraph sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_abortcriteria_module.f90 mus_abortCriteria_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90 mus_param_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_physics_module.f90 mus_physics_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90 mus_relaxationParam_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_relaxationparam_module.f90 sourcefile~mus_scheme_module.f90 mus_scheme_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_module.f90 sourcefile~mus_scheme_type_module.f90 mus_scheme_type_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_timer_module.f90 mus_timer_module.f90 sourcefile~mus_tools_module.f90->sourcefile~mus_timer_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_abortcriteria_module.f90 sourcefile~mus_param_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_physics_module.f90 sourcefile~mus_dervarpos_module.f90 mus_derVarPos_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_moments_type_module.f90 mus_moments_type_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_moments_type_module.f90 sourcefile~mus_scheme_header_module.f90 mus_scheme_header_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_layout_module.f90 mus_scheme_layout_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_turbulence_module.f90 mus_turbulence_module.f90 sourcefile~mus_relaxationparam_module.f90->sourcefile~mus_turbulence_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_type_module.f90 sourcefile~mus_field_module.f90 mus_field_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_geom_module.f90 mus_geom_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_geom_module.f90 sourcefile~mus_interpolate_header_module.f90 mus_interpolate_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_mixture_module.f90 mus_mixture_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_moments_module.f90 mus_moments_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_moments_module.f90 sourcefile~mus_scheme_derived_quantities_type_module.f90 mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_derived_quantities_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_source_type_module.f90 mus_source_type_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_transport_var_module.f90 mus_transport_var_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_transport_var_module.f90 sourcefile~mus_variable_module.f90 mus_variable_module.f90 sourcefile~mus_scheme_module.f90->sourcefile~mus_variable_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_param_module.f90 sourcefile~mus_auxfield_module.f90 mus_auxField_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_auxfield_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_dervarpos_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_module.f90 sourcefile~mus_field_prop_module.f90 mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_field_prop_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_interpolate_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_mixture_module.f90 sourcefile~mus_nernstplanck_module.f90 mus_nernstPlanck_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_nernstplanck_module.f90 sourcefile~mus_pdf_module.f90 mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_pdf_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_header_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_scheme_layout_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_source_type_module.f90 sourcefile~mus_scheme_type_module.f90->sourcefile~mus_transport_var_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_tools_module.f90~~AfferentGraph sourcefile~mus_tools_module.f90 mus_tools_module.f90 sourcefile~mus_aux_module.f90 mus_aux_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_tracking_module.f90 mus_tracking_module.f90 sourcefile~mus_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_config_module.f90 mus_config_module.f90 sourcefile~mus_config_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90 mus_dynLoadBal_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_dynloadbal_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_hvs_aux_module.f90 mus_hvs_aux_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_hvs_aux_module.f90->sourcefile~mus_tracking_module.f90 sourcefile~mus_tracking_module.f90->sourcefile~mus_tools_module.f90 sourcefile~mus_control_module.f90 mus_control_module.f90 sourcefile~mus_control_module.f90->sourcefile~mus_aux_module.f90 sourcefile~mus_harvesting.f90 mus_harvesting.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_aux_module.f90 sourcefile~mus_hvs_config_module.f90 mus_hvs_config_module.f90 sourcefile~mus_harvesting.f90->sourcefile~mus_hvs_config_module.f90 sourcefile~mus_hvs_config_module.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90 musubi.f90 sourcefile~musubi.f90->sourcefile~mus_aux_module.f90 sourcefile~musubi.f90->sourcefile~mus_config_module.f90 sourcefile~musubi.f90->sourcefile~mus_control_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2011-2014,2020-2021 Harald Klimach <harald.klimach@uni-siegen.de> ! Copyright (c) 2011-2014 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2011-2017, 2019, 2021 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2011 Nikhil Anand <n.anand@grs-sim.de> ! Copyright (c) 2011 Jan Hueckelheim <j.hueckelheim@grs-sim.de> ! Copyright (c) 2012, 2014-2016 Jiaxing Qi <jiaxing.qi@uni-siegen.de> ! Copyright (c) 2012-2015 Kartik Jain <kartik.jain@uni-siegen.de> ! Copyright (c) 2014 Julia Moos <julia.moos@student.uni-siegen.de> ! Copyright (c) 2016 Tobias Schneider <tobias1.schneider@student.uni-siegen.de> ! Copyright (c) 2016-2017 Raphael Haupt <raphael.haupt@uni-siegen.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !See copyright notice in the COPYRIGHT file. !! *************************************************************************** ! !> Some generic handy check routines to check the properties of the flow field !! and the current run !! !! Performance estimation, check of the total density, check for NaNs !! module mus_tools_module ! include treelm modules use mpi !$ use omp_lib use env_module , only : rk , long_k , newunit , PathLen , labelLen , & & rk_mpi , outLen use tem_time_module , only : tem_time_dump use tem_timeControl_module , only : tem_timeControl_globalTriggered use tem_timer_module , only : tem_getTimerVal , tem_getMaxTimerVal , & & tem_getTimerName use tem_status_module , only : tem_stat_nan_detected , tem_stat_nonPhysical use tem_isNaN_module , only : tem_isNaN use tem_debug_module , only : dbgUnit use tem_logging_module , only : logUnit use tem_topology_module , only : tem_LevelOf use tem_comm_env_module , only : tem_comm_env_type use tem_comm_module , only : tem_communication_type use tem_general_module , only : tem_general_type use tem_balance_module , only : tem_calc_imbalance use tem_aux_module , only : check_mpi_error , tem_abort use tem_tools_module , only : tem_horizontalSpacer use tem_param_module , only : cs ! include musubi modules use mus_abortCriteria_module , only : mus_abortCriteria_type use mus_param_module , only : mus_param_type , mus_param_out use mus_scheme_type_module , only : mus_scheme_type use mus_IBM_module , only : mus_finishIBM use mus_scheme_module , only : mus_scheme_out use mus_physics_module , only : mus_physics_out use mus_timer_module , only : get_computeRatio , get_communicateRatio , & & get_intpRatio , get_boundaryRatio , & & get_bcBufferTime , get_bcBufferRatio , & & get_computeTime , get_communicateTime , & & get_boundaryTime , & & get_auxTime , & & get_relaxTime , & & get_mainLoopTime , mus_timerHandles use mus_relaxationParam_module , only : mus_check_omegaKine use aotus_module , only : flu_state , aot_get_val use aot_out_module , only : aot_out_type , aot_out_open , aot_out_close , & & aot_out_val implicit none private public :: perform_checks public :: check_streaming_layout public :: check_density public :: check_potential public :: mus_writeSolverSpecInfo public :: dump_linear_partition public :: mus_perf_measure public :: mus_BC_timing public :: dump_bc_timing contains ! ------------------------------------------------------------------------ ! !> Perform run-time checks if interval is active !! subroutine perform_checks ( scheme , minLevel , maxLevel , general , & & mus_aborts , initCheck ) ! -------------------------------------------------------------------- ! type ( mus_scheme_type ), intent ( in ) :: scheme integer , intent ( in ) :: minLevel , maxLevel type ( tem_general_type ), intent ( inout ) :: general type ( mus_abortCriteria_type ), intent ( in ) :: mus_aborts !> True for initial check before main time toop logical , intent ( in ) :: initCheck ! -------------------------------------------------------------------- ! !  Check and output in the main intervals if ( tem_timeControl_globalTriggered ( & & me = general % simControl % timeControl , & & now = general % simControl % now , & & comm = general % proc % comm ) & & . or . initCheck ) then select case ( trim ( scheme % header % kind )) case ( 'fluid' , 'fluid_incompressible' ) ! check total density call check_density ( scheme , minLevel , maxLevel , general ) ! check whether lattice velocity above stability limit call check_velocityFluid ( scheme , minLevel , maxLevel , & & general , mus_aborts ) ! Check omega range only if viscKine STfun is not constant or ! it is initial check. associate ( fluid => scheme % field ( 1 )% fieldProp % fluid ) if ( ( trim ( fluid % viscKine % STfun % fun_kind ) /= 'const' ) & & . or . initCheck ) then call mus_check_omegaKine ( & & omLvlKine = fluid % viscKine % omLvl , & & nSolve = scheme % pdf (:)% nElems_solve , & & schemeRelax = trim ( scheme % header % relaxation ), & & minLevel = minLevel , & & maxLevel = maxLevel , & & general = general ) end if end associate case ( 'multispecies_gas' , 'multispecies_liquid' ) call check_density ( scheme , minLevel , maxLevel , general ) call check_velocityMS ( scheme , minLevel , maxLevel , general , mus_aborts ) case ( 'passive_scalar' , 'nernst_planck' , 'isotherm_acEq' ) call check_density ( scheme , minLevel , maxLevel , general ) case ( 'poisson' , 'poisson_boltzmann_linear' , & & 'poisson_boltzmann_nonlinear' ) call check_potential ( scheme , minlevel , maxLevel , general ) case default write ( logUnit ( 1 ), * ) 'Unknown scheme kind: ' // trim ( scheme % header % kind ) call tem_abort () end select end if end subroutine perform_checks ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Check the total potential for poisson scheme !! !! The output might be delayed by using arrays which are then dumped !! to keep disc access more restricted !! subroutine check_potential ( scheme , minLevel , maxLevel , general , & & total_potential ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( in ) :: scheme !> global scheme independent information integer , intent ( in ) :: minLevel , maxLevel type ( tem_general_type ), intent ( inout ) :: general real ( kind = rk ), intent ( out ), optional :: total_potential ! -------------------------------------------------------------------- ! real ( kind = rk ) :: pot , total_pot integer iLevel , ierror , iElem ! -------------------------------------------------------------------- ! total_pot = 0._rk pot = 0._rk ! Sum up all values in the complete vector to get the total density lvlLoop : do iLevel = minLevel , maxLevel do iElem = 1 , scheme % pdf ( iLevel )% nElems_fluid ! Potential is stored in auxField. Use it to check total potential pot = pot + scheme % auxField ( iLevel )% val ( iElem ) end do ! iElem end do lvlLoop !iLevel ! All ranks check, if there are NaN entries if ( tem_isnan ( pot ) ) then write ( logUnit ( 1 ), * ) ' Error: Total potential is NaN on rank ' , & & general % proc % rank general % simControl % status % bits ( tem_stat_nan_detected ) = . true . endif ! compute total_pot call mpi_reduce ( pot , total_pot , 1 , mpi_double_precision , & mpi_sum , 0 , general % proc % comm , ierror ) call tem_time_dump ( me = general % simControl % now , outUnit = logUnit ( 1 )) ! dump total potential for each field write ( logUnit ( 1 ), '(a11,a,a20)' ) 'field' , ' |' , 'total potential' write ( logUnit ( 1 ), '(i11,a,en20.10)' ) scheme % nFields , ' |' , total_pot write ( logUnit ( 1 ), '(a)' ) '' if ( present ( total_potential )) then total_potential = total_pot end if end subroutine check_potential ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Check the total density for a selected scheme and write to unit !! !! The output might be delayed by using arrays which are then dumped !! to keep disc access more restricted !! subroutine check_density ( scheme , minLevel , maxLevel , general , total_density ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( in ) :: scheme !> global scheme independent information integer , intent ( in ) :: minLevel , maxLevel type ( tem_general_type ), intent ( inout ) :: general real ( kind = rk ), intent ( out ), optional :: total_density ! -------------------------------------------------------------------- ! real ( kind = rk ), allocatable :: dens (:) , total_dens (:) real ( kind = rk ) :: dens_field integer :: iLevel , ierror , iElem , iField integer :: elemOff , dens_pos ( scheme % nFields ) ! -------------------------------------------------------------------- ! ! density is stored in auxField. Use it to check density select case ( trim ( scheme % header % kind )) case ( 'nernst_planck' ) do iField = 1 , scheme % nFields dens_pos ( iField ) = scheme % varSys & & % method & & % val ( scheme % derVarpos ( iField )% moleDensity ) & & % auxField_varPos ( 1 ) end do case default do iField = 1 , scheme % nFields dens_pos ( iField ) = scheme % varSys % method & & % val ( scheme % derVarpos ( iField )% density ) & & % auxField_varPos ( 1 ) end do end select allocate ( dens ( scheme % nFields ) ) allocate ( total_dens ( scheme % nFields ) ) total_dens = 0._rk dens = 0._rk ! Sum up all values in the complete vector to get the total density lvlLoop : do iLevel = minLevel , maxLevel do iElem = 1 , scheme % pdf ( iLevel )% nElems_fluid ! element offset for auxField elemOff = ( iElem - 1 ) * scheme % varSys % nAuxScalars ! compute density for each field do iField = 1 , scheme % nFields ! field density dens_field = scheme % auxField ( iLevel )% val ( elemOff + dens_pos ( iField )) ! set nonPhysical if local field density is negative ! density can never be negative if ( dens_field <= 0.0_rk ) then write ( logUnit ( 1 ), '(a,i3)' ) 'ERROR: Negative density for field' , & & iField write ( logUnit ( 1 ), * ) 'Terminating check total density calculation' write ( logUnit ( 1 ), * ) 'non-physical density=' , dens_field write ( dbgUnit ( 1 ), '(a,i3)' ) 'ERROR: Negative density for field' , & & iField write ( dbgUnit ( 1 ), * ) 'Terminating check total density calculation' write ( dbgUnit ( 1 ), * ) 'non-physical density=' , dens_field write ( dbgUnit ( 1 ), * ) 'TreeID ' , scheme % levelDesc ( iLevel )% total ( iElem ) general % simControl % status % bits ( tem_stat_nonPhysical ) = . true . exit lvlLoop end if ! total density dens ( iField ) = dens ( iField ) + dens_field end do ! iField end do ! iElem end do lvlLoop ! iLevel ! All ranks check, if there are NaN entries if ( any ( tem_isnan ( dens ) ) ) then write ( logUnit ( 1 ), * ) ' Error: Total density is NaN on rank ' , & & general % proc % rank general % simControl % status % bits ( tem_stat_nan_detected ) = . true . end if ! compute total_dens call mpi_reduce ( dens , total_dens , scheme % nFields , mpi_double_precision , & mpi_sum , 0 , general % proc % comm , ierror ) call tem_time_dump ( me = general % simControl % now , outUnit = logUnit ( 1 )) ! dump total density for each field write ( logUnit ( 1 ), '(a11,a,a20)' ) 'field' , ' |' , 'total density' do iField = 1 , scheme % nFields write ( logUnit ( 1 ), '(i11,a,en20.10)' ) iField , ' |' , total_dens ( iField ) end do write ( logUnit ( 1 ), '(a)' ) '' if ( present ( total_density )) then total_density = sum ( total_dens ) end if end subroutine check_density ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Check the maximum velocity whether it is above Ma>0.1 !! subroutine check_velocityFluid ( scheme , minLevel , maxLevel , general , & & mus_aborts ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( in ) :: scheme !> global scheme independent information integer , intent ( in ) :: minLevel , maxLevel type ( tem_general_type ), intent ( inout ) :: general type ( mus_abortCriteria_type ), intent ( in ) :: mus_aborts ! -------------------------------------------------------------------- ! real ( kind = rk ) :: vel ( 3 ) , velMag , maxVel , glob_maxVel integer :: iLevel , ierror , iElem integer :: elemOff , vel_pos ( 3 ) ! -------------------------------------------------------------------- ! ! Sum up all values in the complete vector to get the total density maxVel = 0.0_rk lvlLoop : do iLevel = minLevel , maxLevel do iElem = 1 , scheme % pdf ( iLevel )% nElems_fluid ! element offset for auxField elemOff = ( iElem - 1 ) * scheme % varSys % nAuxScalars ! velocity is stored in auxField. Use it to check velocity vel_pos = scheme % varSys % method & & % val ( scheme % derVarpos ( 1 )% velocity ) & & % auxField_varPos ( 1 : 3 ) vel ( 1 ) = scheme % auxField ( iLevel )% val ( elemOff + vel_pos ( 1 )) vel ( 2 ) = scheme % auxField ( iLevel )% val ( elemOff + vel_pos ( 2 )) vel ( 3 ) = scheme % auxField ( iLevel )% val ( elemOff + vel_pos ( 3 )) velMag = sqrt ( dot_product ( vel , vel )) maxVel = max ( maxVel , velMag ) end do end do lvlLoop ! All ranks check, if there are NaN entries if ( tem_isnan ( maxVel )) then write ( logUnit ( 1 ), * ) ' Error: Lattice velocity is NaN on rank ' , & & general % proc % rank general % simControl % status % bits ( tem_stat_nan_detected ) = . true . endif ! compute maximum of all processes call mpi_reduce ( maxVel , glob_maxVel , 1 , mpi_double_precision , & mpi_max , 0 , general % proc % comm , ierror ) if ( general % proc % isRoot ) then if ( glob_maxVel > mus_aborts % velLat_max ) then write ( logUnit ( 1 ), '(2(A,F6.3))' ) & & 'Error: Maximum lattice velocity in domain: ' , & & glob_maxVel , ' > ' , mus_aborts % velLat_max general % simControl % status % bits ( tem_stat_nonPhysical ) = . true . else if ( glob_maxVel > 0.1_rk ) then write ( logUnit ( 1 ), '(A,F6.3)' ) 'WARNING: Maximum lattice velocity in ' & & // 'domain:' , glob_maxVel end if end if end subroutine check_velocityFluid ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Check the maximum velocity whether it is above Ma>0.1 !! subroutine check_velocityMS ( scheme , minLevel , maxLevel , general , & & mus_aborts ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( in ) :: scheme !> global scheme independent information integer , intent ( in ) :: minLevel , maxLevel type ( tem_general_type ), intent ( inout ) :: general type ( mus_abortCriteria_type ), intent ( in ) :: mus_aborts ! -------------------------------------------------------------------- ! real ( kind = rk ) :: velMag , maxVel , glob_maxVel real ( kind = rk ) :: dens ( scheme % nFields ), mom ( 3 , scheme % nFields ) real ( kind = rk ) :: mixVel ( 3 ), inv_tRho integer :: iLevel , ierror , iElem , iField integer :: elemOff , dens_pos , mom_pos ( 3 ) ! -------------------------------------------------------------------- ! ! Sum up all values in the complete vector to get the total density maxVel = 0.0_rk lvlLoop : do iLevel = minLevel , maxLevel do iElem = 1 , scheme % pdf ( iLevel )% nElems_fluid ! element offset for auxField elemOff = ( iElem - 1 ) * scheme % varSys % nAuxScalars do iField = 1 , scheme % nFields ! velocity is stored in auxField. Use it to check velocity dens_pos = scheme % varSys % method & & % val ( scheme % derVarpos ( iField )% density ) & & % auxField_varPos ( 1 ) mom_pos = scheme % varSys % method & & % val ( scheme % derVarpos ( iField )% momentum ) & & % auxField_varPos ( 1 : 3 ) dens ( iField ) = scheme % auxField ( iLevel )% val ( elemOff + dens_pos ) mom ( 1 , iField ) = scheme % auxField ( iLevel )% val ( elemOff + mom_pos ( 1 )) mom ( 2 , iField ) = scheme % auxField ( iLevel )% val ( elemOff + mom_pos ( 2 )) mom ( 3 , iField ) = scheme % auxField ( iLevel )% val ( elemOff + mom_pos ( 3 )) end do inv_tRho = 1.0_rk / sum ( dens ) ! mixture averaged mass velocity mixVel ( 1 ) = sum ( mom ( 1 ,:)) * inv_tRho mixVel ( 2 ) = sum ( mom ( 2 ,:)) * inv_tRho mixVel ( 3 ) = sum ( mom ( 3 ,:)) * inv_tRho velMag = sqrt ( dot_product ( mixVel , mixVel )) maxVel = max ( maxVel , velMag ) end do end do lvlLoop ! All ranks check, if there are NaN entries if ( tem_isnan ( maxVel )) then write ( logUnit ( 1 ), * ) ' Error: Lattice velocity is NaN on rank ' , & & general % proc % rank general % simControl % status % bits ( tem_stat_nan_detected ) = . true . endif ! compute maximum of all processes call mpi_reduce ( maxVel , glob_maxVel , 1 , mpi_double_precision , & mpi_max , 0 , general % proc % comm , ierror ) if ( general % proc % isRoot ) then if ( glob_maxVel > mus_aborts % velLat_max ) then write ( logUnit ( 1 ), '(2(A,F6.3))' ) & & 'Error: Maximum lattice velocity in domain: ' , & & glob_maxVel , ' > ' , mus_aborts % velLat_max general % simControl % status % bits ( tem_stat_nonPhysical ) = . true . else if ( glob_maxVel > 0.1_rk ) then write ( logUnit ( 1 ), '(A,F6.3)' ) 'WARNING: Maximum lattice velocity in ' & & // 'domain:' , glob_maxVel end if end if end subroutine check_velocityMS ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine measures performance imbalance, MLUPS and dumps timings !! to disk subroutine mus_perf_measure ( totalDens , DomSize , minLevel , & & maxLevel , nElems , scaleFactor , general ) ! -------------------------------------------------------------------- ! !> Total density from check_density real ( kind = rk ), intent ( in ) :: totalDens !> Total number of elements in tree integer ( kind = long_k ), intent ( in ) :: DomSize !> level range integer , intent ( in ) :: minLevel , maxLevel !> array of nElems levelwise integer , intent ( in ) :: nElems ( minLevel : maxLevel ) !> global parameter integer , intent ( in ) :: scaleFactor !> Contains proc, simControl, solveHead type ( tem_general_type ), intent ( in ) :: general ! -------------------------------------------------------------------- ! real ( kind = rk ) :: tMainLoop , tCompute , mlups , mlups_kernel real ( kind = rk ) :: cpuCost , imbalance integer :: iter , iTimer , nTimers , counter , iErr , nLevels real ( kind = rk ), allocatable :: timerVal (:) integer ( kind = long_k ) :: nTotals ( minLevel : maxLevel ) ! -------------------------------------------------------------------- ! cpuCost = get_mainLoopTime () - get_communicateTime () imbalance = tem_calc_imbalance ( cpuCost , & & general % proc % comm , & & general % proc % comm_size , & & general % proc % isRoot ) ! first and last handle convers all musubi handles which are added ! contigously nTimers = mus_timerHandles % last - mus_timerHandles % first + 1 allocate ( timerVal ( nTimers ) ) ! Get maxTimer of all process counter = 0 do iTimer = mus_timerHandles % first , mus_timerHandles % last counter = counter + 1 timerVal ( counter ) = tem_getMaxTimerVal ( timerHandle = iTimer , & & comm = general % proc % comm ) end do nLevels = maxLevel - minLevel + 1 call mpi_allreduce ( int ( nElems ( minLevel : maxLevel ), long_k ), & & nTotals ( minLevel : maxLevel ), & & nLevels , mpi_integer8 , mpi_sum , & & general % proc % comm , iErr ) if ( general % proc % isRoot ) then iter = ( general % simControl % now % iter & & - general % simControl % timeControl % min % iter ) & & / ( scaleFactor ** ( maxLevel - minLevel ) ) ! calculate MLUPS and MLUPS kernel tMainLoop = get_mainLoopTime () mlups = calc_MLUPS ( nElems = nTotals , & & minLevel = minLevel , & & maxLevel = maxLevel , & & scaleFactor = scaleFactor , & & iter = iter , & & time = tMainLoop ) !write(logUnit(7),\"(A)\") \"Calculate MLUPS f r this stage.\" !write(logUnit(7),\"(A,I0)\") \" Now iter: \", general%simControl%now%iter !write(logUnit(7),\"(A,I0)\") \" Ran iter: \", iter !write(logUnit(7),\"(A,F10.2)\") \" Main Loop time: \", tMainLoop !write(logUnit(7),\"(A,F10.2)\") \" MLUPS: \", mlups ! Using compute kernel timer tCompute = get_computeTime () mlups_kernel = calc_MLUPS ( nElems = nTotals , & & minLevel = minLevel , & & maxLevel = maxLevel , & & scaleFactor = scaleFactor , & & iter = iter , & & time = tCompute ) ! dump timing call dump_timing ( totalDens = totalDens , & & DomSize = DomSize , & & MLUPS = mlups , & & MLUPS_kernel = mlups_kernel , & & imbalance = imbalance , & & timerVal = timerVal , & & general = general ) end if end subroutine mus_perf_measure ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Performance results (MLUPs) are written to a file for statistical review !! The file-format is simple can be evaluated with gnuplot !! subroutine dump_timing ( totalDens , DomSize , MLUPS , MLUPS_kernel , & & timerVal , imbalance , general ) ! -------------------------------------------------------------------- ! real ( kind = rk ), intent ( in ) :: totalDens integer ( kind = long_k ), intent ( in ) :: DomSize real ( kind = rk ), intent ( in ) :: MLUPS , MLUPS_kernel , imbalance !> Max. timers of all process real ( kind = rk ), intent ( in ) :: timerVal (:) type ( tem_general_type ), intent ( in ) :: general ! -------------------------------------------------------------------- ! real ( kind = rk ) :: tMusubi logical :: file_exists character ( len = PathLen ) :: filename integer :: fileunit , iTimer , counter character ( len = PathLen ) :: header , output ! -------------------------------------------------------------------- ! ! Header and output should match each other! header = '' output = '' write ( header , '(a,a1,a15)' ) trim ( header ), '#' , 'Revision' write ( output , '(a,a16)' ) trim ( output ), trim ( general % solver % revision ) write ( header , '(a,a21)' ) trim ( header ), 'SimName' write ( output , '(a,a21)' ) trim ( output ), ' ' // trim ( general % solver % simName ) write ( header , '(a,a15)' ) trim ( header ), 'DomSize' write ( output , '(a,i15)' ) trim ( output ), DomSize write ( header , '(a,a10)' ) trim ( header ), 'nProcs' write ( output , '(a,i10)' ) trim ( output ), general % proc % comm_size !$  write(header,'(a,a10)') trim(header), 'nThreads' !$  write(output,'(a,i10)') trim(output), general%proc%nThreads write ( header , '(a,a14)' ) trim ( header ), 'MLUPs' write ( output , '(a,en14.2)' ) trim ( output ), MLUPS write ( header , '(a,a14)' ) trim ( header ), 'MLUPs_kernel' write ( output , '(a,en14.2)' ) trim ( output ), mlups_kernel write ( header , '(a,a14)' ) trim ( header ), 'imbalance(%)' write ( output , '(a,F14.2)' ) trim ( output ), imbalance tMusubi = tem_getTimerVal ( timerHandle = general % solver % timerHandle ) write ( header , '(a,a14)' ) trim ( header ), 'timeMusubi' write ( output , '(a,en14.4)' ) trim ( output ), tMusubi write ( header , '(a,a10)' ) trim ( header ), 'maxIter' write ( output , '(a,I10)' ) trim ( output ), general % simControl % now % iter write ( header , '(a,a19)' ) trim ( header ), 'totalDens' write ( output , '(a,en19.9)' ) trim ( output ), totalDens ! Append all main timer values counter = 0 do iTimer = mus_timerHandles % first , mus_timerHandles % last write ( header , '(a,a16)' ) trim ( header ), & & 'time' // trim ( tem_getTimerName ( timerHandle = iTimer )) counter = counter + 1 write ( output , '(a,f16.4)' ) & & trim ( output ), timerVal ( counter ) end do !  12345678901234567890 write ( header , '(a,a12)' ) trim ( header ), 'timeAux' write ( output , '(a,f12.2)' ) trim ( output ), get_auxTime () write ( header , '(a,a12)' ) trim ( header ), 'timeRelax' write ( output , '(a,f12.2)' ) trim ( output ), get_relaxTime () write ( header , '(a,a12)' ) trim ( header ), 'Comp(%)' write ( output , '(a,f12.2)' ) trim ( output ), get_computeRatio () write ( header , '(a,a12)' ) trim ( header ), 'Comm(%)' write ( output , '(a,f12.2)' ) trim ( output ), get_communicateRatio () write ( header , '(a,a15)' ) trim ( header ), 'BCbuffer(%)' write ( output , '(a,f15.2)' ) trim ( output ), get_bcBufferRatio () write ( header , '(a,a12)' ) trim ( header ), 'BC(%)' write ( output , '(a,f12.2)' ) trim ( output ), get_boundaryRatio () write ( header , '(a,a12)' ) trim ( header ), 'Intp(%)' write ( output , '(a,f12.2)' ) trim ( output ), get_intpRatio () ! open and write to file filename = trim ( general % timingFile ) inquire ( file = trim ( filename ), exist = file_exists ) fileunit = newunit () open ( unit = fileunit , file = trim ( filename ), position = 'append' ) if ( . not . file_exists ) then write ( fileunit , '(a)' ) trim ( header ) end if write ( fileunit , '(a)' ) trim ( output ) close ( fileunit ) ! Write timing.res -------------------------------------------------------- end subroutine dump_timing ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Calculate the MLUPS or MFLUPS for the simulation !! pure function calc_MLUPS ( minLevel , maxLevel , scaleFactor , nElems , iter , & & time ) result ( mlups ) ! -------------------------------------------------------------------- ! !> level range integer , intent ( in ) :: minLevel , maxLevel !> global parameter integer , intent ( in ) :: scaleFactor !> array of nElems levelwise integer ( kind = long_k ), intent ( in ) :: nElems ( minLevel : maxLevel ) !> number of iterations on maxLevel !! number of iteration on iLevel = iter / scaleFactor**(maxLevel-iLevel) integer , intent ( in ) :: iter !> time consumed for running iter iterations real ( kind = rk ), intent ( in ) :: time !> resulting mlups real ( kind = rk ) :: mlups ! -------------------------------------------------------------------- ! integer :: iLevel integer ( kind = long_k ) :: cellUpdates ! -------------------------------------------------------------------- ! cellUpdates = 0_long_k ! MLUPS = sum( nElems(iLevel) * iter(iLevel) ) / mainLoopTime !       = sum( nElems(iLevel) * iter/scaleFactor(iLevel) ) / mainLoopTime !       = sum( nElems(iLevel) / scaleFactor(iLevel) ) * iter / mainLoopTime do iLevel = minLevel , maxLevel cellUpdates = cellUpdates + nElems ( iLevel ) & & / int ( scaleFactor ** ( maxLevel - iLevel ), kind = long_k ) enddo mlups = dble ( cellUpdates * iter ) / ( time * 100000 0._rk ) end function calc_MLUPS ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Check for the streaming layout. !! subroutine check_streaming_layout ( minLevel , maxLevel ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: minLevel , maxLevel ! -------------------------------------------------------------------- ! ! Check, if advection layout is PUSH. if so, abort, because the current code ! can only handle PUSH with single level if ( \"?StreamName?\" == 'push' ) then write ( logUnit ( 1 ), * ) ' Pushing pdfs to neighbor elements after collision ' if ( minLevel /= maxLevel ) then write ( logUnit ( 1 ), * ) ' ----------------------------------------------' & & // '------------ ' write ( logUnit ( 1 ), * ) '           WARNING !!' write ( logUnit ( 1 ), * ) '    Push is not possible with multi-level ' & & // 'execution.' write ( logUnit ( 1 ), * ) ' ----------------------------------------------' & & // '------------ ' write ( logUnit ( 1 ), * ) endif else write ( logUnit ( 1 ), * ) ' Pulling pdfs from neighbor elements before collision' endif end subroutine check_streaming_layout ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Write solver specific info to scratch file subroutine mus_writeSolverSpecInfo ( scheme , params , rank , outUnit ) ! -------------------------------------------------------------------- ! !> scheme type type ( mus_scheme_type ), intent ( in ) :: scheme !> Contains physical convertion info and scaling type type ( mus_param_type ), intent ( in ) :: params !> Rank of the process either from !! global communicator or tracking output communicator integer , intent ( in ) :: rank !> unit to output solver info in lua format integer , intent ( inout ) :: outUnit ! -------------------------------------------------------------------- ! type ( aot_out_type ) :: conf ! -------------------------------------------------------------------- ! ! Write scratch file only from root process and ! outUnit is not initialized before if ( rank == 0 . and . outUnit == - 1 ) then outUnit = newUnit () open ( unit = outUnit , status = 'scratch' ) call aot_out_open ( put_conf = conf , outUnit = outUnit ) ! write global parameter info call mus_param_out ( me = params , conf = conf ) ! write physics call mus_physics_out ( me = params % physics , & & conf = conf ) ! write schemes call mus_scheme_out ( me = scheme , & & conf = conf ) ! close conf call aot_out_close ( put_conf = conf ) end if end subroutine mus_writeSolverSpecInfo ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! subroutine dump_linear_partition ( treeID , nElems , offset , myRank , iter ) ! -------------------------------------------------------------------- ! integer , intent ( in ) :: nElems integer ( kind = long_k ), intent ( in ) :: offset integer ( kind = long_k ), intent ( in ) :: treeID ( 1 : nElems ) integer , intent ( in ) :: myRank integer , intent ( in ) :: iter ! -------------------------------------------------------------------- ! integer :: ii , level , previous , fileunit , minElem , maxElem , L integer :: block = 1024 character ( len = PathLen ) :: filename logical :: file_exists , toWrite character ( len = 65536 ) :: buffer ! -------------------------------------------------------------------- ! write ( logUnit ( 1 ), \"(A)\" ) 'Dump linear partition file.' write ( filename , \"(A,I5.5,A,I6.6,A)\" ) & & 'elemlist_partition_p' , myRank , '_t' , iter , '.res' inquire ( file = trim ( filename ), exist = file_exists ) fileunit = newunit () open ( unit = fileunit , file = trim ( filename ), position = 'append' ) write ( fileunit , \"(A10, A8)\" ) '# iElem' , 'level' buffer = '' ! always write the first element level = tem_LevelOf ( treeID ( 1 ) ) previous = level write ( fileunit , \"(A,I10,I8)\" ) trim ( buffer ), 1 + offset , level ! write elements by blocks do minElem = 2 , nElems , block maxElem = min ( minElem + block - 1 , nElems ) buffer = '' toWrite = . false . do ii = minElem , maxElem level = tem_LevelOf ( treeID ( ii ) ) ! only dump when my level is different from the level of my previous ! neighbor if ( level /= previous ) then write ( buffer , \"(A,I10,I8,A)\" ) trim ( buffer ), ii + offset - 1 , previous , & & new_line ( \"A\" ) write ( buffer , \"(A,I10,I8,A)\" ) trim ( buffer ), ii + offset , level , & & new_line ( \"A\" ) previous = level toWrite = . true . end if end do ! ii = minElem, maxElem ! the last character is a new_line, do not need to write it L = len ( trim ( buffer )) if ( toWrite ) write ( fileunit , \"(A)\" ) buffer ( 1 : L - 1 ) end do ! minElem = 2, nElems ! always write the last element level = tem_LevelOf ( treeID ( nElems ) ) write ( fileunit , \"(A,I10,I8)\" ) trim ( buffer ), nElems + offset , level close ( fileunit ) end subroutine dump_linear_partition ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> Output the min and max time across all ranks, !! which are spent on each boundary condition. subroutine mus_BC_timing ( nBCs , bc_labels , comm ) integer , intent ( in ) :: nBCs character ( len = labelLen ), intent ( in ) :: bc_labels ( nBCs ) integer , intent ( in ) :: comm real ( kind = rk ) :: bc_t ( nBCs ), min_t ( nBCs ), max_t ( nBCs ) integer :: ii , iError if ( nBCs > 0 ) then do ii = 1 , nBCs bc_t ( ii ) = get_boundaryTime ( ii ) end do call mpi_reduce ( bc_t , min_t , nBCs , rk_mpi , mpi_min , 0 , comm , ierror ) call mpi_reduce ( bc_t , max_t , nBCs , rk_mpi , mpi_max , 0 , comm , ierror ) call tem_horizontalSpacer ( fUnit = logUnit ( 5 )) write ( logUnit ( 5 ), \"(A)\" ) 'Boundary timing information:' do ii = 1 , nBCs write ( logUnit ( 5 ), \"(A12,2(A,F8.2))\" ) trim ( bc_labels ( ii )), & & ', min time: ' , min_t ( ii ), ', max time: ' , max_t ( ii ) end do call tem_horizontalSpacer ( fUnit = logUnit ( 5 )) end if end subroutine mus_BC_timing ! ------------------------------------------------------------------------ ! ! ------------------------------------------------------------------------ ! !> This routine dump compute and BC timing for all ranks !! rank    nFluids     tCompute     nBCElems     tBC    tCPU    tMainLoop subroutine dump_bc_timing ( proc , nFluids , nBCElems , DomSize , iter , send ) type ( tem_comm_env_type ), intent ( in ) :: proc integer , intent ( in ) :: nFluids integer , intent ( in ) :: nBCElems integer ( kind = long_k ), intent ( in ) :: DomSize integer , intent ( in ) :: iter type ( tem_communication_type ), intent ( in ) :: send ! -------------------------------------------------------------------------- character ( len = PathLen ) :: filename real ( kind = rk ) :: tMainLoop , tBC , tCompute , tBCBuffer , tComm , tCPU real ( kind = rk ) :: totalCPU , maxCPU integer :: fileunit , iError , msgsize , nLinks , totalProcs , totalLinks , ii character ( len = OutLen ) :: output integer :: ioStatus ( mpi_status_size ) ! -------------------------------------------------------------------------- tMainLoop = get_mainLoopTime () tCompute = get_computeTime () tBCBuffer = get_bcBufferTime () tBC = get_boundaryTime () tComm = get_communicateTime () tCPU = tBC + tCompute + tBCBuffer nLinks = 0 do ii = 1 , send % nProcs nLinks = nLinks + send % buf_real ( ii )% nVals end do call mpi_reduce ( tCPU , totalCPU , 1 , mpi_double_precision , & mpi_sum , 0 , proc % comm , ierror ) call mpi_reduce ( tCPU , maxCPU , 1 , mpi_double_precision , & mpi_max , 0 , proc % comm , ierror ) totalCPU = totalCPU / dble ( proc % comm_size ) call mpi_reduce ( send % nProcs , totalProcs , 1 , mpi_integer , & mpi_sum , 0 , proc % comm , ierror ) call mpi_reduce ( nLinks , totalLinks , 1 , mpi_integer , & mpi_sum , 0 , proc % comm , ierror ) totalProcs = totalProcs / proc % comm_size totalLinks = totalLinks / proc % comm_size write ( filename , \"(A)\" ) 'bc_timing.res' if ( proc % isRoot ) then fileUnit = newunit () open ( unit = fileunit , file = trim ( filename ), position = 'append' ) ! Write Header --------------------------------------------------- !                       12345678901234567890 write ( fileUnit , '(A)' ) '' write ( fileUnit , '(A,I0)' ) '# DomSize: ' , DomSize write ( fileUnit , '(A,I0)' ) '# Iteration: ' , iter write ( fileUnit , '(A,ES10.2)' ) '# tMainLoop: ' , tMainLoop write ( fileUnit , '(2(A,ES10.2),A,F5.1)' ) '# tCPU average/max = ' , & & totalCPU , ' / ' , maxCPU , & & ' = ' , ( totalCPU / maxCPU ) * 10 0._rk write ( fileUnit , '(A,I0,A,I0)' ) '# Send mean nProcs: ' , totalProcs , & & ', mean nLinks: ' , totalLinks write ( fileUnit , '(A6,7A10)' ) & & '# rank' , & & 'nFluids' , & & 'tCompute' , & & 'nBCElems' , & & 'tBCBuffer' , & & 'tBC' , & & 'tCPU' , & & 'tComm' close ( fileunit ) end if ! Make sure root finishes writing header call MPI_BARRIER ( proc % comm , iError ) ! Write Data --------------------------------------------------- output = '' ! Write data into string write ( output , \"(A,I6)\" ) trim ( output ), proc % rank write ( output , \"(A,I10)\" ) trim ( output ), nFluids write ( output , \"(A,ES10.2)\" ) trim ( output ), tCompute write ( output , \"(A,I10)\" ) trim ( output ), nBCElems write ( output , \"(A,ES10.2)\" ) trim ( output ), tBCBuffer write ( output , \"(A,ES10.2)\" ) trim ( output ), tBC write ( output , \"(A,ES10.2)\" ) trim ( output ), ( tBC + tCompute + tBCBuffer ) write ( output , \"(A,ES10.2)\" ) trim ( output ), tComm write ( output , \"(A,A)\" ) trim ( output ), new_line ( 'A' ) call MPI_File_open ( proc % comm , trim ( filename ), & & ior ( MPI_MODE_APPEND , MPI_MODE_WRONLY ), MPI_INFO_NULL , & & fileunit , iError ) call check_MPI_error ( iError , 'Open BC timing file' ) msgsize = len_trim ( output ) call MPI_File_write_ordered ( fileunit , trim ( output ), msgsize , & & MPI_CHARACTER , iostatus , iError ) call MPI_File_close ( fileunit , iError ) call check_MPI_error ( iError , 'Close BC timing file' ) end subroutine dump_bc_timing ! ------------------------------------------------------------------------ ! end module mus_tools_module ! **************************************************************************** !","tags":"","loc":"sourcefile/mus_tools_module.f90.html"},{"title":"mus_wall_function_reichardt_module.f90 – Musubi","text":"This file depends on sourcefile~~mus_wall_function_reichardt_module.f90~~EfferentGraph sourcefile~mus_wall_function_reichardt_module.f90 mus_wall_function_reichardt_module.f90 sourcefile~mus_wall_function_abstract_module.f90 mus_wall_function_abstract_module.f90 sourcefile~mus_wall_function_reichardt_module.f90->sourcefile~mus_wall_function_abstract_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mus_wall_function_reichardt_module.f90~~AfferentGraph sourcefile~mus_wall_function_reichardt_module.f90 mus_wall_function_reichardt_module.f90 sourcefile~mus_turb_wallfunc_module.f90 mus_turb_wallFunc_module.f90 sourcefile~mus_turb_wallfunc_module.f90->sourcefile~mus_wall_function_reichardt_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2023 Gregorio Gerardo Spinelli <gregoriogerardo.spinelli@dlr.de> ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, ! this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, ! this list of conditions and the following disclaimer in the documentation ! and/or other materials provided with the distribution. ! ! THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF SIEGEN “AS IS” AND ANY EXPRESS ! OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ! OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ! IN NO EVENT SHALL UNIVERSITY OF SIEGEN OR CONTRIBUTORS BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ! ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! **************************************************************************** ! !> This module contains data types, function and routines for wall function !! computations relative to Reichardt profile. !! Haussmann, Marc; BARRETO, Alejandro CLARO; KOUYI, Gislain LIPEME; !! Rivière, Nicolas; Nirschl, Hermann; Krause, Mathias J. (2019): !! Large-eddy simulation coupled with wall models for turbulent channel !! flows at high Reynolds numbers with a lattice Boltzmann method !! — Application to Coriolis mass flowmeter. In Computers & Mathematics !! with Applications 78 (10), pp. 3285–3302. DOI: 10.1016/j.camwa.2019.04.033. !! !! The explicit power-law in terms of friction velocity given in Eq. 33 in !! S. Wilhelm, J. Jacob, and P. Sagaut, \"An explicit power-law-based wall !! model for lattice Boltzmann method–Reynolds-averaged numerical simulations !! of the flow around airfoils\", Physics of Fluids 30, 065111 (2018) !! https://doi.org/10.1063/1.5031764 !! !! The model constants are chosen according to Werner and Wengle: !! Wengle, H. and Werner, H. (1993) ‘Large-eddy Simulation of Turbulent Flow !! Over Sharp-edged Obstacles in a Plate Channel’, (1985), pp. 192–199. !! !! author: Gregorio Gerardo Spinelli module mus_wall_function_reichardt_module ! include treelm modules use env_module , only : rk use mus_wall_function_abstract_module , only : mus_wall_function_type implicit none private !! Constant parameters for Reichardt's law real ( kind = rk ), parameter :: vonKA = 0.4_rk real ( kind = rk ), parameter :: oneOvervonKA = 1.0_rk / vonKA public :: mus_wall_function_reichardt_type !> extend the abstract subclass mus_wall_function_type type , extends ( mus_wall_function_type ) :: mus_wall_function_reichardt_type contains !> function to get uPlus procedure , nopass :: get_uPlus !> function to apply the newon method ! F = uPlus_n - uPlus_(n+1) ! here we compute the derivative of uPlus_(n+1) w.r.t. u_tau ! this function computes the derivative of uPlus with respect to uTau procedure , nopass :: get_d_uPlus_d_uTau end type mus_wall_function_reichardt_type contains !> function to get uPlus pure function get_uPlus ( yPlus ) result ( uPlus ) !> yPlus real ( kind = rk ), intent ( in ) :: yPlus !> output: uPlus real ( kind = rk ) :: uPlus ! ------------------------------------------------------------------------------ !uPlus = oneOvervonKA * log( 1.0_rk + vonKA*yPlus )     & !   &                 + 7.8 * ( 1.0_rk-exp(-yPlus/11._rk)  & !   &                 - (yPlus/11._rk) * exp(-yPlus/3._rk) ) ! above expression simplified with sympy in python uPlus = - 0.709090909090909_rk * yPlus * exp ( - yPlus / 3._rk ) & & + log ( vonKA * yPlus + 1._rk ) + 7.8_rk & & - 7.8_rk * exp ( - yPlus / 1 1._rk ) + oneOvervonKA end function get_uPlus !> function to get the derivative of uPlus with respect to uTau pure function get_d_uPlus_d_uTau ( y , uTau , nu ) result ( d_uPlus_d_uTau ) !> vertical distance from the wall real ( kind = rk ), intent ( in ) :: y !> uTau at iteration n real ( kind = rk ), intent ( in ) :: uTau !> dynamic viscosity real ( kind = rk ), intent ( in ) :: nu !> output: derivative of uPlus with respect to uTau real ( kind = rk ) :: d_uPlus_d_uTau ! ------------------------------------------------------------------------------ real ( kind = rk ) :: inv_nu , yPlus , nu_sqr , y_inv_nu , A , B inv_nu = 1._rk / nu y_inv_nu = y * inv_nu yPlus = uTau * y_inv_nu nu_sqr = nu ** 2 A = 0.709090909090909_rk * y_inv_nu B = exp ( - yPlus / 3._rk ) ! obtained as diff from sympy in python d_uPlus_d_uTau = vonKA * y / ( nu * ( vonKA * yPlus + 1._rk ) ) & & + A * ( exp ( - yPlus / 1 1._rk ) - B ) & & + 0.236363636363636_rk * yPlus * y_inv_nu * B end function get_d_uPlus_d_uTau end module mus_wall_function_reichardt_module","tags":"","loc":"sourcefile/mus_wall_function_reichardt_module.f90.html"},{"title":"Documentation – Musubi","text":"Tutorials Start here to familiarize yourself with Musubi setup. Features Find details and examples for specific features. Test Cases Documentation of the regression test cases. Treelm Musubi uses the Treelm data structures. The Treelm library defines\nportable, convienent and complex data structures as well as data maniulation and\naccessing routines. Usage Quick Start: Building and Compiling Musubi Configuring Simulation Runs Requirements: Treelm","tags":"","loc":"page/index.html"},{"title":"Bibliography – Musubi","text":"[1]\nJoshua Boyd, James M Buick, and Simon Green. Analysis of the Casson and Carreau-Yasuda non-Newtonian blood models in steady and oscillatory flows using the lattice Boltzmann method. Physics of Fluids, 19(9):093103, 2007. [2]\nDaniel F. Harlacher, Harald Klimach, Sabine Roller, Christian Siebert, and Felix Wolf. Dynamic load balancing for unstructured meshes on space-filling curves. In Parallel and Distributed Processing Symposium Workshops PhD Forum (IPDPSW), 2012 IEEE 26th International, pages 1661–1669, may 2012. [3]\nMichael Junk, Axel Klar, and Li-Shi Luo. Asymptotic analysis of the lattice Boltzmann equation. Journal of Computational Physics, 210(2):676–704, December 2005. [4]\nHarald Klimach, Manuel Hasert, Jens Zudrop, and Sabine Roller. Distributed octree mesh infrastructure for flow simulations. European Congress on Computational Methods in Applied Sciences and Engineering, pages 1–15, 2012. [5]\nJonas Latt. Hydrodynamic limit of lattice Boltzmann equations. PhD thesis, Université Genève, September 2011. [6]\nMorton. A computer oriented geodetic data base and a new technique in file sequencing. Technical report, IBM Ltd., 1966. [7]\nKeigo Ota, Kosuke Suzuki, and Takaji Inamuro. Lift generation by a two-dimensional symmetric flapping wing: immersed boundary-lattice Boltzmann simulations. Fluid Dynamics Research, 44(4):045504, April 2012.","tags":"","loc":"page/bibliography.html"},{"title":"Examples – Musubi","text":"Warning WORK IN PROGRESS This is a collection of examples that illustrates the usage of the various\ncapabilities of Musubi. Musubi is configured via Lua scripts which need to define several variables.\nMost of these variables are tables with multiple components. See any of the\nspecific examples below for a complete configuration. At least the following need to be defined: sim_control , see tem_simControl_module , note that there are additional\n                 abort options defined for Musubi,\n                 see mus_abortCriteria_module mesh , see treelmesh_module physics , see mus_physics_module identify , see mus_scheme_header_module initial_condition , see mus_flow_module boundary_condition , see mus_bc_header_module Some other variables may be set to enable optional features or override\ndefaults: tracking , see mus_tracking_module restart , see mus_restart_module logging , see tem_logging_module Treelm also provides various general settings that may be specified in the\nconfiguration, see tem_general_module . Please note that you can include other Lua scripts with require .\nAnd you can access table components with a dot notation like equation.name . The Lua script will be executed by Musubi and in the end the defined variables\nwill be used as configuration for the simulation. A configuration that shows the typical parameters for a flow simulation is\nprovided in Nozzle Flow inside . Examples The example setups are structured according to the physics supported by Musubi: Fluid flows Weakly compressible flows Incompressible flows Isothermal acoustics flows Multicomponent flows Gas mixtures Liquid mixtures Advection-Diffusion equations (Scalar transport equations) Nernst-Planck equation for ionic species transport Poisson equation","tags":"","loc":"page/examples/index.html"},{"title":"Weakly compressible flows – Musubi","text":"Warning WORK IN PROGRESS Weakly compressible flows Navier-Stokes equations Mass conservation equation Momentum conservation equations Equation of state Benchmarks Applications","tags":"","loc":"page/examples/fluid/index.html"},{"title":"Applications – Musubi","text":"Warning WORK IN PROGRESS Application test cases for weakly compressible flows Airfoil Immerse boundary method Nonreflecting boundary condition Nozzle Silencer","tags":"","loc":"page/examples/fluid/application/index.html"},{"title":"Nonreflecting Boundary Conditions – Musubi","text":"Warning WORK IN PROGRESS, see also issue #2286 This setup shows the use of non-reflecting boundary conditions. Here is an example for the definition of a boundary condition of this type: { label = 'east' , kind = 'outlet' , pressure = 0 , kappa = 1 , sigma = 0.1 , length = 256 , mach_lat = 0.05 / math.sqrt ( 1. / 3. ) } Look in mus_bc_header_module for details on configuring boundary conditions\nand mus_bc_fluid_module for their actual implementation. The configuration file musubi.lua provides a complete example for a simulation\nsetup with this boundary condition: -- This setup illustrates the use of non-reflecting boundary conditions. -- -- This kind of boundary condition is selected by 'outlet_nrbc'. -- It requires the definition of the following parameters: -- -- * kappa: TODO, add description -- * sigma: TODO, add description -- * length: TODO, add description -- * mach_lat: TODO, add description simulation_name = 'nrbc' require \"seeder\" omega = 1.8 model = 'fluid' Re = 200 amplitude = 0.1 cs2LB = 1. / 3. rho0LB = 1. bcKind = 'outlet_nrbc' verbose = true --Scaling----------------------------------------------------------------------- scaling = 'acoustic' -- at this point in time, the reflection from the nrbc outlet has propagated -- back to the tracking point to yield a maximum there. tEnd = 5 u0 = 1. -- length and level is defined in seeder.lua viscosity = u0 * length / Re dx = length / 2. &#94; level u0LB = 0.05 uLB = u0LB dt = uLB / u0 * dx viscLB = viscosity * dt / dx / dx omega = 1. / ( 3. * viscLB + 0.5 ) nIter = math.ceil ( tEnd / dt ) p0 = 0 MaLB = uLB / math.sqrt ( cs2LB ) ------------------------------------------------------------------------------- kind = {} kind [ 'xM' ] = 'wall' kind [ 'xP' ] = 'wall' kind [ 'yM' ] = 'wall' kind [ 'yP' ] = 'wall' kind [ 'zM' ] = 'wall' kind [ 'zP' ] = 'wall' -- checkDir is defined in seeder.lua kind [ checkDir ] = bcKind -- factorTrack = {} factorTrack [ 'xM' ] = { 0.25 , 0.5 , 0.5 } factorTrack [ 'xP' ] = { 0.75 , 0.5 , 0.5 } factorTrack [ 'yM' ] = { 0.5 , 0.25 , 0.5 } factorTrack [ 'yP' ] = { 0.5 , 0.75 , 0.5 } factorTrack [ 'zM' ] = { 0.5 , 0.5 , 0.25 } factorTrack [ 'zP' ] = { 0.5 , 0.5 , 0.75 } trackPos = { origin [ 1 ] + factorTrack [ checkDir ][ 1 ] * length , origin [ 2 ] + factorTrack [ checkDir ][ 2 ] * length , origin [ 3 ] + factorTrack [ checkDir ][ 3 ] * length } print ( 'tracking Position:  ' .. trackPos [ 1 ] .. ' ' .. trackPos [ 2 ] .. ' ' .. trackPos [ 3 ] ) rho0 = 1.0 kappa = 1.0 sigma = 0.1 LcharLB = 2 &#94; level timing_file = 'mus_timing.res' -- Simulation name mesh = 'mesh/' -- Mesh information -- Time step settigs tmax = nIter interval = tmax / 20 sim_control = { time_control = { max = tEnd } } interpolation_method = 'quadratic' physics = { dt = dt , rho0 = 1. } identify = { kind = 'fluid' , -- simulation type of this scheme relaxation = 'bgk' , -- relaxation type (bgk, mrt, ...) layout = 'd3q19' } originX = origin [ 1 ] + length / 2. originY = origin [ 2 ] + length / 2. originZ = origin [ 3 ] + length / 2. halfwidth = length / 50. function ic_1Dgauss_pulseX ( x , y , z , t ) return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( x - originX ) &#94; 2 ) end function ic_1Dgauss_pulseY ( x , y , z , t ) return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( y - originY ) &#94; 2 ) end function ic_1Dgauss_pulseZ ( x , y , z , t ) return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( z - originZ ) &#94; 2 ) end function ic_2Dgauss_pulse ( x , y , z , t ) return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( ( x - originX ) &#94; 2 + ( y - originY ) &#94; 2 ) ) end function ic_3Dgauss_pulse ( x , y , z , t ) return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( ( x - originX ) &#94; 2 + ( y - originY ) &#94; 2 + ( z - originZ ) &#94; 2 ) ) end function gausspulse ( x , y , z , t ) if checkDir == 'xM' or checkDir == 'xP' then val = ic_1Dgauss_pulseX ( x , y , z ) elseif checkDir == 'yM' or checkDir == 'yP' then val = ic_1Dgauss_pulseY ( x , y , z ) elseif checkDir == 'zM' or checkDir == 'zP' then val = ic_1Dgauss_pulseZ ( x , y , z ) end return val end -- Initial condition initial_condition = { pressure = gausspulse , velocityX = 0.0 , velocityY = 0.0 , velocityZ = 0.0 , Sxx = 0 , Syy = 0 , Szz = 0 , Sxy = 0 , Syz = 0 , Sxz = 0 , } -- outer omega cutoff ratio w_min = 10. -- inner omega cutoff ratio w_max = 1. cutoff_min = 0.45 * length * 0.5 cutoff_max = 0.5 * length * 0.5 function spatialFunction ( x , y , z ) if ( x < cutoff_min ) then res = w_max elseif ( x >= cutoff_max ) then res = w_min else slope = ( w_max - w_min ) / ( cutoff_min - cutoff_max ) res = x * slope + w_max - cutoff_min * slope end return res end fluid = { kinematic_viscosity = viscosity , bulk_viscosity = 2 * viscosity / 3.0 } boundary_condition = { { label = 'wall_xM' , kind = kind [ 'xM' ], pressure = 'p0' , kappa = kappa , sigma = sigma , length = LcharLB , mach_lat = MaLB }, { label = 'wall_xP' , kind = kind [ 'xP' ], pressure = 'p0' , kappa = kappa , sigma = sigma , length = LcharLB , mach_lat = MaLB } } logging = { level = 10 } -- user variables variable = { { name = 'p0' , ncomponents = 1 , vartype = 'st_fun' , st_fun = p0 } } -- Tracking tracking = { { label = 'probe_' .. identify . kind , variable = { 'pressure_phy' , 'density' ,}, folder = 'tracking/' , shape = { kind = 'canoND' , object = { origin = trackPos } }, time_control = { min = 0 , max = tmax , interval = dt }, output = { format = 'ascii' }, }, { label = 'hvs' , variable = { 'pressure_phy' , 'density' }, folder = 'tracking/' , shape = { kind = 'canoND' , object = { origin = trackPos } }, time_control = { min = 0 , max = tmax , interval = interval }, output = { format = 'harvester' } } } if verbose then print ( 'Scaling  ' .. scaling .. ' on level ' .. level ) print ( '  Re       ' .. Re ) print ( '  omega    ' .. omega ) print ( '  uLB      ' .. uLB ) print ( '  dx       ' .. dx ) print ( '  dt       ' .. dt ) print ( '  nIter    ' .. nIter ) end restart = { write = 'restart/' , time_control = { min = 0. , max = nIter , interval = interval } }","tags":"","loc":"page/examples/fluid/application/Nonreflecting_BC/index.html"},{"title":"Nozzle – Musubi","text":"Warning WORK IN PROGRESS Nozzle This testcase is used in SimTec-II lecture to find optimal nozzle configuration\nwith least pressure at nozzle neck. Here are the list of test cases used in SimTec-II: Nozzle flow inside : Used to introduced nozzle \ntestcase. Nozzle flow in and around : Used in final\noptimization project.","tags":"","loc":"page/examples/fluid/application/Nozzle/index.html"},{"title":"Nozzle flow inside an around – Musubi","text":"Warning WORK IN PROGRESS Nozzle flow inside and around","tags":"","loc":"page/examples/fluid/application/Nozzle/NOZ_FlowInAndAround/index.html"},{"title":"Nozzle flow inside – Musubi","text":"Warning WORK IN PROGRESS Nozzle flow inside","tags":"","loc":"page/examples/fluid/application/Nozzle/NOZ_FlowInside/index.html"},{"title":"Benchmarks – Musubi","text":"Benchmark test cases for weakly compressible flows Gaussianpulse Channel 2D Channel 3D Backward facing step Turbulent channel Absorbing layer","tags":"","loc":"page/examples/fluid/benchmark/index.html"},{"title":"Channel 2D – Musubi","text":"Channel 2D The objective of the channel 2D examples are to introduce the following \nfeatures in Musubi: Boundary conditions to define pressure and velocity at the boundaries. Q-Values at boundaries to improve the accuracy of boundary conditions. Multilevel simulations Non-Newtonian models. External forces. Here are the list of test cases to learn these features in Musbi: Simple Boundary conditions Flow around the cylinder Single-level Multi-level Non-Newtonian External force In these test cases, in addition to the aforementioned features, \nyou will also learn how to: Create a mesh with boundaries using Seeder. Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/index.html"},{"title":"Channel 2D Boundary Conditions – Musubi","text":"Warning WORK IN PROGRESS Channel 2D Boundary Conditions The testcases of channel 2D boundary present some\ncombination of boundary conditions using the Poisueille testcase: Boundary conditions to define pressure, velocity or mass flow rate at the \nboundaries, using the analytical solution as input. Some of the cases use symmetry conditions. Q-Values at boundaries to improve the accuracy of boundary conditions. Here is the list of test cases: inlet: mass flow rate bounce back, outlet: pressure extrapolation inlet: mass flow rate equilibrium, outlet: pressure equilibrium inlet: pressure extrapolation, outlet: pressure extrapolation inlet: velocity bounce back, outlet: pressure extrapolation inlet: velocity linear extrapolation , outlet: pressure extrapolation inlet: velocity equilibrium, outlet: pressure equilibrium inlet: velocity non-equilibrium etrapolation, outlet: pressure non-equilibrium etrapolation","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/index.html"},{"title":"Channel 2D MfrBB PressExpol – Musubi","text":"Warning WORK IN PROGRESS Test case description:\nSimple channel flow using mass flow rate bounce back as inlet and pressure extrapolation as outlet boundary.\nBe aware: Mass flow rate is given as scalar value, so the inflow condition does not match the analytical solution. using symmetry at y-Axis. So computing only the lower part of the channel.\nThe upper part of the channel is symmetric to the lower part. The templates directory contains a shepherd config file and all necessary template files to run convergence studies for mesh refinement and omega.\nFor numeric stability the Reynolds number has been decreased to 10  to ensure the simulations stay below limits of LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_MfrBB_PressExpol/index.html"},{"title":"Channel 2D MfrEq PressEq – Musubi","text":"Warning WORK IN PROGRESS Channel 2D - Pressure Equilibrium BCs Test Case Description Simple channel flow driven by pressure drop across the channel.\nUsing mass flow rate equilibrium as inlet boundary and pressure equilibrium\nboundary as outlet.\nIn order to run the test case with the same settings as the other C2D_BC cases,\ndouble the number of elements in height  (nHeight = 40) in seeder.lua to use 40\ninstead of 20 elements and thus a finer resolution. Plots For the nightly regression check, the tracking is mostly deactivated. Please\nmake sure to remove the comments to activate it for usual runs. Templates for Advanced Studies The templates directory contains a shepherd config file and all necessary\ntemplate files to run convergence studies for mesh refinement and omega.\nFor numerical stability the Reynolds number has been decreased to 10 (instead of\n100) to ensure that the simulations stay below limits of the LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_MfrEq_PressEq/index.html"},{"title":"Channel 2D PressExpol PressExpol – Musubi","text":"Warning WORK IN PROGRESS Channel 2D - Pressure Extrapolation BCs Test Case Description Simple channel flow driven by pressure drop across the channel.\nUsing pressure extrapolation boundary as in- and outlet.\nIn order to run the test case with the same settings as the other C2D_BC cases,\ndouble the number of elements in height  (nHeight = 40) in seeder.lua to use 40\ninstead of 20 elements and thus a finer resolution. Plots For the nightly regression check, the tracking is mostly deactivated. Please\nmake sure to remove the comments to activate it for usual runs. Templates for Advanced Studies The templates directory contains a shepherd config file and all necessary\ntemplate files to run convergence studies for mesh refinement and omega.\nFor numerical stability the Reynolds number has been decreased to 10 (instead of\n100) to ensure that the simulations stay below limits of the LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_PressExpol_PressExpol/index.html"},{"title":"Channel 2D VelBB PressExpol – Musubi","text":"Warning WORK IN PROGRESS Test case description:\nSimple channel flow using velocity bounce back inlet boundary and pressure extrapolation outlet boundaryusing velocity bounce back inlet boundary and pressure expol outlet boundary. using symmetry at y-Axis. So computing only the lower part of the channel.\nThe upper part of the channel is symmetric to the lower part. The templates directory contains a shepherd config file and all necessary template files to run convergence studies for mesh refinement and omega.\nFor numeric stability the Reynolds number has been decreased to 10  to ensure the simulations stay below limits of LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_VelBB_PressExpol/index.html"},{"title":"Channel 2D VelBFL PressExpol – Musubi","text":"Warning WORK IN PROGRESS Test case description:\nSimple channel flow using BFl velocity inlet boundary and pressure extrapolation outlet boundary. using symmetry at y-Axis. So computing only the lower part of the channel.\nThe upper part of the channel is symmetric to the lower part. The templates directory contains a shepherd config file and all necessary template files to run convergence studies for mesh refinement and omega.\nFor numeric stability the Reynolds number has been decreased to 10  to ensure the simulations stay below limits of LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_VelBFL_PressExpol/index.html"},{"title":"Channel 2D VelEq PressEq – Musubi","text":"Warning WORK IN PROGRESS Test case description:\nSimple channel flow using velocity equilibrium inlet boundary and pressure equilibrium outlet boundary. using symmetry at y-Axis. So computing only the lower part of the channel.\nThe upper part of the channel is symmetric to the lower part. The templates directory contains a shepherd config file and all necessary template files to run convergence studies for mesh refinement and omega.\nFor numeric stability the Reynolds number has been decreased to 10  to ensure the simulations stay below limits of LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_VelEq_PressEq/index.html"},{"title":"Channel 2D VelNonEqExpol PressNonEqExpol – Musubi","text":"Warning WORK IN PROGRESS Channel 2D - Non-Equilibrium Extrapolation BCs Test Case Description Simple channel flow driven by pressure drop across the channel.\nUsing velocity nonequilibrium extrapolation boundary as inlet and pressure non-\nequilibrium extrapolation as outlet.\nIn order to run the test case with the same settings as the other C2D_BC cases,\ndouble the number of elements in height  (nHeight = 40) in seeder.lua to use 40\ninstead of 20 elements and thus a finer resolution. Plots For the nightly regression check, the tracking is mostly deactivated. Please\nmake sure to remove the comments to activate it for usual runs. Templates for Advanced Studies The templates directory contains a shepherd config file and all necessary\ntemplate files to run convergence studies for mesh refinement and omega.\nFor numerical stability the Reynolds number has been decreased to 10 (instead of\n100) to ensure that the simulations stay below limits of the LBM method.","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_BoundaryConditions/C2D_BC_VelNonEqExpol_PressNonEqExpol/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D | Test case channel 2D boundary condition → Poisueille flow in a channel 2D using different bgk collision schemes In this example, we will investigate the Poiseuille flow in a plain 2D channel.\nThe objectives of this example is to introduce how to: Create a mesh with boundaries using Seeder. Post-process the mesh using Seeder-harvester and visualize it Paraview. Simulate Poiseuille flow in the channel using Musubi. Use different bgk collision schemes (see 'Recommendations' below). Validate the numerical results. Visualize the flow in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot. Here is the list of test cases to learn these features in Musbi and some hints\non when to use what:\nToDo: Update points/characteristics below. Bhatnagar-Gross-Krook (BGK) Simplest BGK scheme Regularized BGK (rBGK) Non-dissipative scheme. In general more unstable than the classical BGK scheme. Said to exhibit increased stability for problems with large gradients and\n    turbulent flows. Recursive regularized BGK (rrBGK) Enhanced stability and accuracy compared to the classical BGK scheme. Said to be cheaper then the classical one. Projected recursive regularized BGK (prrBGK) ToDo: Add information here. Hybrid recursive regularized BGK (prrBGK) ToDo: Add information here. Dual relaxation time BGK (drtBGK) ToDo: Add information here. Problem description The Poiseuille flow is the fully developed laminar flow between two parallel\nplates induced by a constant pressure drop in a channel of length L.\nIn general, the flow can be induced by any of the following way: Defining pressure at inlet and outlet of the channel. Defining velocity at inlet and pressure at outlet of the channel. Here is the example. Using pressure gradient i.e. pressure drop/length as a external force. Here is the example. Here, the flow is induced by pressure boundary condition at inlet (west)\nand outlet (east) boundaries as shown in figure below. The pressure drop along the channel per unit length is where, - the maximum fluid velocity at the channel center axis, - the fluid density and - kinematic viscosity. The Reynolds number is defined as where, - the mean velocity.\nFor the parabolic velocity profile, the mean velocity can be computed with . The analytical velocity profile along channel height is given as the analytical pressure profile along the channel length is and wall shear stress profile along the channel height is The error between analytical solution ( ) and simulated results\n( ) are defined by the relative error norm as Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define boundary condition Post-processing Here are the results from the simulation. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.inf.tu-dresden.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using BGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the bgk collision scheme. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_BGK/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using drtBGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the dual relaxation time bgk (drtBGK) collision scheme with a second order\nregularization. This collision scheme is called as below in the identify table.\nrelaxation = 'drt_bgk' The fluid table in musubi.lua should include the following\n--! [Fluid]\nfluid = {\n  kinematic_viscosity = nu_phy,\n  drt_taun = 0.55 -- default = 0.70\n}\n--! [Fluid] The taun has a default value of 0.70 which can be overwritten from input. This\nrepresents a relaxation time, therefore must be greater than 0.50 for stability.\nIf the value inserted does not produce a stable result, please decrease it\ntowards 0.50. For this test case with the original seeder.lua file, the default\nvalue of 0.70 does not produce a stable run. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. To create them, double the number of\nelements in height (nHeight=32) in seeder.lua. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_drtBGK/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using hrrBGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the hybrid recursive regularized bgk (hrrBGK) collision scheme with a\nfourth order regularization. This collision scheme is called as below in the identify table.\nrelaxation = 'hrr_bgk' The fluid table in musubi.lua should include the following\n--! [Fluid]\nfluid = {\n  kinematic_viscosity = nu_phy,\n  hrr_sigma = 0.99 -- default = 0.98\n}\n--! [Fluid] The sigma has a default value of 0.98 which can be overwritten from input. This\nrepresents a blending coefficient, therefore must be greater equal than 0.0\nand lower equal than 1.0. A value of 0.00 reverts the HRR to the PRR scheme.\nA value of 1.0 reverts the HRR into the RR scheme. Any value in between\nis a blended scheme. For non dissipative runs, try to stay closer to 0.98.\nThe RR scheme dissipates less than the PRR scheme. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. To create them, double the number of\nelements in height (nHeight=32) in seeder.lua. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_hrrBGK/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using prrBGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the projected recursive regularized bgk (prrBGK) collision scheme with a\nfourth order regularization. This collision scheme is called as below in the identify table.\nrelaxation = 'prr_bgk' This is a high dissipative scheme. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. To create them, double the number of\nelements in height (nHeight=32) in seeder.lua. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_prrBGK/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using rBGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the regularized bgk (rBGK) collision scheme with a second order\nregularization. This collision scheme is called as below in the identify table.\nrelaxation = 'r_bgk' This is a non-dissipative scheme. In general it is more unstable than the\nclassic BGK scheme. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_rBGK/index.html"},{"title":"Poisueille flow in a channel 2D – Musubi","text":"Navigate: ← Test case channel 2D Poisueille flow in a channel 2D using rrBGK collision scheme In this example, we will investigate the Poiseuille flow in a plain 2D channel\nusing the recursive regularized bgk (rrBGK) collision scheme with a fourth\norder regularization. This collision scheme is called as below in the identify table.\nrelaxation = 'rr_bgk' This is a non-dissipative scheme. A detailed description of test case can be found in the parent directory Description of test case channel 2D . Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. To create them, double the number of\nelements in height (nHeight=32) in seeder.lua. Velocity along the height of the channel: Pressure across the length of the channel: Wall shear stress along the height of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/Channel2D/C2D_Simple/C2D_Simple_rrBGK/index.html"},{"title":"Channel 3D test cases – Musubi","text":"Warning WORK IN PROGRESS Channel 3D Here is the list of test cases:\n* Channel 3D Sphere with multilevel and LES","tags":"","loc":"page/examples/fluid/benchmark/Channel3D/index.html"},{"title":"Turbulent flow around the cylinder in a channel 3D at Re=3900 – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case channel 3D Turbulent flow around the sphere in a channel 3D In this example, we will investigate the turbulent flow around the cylinder\nin a 3D channel for Re=3900.\nThe objectives of this example is to introduce how to: Create a mesh with boundaries using Seeder. Post-process the mesh using Seeder-Harvester and visualize it with Paraview. Simulate the flow in the channel using Musubi. Validate the numerical results. Visualize the flow in Paraview.","tags":"","loc":"page/examples/fluid/benchmark/Channel3D/C3D_Cylinder_MultiLevel_LES/index.html"},{"title":"Turbulent flow around the sphere in a channel 3D – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case channel 3D Turbulent flow around the sphere in a channel 3D In this example, we will investigate the turbulent flow around the sphere\nin a 3D channel for Re=1000.\nThe objectives of this example is to introduce how to: Create a mesh with boundaries using Seeder. Post-process the mesh using Seeder-Harvester and visualize it with Paraview. Simulate the flow in the channel using Musubi. Validate the numerical results. Visualize the flow in Paraview.","tags":"","loc":"page/examples/fluid/benchmark/Channel3D/C3D_Sphere_MultiLevel_LES/index.html"},{"title":"Turbulent channel – Musubi","text":"Turbulent channel flow test cases for weakly compressible flows SingleLevel","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/index.html"},{"title":"Turbulent channel wall model validation – Musubi","text":"Navigate: ← Test case turbulent channel Turbulent channel flow test cases for weakly compressible flows This example is used to validate the wall model implementation in Musubi.","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/TC_SingleLevel/index.html"},{"title":"Turbulent channel wall model Musker – Musubi","text":"Navigate: ← Test case turbulent channel Turbulent channel flow test cases for weakly compressible flows This example is used to validate the Musker wall model with fixed point nonlinear \nsolver implementation in Musubi.","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/TC_SingleLevel/TC_SL_MuskerFixedPoint/index.html"},{"title":"Turbulent channel wall model Musker (Newton) – Musubi","text":"Navigate: ← Test case turbulent channel Turbulent channel flow test cases for weakly compressible flows This example is used to validate the Musker wall model with Newton nonlinear\nsolver implementation in Musubi.","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/TC_SingleLevel/TC_SL_MuskerNewton/index.html"},{"title":"Turbulent channel wall model Power-Law – Musubi","text":"Navigate: ← Test case turbulent channel Turbulent channel flow test cases for weakly compressible flows This example is used to validate the Power-Law wall model solver implementation in Musubi.","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/TC_SingleLevel/TC_SL_PowerLaw/index.html"},{"title":"Turbulent channel wall model Reichardt – Musubi","text":"Navigate: ← Test case turbulent channel Turbulent channel flow test cases for weakly compressible flows This example is used to validate the Reichardt wall model with fixed point nonlinear \nsolver implementation in Musubi.","tags":"","loc":"page/examples/fluid/benchmark/TurbulentChannel/TC_SingleLevel/TC_SL_ReichardtFixedPoint/index.html"},{"title":"Convected vortex in a domain with a coarser grid at the center – Musubi","text":"Vortex convection In this example, we will simulate a Vortex convected in a uniform flow. The objectives of this example is to introduce how to:\n* How to use the new interpolation based on the transfer of both\n  equilibrium and non equilibrium pdfs at multi level interfaces. The choice is available in the musubi.lua file.\ninterpolation_method = {\n  method = 'quadratic', -- or any other: linear, weighted_average\n  type_of_interpolation = 'moment'  -- 'pdf' \n} type_of_interpolation = pdf => feq_neq (new version)\ntype_of_interpolation = moment => moment (old version) how to set the new collision models: \n    Recursive Regularized bgk (rr_bgk), \n    Projected RR_bgk (prr_bgk), \n    Hybrid RR_bgk (hrr_bgk), \n    Dual Relaxation Time rr_bgk (drt_bgk). \n  For HRR_bgk we need to give in input the value of sigma in the fluid \n  table, see below. The default value is 0.98. For DRT_bgk we need to \n  give in input the tauN value. The dafault value is 0.70. --! [Scheme identifier]\nidentify = {\n  layout = 'd2q9',    -- Stencil\n  relaxation = 'prr_bgk', -- Collision: rr_bgk, prr_bgk, hrr_bgk\n  kind = 'fluid'      -- Physics\n}\n--! [Scheme identifier] --! [Fluid]\nfluid = {\n  kinematic_viscosity = nu_phy,\n  hrr_sigma = 0.00, -- default: 0.98\n  drt_taun = 0.7, -- default: 0.70\n}\n--! [Fluid] ToDo This file has to be filled with content like:\n* Problem description\n* Formulas\n* Results\n* Comparison for different resoultions\n* How to run the simulation","tags":"","loc":"page/examples/fluid/benchmark/Vortex_convection/index.html"},{"title":"Absorbing layers – Musubi","text":"Benchmark test cases to validate absorbing layer Acoustic pulse2D Acoustic pulse3D Acoustic line source Acoustic cylinder 2D","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/index.html"},{"title":"Acoustic Line Source – Musubi","text":"Acoustic 2D line source for plane absorbing layer This test case provides an example for using absorbing layer at outlet boundary.\nThe fluctuating pressure field is defined at the west boundary and \nbackground pressure is defined at the east boundary. The planar absorbing layer\nis defined at the east boundary with a thickness of 0.8.","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticCylinder2D/index.html"},{"title":"Acoustic Line Source 2D – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case absorbing layer | Test case acoustic pulse 2D → | Test case acoustic pulse 3D → | Test case acoustic cylinder 2D → Acoustic 2D line source for plane absorbing layer This test case provides an example for using absorbing layer at outlet boundary.\nThe ambient pressure is distrubed by a 2D acousic line source. The total\npressure field (ambient plus fluctuations) is defined at the west boundary and\nambient pressure is defined at the east boundary. The planar absorbing layer\nis defined at the east boundary with a thickness of 0.8.\nThe objectives of this example is to introduce how to: Create a mesh with boundaries using Seeder. Post-process the mesh using Seeder-harvester and visualize it Paraview. Simulate a 2D acoustic line source in a channel using Musubi. Set up an absorbing layer. Validate the numerical results. Visualize the flow in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot. Generating mesh Define geometry information Define spatial objects Running simulation Define flow parametes Define collision parameter Define boundary condition Post-processing Here are the results from the simulation. Pressure across the length of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticLineSource2D/index.html"},{"title":"Acoustic pulse 2D – Musubi","text":"Acoustic 2D pulse test cases with different spatial absorbing layers {ex_fluid_abslayer_pulse2D} The objective of the acoustic 2D pulse examples are to introduce the following\nfeatures in Musubi: Define a function (pulse) to use it for boundary conditions. Define absorbing layer as source term. Setup of different sponges as listed below. Here are the list of test cases to learn these features in Musubi: Absorbing layer plane Absorbing layer box Absorbing layer radial In these test cases, in addition to the aforementioned features, you will also\nlearn how to: Create a mesh with boundaries using Seeder. Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticPulse2D/index.html"},{"title":"Acoustic pulse 2D with absorbing layer box 2d – Musubi","text":"Acoustic pulse 2D with absorbing layer box The predefined spatial function \"absorblayer_box_2d\" creates absorbing layer\nwith rough corners.","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticPulse2D/absLayerBox/index.html"},{"title":"Acoustic pulse 2D with absorbing layer plane – Musubi","text":"Absorbing layer plane The predefined spatial function \"absorblayer_plane\" creates absorbing layer\nat four sides with four space-time functions.","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticPulse2D/absLayerPlane/index.html"},{"title":"Acoustic pulse 2D with absorbing layer radial – Musubi","text":"Acoustic pulse 2D with absorbing layer radial The predefined spatial function \"absorblayer_radial\" creates radial absorbing\nlayer which is best suited to absorb acoustic waves generated at the center\nof the domain.","tags":"","loc":"page/examples/fluid/benchmark/absorbingLayer/acousticPulse2D/absLayerRadial/index.html"},{"title":"Gaussian Pulse in Pressure in a Cube – Musubi","text":"Warning WORK IN PROGRESS Gaussian Pulse in Pressure in a Cube In this example, we will simulate a Gaussian pulse in pressure in a simple\npre-defined cube with periodic boundaries and user-defined initial condition.\nThe gaussian pulse can be also used via a pre-defined function, c. f.\n* pre-defined gaussian pulse For this simple geometry, we even do not need Seeder . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Simulate the Gaussian pulse in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Validate the numerical results by comparing them against the analytic\n  solution. The latter one is calculated using NumPy, a mathematic extension for\n  Python.\n* Compare the simulation results (L4) to previously generated data obtained with\n  higher resolution (reference folder, L5 & L6) to experience the influence of\n  the resolution. ToDo This file has to be filled with content like:\n* Problem description\n* Formulas\n* Results\n* Comparison for different resolutions\n* How to run the simulation Here are the results from the simulation. Pressure across the length of the channel for different resolutions at the\nbeginning (initial condition): The higher the level -- and with that the resolution -- the better the solution\ncompared to the analytical one. Pressure across the length of the channel for high resolution (L6) at the end: To reproduce this plot, set 'shepherd = false' in musubi.lua. To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid/benchmark/gaussianPulse/index.html"},{"title":"Tracking point outside the domain – Musubi","text":"A tracking point slightly outside the domain This test case provides an example where the a probe is put\nat a point that is slightly outside the domain and needs to\nbe extrapolated.","tags":"","loc":"page/examples/fluid/benchmark/trackOutside/index.html"},{"title":"Incompressible flows – Musubi","text":"Warning WORK IN PROGRESS Incompressible flows Navier-Stokes equations Mass conservation equation Momentum conservation equations Equation of state Benchmarks Applications","tags":"","loc":"page/examples/fluid_incompressible/index.html"},{"title":"Applications – Musubi","text":"Warning WORK IN PROGRESS Application test cases for incompressible flows Spacer Aneurysm Electro-Osmotic Flow Pulsatile Flow Spacer Stent","tags":"","loc":"page/examples/fluid_incompressible/application/index.html"},{"title":"Benchmarks – Musubi","text":"Warning WORK IN PROGRESS Benchmark test cases for incompressible flows Gaussian Pulse Lid-Driven Cavity Channel 2D Channel 3D Pipe Concentric Cylinders","tags":"","loc":"page/examples/fluid_incompressible/benchmark/index.html"},{"title":"Channel 2D – Musubi","text":"Warning WORK IN PROGRESS Channel 2D The objective of the channel 2D examples are to introduce the following \nfeatures in Musubi: Boundary conditions to define pressure and velocity at the boundaries. Q-Values at boundaries to improve the accuracy of boundary conditions. Multilevel simulations Non-Newtonian models. External forces. Here is the list of test cases to learn these features in Musbi: Simple Boundary conditions Flow around the cylinder Single-level Multi-level Non-Newtonian External force In these test cases, in addition to the aforementioned features, \nyou will also learn how to: Create a mesh with boundaries using Seeder. Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Channel2D/index.html"},{"title":"Flow around the cylinder 2D single level – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test Case Channel 2D Flow around the cylinder in a channel 2D This example looks at the flow though a 2D channel with a cylinder placed into\nit and a mesh of multiple levels to better resolve the flow close to walls. Problem description The Poiseuille flow is the fully developed laminar flow between two parallel\nplates induced by a constant pressure drop in a channel of length L.\nWe place a cylinder into that channel as a disturbance and look at the flow\naround this cylinder.\nIn general, the flow can be induced by any of the following way: Defining pressure at inlet and outlet of the channel. Defining velocity at inlet and pressure at outlet of the channel. Using pressure gradient i.e. pressure drop/length as a external force. Here, the flow is induced by pressure boundary conditions at inlet (west)\nand outlet (east) boundaries. The pressure drop along the channel per unit length is where, - the maximum fluid velocity at the channel center axis, - the fluid density and - kinematic viscosity. Note In this testcase we compute the viscosity according to the Reynolds number\nand the speed of sound according to the Mach number. The Reynolds number is defined as where, - the mean velocity.\nFor the parabolic velocity profile, the mean velocity can be computed with . Post-processing Tracking relevant quantities gives us the following visualizations: Lift coefficient of the cylinder over time: Drag coefficient of the cylinder over time: Pressure along the length of the channel: Pressure coefficient over the cylinder surface: Pressure difference between stagnation in front of cylinder\nand back of the cylinder over time: The X-velocity component along the length of the channel: The Y-velocity component along the length of the channel: A Fourier transform of the flow field: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.inf.tu-dresden.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Channel2D/C2D_Cylinder_MultiLevel/index.html"},{"title":"Flow around the cylinder 2D single level – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test Case Channel 2D | Test Case Channel 2D Cylinder Multi-Level → Flow around the cylinder in a channel 2D This example looks at the flow though a 2D channel with a cylinder placed into\nit. Problem description The Poiseuille flow is the fully developed laminar flow between two parallel\nplates induced by a constant pressure drop in a channel of length L.\nWe place a cylinder into that channel as a disturbance and look at the flow\naround this cylinder.\nIn general, the flow can be induced by any of the following way: Defining pressure at inlet and outlet of the channel. Defining velocity at inlet and pressure at outlet of the channel. Using pressure gradient i.e. pressure drop/length as a external force. Here, the flow is induced by pressure boundary conditions at inlet (west)\nand outlet (east) boundaries. The pressure drop along the channel per unit length is where, - the maximum fluid velocity at the channel center axis, - the fluid density and - kinematic viscosity. Note In this testcase we compute the viscosity according to the Reynolds number\nand the speed of sound according to the Mach number. The Reynolds number is defined as where, - the mean velocity.\nFor the parabolic velocity profile, the mean velocity can be computed with . Post-processing Tracking relevant quantities gives us the following visualizations: Lift coefficient of the cylinder over time: Drag coefficient of the cylinder over time: Pressure along the length of the channel: Pressure coefficient over the cylinder surface: Pressure difference between stagnation in front of cylinder\nand back of the cylinder over time: The X-velocity component along the length of the channel: The Y-velocity component along the length of the channel: A Fourier transform of the flow field: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.inf.tu-dresden.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Channel2D/C2D_Cylinder_SingleLevel/index.html"},{"title":"Channel 3D – Musubi","text":"Warning WORK IN PROGRESS Note Add the following:\n* General informations\n* Features\n* Test cases Channel 3D The objective of the channel 3D examples are to introduce the following\nfeatures in Musubi: List general informations here. Here is the list of test cases to learn these features in Musubi: Simple Flow around the cylinder Single-level Multi-level Sponge In these test cases, in addition to the aforementioned features, you will also\nlearn how to: Create a mesh with boundaries using Seeder. Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\n  extracts data from Musubi ascii output and uses matplotlib in python library\n  to create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Channel3D/index.html"},{"title":"Simple Flow in a 3D Channel – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test Case Channel 3D Simple Flow in a Channel 3D Note Note that we reduced the pysical simulation time of the case for our\nrecheck. Therefore, 'useRecheck' is set to true in 'musubi.lua'. To reproduce\nthe results presented in the following, you have to deactivate this option in\n'musubi.lua': lua\nuseRecheck = false The tracking output of the fully converged reference is found in reference/converged . In this example, we will investigate the flow in a simple 3D channel.\nThe objectives of this example are to introduce how to: Create a mesh with boundaries using Seeder. Post-process the mesh using sdr_harvester and visualize it with Paraview. Simulate the flow in the channel using Musubi. Validate the numerical results. Visualize the simulation results in Paraview. Create a 2D plot using the Gleaner tool. Gleaner is a Python tool which\n  extracts data from Musubi ascii output and uses matplotlib in python library\n  to create a plot. Problem Description The test case is based on the well-known paper:\nSchäfer, M. et al. (1996) ‘Benchmark Computations of Laminar Flow Around a\nCylinder’, in Hirschel, E. H. (ed.) Flow Simulation with High-Performance\nComputers II: DFG Priority Research Programme Results 1993--1995. Wiesbaden:\nVieweg+Teubner Verlag, pp. 547–566. doi: 10.1007/978-3-322-89849-4_39. As we want to increase the complexity step by step, we start with the channel,\nbut without the cylinder in it. The geometry configurations and the boundary\nconditions are depicted in the figure below. The channel has a squared cross-section, where height and width are H = 0.41m.\nThe length of the channel is L = 2.5m. The fluid can be described as incompressible Newtonian fluid, with a\nkinematic viscosity of , where the fluid density is . Note In the simulation the viscosity is derived from the Re, to use a Mach number\nthat allows for a faster computation of the problem. The Reynolds number is defined as where, - the mean velocity.\nThe mean velocity can be computed with where, - the maximum fluid velocity at the channel center\naxis. The flow is induced by defining velocity at inlet and pressure at outlet of the\nchannel. At the inlet (green in the figure above), a parabolic velocity inflow\ncondition in x-direction is used: with resulting in a mean velocity of and a Reynolds number (\\ Re = 20 ).\nAt the outlet (red in the figure above), the ambient pressure is prescribed with\n(\\ p=0.0 ) . For all the other boundaries (north, south, top and bottom), wall\nboundary conditions are used. For a better overview of the parameters used, one can use the printParams.lua .\nBy running it with 'lua printParams.lua' one gets the following information: ----------------------------------------------------------------------- Simulation name:        C3D_Simple ----------------------------------------------------------------------- ------ Mesh parameters ------ height       =  0 . 41 width        =  0 . 41 length       =  2 . 5 in length    =  196 length_bnd   =  3 . 28 level        =  8 ----- Number of elements ---- in height    =  32 in width     =  32 in length    =  196 -------- Resolution --------- spatial    =    0 . 0128125 temporal   =    2 . 156647324779e - 05 ----------------------------------------------------------------------- ------ Flow parameters ------ ------ In physical units ---- Re                =     20 Vel . mean         =     15 . 244444444444 [ m/s ] Vel . max . =     34 . 3 [ m/s ] Kinematic visc . =     0 . 31251111111111 [ m&#94;s/2 ] Density           =     1 [ kg/m&#94;3 ] Press . ambient    =     117649 [ N/m&#94;2 ] Element size (dx) =     0 . 0128125 [ m ] Time step (dt)    =     2 . 156647324779e - 05 [ s ] ------ In lattice units ----- Vel . =       0 . 057735026918963 Ma                =       0 . 1 Kinematic lattice visc . = 0 . 041056019142373 Relaxation param . =       1 . 6047035596284 ----------------------------------------------------------------------- Post-Processing Here are the results from the simulation. Velocity along the height of the channel: Pressure across the length of the channel: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.inf.tu-dresden.de/hg/gleaner .","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Channel3D/C3D_Simple/index.html"},{"title":"Concentric Cylinders – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Benchmark Test Cases | Test case concentric cylinder Couette flow → Concentric Cylinders-Couette Flow Couette flow between two circular cylinders is used to investigate the behaviour\nof velocity boundary condition for complex geometries with q-values.\nIn this flow, the inner cylinder with radius rotates with a constant\nangular velocity and the outer cylinder with radius is kept\nstationary. This Couette flow has the following analytical solution where and . Here are the list of test cases: Single-level Multi-level The geometry of the this cylindrical channel is created with the help of the\nSTL in cylinder_Dia1m.stl . In these test cases, in addition to the aforementioned features,\nyou will also learn how to: Create a mesh with boundaries with q-values using Seeder. Post-processing and visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python\nto create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/ConcentricCylinders/index.html"},{"title":"Concentric Cylinders – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test Case Concentric Cylinder Couette Flow | Test Case Concentric Cylinder Couette Flow Multi-Level → Concentric Cylinders-Couette Flow Couette flow between two circular cylinders is used to investigate the behaviour\nof velocity boundary condition for complex geometries with q-values.\nIn this flow, the inner cylinder with radius rotates with a\nconstant angular velocity and the outer cylinder with\nradius is kept stationary. This Couette flow has the following analytical solution where and . This analytical solution is provided as the variable vel_analy in the musubi\nconfiguration. The mesh created here is a single level with 32 elements in the inner cylinders\ndiameter (and accordingly 32 elements between inner and outer cylinder). To decide the convergence, the x axis in the right side of the cylinder is\nused. This line is defined as the track_line table and used in the abort\ncriteria, a tracking over time and the spatial tracking for the final output.\nOnce the average velocity magnitude over this line doesn't change more than\nthe provided threshold in the abort section anymore or the tmax_phy time is\nreached, the simulation will stop. The run.sh runs the complete simulation, from mesh generation to creating an\nimage of the velocity profile over the track_line .\nYou need to set the executable paths there accordingly and have gleaner for it\nto work.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/ConcentricCylinders/COC_CoeutteFlow/index.html"},{"title":"Concentric Cylinders – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test Case Concentric Cylinder Couette Flow | Test Case Concentric Cylinder Couette Flow Single-Level → Concentric Cylinders-Couette Flow Multi-level Couette flow between two circular cylinders is used to investigate the behaviour\nof velocity boundary condition for complex geometries with q-values.\nIn this flow, the inner cylinder with radius rotates with a\nconstant angular velocity and the outer cylinder with\nradius is kept stationary. This Couette flow has the following analytical solution where and . This analytical solution is provided as variable vel_an in the configuration\nof the testcase. The mesh created here is multiple resolutions.\nDistance refinement is used to refine towards both inner and outer cylinder\nwith level=minlevel+2. The element size near the cylinder is similar to 64\nelements in inner cylinder of a single level mesh. To decide the convergence, the x axis in the right side of the cylinder is\nused. This line is defined as the track_line table and used in the abort\ncriteria, a tracking over time and the spatial tracking for the final output.\nOnce the average velocity magnitude over this line doesn't change more than\nthe provided threshold in the abort section anymore or the tmax_phy time is\nreached, the simulation will stop. The run.sh runs the complete simulation, from mesh generation to creating an\nimage of the velocity profile over the track_line .\nYou need to set the executable paths there accordingly and have gleaner for it\nto work.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/ConcentricCylinders/COC_CoeutteFlow_MultiLevel/index.html"},{"title":"Lid driven cavity – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Benchmark Test cases | Test case lid driven cavity simple → Lid driven cavity in 2D Lid-driven cavity is a simple 2D problem with simple boundary conditions.\nIn a square domain, dirichlet boundary conditions are set on all sides.\nFixed wall ( ) boundary conditions on 3 sides (west, east and\nsouth) and moving wall ( ) boundary condition on north\nside. Here are the list of test cases to learn these features in Musubi: Simple Multi-level In these test cases, in addition to the aforementioned features, \nyou will also learn how to: Create a mesh with boundaries using Seeder. Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/LidDrivenCavity/index.html"},{"title":"Lid driven cavity – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case lid driven cavity single level | Test case lid driven cavity → Lid driven cavity in 2D with multilevel Lid-driven cavity is a simple 2D problem with simple boundary conditions.\nIn a square domain, dirichlet boundary conditions are set on all sides.\nFixed wall ( ) boundary conditions on 3 sides (west, east and\nsouth) and moving wall ( ) boundary condition on north\nside.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/LidDrivenCavity/LDC_MultiLevel/index.html"},{"title":"Lid driven cavity – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case lid driven cavity | Test case lid driven cavity multilevel → Lid driven cavity in 2D Lid-driven cavity is a simple 2D problem with simple boundary conditions.\nIn a square domain, dirichlet boundary conditions are set on all sides.\nFixed wall ( ) boundary conditions on 3 sides (west, east and\nsouth) and moving wall ( ) boundary condition on north\nside.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/LidDrivenCavity/LDC_Simple/index.html"},{"title":"Pipe 3D – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Benchmark Test cases | Test case pipe simple → Pipe 3D This testcase defines the flow inside a pipe with simple boundary condition\nat inlet and outlet. Either pressure-pressure or velocity-pressure.\nIn PIP_Force and PIP_LES, the flow is induced by an external force.\nD3Q27 stencil with qvalues is used in all these testcases. Here are the list of test cases to learn these features in Musubi: Simple Multi-level Force LES Split","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/index.html"},{"title":"Pipe Force – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case pipe 3D | Test case pipe les → Pipe Force In this example, the flow in the infinite long channel is induced by pressure\ngradient as external force.\nThe infinite lone channel is realized by periodic boundaries at inlet and outlet.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/PIP_Force/index.html"},{"title":"Pipe LES – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case pipe 3D | Test case pipe split → Pipe LES In this example, the turbulent flow inside the infinite long channel is \ncreated by an external force.\nThe infinite lone channel is realized by periodic boundaries at inlet and outlet.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/PIP_LES/index.html"},{"title":"Pipe 3D – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case pipe 3D | Test case pipe force → Pipe Multilevel In this example, the flow is induced by velocity at inlet and \npressure at outlet. The pipe refined with distance refinement feature in Seeder.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/PIP_MultiLevel/index.html"},{"title":"Pipe Simple – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case pipe 3D | Test case pipe multilevel → Pipe Simple In this example, the flow is induced by pressure-pressure boundary conditions.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/PIP_Simple/index.html"},{"title":"Pipe Split – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Test case pipe 3D | Test case concentric cylinders → Pipe Split In this example, the pipe has one inlet and two outlets. The length of the outlet\nafter the split is different.\nPressure is prescribed at both inlet and outlets. Both outlets are set to \npressure ambient and inlet pressure is set to 0.1 * pressure ambient.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/Pipe/PIP_Split/index.html"},{"title":"Taylor Green Vortex – Musubi","text":"Warning WORK IN PROGRESS Progress of this test case collection for TGV is tracked in the following ticket:\nAction #2246: Test case - Benchmark: Taylor-Green Vortex Taylor-Green Vortex In these examples, we will investigate the creation and evolution of vortices in\nsimple pre-defined cubes with periodic boundaries. For such a simple geometry we\neven do not need seeder. The case is based on the well-known Taylor-Green vortex benchmark case, which is\nsubject of the following papers:\n[1] Brachet, M. E., Meiron, D. I., Nickel, B. G., Morf, R. H., Frisch, U., &\nOrszag, S. A. (1983). Small-scale structure of the taylor-green vortex. Journal\nof Fluid Mechanics, 130, 411–452.\n[2] Brachet, M. E. (1991). Direct simulation of three-dimensional turbulence in\nthe Taylor-Green vortex. Fluid Dynamics Research, 8(1–4), 1–8.\n[3] DeBonis, J. R. (2013). Solutions of the Taylor-Green vortex problem using\nhigh-resolution explicit finite difference methods. 51st AIAA Aerospace Sciences\nMeeting Including the New Horizons Forum and Aerospace Exposition 2013,\n(February 2013). The objective of the TGV examples are to introduce the following features in Musubi : Define functions (TGV) to use them for boundary conditions. Calculate the kinetic energy after runtime and compare it to reference data. Use of different turbulence models. Here is the list of test cases to learn these features in Musubi: Simple TGV TGV with different LES models In these test cases, in addition to the aforementioned features, you will also\nlearn how to: Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/index.html"},{"title":"Taylor-Green Vortex with LES Turbulence Models at Re = 1600 – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Taylor Green Vortex | Taylor Green Vortex without Turbulence Models → Taylor-Green Vortex with LES Turbulence Models at Re = 1600 In this example, we will investigate the creation and evolution of vortices in a\nsimple pre-defined cube with periodic boundaries and different turbulence\nmodels. For this case, the Reynolds number ( Re ) is set to 1600. A detailed description of the general test case can be found in the parent\ndirectory Description of test case TGV . The objective of the TGV-LES examples are to introduce the following turbulence\nmodels in Musubi : TGV-LES Smagorinksy from PDF TGV-LES Smagorinksy from Velocity Gradient TGV-LES Vreman TGV-LES WALE In these test cases, in addition to the aforementioned features, you will also\nlearn how to: Post-processing nd visualization in Paraview. Create a 2D plot using Gleaner tool. Gleaner is a Python tool which\nextracts data from Musubi ascii output and uses matplotlib in python library\nto create a plot.","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/TGV_LES/index.html"},{"title":"Taylor-Green Vortex with WALE Smagorinsky (GradU) model at Re = 1600 – Musubi","text":"Warning WORK IN PROGRESS Taylor-Green Vortex LES-Smagorinsky (using Velocity Gradient) In this example, we will investigate the creation and evolution of vortices in a\nsimple pre-defined cube with periodic boundaries. For this case, the Reynolds\nnumber ( Re ) is set to 1600. A detailed description of test case can be found in the parent directory Description of test case TGV . A description about the LES cases can be found here: Description of test case TGV_LES . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Use a turbulence model.\n* Simulate the Taylor-Green Vortex in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Post-process the results by calculating the volume average of the tracked\n  kinetic energy.\n* Calculate the dissipation rate by means of the tracked quantities.\n* Compare the tracked and calculated dissipation rate with a reference solution. Running simulation For the Smagorinksy turbulence model, the strain rate can be computed from\nvelocity gradient as in this example here or from the particle distribution\nfunction (PDF). For the setup of latter one see: TGV-LES Smagorinksy from PDF Define flow parametes Define collision parameter Post-processing Here are the results from the simulation. Kinetic energy over time compared: Dissipation rate over time compared to reference solution from Brachet: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'. Download Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/TGV_LES/TGV_SmagGradU/index.html"},{"title":"Taylor-Green Vortex with WALE Smagorinsky (PDF) model at Re = 1600 – Musubi","text":"Warning WORK IN PROGRESS Taylor-Green Vortex LES-Smagorinsky (using PDF) In this example, we will investigate the creation and evolution of vortices in a\nsimple pre-defined cube with periodic boundaries. For this case, the Reynolds\nnumber ( Re ) is set to 1600. A detailed description of test case can be found in the parent directory Description of test case TGV . A description about the LES cases can be found here: Description of test case TGV_LES . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Use a turbulence model.\n* Simulate the Taylor-Green Vortex in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Post-process the results by calculating the volume average of the tracked\n  kinetic energy.\n* Calculate the dissipation rate by means of the tracked quantities.\n* Compare the tracked and calculated dissipation rate with a reference solution. Running simulation For the Smagorinksy turbulence model, the strain rate can be computed from\nthe particle distribution function (PDF) as in this example here or from\nvelocity gradient. For the setup of latter one see: TGV-LES Smagorinksy from Velocity Gradient Define flow parametes Define collision parameter Post-processing Here are the results from the simulation. Kinetic energy over time compared: Dissipation rate over time compared to reference solution from Brachet: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'. Download Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/TGV_LES/TGV_SmagPDF/index.html"},{"title":"Taylor-Green Vortex with Vreman LES model at Re = 1600 – Musubi","text":"Warning WORK IN PROGRESS Taylor-Green Vortex LES-Vreman In this example, we will investigate the creation and evolution of vortices in a\nsimple pre-defined cube with periodic boundaries. For this case, the Reynolds\nnumber ( Re ) is set to 1600. A detailed description of test case can be found in the parent directory Description of test case TGV . A description about the LES cases can be found here: Description of test case TGV_LES . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Use a turbulence model.\n* Simulate the Taylor-Green Vortex in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Post-process the results by calculating the volume average of the tracked\n  kinetic energy.\n* Calculate the dissipation rate by means of the tracked quantities.\n* Compare the tracked and calculated dissipation rate with a reference solution. Running simulation Define flow parametes Define collision parameter Post-processing Here are the results from the simulation. Kinetic energy over time compared: Dissipation rate over time compared to reference solution from Brachet: To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'. Download Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/TGV_LES/TGV_Vreman/index.html"},{"title":"Taylor-Green Vortex with WALE LES model at Re = 1600 – Musubi","text":"Warning WORK IN PROGRESS Taylor-Green Vortex LES-WALE In this example, we will investigate the creation and evolution of vortices in a\nsimple pre-defined cube with periodic boundaries. For this case, the Reynolds\nnumber ( Re ) is set to 1600. A detailed description of test case can be found in the parent directory Description of test case TGV . A description about the LES cases can be found here: Description of test case TGV_LES . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Simulate the Taylor-Green Vortex in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Post-process the results by calculating the volume average of the tracked\n  kinetic energy.\n* Calculate the dissipation rate by means of the tracked quantities.\n* Compare the tracked and calculated dissipation rate with a reference solution. Running simulation Define flow parametes Define collision parameter Post-processing Here are the results from the simulation. To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'. Download Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/TaylorGreenVortex/TGV_LES/TGV_WALE/index.html"},{"title":"Gaussian Pulse in Pressure in a Cube – Musubi","text":"Warning WORK IN PROGRESS\nProgress of this test case is tracked in the following ticket: Action #2206: Test case - Benchmark: Gaussian pulse Gaussian Pulse in Pressure in a Cube In this example, we will simulate a Gaussian pulse in pressure in a simple\npre-defined cube with periodic boundaries and user-defined initial condition.\nThe gaussian pulse can be also used via a lua function, c. f.\n* lua-function of gaussian pulse For this simple geometry, we even do not need Seeder . The objectives of this example is to introduce how to:\n* Use a pre-defined geometry instead of creating a mesh with Seeder.\n* Simulate the Gaussian pulse in the cube using Musubi.\n* Create 2D plots using the Gleaner tool. Gleaner is a Python tool that extracts\n  data from Musubi ASCII output and uses the plotting library Matplotlib in\n  Python to create a plot.\n* Validate the numerical results by comparing them against the analytic\n  solution. The latter one is calculated using NumPy, a mathematic extension for\n  Python.\n* Compare the simulation results (L4) to previously generated data obtained with\n  higher resolution (reference folder, L5 & L6) to experience the influence of\n  the resolution. ToDo This file has to be filled with content like:\n* Problem description\n* Formulas\n* Results\n* Comparison for different resolutions\n* How to run the simulation Here are the results from the simulation. Pressure across the length of the channel for different resolutions at the\nbeginning (initial condition): The higher the level -- and with that the resolution -- the better the solution\ncompared to the analytical one. Pressure across the length of the channel for different resolutions at the end: It can be seen that the resolution has a great impact on the results. To create these plots, run python plot_track.py to create the plots.\nBefore running the plot script, open 'plot_track.py' and update path to\nGleaner script in 'glrPath'.\nDownload Gleaner script using hg clone https://geb.sts.nt.uni-siegen.de/hg/gleaner","tags":"","loc":"page/examples/fluid_incompressible/benchmark/gaussianPulse/index.html"},{"title":"Tutorials – Musubi","text":"Tutorials The tutorials show you how to install, configure and set up Musubi .\nYou are guided through all required steps from generating meshes, configuring\nthe solver and post-processing the results.\nYou can choose a special topic or you can go through the tutorials step by step. If not stated otherwise, we use the generic channel case for the tutorials. The\ntest case can be found under examples/tutorials/tutorial_cases/tutorial_channelGeneric . Overview Tutorial 00 - Prerequisites What do you need before you can start using Musubi ? Tutorial 01 - Configuration Basic configuration of Musubi simulations. Tutorial 02 - Toolchain Using the complete APES simulation tool-chain. Generation of meshes, running the solver and post-processing the results. Tutorial 03 - Tracking Tracking flow quantities during the simulation. Tutorial 04 - Boundary Conditions Setting boundary conditions. Tutorial 05 - Restart Restarting simulations. Tutorial 06 - Initial Conditions Setting initial conditions. Tutorial 07 - Abort Criteria Conditions for convergence and stopping the code in general. Tutorial 08 - Source terms Using source terms in Musubi . Tutorial 09 - Multi-Level Simulations Using multi-level simulations. Tutorial 10 - Changes in Musubi2.0 Changes that need to be done when upgrading from Musubi1.0 to Musubi2.0 . Required Knowledge We assume that you know how to install programs on your computer\nand how to use a console.\nAlso, we assume that you have some basic idea of the Lattice Boltzmann\n Method (see here or here for a brief description of it).","tags":"","loc":"page/examples/tutorials/index.html"},{"title":"Prerequisites – Musubi","text":"Warning WORK IN PROGRESS Navigate: Overview | Configuration → Prerequisites Download, build and run Musubi . Note We assume that you are using a UNIX-like system.\nIf you run Windows, some commands might be different. Download We use git with submodules for revision control.\nYou need to have it installed on your system in order to download Musubi . Create a directory for everything that happens in these tutorials\n(we will call this directory apes ), but you can use a different name.\nInside this directory, clone the Musubi repository from https://github.com/apes-suite/musubi.git by running git clone --recurse-submodules https://github.com/apes-suite/musubi.git in your console.\nIf this worked, you have an up-to-date copy of the Musubi source code,\nwhich we will compile now. If you already cloned Musubi you can update Musubi via: git pull --recurse-submodules Build We use the waf build system, you can learn more about it from its website .\nAlso, you need MPI installed on your system, see for example the OpenMPI website for instructions.\nFinally, you need to set environment variables FC and CC in order to\nassign the correct Fortran and C compilers to waf .\nThe compilers should point to the MPI wrappers from your MPI installation.\nTypically these are mpif90 (Fortran) and mpicc (C).\nSet them with the bash commands export CC = mpicc ; export FC = mpif90 If you updated Musubi you need yo clean the old build and the coco\npreprocessor. If you cloned Musubi there is no need to do so. bin/waf cleanall Once you have done all this, navigate to your Musubi directory and use the\ncommand bin/waf configure to configure the compilation. We are now ready to compile Musubi . Run bin/waf build to get a Musubi executable including Mus_Harvester for post-processing in\nthe build subdirectory. To compile musubi only add the following argument: --target = \"musubi\" If the compilation finishes without errors, you have Musubi ready to run your\nfirst test case! Run To check your Musubi -installation, navigate to your musubi directory and\ncreate a required tracking directory for the output with mkdir tracking Execute Musubi with ./build/musubi which should result in loads of output, ending with a message similar to Done with Musubi in [ s ] 1 .864378E-01 indicating that everything worked fine.\nIf you get any errors up to here, read the instructions again and follow\nthem carefully. You need to have this running before you proceed. Mesh Generation and Post-Processing Most of the tutorials will require creation of a mesh and some\npost-processing of the results. The corresponding tools in our toolchain\n\"APES tool chain\" are Seeder for mesh-generation, for post-processing Seeder-Harvesting and Musubi-Harvesting . The installation procedure for Seeder is very similar to Musubi . Again, navigate to your apes directory\nand run git clone https://github.com/apes-suite/seeder.git to get a fresh copy of Seeder . Compile it by running cd seeder\nbin/waf configure build and fix any errors before you proceed. Note You can make your life easier by adding apes/seeder/build , apes/seeder/build/sdr_harvesting , apes/musubi/build and apes/musubi/build/mus_harvesting to your path,\nfor example by editing ~/.profile (MacOS X) or ~/.bashrc (Unix with\nbash) or whatever it is on your system.\nIn the following tutorials, we assume that you have done just that.\nIf you have not, you must add the correct paths to the command any time\nyou try to call Musubi , Musubi-Harvesting , Seeder-Harvesting or Seeder . Once you are done with all that, we can start defining our first simulation. Troubleshooting Once you get errors running Musubi , it is possible that something is wrong\nwith your code version. In order to get more detailed information concerning the\nerrors you can type this command inside the musubi directory which is apes/musubi/ as default: bin/waf distclean configure debug If you run your simulation once again, you will get more information about the\nfiles that cause errors. Now, you have to run Musubi from a different directory which is /build/debug/musubi instead of /build/musubi . Next chapter: Configuration →","tags":"","loc":"page/examples/tutorials/tut_00_prerequisites.html"},{"title":"Configuration – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Prerequisites | Overview | Toolchain → Configuration Set up your first simulation with Musubi . This tutorial is using a 1D gaussian_pulse in pressure computed in a 3D domain.\nThe necessary configuration file to run this case will be generated from\nscratch within this tutorial.\nThe final config-file for this case can be found in examples/tutorials/tutorial_cases/tutorial_gaussian_pulse/ . The musubi.lua File We communicate with Musubi via a Lua-Script that tells Musubi what we\nwant to simulate and which options we want to set.\nThe Lua-syntax is fairly easy, and for this tutorial, we will use only a\nsmall subset of it, so don't be afraid if you hear of Lua for the first time. By default, Musubi looks for a file called musubi.lua inside your current\nworking directory. If you want, you can use different names (for example if\nyou want to keep more than one script e.g. musubi_test.lua ) and pass the name\nof the script you want the application to use as a command-line argument.\n(e.g. ~/apes/musubi/build/musubi musubi_test.lua ) We are now going to build a working, almost-minimal musubi.lua file\nstep-by-step.\nPlease navigate to your simulation directory, and create a new file called musubi.lua with your favorite text editor. Note Most configuration options have some sane defaults, which allows you to\nleave them alone if they are not relevant to you. Note Before you run the following simulation setup, make sure that you have\ncreated the subdirectories restart and tracking in the same path where musubi.lua is located. Lua concepts for the configuration Lua provides a convenient data structure called tables , that we use extensively in the\nconfiguration to structure it.\nTables allow us to gather relevant settings together.\nThey are indicated by curly brackets {} .\nThus, we can define a table like this: atable = { somevalue = 123 } Note that tables can be nested and values inside the table can be themselves\nbe tables again.\nWe can have an arbitrary amount of values in the table definition and individual\nsettings are separated by comma ( , ), like this: atable = { somevalue = 123 , anothervalue = \"abc\" } A superfluous comma at the end of the last entry is also valid syntax here. Alternatively, we can also modify or add values to an existing table via the\ndot operator: atable . somevalue = 42 atable . third = 1.23 Here we modify somvalue in the atable table and add a third entry\nwith the value 1.23 to the table. Comments in Lua are introduced by two dashes ( -- ). We also make use of\nthese to offer explanations to the settings in the configuration scripts. Note The complete configuration file is executed and the status of the various\nsettings \"at the end\" of that execution is what Musubi will obtain. General Simulation Name Every simulation should have a name, which is specified by the variable simulation_name in the Lua script. In this example, we will simulate a Gaussian pulse in pressure, hence the name Gausspulse seems adequate.\nYou can use just anything as a simulation name, just make it clear and\ndescriptive, as it will help you to identify produced results from the\nsimulation. Note The simulation name will appear in all output files, so if you use good\nand unique names, you always know where a particular output came from. simulation_name = 'Gausspulse' Fluid table Musubi requires us to define the properties of the fluid to simulate in\na fluid table.\nIn that table we define the kinematic viscosity in the variable kinematic_viscosity : fluid = { kinematic_viscosity = 1.2e-6 } In the incompressible model this is already enough to define the fluid.\nFor weakly compressible models, we also need to provide the bulk viscosity\nin the variable bulk_viscosity : fluid = { kinematic_viscosity = 1.2e-6 } fluid . bulk_viscosity = 2 * fluid . kinematic_viscosity / 3 Notice how we defined the second entry here in dependency of the first.\nThis is not possible when defining all entries in the table directly, thus\nwe are using a separate line after the first definition of the table\nto set the bulk viscosity. One question that arises in setting the values in the fluid table, but\nalso in other settings like the initial conditions, boundary conditions or source\nterms, is in what units those values are to be provided. The solver works on so called lattice units, which are tied to the discretization.\nHowever, that often is a little cumbersome to work with and it also provides\nthe possibility to instead translate the given quantities from physical\nunits.\nTo that end the user has to provide a physics table.\nWhen provided by the user that table will be used by Musubi to convert\ngiven fluid property settings to the internal lattice units for the computation.\nIt will also be used to translate results back to physical units in variable\nnames that have a _phy suffix.\nThus, when you want to refer obtain the resulting velocity field from the\ncomputation you would access the velocity_phy variable, which provides the\nvelocity converted with the help of the settings in the physics table. Physics table The physics table provides the necessary quantities to transform physical units\nto the lattice units used by the solver internally.\nSpecifically it applies to the fluid.kinematic_viscosity setting and macroscopic\nvariables like pressure and velocity used in the definition of boundary and\ninitial conditions. As described above, these parameters/variables can be defined either in physical units\nor lattice (non-dimensional) units.\nBut they can not be mixed i.e. some in physical and others in lattice units.\nIt is important that they are consistent. Two settings describe space and time: the edge length of the coarsest elements in the\ngrid ( dx ) and the step length of the time steps of those elements ( dt ).\nWhile dx is given by the mesh definition, the time step length has to be provided in\nthe physics table for the conversion between lattice and physical units.\nAdditionally we need to define either the mean density rho0 of the fluid or the \nfluid mass mass0 in the coarsest elements. \nProviding the mass is more natural when simulating multiple species, as we can work\nwith the respective mass fractions in that case.\nOtherwise, we normally describe the mean density.\nBoth, dt and a measure for the mass have to be provided in the physics table.\nThus, a minimal physics table should look like this: physics = { dt = 1.0e-3 , rho0 = 1.0 } In Musubi, the following reference values are used to convert\nparameters/variables in physical units to lattice units and vice-versa: Measure Unit Reference Notation. Name in physics table Default value Mass $kg$ fluid mass $m_{ref}$ mass0 $rho0\\times dx&#94;3$ Density $kg/m&#94;3$ mean fluid density $\\rho_{ref}$ rho0 $mass0/dx&#94;3$ Length $m$ coarsest element $dx_{ref}$ Not required is taken from mesh Time $s$ coarsest time step size $dt_{ref}$ dt - Amount of substance $mol$ Inverse of Avagadro's number $N_A$ mole0 $1/6.02214129e&#94;{-23}$ Mole density $mol/m&#94;3$ mean mole density $c_{ref}$ moleDens0 $1/(N_A dx&#94;3)$ Molecular weight $kg/mol$ Largest molecular weight of species $M_{ref}$ molWeight0 $mass0/mole0$ Temperature $K$ fluid temperature $T_{ref}$ temp0 1.0 Electric charge $C$ fundamental electric charge $q_{ref}$ coulomb0 $1.60217657e&#94;{-19}$ As shown in the table most of them have default values and the coarsest element size ( dx )\nis taken from the mesh.\nThus the physics table provided above offers the minimal, but also usual\nsetting for most cases. The non-dimensional lattice units (subscript l) are scaled to one for the computation\nby choosing the provided physical units (subscript p) provided in the physics table also\nas the reference values (subscript ref): Lattice density, $\\rho_{l} = \\frac{\\rho_{p}}{\\rho_{ref}} = 1.0$ Lattice element size, $dx_{l} = \\frac{dx_p}{dx_{ref}} = 1.0$ Lattice time step, $dt_{l} = \\frac{dt_p}{dt_{ref}} = 1.0$ and so on. All other derived variables in lattice units are converted to physical units\nusing the reference variables in physical units. \nFor simplicity, the subscript 'ref' is dropped in the equations below for the reference values: Lattice pressure $p_l$ to physical pressure, $p_p = p_l * \\frac{\\rho \\cdot dx&#94;2}{dt&#94;2}$ $[kg/m/s&#94;2]$ Lattice velocity $u_l$ to physical velocity, $u_p = u_l * \\frac{dx}{dt}$ $[m/s]$ Lattice kinematic viscosity to physical kinematic viscosity, $\\nu_p = \\nu_l * \\frac{dx&#94;2}{dt}$ $[m&#94;2/s]$ Lattice force $f_l$ to physical force, $f_p = f_l * \\frac{\\rho \\cdot dx&#94;4}{dt&#94;2}$ $[kg m/s&#94;2]$ Lattice current $I_l$ to physical current, $I_p = I_l * \\frac{q}{dt}$ $[C/s]$ Lattice potential $\\phi_l$ to physical potential, $\\phi_p = \\phi_l * \\frac{\\rho \\cdot  dx&#94;5}{q \\cdot dt&#94;2}$ $[kg m&#94;2 /(C s&#94;2)=V]$ For more on the unit conversion for other derived variables refer to \n[mus_physics_module(module)]. All physical quantities set in the configuration are affected by these\nconversions.\nThis includes the settings in the fluid , species and mixture tables,\naswell as the macroscopic variables in the initial_condition , boundary_condition and source tables. Now, usually we do not really care about the timestep width, but rather\nwant to compute this from the other fluid properties.\nBy using a Lua script for the configuration, we can easily define those\nrelations by defining appropiate variables and compute the needed variables\nfor the Musubi settings. For example like this: -- Flow parameters -- Mach number Ma = 0.05 -- Reynolds number of the flow Re = 60 -- speed of sound in air [m/s] cs_phy = 343 -- Density of the fluid [kg/m&#94;3] rho0_phy = 1.0 -- Ambient pressure [kg/(m s&#94;2)] press_ambient_phy = rho0_phy * cs_phy &#94; 2 For convenience, a suffix '_phy' and '_lat' are used to represent variables in \nphysical and lattice units respectively.\nIn Musubi, the flow is considered to be isothermal. For a perfect ideal gas,\nthe pressure is related to the speed of sound as i.e. $p = \\rho c&#94;2_s$. The lattice speed of sound is fixed to $c_{s,lat} = \\sqrt{(1/3)}$ -- Lattice speed of sound cs_lat = math.sqrt ( 1.0 / 3.0 ) Finally, the physical time step size $dt$ required in the physics table.\nIt is computed either by acoustic or diffusive scaling.\nIn acoustic scaling, the time step $dt$ is computed from the speed of sound or \nvelocity so that the Mach ($Ma$) number is fixed across different element sizes. \nThus, when conducting grid convergence studies with \nacoustic scaling, the Mach number, lattice speed of sound and lattice velocity \nremains constant while lattice viscosity nu_lat``and relaxation parameter omega` ($\\omega$) changes. -- Inflow velocity computed from Ma number [m/s] vel_phy = Ma * cs_phy -- Kinematic viscosity of the fluid calculated from Re [m&#94;2/s] nu_phy = vel_phy * height / Re -- Lattice velocity vel_lat = Ma * cs_lat -- Physical timestep computed from physical and lattice speed of sound dt = cs_lat / cs_phy * dx -- Lattice viscosity nu_lat = nu_phy * dt / dx &#94; 2 -- Relaxation parameter omega = 1.0 / ( nu_lat / cs_lat &#94; 2 + 0.5 ) On the other hand, in diffuive scaling, the time step $dt$ is computed from \nthe kinematic viscosity so that the lattice kinematic viscosity nu_lat and the relaxation parameter omega ($\\omega$) are fixed across the element \nsizes while the Mach number $Ma$ and lattice velocity $vel_lat$ changes. -- In diffusive scaling, Kinematic viscosity and omega are fixed by user -- Kinematic viscosity of the fluid [m&#94;2/s] nu_phy = 0.285 -- Inflow velocity is computed from Re and viscosity [m/s] vel_phy = Re * nu_phy / height -- Relaxation parameter omega = 1.7 -- Lattice viscosity nu_lat = ( 1.0 / omega - 0.5 ) / 3.0 -- Physical timestep computed from physical and lattice velocity dt = nu_lat / nu_phy * dx * dx -- Lattice velocity vel_lat = vel_phy * dt / dx -- Mach number Ma = vel_lat * cs_lat Note Most of the variables mentioned above are local variables.\nwe need rho0_phy and dt to define variables in physical units in the physics table, nu_phy to define the fluid property in the fluid table,\nand press_ambient_phy and vel_phy to define initial and boundary conditions\nin initial_condition and boundary_condition tables. In simple words, with acoustic scaling, the time step size $dt$ is reduced by \nhalf when the element size $dx$ is reduced by half i.e. $dt \\propto dx$ but \nwith diffusive scaling, the time step size $dt$ is reduced to one-fourth i.e.\n$dt \\propto dx&#94;2$. With those definitions in place you can then define the physics table with\nthe help of those variables: physics = { dt = dt , rho0 = rho0_phy } And of course also the fluid table: fluid = { kinematic_viscosity = nu_phy } When physical units are not of interest and you would like to just run a simulation\nby defining lattice units, remove the physics table from the Musubi\nconfiguration file. In this case, the variables are then defined in lattice units -- Relaxation parameter omega = 1.8 -- Background density in lattice unit rho0 = 1.0 -- Lattice speed of sound cs = math.sqrt ( 1 / 3.0 ) -- Background pressure in lattice unit p0 = rho0 * cs &#94; 2 -- Kinematic viscosity in lattice unit nu = ( 1.0 / omega - 0.5 ) / 3.0 Note Musubi can dump output variables in physical units. \nIt just requires a suffix '_phy' to the variable name in tracking table. Time Settings Now we should specify the number of timesteps for our simulation.\nWe do this by opening a time section with at least the variable max given to specify the maximal number of timesteps you want to simulate.\nAdditionally, you might provide the interval -setting, that controls the\ndebug output: after a predefinded number of iterations, the total density of\nthe system is calculated and written to the console, this defaults to 1.\nThe number of iterations can be set by using {iter=#} to set the number of\niterations. Alternative one can use {sim=#} to trigger the check after certain\ntimesteps in your simulation or use {clock=#} to trigger the check after a\ncertain runtime. Since we have conservation of mass, the total density should\nnot change much, so if it does, it is a hint for the user that the results of\nthe simulation are probably wrong. Setting the interval to something around [max/10] is reasonable. sim_control = { time_control = { max = { iter = 50 }, interval = { iter = 5 } } } Identification It should be followed by a part that identifies the nature of the simulation.\nTo this part belong the following aspects: the layout , the kind and the relaxation . For now, it is not necessary to know these settings in detail.\nyou can choose between some values that you can look up in the mus_scheme_header_module .\nIf these settings are not defined, Musubi will use default values.\nAs a first example, you can set up the identify table as: identify = { kind = 'fluid' , layout = 'd3q19' , relaxation = 'bgk' , } Geometry The geometry is usually a more complicated thing to define. For anything\nbut the simplest case, we need Seeder , a tool that will be dealt with\nin the next tutorial chapter .\nFor now, we will use a pre-defined geometry, which is just a simple cube\nwith periodic boundaries and no obstacles. We can specify the length and position ( origin ) of that cube. The position of the cube is only\nrelevant if you specify positions of other objects, too, such as\ninitial conditions or trackers (we will explain what that is in chapter_03 ). Last but not least, the refinementLevel tells Musubi how fine the\ninitial cube (with a length of 10 here) needs to be discretized. A refinement\nlevel of 4 means that our initial cube is cut into portions in\neach dimension, which leaves us with cells in 3 dimensions. mesh = { predefined = 'cube' , origin = { 0.0 , 0.0 , 0.0 }, length = 10.0 , refinementLevel = 4 } Warning Lua is case-sensitve, and some Musubi options (like refinementLevel )\nhave to be written in camelCase. Tracking Of course you do not only want to simulate, you also want to see results.\nThe tracking section is your way to control some subset output from Musubi .\nThe idea behind it is that for any real-life scale problem, you just\ncannot save all the information of every point at every timestep,\nsince the shear amount of data would be too much to handle. Thus, we\ntell Musubi what we want to see (like pressure, velocity...), at what\ntime, and in what position. Each output is handled by a tracker . Let us define a tracker now, step\nby step.\nFirst, a tracker has a name (specified in label ) that will appear in\nevery output file created by this tracker . Anything that is precise and\nmeaningful will do. tracking = { label = 'track_pressure' , Next, we should tell the tracker what we are interested in. The variable section will do just that for us. In this example, we will ask the tracker to store density and velocity information for us. The output will be stored on your hard drive, in the location you specify\nin folder . Warning You have to create the folder yourself before you start the\nsimulation. If it doesn't exist, Musubi will crash with a Fortran runtime error. variable = { 'pressure' , 'velocity' }, folder = './tracking/' , The most complicated part is the tem_shape_module variable.\nIt defines where inside\nthe simulation domain (which is a cube in our example) you want to observe the\nvariables. You can take samples at a point, along a line, everywhere on a plane,\nor even everywhere inside a given box. These options will be discussed in more\ndepth in chapter_03 .\nFor now, we are happy with a point at position (1,1,1) : shape = { kind = 'canoND' , object = { origin = { 1.0 , 1.0 , 1.0 } } }, The format option lets you choose the file format in which the data\nshould be stored. The options you have are ascii , asciiSpatial and vtk . Ascii is only really usable for point trackers . For anything more\nsophisticated (starting in the next chapter), we will use the build-in tool mus_harvesting for post-processing the data. output = { format = 'ascii' }, Finally, we have to specify at which timesteps we want to save data.\nInside the time section, you can specify the first ( min ) and last\n( max ) timestep that is of interest to you. If [max] is negative,\nevery timestep till the end will be considered. In interval , you can\nchoose if you want to save every timestep (set it to 1 then) or only\nevery [n] -th timestep (set interval to n in this case). time_control = { min = { iter = 1 }, max = { iter = 50 }, interval = { iter = 1 } }, } Don't forget to close the tracking section with another curly brace. Restart In the restart part of your musubi.lua file you can create so-called restart\nfiles in order to save the results of your simulation. With these restart files\nyou can create vtk files with mus_harvesting to view them in Paraview. In\naddition to that, you can also read the restart files to go on with your\nsimulation beginning at the saved point written in the restart files. In the\n\"restart\" section you are also able to use time_control to define the min , max and the interval time, when Musubi writes a restart file to the restart/ folder. Be sure that you set up useful definitions for that. For\nexample, you can set up the restart settings like this: restart = { write = 'restart/' , -- prefix to write the files to time_control = { min = 0 , max = 10 , interval = 10 } -- timing definitions (either iterations or simulation time) } Note You have to create the restart folder within your simulation folder at\nfirst.\nSo far, these are only basic information about restart .\nFurther information about the restart are explained in Tutorial 5: Restart . Initial Conditions Initial conditions can be specified in the initial_condition table.\nFirst, let us define that the velocity at t=0 should be 0 everywhere. But if every point is equal, not much is going to happen. So for the\ninitial pressure, we will do something more fancy: We will define a function gausspulse that will set the initial pressure such that it has a peak\nin the middle of the domain, and decreases quickly towards the sides.\nWith this, we will create two waves running from the center towards both\nsides. The initial_condition -table will point to this function for the\ndensity: initial_condition = { velocityX = 0.0 , velocityY = 0.0 , velocityZ = 0.0 , pressure = gausspulse } The function can be defined like this in the Lua script: function gausspulse ( x , y , z ) originX = 5.0 halfwidth = 1.0 amplitude = 0.01 return p0 + amplitude * math.exp ( - 0.5 / ( halfwidth &#94; 2 ) * ( x - originX ) &#94; 2 ) end Warning Define the function before the initial_condition table or you will receive an error whilst\nrunning Musubi . Moreover,define the p0 as global variable in the function.\nSo that it will return the function like p0+amplitude*math.exp(-0.5/halfwidth&#94;2)*(x-originX)&#94;2 : rho0 = 1. cs2 = 1. / 3. p0 = rho0 * cs2 Note A last short remark on variables: If you do something more complicated\nin your musubi.lua script, you are of course free to use functions,\nvariables, loops, branches, whatever you want.\nThe only thing that counts is what is defined after running your script.\nBe careful, however, when using your own variables, as you might set Musubi options that you are not aware of.\nIt might be wise to use variables only inside your own functions,\nor at least give them some prefix so you don't confuse your own variables\nwith Musubi options. Note An important remark on the pressure variable. It is a total pressure irrespective \nof fluid and fluid_incompressible . So if pressure flucations are required\nto compute the acoustic waves then they can be obtained by calculating a\ndifference between numerical pressure computed from simulation and \nambient pressure defined in initial/boundary condition. Result If you did all steps correct you're now able to run the test case. If something\nis not working you can compare your config file with our template you can find\nunder: examples/tutorials/tutorial_cases/tutorial_gaussian_pulse/musubi.lua .\nAfter finishing your run, you will find an output file called Gausspulse_track_pressure_p00000.res in your tracking -folder.\nIf you open it, you will find densities and velocities for every iteration.\nIf you choose an other interval in tracking-table (for example iter=5 ), the values for every choosen iteration\n(e.g. every 5th iteration) will be listed here. Note The Ascii output is used only in this first tutorial. You can visualize\nthis data with any program you like, for example with Gnuplot , if you\nhave it installed. If not, wait for the next chapter, as we are going to\nintroduce different tools there, anyway.\nSimply run Gnuplot with: gnuplot -p -e \"plot \\\"tracking/Gausspulse_track_pressure_p00000.res\\\" using 1:2\" to get a plot of the pressure similar to this one: The picture shows the pulse running through your point tracker several\ntimes. This happens because of the periodic boundaries. The intensity of\nthe pulse decreases due to dissipation. In the next chapter, we will learn to define more complex geometries, and\nto create more sophisticated outputs. Next chapter: Toolchain →","tags":"","loc":"page/examples/tutorials/tut_01_mus_config.html"},{"title":"Toolchain – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Configuration | Overview | Tracking → Toolchain In this tutorial, you will learn how to use the complete toolchain of the APES\nsuite to deploy simulations. This includes the generation of the mesh with Seeder , running the actual simulation with Musubi and finally\npost-processing the results with mus_harvesting which generates files to be\nvisualized with standard tools like Gnuplot and Paraview. Therefore we use a\nchannel as an example. The test case can be found under examples/tutorials/tutorial_cases/tutorial_channelGeneric .\nThis test case will be used in most of the following tutorials.\nSome parts will be explained in more depths later. Preparing the Simulation Folder Generate the folders mesh tracking restart harvest output using: mdkir mesh tracking restart harvest output Generate the Mesh Make sure that Seeder is compiled and you know how to call it\n( see here ). At first, we define the seeder.lua file containing general informations\n/ global variables like sizes and the refinement levels of the mesh. --! [Global variables] -- Height of the channel [m] height = 1.0 -- Length to height ratio l_h = 8.0 -- Length of the channel [m] length = l_h * height -- Depth of the channel [m] depth = length -- General level of mesh refinement level = 8 -- Special levels for local refinement. Set to 0 to make refinement optional. -- If it should be used, activate useRefine in the 'Geometry definition'. The -- refinmentLevels will be increased then. refinementLevel = 0 refinementLevel2 = 0 --outputpreview = true --! [Global variables] In the next part we have some variables with boolian values. We use them to\nactivate or deactivate some parts of the script which give us some flexiblity to\neasily modify the case. With this script we can have a look at the effect of\nqvalues, periodic boundaries and the use of different STL files. --! [Geometry definition] case2d = false -- Creates a 2D channel if set to true usePeriodic = true -- Activates periodic boundaries qValues = true -- Activates qvalues useObstacle = false -- Activates obstacle in the channel fixHeight = true -- Channel's height is fixed and is used to compute dx useRefine = false -- Activate refinement, increase levels by 1 and 2. smoothlevels = false -- False avoids refinement of single elements. smoothbounds = false -- False avoids refinement of single elements. --! [Geometry definition] You might remember the fixHeight value from above. If it is set to true the dx is computed by the specified height of the channel. Else dx is computed\ndefining the length of the channel first. --! [dx computed by height] if fixHeight then -- Number of elements in the height nHeight = 2 &#94; ( level - 4 ) -- Element size [m] dx = height / nHeight -- Number of elements in bounding cube -- = number of elements in channel + inlet + outlet nLength = nHeight * l_h + 2 -- Level required to reach computed dx level = math.ceil ( math.log ( nLength ) / math.log ( 2 )) -- Length of the bounding cube length_bnd = ( 2 &#94; level ) * dx --! [dx computed by height] --! [dx computed by length] else -- Length of the bounding cube length_bnd = length / ( 1.0 - 2.0 / 2 &#94; level ) -- Element size [m] dx = length_bnd / ( 2.0 &#94; level ) -- Number of elements in height nHeight = 2.0 * math.floor ( length / ( dx * 2.0 * l_h )) -- Height of the channel height = nHeight * dx end --! [dx computed by length] Here, we have some reference values that have effect on the geometry of the\nchannel. You might change them and compare the effects later on in Paraview. --! [Reference values] -- A minimum level, by which all parts in the computational domain should at -- least be resolved with. Default is 0. Here, set it to value calcualted above. minlevel = level -- A maximum level, which is reached on finest level of refinement. maxLevel = level + math.max ( refinementLevel , refinementLevel2 ) -- Smallest element size (on finest level) [m] dxMin = length_bnd / ( 2 &#94; maxLevel ) -- Half of element size on finest level [m] dx_half = 0.5 * dxMin -- Smallest possible element size dx_eps = length_bnd / 2 &#94; 20 The next section is about refinement at selected positions.\nThe usage of refinements is explained in [chapter 09] . -- Increase refinement levels, if useRefine is active. if useRefine then refinementLevel = refinementLevel + 1 -- Refinement level 2 can only be one larger than 1, otherwise level jump is -- too big. refinementLevel2 = refinementLevel + 1 end --! [Refinement box 1] -- Size of refinement box 1 in x-direction size_x = 0.75 * length -- Start of refinement box 1 (x)  based on length start_x = - 0.425 * length -- Size of refinement box 1 in y-direction size_y = 0.5 * height -- Start of refinement box 1 (y)  based on height start_y = - 0.25 * height -- Size of refinement box 1 in y-direction size_z = 0.5 * height -- Start of refinement box 1 (z)  based on height start_z = - 0.25 * height --! [Refinement box 1] --! [Refinement box 2] -- Size of refinement box 2 in x-direction and start of it start2_x = - 0.375 * length size2_x = 0.5 * size_x -- Size of refinement box 2 in y-direction and start of it size2_y = 0.5 * size_y start2_y = - 0.5 * size2_y -- Size of refinement box 2 in z-direction and start of it size2_z = size2_y - dx_half start2_z = start2_y + dx_half / 2.0 --! [Refinement box 2] --! [Reference values] Next, we define the bounding cube. It is the box that includes the complete\nsimulation domain. It must be large enough, otherwise it just truncates all\ngeometries that go beyond this cube. --! [Bounding cube] -- Bounding_cube: two entries (origin and length in this order, if no keys used) bounding_cube = { origin = { - 0.5 * length_bnd , - 0.5 * length_bnd , - 0.5 * length_bnd }, length = length_bnd } --! [Bounding cube] This part is followed by the spatial_object table. Here we define the seed\nand some refinements. If useRefine = false the level of our refinement boxes\nwill be the same as the rest of our mesh and so no refinement will be added. --! [Spatial objects] spatial_object = { { attribute = { kind = 'seed' }, geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , dx_half }, } } }, --! [Refinement box 1 & 2] { attribute = { kind = 'refinement' , level = refinementLevel + level , label = 'box1' }, geometry = { kind = 'canoND' , object = { origin = { start_x , start_y , start_z }, vec = { { size_x , 0.0 , 0.0 }, { 0.0 , size_y , 0.0 }, { 0.0 , 0.0 , size_z } } } } }, { attribute = { kind = 'refinement' , level = refinementLevel2 + level , label = 'box2' }, geometry = { kind = 'canoND' , object = { origin = { start2_x , start2_y , start2_z }, vec = { { size2_x , 0.0 , 0.0 }, { 0.0 , size2_y , 0.0 }, { 0.0 , 0.0 , size2_z } } } } }, --! [Refinement box 1 & 2] Here we can define our boundaries the inlet and the outlet of the channel. --! [Inlet and outlet boundary conditions] { attribute = { kind = 'boundary' , label = 'east' -- outlet }, geometry = { kind = 'canoND' , object = { origin = { 0.5 * length + dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { 0.0 , height + 2 * dx_eps , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, { attribute = { kind = 'boundary' , label = 'west' -- inlet }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { 0.0 , height + 2 * dx_eps , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, --! [Inlet and outlet boundary conditions] Here we can define our boundaries north and south of the channel. --! [Walls] { attribute = { kind = 'boundary' , label = 'north' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , 0.5 * height + dx_eps , - 0.5 * depth - dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, { attribute = { kind = 'boundary' , label = 'south' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, --! [Walls] } --! [Spatial objects] It is possible for the channel to make use of periodic boundaries.\nTherefore you need to define two planes close to each other that are repeated\nalong the channel depth ( usePeriodic=true ) . Note Since we can't use if conditions inside a table we use table.insert(spatial_object, ...) to append this part to the spatial_object table. --! [Use periodic boundaries] -- If usePeriodic is active, periodic boundary conditions are used in depth, -- which means in z-direction in this case. This is one way of creating a quasi- -- 2D domain. if usePeriodic == true then depth = dx table.insert ( spatial_object , { attribute = { kind = 'periodic' , label = 'periodic' }, geometry = { kind = 'periodic' , object = { plane1 = { -- top plane origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , depth + dx_half / 4.0 }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , height + 2 * dx_eps , 0.0 } } }, plane2 = { -- bottom plane origin = { - 0.5 * length + dx_eps , - 0.5 * height + dx_eps , - dx_half / 4.0 }, vec = { { 0.0 , height + 2 * dx_eps , 0.0 }, { length + 2 * dx_eps , 0.0 , 0.0 } } }, } } } ) --! [Use periodic boundaries] Of course you do not have to use periodic boundaries. Instead you could use a\nscript that defines specific boundaries for top and bottom of the channel.\nHere, we can make use of the aformentionded boolean to easily switch between two\ncases:  while we choose a depth of dx for a 2D case, for a 3D test case we use\na rectangular channel, where the depth is equal to the height. --! [Non-periodic] -- If usePeriodic is deactived, but case2d is selected, we use another wayt to -- create a quasi-2D channel: a channel with 1 element in depth. If not, we -- create a 3D channel. else if case2d then depth = dx else depth = height end table.insert ( spatial_object , { attribute = { kind = 'boundary' , label = 'top' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , 0.5 * depth + dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , height + 2 * dx_eps , 0.0 } } } -- object } -- geometry } -- spatial object ) table.insert ( spatial_object , { attribute = { kind = 'boundary' , label = 'bottom' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , height + 2 * dx_eps , 0.0 } } }, -- object } -- geometry } -- spatial object ) end --periodic --! [Non-periodic] In order to simulate a flow around an obstacle you might activate useObstacle=true . Here you can choose between two stl files for a sphere (2D)\nor a cylinder (3D). You have to make sure that the files are located in the\ndefined directory. Now it makes sense to activate qvalues. This allows to\nrefine the mesh at i.e. circular boundaries. This is done with calc_dist = true in the attribute table of a spatial object. --! [Use of obstacles] -- If obstacle is true, we distinguish between 2D (cylinder) and 3D (sphere) -- case. if useObstacle == true then if case2d == true then stlfile = 'stl/cylinder.stl' stlLabel = 'cylinder' else if usePeriodic == true then stlfile = 'stl/cylinder.stl' stlLabel = 'cylinder' else stlfile = 'stl/sphere.stl' stlLabel = 'sphere' end end -- If we use an obstacle, we can make use of qValues. Here, we also -- distinguish between 2D (cylinder) and 3D (sphere). If we don't want to use -- them. table.insert ( spatial_object , { attribute = { kind = 'boundary' , level = maxLevel , label = stlLabel , calc_dist = qValues , }, geometry = { kind = 'stl' , object = { filename = stlfile , } }, transformation = { -- Deformation factor to scale the obstacle. Here: 1 --> remains the same. deformation = 1 , -- In this case, we do not have to move the geometry. translation = { 0.0 , 0.0 , 0.0 } } } ) end -- useObstacle --! [Use of obstacles] Now you can start Seeder . If it successfully finishes, the mesh was generated. Control the Generated Mesh Harvester (integrated in Seeder ) can process the mesh and generate a VTK\nfile, which can then be visualized by Paraview. Let's prepare the sdr_harvester.lua for visualization. This is the simplest form of mesh visualization. For more\npossibilities have a look at the Seeder documentation . The sdr_harvester.lua contains two parts. The first part defines the input: -- Mesh to visualize, this is the common mesh definition, as found in -- treelm/config.lua. -- Either a predefined mesh, or the prefix for a mesh on disk. mesh = 'mesh/' -- If restart table and mesh are present then priority is given to restart restart = { --   read = 'debug/final100_restart_ProtoData_header_100.lua' } The second part defines the output -- To dump complete mesh or restart file with out any tracking table -- just default output table with basename, format as shown below -- Configuration for the output to produce output_folder = 'debug/' -- Prefix to use for the produced files, -- if it ends in a '/', this is a directory, -- which needs to exist! output = { format = 'vtk' , -- Visualization file format, defaults to 'vtk' -- Currently only vtk is supported here. dataform = 'binary' , -- Form to write data in: --   - 'binary',  or --   - 'ascii' -- Default is 'binary' write_pvd = false -- write pvd file containing all timesteps -- Default is true } Now run ~/apes/seeder/build/sdr_harvesting sdr_harvester.lua . Visualize the mesh with Paraview.\nIf you set up usePeriodic = false in seeder.lua\nthe VTU file should look like this: Otherwise you can build a two-dimensional channel like this: The periodic version looks like the 2D channel. Run Musubi Let's have a look at how to configure Musubi . Note Many things were mentioned in the last tutorial In order to repeat the most important things, you can make use of a checklist.\nFor the simulation you need to define: Basic information mesh location of the directory is needed. identify = { layout = \"..\", kind = \"..\", relaxation = \"..\"} There exist default values, which are explained in the last tutorial . Physical and lattice reference values Time settings that describe the time interval, the time maximum and an\n     abort criteria. fluid table with information about physics and LBM units. initial_condition table with the initial pressure and velocity. boundary_condition table aims to tell Musubi how to handle the\n     boundaries that were set up in seeder.lua. It reads the boundaries' labels\n     and converts them into a wall, an inlet or an outlet. tracking table for information about the target output. It exist a\n     description module for tracking that you find here . 1. Basic Information First we need to include seeder.lua to acess all geometric variables. require \"seeder\" -- Tells musubi.lua to use defined variables from seeder.lua simulation_name = simName Specify the scaling (diffusive or acoustic): -- Scaling for multilevel simulation scaling = 'acoustic' We define local variables that we need to turn off or on a few features: -- Initialization of channel, for true --> values>0, false --> initalized with 0 initChannel = false Next we define some variables: --! [Variables] -- Collision Model (bgk, trt, mrt) relaxationModel = 'bgk' -- Stencil (d1q3, d2q9, d3q6, d3q7, d3q19, d3q27) if case2d then stencil = 'd2q9' -- use 2D stencil else stencil = 'd3q19' --use 3D stencil end -- Physics (fluid, fluid_incompressible) physicsModel = 'fluid_incompressible' --! [Variables] And the flow parameters used: --! [Local variables] -- Flow parameters -- Density of the fluid [kg/m&#94;3] rho0_phy = 1.0 -- Reynolds number of the flow Re = 60 -- speed of sound in air [m/s] cs_phy = 343 Other flow parameters like Mach number and viscosity are defined below depending\non scaling type which is used to compute time step. In acoustic scaling, \ndt is computed for fixed Ma number whereas in diffusive scaling, dt is computed\nfor fixed viscosity and omega.\nHere are timestep calculation for acoustic and diffusive scaling. ------------------------ Compute physical timestep ----------------------------- -- Lattice speed of sound cs_lat = math.sqrt ( 1.0 / 3.0 ) if ( scaling == 'acoustic' ) then -- In acoustic scaling, Ma is fixed by user -- Mach number Ma = 0.05 -- Inflow velocity computed from Ma number [m/s] vel_phy = Ma * cs_phy -- Kinematic viscosity of the fluid calculated from Re [m&#94;2/s] nu_phy = vel_phy * height / Re -- Lattice velocity vel_lat = Ma * cs_lat -- Physical timestep computed from physical and lattice speed of sound dt = cs_lat / cs_phy * dx -- Lattice viscosity nu_lat = nu_phy * dt / dx / dx -- Relaxation parameter omega = 1.0 / ( 3.0 * nu_lat + 0.5 ) else -- In diffusive scaling, Kinematic viscosity and omega are fixed by user -- Kinematic viscosity of the fluid [m&#94;2/s] nu_phy = 0.285 -- Inflow velocity is computed from Re and viscosity [m/s] vel_phy = Re * nu_phy / height -- Relaxation parameter omega = 1.7 -- Lattice viscosity nu_lat = ( 1.0 / omega - 0.5 ) / 3.0 -- Physical timestep computed from physical and lattice velocity dt = nu_lat / nu_phy * dx * dx -- Lattice velocity vel_lat = vel_phy * dt / dx -- Mach number Ma = vel_lat * cs_lat end -------------------------------------------------------------------------------- The bulk viscosity for weakly-compressible model: -- Bulk viscosity if physicsModel == 'fluid' then bulk_visc = 2.0 / 3.0 * nu_phy end Now we define our reference lattice values and derive some variables based on\nprevious defined ones: --! [Reference LB values] -- Square of lattice speed of sound cs2_lat = 1.0 / 3.0 -- Lattice density rho0_lat = 1.0 --! [Reference LB values] --! [Reference pressure in physical unit] press_ambient = rho0_phy * cs_phy &#94; 2 --! [Reference pressure in physical unit] The last block defines some neccessery runtime variables: ----------------------------- Time settings ------------------------------------ -- Physical simulation end time [s] tmax_phy = 10.0 -- Number of iterations required to reach physical simulation end time. -- tmax_iter is also number of lattice iterations tmax_iter = math.ceil ( tmax_phy / dt ) -- Interval to check status of the simulation [s] interval_phy = tmax_phy / 10.0 -- Starting time for tracking output [s] trac_start = 0.0 -- Starting time for restart output [s] rest_start = tmax_phy / 4.0 ------------------------- End of time settings --------------------------------- --! [Local variables] 2. Lua Functions We need some lua functions to compute certain values. These are shown here: ---------------------------- Lua functions ------------------------------------- --! [Pressure function] -- Pressure drop across the channel length for Poiseuille flow press_drop = 8 * vel_phy * rho0_phy * nu_phy * length / height &#94; 2 function pressureRef ( x , y , z ) return press_ambient + press_drop * ( 0.5 - x / length ) end --! [Pressure function] --! [Boundary pressure] -- Pressure at inlet pressureIn = pressureRef ( - length / 2 , 0.0 , 0.0 ) -- Pressure at outlet pressureOut = pressureRef ( length / 2 , 0.0 , 0.0 ) --! [Boundary pressure] -- Reference values for the flow state in the 2d stationary channel at laminar -- flow state --! [Velocity function] function velX ( x , y , z ) velX_phy = vel_phy * ( 1.0 - ( 2.0 * y / height ) &#94; 2 ) return velX_phy end --! [Velocity function] function Sxx ( x , y , z ) return 0.0 end function Syy ( x , y , z ) return 0.0 end --! [Shear Stress Function] function Sxy ( x , y , z ) tauxy = - nu_phy * rho0_phy * 8. / height &#94; 2 * vel_phy * y S_xy = tauxy / nu_phy / rho0_phy return S_xy end --! [Shear Stress Function] -- Reference shear stress function stressRef ( x , y , z ) return Sxy ( x , y , z ) * rho0_phy * nu_phy end -- Consistent initial conditions for the channel if initChannel then function ic_velX ( x , y , z ) return velX ( x , y , z ) end function ic_pressure ( x , y , z ) if ( physicsModel == 'fluid' ) then return pressureRef ( x , y , z ) + rho0_phy * cs2 * dx / dt else return pressureRef ( x , y , z ) end end function ic_Sxx ( x , y , z ) return Sxx ( x , y , z ) end function ic_Syy ( x , y , z ) return Syy ( x , y , z ) end function ic_Sxy ( x , y , z ) return Sxy ( x , y , z ) end else -- Initialize with 0 function ic_velX ( x , y , z ) return 0. end function ic_pressure ( x , y , z ) return press_ambient end function ic_Sxx ( x , y , z ) return 0. end function ic_Syy ( x , y , z ) return 0. end function ic_Sxy ( x , y , z ) return 0. end end ---------------------------- Lua functions ------------------------------------- 3. Musubi Related Variables Here we define some variables used to control musubi's behavior: -- Simulation name used in tracking and restart outputs simulation_name = 'channel' -- Print runtime information like memory usage at the end of the simulation printRuntimeInfo = false -- file to write measurement time of simulation for each solver step timing_file = 'mus_timing.res' -- Location of mesh files mesh = './mesh/' -- Logging output from simulation logging = { level = 3 , --filename = 'log' -- filename to write logging output } -- Interpolation method for multilevel simulation (linear, quadratic) interpolation_method = 'quadratic' -- Debug outputs to write additional information NOdebug = { logging = { level = 1 , filename = 'dbg' , root_only = false -- all involved MPI processes writes output } } 4. Simulation Control We define the sim_control table tem_simControl_module containing\ninformation about time_control tem_timeControl_module and abort_criteria tem_abortCriteria_module . --! [Simulation Control] sim_control = { time_control = { max = { sim = tmax_phy }, interval = { sim = interval_phy }, clock = 3600 --s }, -- Abort conditions for simulation abort_criteria = { -- Abort if file with the name 'stop' exist stop_file = 'stop' , -- Abort if steady state is reached with condition defined in convergence -- table steady_state = true , -- Convergence condition for steady state check convergence = { -- Variables to check variable = { 'pressure_phy' }, -- Check only point in middle of domain shape = { kind = 'canoND' , object = {{ origin = { 0. , 0. , 0. } }} }, -- Reduce variables values in space to single average value reduction = { 'average' }, -- How often to do convergence? time_control = { min = tmax_phy / 2.0 , -- Start convergence check after half sim. time max = tmax_phy , -- DO convergence until end of simulation interval = 10 * dt -- Do convernce check every 10*dt [s] }, norm = 'average' , nvals = 50 , absolute = false , -- Condition to statisfy to every variable condition = { { threshold = 1.e-5 , operator = '<=' }, } }, } } --! [Simulation control] 5. Fluid, Identity and Physics Table We define the physics, identity and fluid table here.\nThese have been explained in [chapter 01] . --! [Physics parameters] -- Required to convert physical unit to lattice unit physics = { dt = dt , rho0 = rho0_phy } --! [Physics parameters] --! [Scheme identifier] identify = { layout = stencil , relaxation = relaxationModel , kind = physicsModel } --! [Scheme identifier] --! [Fluid] -- For both, incompressible and compressible kinematic viscosity has to be -- defined. While for the first one, default values are stored for bulk -- viscosity,, the user has to explicitly give them for compr. fluid. if ( physicsModel == 'fluid' ) then fluid = { kinematic_viscosity = nu_phy , bulk_viscosity = bulk_visc } else fluid = { kinematic_viscosity = nu_phy , } end --! [Fluid] 6. Initial Condition Here we define the initial conditions for the simulation. --! [Initial conditions] initial_condition = { pressure = ic_pressure , velocityX = ic_velX , velocityY = 0.0 , velocityZ = 0.0 , Sxx = ic_Sxx , Syy = ic_Syy , Sxy = ic_Sxy } --! [Initial conditions] 7. Boundary Conditions Next, we define the boundary conditions to handle the boundaries we have set up\nin seeder.lua . -- Label is a boundary identifier and it should be same as in seeder -- configuration. boundary_condition = { { label = 'north' , kind = 'wall' }, { label = 'south' , kind = 'wall' }, { label = 'west' , kind = 'pressure_expol' , pressure = 'pressureIn' }, { label = 'east' , kind = 'pressure_expol' , pressure = 'pressureOut' } } -- If we deactivated usePeriodic in seeder.lua, we have to add boundaries for -- top and bottom. if usePeriodic == false then table.insert ( boundary_condition , { label = 'top' , kind = 'wall' } ) table.insert ( boundary_condition , { label = 'bottom' , kind = 'wall' } ) end -- If we activated useObstacle in seeder.lua, we have to add a boundary for it, -- too. Label depends on 2D (cylinder) or 3D (sphere). if useObstacle == true then table.insert ( boundary_condition , { label = stlLabel , kind = 'wall_libb' } ) end --! [Boundary conditions] 8. Variable and Tracking Table During the simulation we track variables to have a look at e.g. the pressure\nover time. Therefore we use the tem_tracking_module . If we want to\nmake use of different than the default values we define the variable table\nthat is explained here . --! [User defined variables] -- Mainly used for tracking. -- This variable can be refered to as variable in boundary condition and source variable = { -- Reference pressure dependent on physicsModel { name = 'pressureRef' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureRef }, -- Background pressure { name = 'pressure0' , ncomponents = 1 , vartype = 'st_fun' , st_fun = press_ambient }, -- Pressure at inlet { name = 'pressureIn' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureIn }, -- Pressure at outlet { name = 'pressureOut' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureOut }, -- Reference shear stress { name = 'stressRef' , ncomponents = 1 , vartype = 'st_fun' , st_fun = stressRef }, -- Difference between numerical pressure and reference pressure { name = 'press_error' , ncomponents = 1 , vartype = 'operation' , operation = { kind = 'difference' , input_varname = { 'pressure_phy' , 'pressureRef' ,}, }, }, -- Difference between numerical pressure and background pressure { name = 'press_fluc' , ncomponents = 1 , vartype = 'operation' , operation = { kind = 'difference' , input_varname = { 'pressure_phy' , 'pressure0' ,}, }, }, } --! [User defined variables] Now we need to define the tracking. We only use one example here. Inside the\nexample musubi.lua a lot more trackings can be found. The next [chapter 03] will explain the tracking in more detail. --! [Tracking example] tracking = { -- Track pressure at the center of the channel over time. { label = 'probeAtCenter' , --label = 'probePressure', folder = 'tracking/' , variable = { 'pressure_phy' }, shape = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 } } }, time_control = { min = { iter = 1 }, interval = { iter = 1 } }, output = { format = 'ascii' }, }, --! [Tracking example] 9. Restart Table We need to define a table for a restart of our simultion. If this table doesn't\nexist, no restart files will be created. Find more information in [chapter 05] . --! [Restart] -- Without timeControl restart will be dumped by default at end -- of simulation when write restart is set. restart = { NOread = 'restart/channel2D_lastHeader.lua' , write = 'restart/' , time_control = { min = { iter = rest_start }, max = { iter = tmax_phy }, interval = { iter = interval_phy } } } --! [Restart] Now run the simulation with: ~/apes/musubi/build/musubi musubi.lua Post-Process the Results After the simulation run you can have a look at the vtk files with Paraview.\nHere, you can see a possible output from Paraview: Now you are free to go on with the next chapter that deals with Tracking. Next chapter: Tracking →","tags":"","loc":"page/examples/tutorials/tut_02_mus_toolchain.html"},{"title":"Tracking – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Toolchain | Overview | Boundary Conditions → Tracking Tracking quantities during the simulation run. In this tutorial we deal with tracking, that is tracking flow quantities\nduring the simulation run and visualizing them. An extensive documentation of the tracking features can be found in tem_tracking_module and in its documentation page Two additional examples dealing with shapes are given in tem_load_shapes . In the musubi.lua file, there has to be a section called tracking .\nIn order to get a simulation output for harvester you set up some\ninformation for each tracked quantity.\nThese are in general: label This defines the name of the tracked quantity. variable What variable values are tracked? (i.e. pressure, velocity) shape How does the geometry look like in the mesh? Shall it be a point\n  or a line? Where is it placed? These are the questions you are\n  supposed to answer here. time_control This behaves similar to the general time settings in musubi.lua . You have\n  to define a starting and an end point for the tracked quantity. In addition\n  to that, you must give Musubi information about the time interval, when\n  i.e. the pressure gets its values during the simulation. format You can choose between these three formats: vtk This format creates results in the Treelm format. It is used to process\ninput files for Paraview. When using this format, make sure there is a\ndirectory called output in the simulation path.\n(This has been done in the last tutorial as well).\nHere you can see another example (planeXY) : ascii This output format creates a .res file that contains the tracked quantities\nlike pressure and velocity over certain timesteps. It is normally used for\n1D shapes (a single point). Nevertheless, it is possible to track the\nvariable values over a 2D shape. In this case, a reduction is used. There\nare picked up certain points of the shape and they are reduced to a single\nresult. The table in the resulting file is build up as following.\nIn the first column, you can find the time (t_0, t_1, t_2, ..., t_n). It is\nfollowed by the variable values. Every row replaces one timestep with values\nfor each variable.\nHere you can see an example that is plotted by GNUplot (probeAtCenter): asciiSpatial This kind of format creates not only one res. file. Moreover it creates\none .res file for each timestep. This means, that you get a table with\nthe x, y and z coordinates of the shape in the first three columns. These\nare followed by the different variable values like pressure and shear stress.\nIn summary, you get all these information for each timestep in another\nfile. You can plot these values as well, so that you get something like\nthis (pressAlongLength): folder Here, you have to define the location where your resulting files shall be dumped. Here is a demonstration example of how a tracking section in the musubi.lua file\ncan look like: -- probeAtCenter tracking = { { label = 'probePressure' , variable = { 'pressure_phy' }, shape = { kind = 'canoND' , object = { origin = { 0.0 , 0. , 0. } } }, time_control = { min = { iter = 1 }, interval = { iter = 1 }}, output = { format = 'ascii' }, folder = './tracking/' } } You have to define your variable values first before you can track them. Have a look here on how to do this. Here ends the tutorial for tracking quantities during the simulation. You can go on for\nmore information about boundary conditions in the next tutorial. Next chapter: Boundary Conditions →","tags":"","loc":"page/examples/tutorials/tut_03_tracking.html"},{"title":"Boundary Conditions – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Tracking | Overview | Restart → Boundary Conditions In this tutorial we use the 2D channel case to explain how to define boundary\nconditions that are needed for the simulation run. Note To run this case use the generic channel test case and set in seeder.lua : lua\ncase2d = true\nusePeriodic = true\nqValues = false\nuseObstacle = false\nfixHeight = true\nuseRefine = true Note Multi-level meshes at boundaries lead to fluctuation in the boundary layer.\nAlso avoid single refinement layers since they could lead to crashes.\nAt least four refined elements are recommended. Where the Information for the Boundaries are Taken From In Seeder , boundaries are defined by spatial_object attribute kind \"boundary\".\nThe output of Seeder is normally placed in the ./mesh folder. There you can\nfind files called bnd.lua and bnd.lsb . bnd.lua file contains basic information about boundaries like number of\nboundaries in a mesh and list of boundary labels in ascii format. bnd.lsb file contains boundary IDs for 26 directions for each fluid element\nwhich has boundary neighbor in binary format.\nThese two files are important for Musubi in case of defining the boundary\nconditions. If you open bnd.lua file, you will probably find something like this: nSides = 26 nBCtypes = 4 bclabel = { 'south' , 'north' , 'east' , 'west' } In the example, there are four different boundaries we have set up with Seeder .\nIn this case they have the labels north , south , east and west . This\ngives you a feeling of how to view this channel. These boundaries are defined in the mesh, but it is not clear which function\neach boundary has at the moment. So this is the part you have to do in Musubi .\nAs an example, we want to simulate a channel. A channel in 2D needs two walls,\none inlet and one outlet. If you would like to know in detail how the boundaries are defined you might\nhave a look at tem_bc_module and tem_load_bc_state . How to Define Boundary Conditions in Musubi? Now, we will have a look on the boundary_conditions table in Musubi for the\nchannel test case. boundary_condition = { { label = 'north' , kind = 'wall' }, { label = 'south' , kind = 'wall' }, { label = 'west' , kind = inlet_kind , -- local variable inlet_kind pressure = 'pressureIn' }, -- refers to pressure defined in variable table -- (see last tutorial) { label = 'east' , kind = outlet_kind , -- local variable outlet_kind pressure = 'pressureOut' }} -- local variable from variable table In this basic example you can see the function of each boundary as outlined\nabove. boundary_condition Table In boundary_condition table, for each boundary label from Seeder , a kind\nmust be defined in Musubi which defines what to do with that boundary. The\norder of boundary definition in Musubi does not depend on the order in Seeder (bnd.lua). It just has to exist in both files. boundary_condition = { ... Label For every boundary which you have created in Seeder , you have to set its status.\nTherefore, you call the boundary with the exact name ( label = ... ) that you\ncan see in the bnd.lua file and give it a certain kind that is explained in\nthe next section. boundary_condition = { label = 'south' , ... Kind You can choose between some basic boundary kinds. They define the use of the\nboundary in the simulation run. Some of these kinds are described below. wall A wall means that the fluid is not able to penetrate through this boundary.\n  It has to regard the wall as an obstacle. Moreover, the wall is seen as a no-slip boundary. If you would like to observe slip as well you have to\n  use the separate kind slip_wall . boundary_condition = { label = 'south' , kind = 'wall' } slip_wall If slip shall be defined as well, you will have to set kind to kind = slip_wall . Slip means that the normal and the tangential velocity in\n  normal direction equal zero. The pressure gradient along the normal direction\n  is equal to zero as well. The degree of slip can be defined by the\n  multiplication of a slip-factor called fac and the velocity. Special cases\n  are on the one hand fac = 1 which means that there is free-slip or full-slip\n  and on the other hand, there is fac = 0 which is used for no-slip. This case\n  is the default case for the kind = wall which is mentioned above. boundary_condition = { label = 'north' , kind = 'slip_wall' , fac = 0.4 } More information can be found in the mus_bc_fluid_wall_module . wall_libb There is a possibility to make your simulation more efficient: Instead of\nmaking use of a higher refinement level, you could use linear interpolation.\nThe obstacle in the fluid will have a higher resolution if the distance\nbetween the barycentric centre position of the fluid element to the obstacle\nis calculated which is \"q\". The total distance between the center positions of\neach, the fluid element's and the obstacle's is q=1 . There is a case\ndifferentiation between q<0.5 and q>=0.5 . For this formula is used: For this formula is used: Therefore, Seeder has to be configured. For each spatial_object which has\nboundary kind, calc_dist = true has to be added to the attributes right\nbehind kind and label. Here is the seeder.lua block before the changes: table.insert ( spatial_object , { attribute = { kind = 'boundary' , label = 'north' }, geometry = { kind = 'canoND' , object = { origin = { - length * 0.5 , height * 0.5 + dxDash , - length * 0.5 }, vec = {{ length , 0.0 , 0. }, { 0. , 0.0 , length }} } } }) table.insert ( spatial_object , { attribute = { kind = 'boundary' , label = 'south' }, geometry = { kind = 'canoND' , object = { origin = { - length * 0.5 , - height * 0.5 - dxDash , - length * 0.5 }, vec = {{ length , 0.0 , 0. }, { 0. , 0.0 , length }} } } }) In the spatial_object tables for the boundaries, you have to add to the\n attributes calc_dist = true . Then there should be written as an example for one boundary: table.insert ( spatial_object , { attribute = { kind = 'boundary' , level = maxLevel , --local variable label = stlLabel , --local variable calc_dist = true , }, geometry = { kind = 'stl' , object = { filename = stlfile --local variable --          { origin = {-length*0.3,-0.01*height,0.}, --            radius = radius } } }, transformation = { deformation = 2.0 , translation = { - 2. , 0. , 0. } } }) After that, you are able to set the kind of the boundary in musubi.lua to wall_libb instead of wall . You have to use the same syntax\n  as shown above, otherwise it will not work. boundary_condition = { label = 'south' , kind = 'wall_libb' , } The information about linear interpolation are taken from M. Bouzidi,\nM. Firdaouss, and P. Lallemand, \"Momentum transfer of a Boltzmann-lattice\nfluid with boundaries,\" Physics of Fluids, vol. 13, no. 11,\npp. 3452–3459, Nov. 2001 Equations 5 (linear interpolation).\nMore information about no-slip wall linear interpolation can be found in mus_bc_fluid_wall_module . Velocity Boundary Conditions velocity_eq kind = velocity_eq makes use of the equilibrium function concerning\nthe Lattice Boltzmann Method (LBM). This function gets the density (rho) from\nthe fluid. The velocity (u) has to be defined for each coordinate x, y and z.\nTherefore you can place the definition of the velocity after the kind of the\nboundary. Example: boundary_condition = { { label = 'inlet' , kind = 'velocity_eq' , velocity = 'inlet_vel' } You can get more information about the equilibrium function currently in\nthe documentation for the subroutine velocity_eq . velocity_bounceback In addition to that you can set kind = velocity_bounceback . You can imagine\nbounceback like this: A fluid particle gets near the boundary. If it reaches the\nboundary, the particle will bounce back in the same angle as it gets there.\nFor this kind, you have to set the velocity values, too. boundary_condition = { { label = 'west' , kind = 'velocity_bounceback' , velocity = 'inlet_vel' } More details can be found in the documentation for subroutine velocity_bounceback . mfr_bounceback Like for velocity_bounceback there is an \"Inlet Velocity Bounce Back\" boundary\ncondition. But in this case, mass flow rate ( mfr ) is used as an input\nargumet as well. It is used like that: boundary_condition = { { label = 'inlet' , kind = 'mfr_bounceback' , massflowrate = 0.1 } For more information visit mfr_bounceback . mfr_eq In this case, the mass flow rate is used for the equilibrium boundary condition\nand the velocity is taken from the configuration file. boundary_condition = { { label = 'inlet' , kind = 'mfr_eq' , massflowrate = 0.1 } The corresponding Documentation can be found in mfr_eq . Pressure Boundary Conditions pressure_expol The variable values are extrapolated during the simulation. boundary_condition = { { label = 'east' , kind = 'pressure_expol' , pressure = 2.0 } Detail information can be found in pressure_expol . pressure_antiBounceBack This is the outlet pressure anti-bounce back boundary condition kind. The\nvelocity is extrapolated by two of its neighbors. The pressure has to be given\nas well. boundary_condition = { { label = 'east' , kind = 'pressure_antiBounceBack' , pressure = 2.0 } More information pressure_antiBounceBack . pressure_eq The incoming densities are set to the equilibrium distribution with macroscopic\nvelocity and pressure. boundary_condition = { { label = 'east' , kind = 'pressure_eq' , pressure = 1.0 } Detail information in the pressure_eq . symmetry For symmetric test cases this boundary condition can be used to mirror the\nflow-parameters at this border. This allows to reduce the computational effort.\nThe missing part can be easily mirrored when post-processing. Warning Be aware: The symmetric boundary has to be the last boundary created\nby Seeder !\n@end warning boundary_condition = { { label = 'east' , kind = 'symmetry' } Physical Conditions If you define the inlet and the outlet boundary for the shape, you will have to\ngive Musubi further information about the variable values. This depends on the\nused test case. They are defined in the bc_states_type . You can use the\nfollowing: velocity massflowrate pressure molefrac moleflux moleDens molediff_flux pdf potential surChargeDens For example, to simulate the channel, you are free to give information about the\nvariable values with space time functions . Space Time Functions The documentation for these functions can be found in the tem_spacetime_fun_module in subroutine tem_load_spacetime_single . Variable values like pressure and velocity are defined as space time functions . Space time functions contain the x-, y- and\nz-coordinates and the time as arguments. There are some different ways to get\nto a value for i.e. pressure and velocity at different timesteps that are\ndescribed shortly in the following. Before they are used in the boundary_condition table they are defined in the variable table. Note See this documentation for more information. Inside the variable = {..} table space time functions can be defined as a\nconstant, a lua function, a predefined fortran function or a combination of\nspatial and transient functions that are themselves defined as a constant, a\nlua function or a predefined fortran function. Here are a few examples on how to implement space time functions as a boundary\ncondition. lua function function lua_function ( x , y , z , t ) ... return end variable = { { label = 'var_label' , ncomponents = 1 , kind = 'st_fun' , st_fun = lua_function }, ... } boundary_condition = { { label = 'bc_label' , kind = 'bc_kind' bc_variable = 'var_label' }, ... } constant boundary_condition = { label = 'bc_label' , kind = 'bc_kind' , bc_variable = 1.0 } variables with more than one component Do not forget to give combination variables to make a vector out of each\nvelocity, moleflux and molediff_flux component. Here is an example on how to implement velocity as a boundary variable: variable = { -- example for a predefined space time function { name = 'inlet_vel' , ncomponents = 3 , vartype = 'st_fun' , st_fun = { predefined = 'combined' , temporal = { predefined = 'smooth' , min_factor = 0 , max_factor = u_in_L , from_time = 0 , to_time = tmax / 4 }, spatial = { const = { 1.0 , 0.0 , 0.0 } } } }, -- example for a combination of 3 functions { name = 'velX' , ncomponents = 1 , vartype = 'st_fun' , st_fun = lua_function }, { name = 'velY' , ncomponents = 1 , vartype = 'st_fun' , st_fun = 0.0 }, { name = 'velZ' , ncomponents = 1 , vartype = 'st_fun' , st_fun = 0.0 }, { name = 'inlet_vel2' , ncomponents = 3 , vartype = 'operation' , operation = { kind = 'combine' , input_varname = { 'velX' , 'velY' , 'velZ' } } } } You can find more examples in the subroutine tem_load_bc_state and on variable system page . Next chapter: Restart →","tags":"","loc":"page/examples/tutorials/tut_04_boundaries.html"},{"title":"Restart – Musubi","text":"Warning WORK IN PROGRESS navigate: ← Boundary Conditions | Overview | Initional Conditions → Restart In this tutorial we explain how to restart a simulation from a certain time\npoint and to make a simulation restartable from the last timestep of the\nsimulation run. How to Make it Possible to Restart the Simulation? You are preparing your simulation with writing the musubi.lua file and you have\nnot yet run it.\nTo make a restart possible you have to do the following: At first, you have to create the restart folder in your simulation directory\nwith mkdir restart . Add the following code to your musubi.lua file somewhere at the end: restart = { write = 'restart/' , time_control = { min = { iter = rest_start }, max = { iter = tmax_phy }, interval = { iter = interval_phy } } } After that, you are able to test if the restart table is working. For every\ntimestep, Musubi writes each a .lua file and a .lsb file to ./restart/ .\nFor example, here is a lua file for a random timestep: binary_name = { 'restart/channel_9.021E-03.lsb' } solver_configFile = 'musubi.lua' mesh = './mesh/' weights = '' time_point = { sim = 9.021097956087902E-03 , iter = 5 , clock = 103.734125999999996E-03 } nElems = 2048 nDofs = 1 solver = 'Musubi_v2.0' varsys = { systemname = 'fluid_incompressible' , variable = { { name = 'pdf' , ncomponents = 19 , state_varpos = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 } } }, nScalars = 19 , nStateVars = 1 , nAuxScalars = 4 , nAuxVars = 2 } It refers itself to the binary file which is the .lsb file. Now it is possible to restart your simulation from each timestep that is\navailable in the restart folder. Restart your Simulation from any Timestep If you wish to restart from this random timestep, you will have to change the\nrestart table in musubi.lua to: restart = { read = 'restart/channel_header_9.021E-03.lua' , write = 'restart/' , time_control = { min = { iter = rest_start }, max = { iter = tmax_phy }, interval = { iter = interval_phy } } } Note tEnd and interval are variables that are defined at the beginning of\nthe musubi.lua file of the channel testcase. You are free to use different\nvalues in the time_control table. As you can see, you have to refer to the lua and not to the lsb file in the restart table. Restart your Simulation right after the Last Timestep If you wish to restart your simulation from the last timestep when data was\nwritten to the restart folder, you will have to change: read = 'restart/channel_header_9.021E-03.lua' , to read = 'restart/channel_lastHeader.lua' , Musubi uses a pretty easy syntax in this case for restart files.\nThe filename is \"simulation_name\"+\"lastHeader.lua\". Now you have learned how to restart a simulation from any time point you wish\nto. This is very useful while you make use of expensive ressources like\nsupercomputers or while it takes a long time to simulate to time x and\nyou wish to go on from time x to time y. Next chapter: Initial Conditions →","tags":"","loc":"page/examples/tutorials/tut_05_restart.html"},{"title":"Initial Conditions – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Restart | Overview | Abort Criteria → Initial Conditions Definition of Initial Conditions In this tutorial, we cover the definition of initial conditions.\nThey can be defined either in lattice units or in physical units.\nLattice units can be confusing, especially to people just starting in this field.\nThe relationships between lattice and physical units can be found in this paper: unit conversion by Jonas Latt . In this tutorial, a two-dimensional plain channel is set up.\nNot only are the boundaries specified to obtain a defined pressure drop over\nthe channel length, but also are the initial conditions set in a consistent\nmanner. Note To run this test case use the generic channel test case and set in seeder.lua : lua\ncase2d = true\nusePeriodic = false\nqValues = false\nuseObstacle = false\nfixHeight = true\nuseRefine = false For the viscous, laminar two-dimensional plain channel flow, an analytical\nsolution of the incompressible Navier-Stokes equation can be derived. From the\nanalytical solution the pressure drop, the velocity profile and the shear stress\ndistribution can be computed. Before starting, we need to define the flow regime and physical reference values. -- Density of the fluid [kg/m&#94;3] rho0_phy = 1.0 -- Reynolds number of the flow Re = 60 -- Inflow velocity [m/s] vel_phy = 1.0 -- Kinematic viscosity of the fluid calculated from Re [m&#94;2/s] nu_phy = vel_phy * height_phy / Re For the Lattice_Boltzmann simulation, basic simulation parameters such as a\nlattice velocity, the timestep and the lattice viscosity need to\nbe specified. if ( scaling == 'acoustic' ) then -- Lattice Mach number Ma_lat = 0.05 -- Lattice velocity vel_lat = Ma_lat * cs_lat -- Physical timestep computed from physical and lattice velocity dt = vel_lat / vel_phy * dx -- Lattice viscosity nu_lat = nu_phy * dt / dx / dx -- Relaxation parameter omega = 1.0 / ( 3.0 * nu_lat + 0.5 ) else -- Diffusive scaling -- Relaxation parameter omega = 1.7 -- Lattice viscosity nu_lat = ( 1.0 / omega - 0.5 ) / 3.0 -- Physical timestep computed from physical and lattice velocity dt = nu_lat / nu_phy * dx * dx -- Lattice velocity vel_lat = vel_phy * dt / dx -- Lattice Mach number Ma_lat = vel_lat * cs_lat end -------------------------------------------------------------------------------- --! [Reference LB values] -- Square of lattice speed of sound cs2 = 1.0 / 3.0 -- Lattice density rho0_lat = 1.0 -- Zero lattice density rho0_lat0 = 0.0 --! [Reference LB values] Depending on the model used, the reference pressure differs. For the\nincompressible model, the reference pressure is 0, while for the compressible\nmodel the reference pressure is rho0*cs2 --! [Reference pressure dependent on fluid kind] if physicsModel == 'fluid_incompressible' then p0 = 0.0 else p0 = rho0_lat * cs2 * dx * dx / dt / dt end --! [Reference pressure dependent on fluid kind] From the solution of the Navier-Stokes equation, the following relations for the\nvelocity distribution across the channel height can be obtained --! [Velocity function] function velX ( x , y , z ) velX_phy = vel_phy * ( 1.0 - ( 2.0 * y / height_phy ) &#94; 2 ) return velX_phy end --! [Velocity function] Similarly for the pressure drop along the channel length --! [Pressure function] function pressureRef ( x , y , z ) press_drop = vel_phy * 8. * nu_phy * rho0_phy / height_phy &#94; 2 * length return p0 + press_drop * 0.5 - press_drop / length * x end --! [Pressure function] and the shear stress across the channel height --! [Shear stress function] function Sxy ( x , y , z ) tauxy = - nu_phy * rho0_phy * 8. / height_phy &#94; 2 * vel_phy * y S_xy = tauxy / nu_phy / rho0_phy return S_xy end --! [Shear stress function] Now the physics table establishes the connection between the lattice reference\nvalues and the physical values and gives Musubi means of transferring between\nthese two unit systems. See mus_physics_module for more information. physics = { dt = dt , rho0 = rho0_phy } For the Lattice_Boltzmann algorithm, a reference density and the kinematic\nviscosity (for compressible also the bulk viscosity) need to be defined.\nSee mus_fluid_module for more information. fluid = { kinematic_viscosity = nu_phy , bulk_viscosity = bulk_visc } Now the initial conditions for each element in the simulation domain is defined\nby setting each physical quantity and connecting it to a lua function, which we\ndefined above. --! [Initial conditions] initial_condition = { pressure = ic_pressure , velocityX = ic_velX , velocityY = 0.0 , velocityZ = 0.0 , Sxx = ic_Sxx , Syy = ic_Syy , Sxy = ic_Sxy } --! [Initial conditions] Note The whole code of musubi.lua is shown in the chapter_02 . Next chapter: Abort Criteria →","tags":"","loc":"page/examples/tutorials/tut_06_initial.html"},{"title":"Abort Criteria – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Initial Conditions | Overview | Source Terms → Abort Criteria In this tutorial, we show how to use a convergence criterium to\nstop the code before reaching the maximum time.\nConvergence sensors are actually objects part of the sim_control table with\nan additional abort_criteria table. sim_control = { time_control = { ... }, abort_criteria = { ... convergence = { variable = {...}, shape = {...}, time_control = {...}, reduction = {...}, norm = ... , -- 'simple' or 'average' nvals = ... , absolute = ... , -- 'true' or 'false' condition = {...}, -- nConditions == nVariables } } } Note See tem_convergence_load for a set of options and few examples. Let's consider the channel test case of before again.\nIf we now want to add a convergence sensor to the simulation, we add the table abort_criteria to sim_control . --! [Simulation Control] sim_control = { time_control = { max = { sim = tmax_phy }, interval = { sim = interval_phy }, clock = 3600 --s }, -- Abort conditions for simulation abort_criteria = { -- Abort if file with the name 'stop' exist stop_file = 'stop' , -- Abort if steady state is reached with condition defined in convergence -- table steady_state = true , -- Convergence condition for steady state check convergence = { -- Variables to check variable = { 'pressure_phy' }, -- Check only point in middle of domain shape = { kind = 'canoND' , object = {{ origin = { 0. , 0. , 0. } }} }, -- Reduce variables values in space to single average value reduction = { 'average' }, -- How often to do convergence? time_control = { min = tmax_phy / 2.0 , -- Start convergence check after half sim. time max = tmax_phy , -- DO convergence until end of simulation interval = 10 * dt -- Do convernce check every 10*dt [s] }, norm = 'average' , nvals = 50 , absolute = false , -- Condition to statisfy to every variable condition = { { threshold = 1.e-5 , operator = '<=' }, } }, } } --! [Simulation control] In the convergence table you now specify under which condition a simulation is\nconverged. We already chose the quantity to use as the pressure above. The norm\nto evaluate the convergence defines how to compute the converged condition on a\nset of available data. The length of this set is defined by nvals . This\nbasically means over how many points in time the convergence is evaluated.\nThe condition under which convergence is achieved is done with the condition table. You specify a threshold and the operator. You can choose if you want an absolute or a relative metric by specifying absolute = true / false . Each point in time when this object is active (i.e. the conditions of the time\ndefinition table are met), a value is added to the convergence data set. The\ncurrent convergence quantity is then compared to the norm of the convergence\ndata set. If the condition is met, convergence is achieved. See residual is evaluated within tem_convergence_evaluate with function evaluate_residual . In our case, the current pressure value is compared to the average over fifty\npoints in time. If the difference is smaller or equal to 1.e-5, the convergence\nis set to be achieved. Once convergence is achieved, this is communicated to all other processes in\nthe next interval, when the total density is computed.  Then, the simulation is\nterminated after writing out all tracking, restart and output data. Automatic and Manual Stopping of Musubi The code might have to stop in other cases. One case is when invalid numbers\nare encountered. When the total density within the simulation domain is\ncomputed, Musubi checks if invalid numbers are found. If so, the result is\ninvalid, as the code has just been crashing, and the simulation can be stopped.\nNevertheless, all tracking and restart files are written. Sometimes computing resources are restricted to a certain time interval only.\nIt should therefore be ensured that Musubi terminates cleanly upon reaching\nsuch a time limit. You can define maximum wall clock limits, upon which Musubi then stops. In the time object, you just have to give the maximum\nnumber of seconds as: sim_control = { time_control = { max = tEnd , interval = interval , clock = 3600 --s }, abort_criteria = { ... } } If you manually want to terminate Musubi , you can create a file in the musubi\ndirectory during runtime. It must be named stop and does not have to have any\ncontent. Upon next check interval, Musubi checks for the existence of the\nfile. If encountered, Musubi terminates cleanly. Next chapter: Source Terms →","tags":"","loc":"page/examples/tutorials/tut_07_convergence.html"},{"title":"Source Terms – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Abort Criteria | Overview | Multi-Level Simulations → Source Terms Force as a source term. An example testcase can be found in examples/tutorials/tutorial_cases/tutorial_PIP_Force . To define a force that affects the whole domain one uses the glob_source table. --! [Source] glob_source = { force = { press_grad , 0.0 , 0.0 }, force_order = 2 } --! [Source] The force press_grad has to be defined inside the variable table. variable = { { name = 'press_grad' , ncomponents = 1 , vartype = 'st_fun' , st_fun = press_grad }, Note st_fun = press_grad refers to a lua-function defined somewhere else in\nthe lua file. Next chapter: Multi-Level Simulations →","tags":"","loc":"page/examples/tutorials/tut_08_source.html"},{"title":"Multilevel Simulations – Musubi","text":"Warning WORK IN PROGRESS Navigate: ← Source Terms | Overview Multi-level Simulations In some simulations there are regions of special interest. In these regions\nstrong gradients might occur, so that a higher resolution is required.\nYou then have basically two possibilities to resolve this problem: Increase the global resolution of your simulation. This is generally\n   not a good idea because you very quickly might run into memory problems.\n   A high number of fluid cells also means long computation times. Locally refine the mesh in regions of high interest.\n   You can refine the mesh in regions where it is desired.\n   This focuses the computation cost and memory expenses on the regions\n   where it actually is required. Why waste computation time on flow regions\n   where very little happens? A general problem are the interfaces between\n   grid levels. You can easily get reflections or non-discontinuities there\n   which is why you usually place interfaces in regions where the flow does\n   not fluctuate considerably. In mus_interpolate_module you can get some background information on the\nimplemented interpolation methods and the general workflow. Test Case Description In this tutorial we cover a channel test case with a cylinder inside.\nThe area around and behind the cylinder is refined by a refinement\npatch with a higher resolution. Note To run this case use the generic channel test case and set in seeder.lua : lua\ncase2d = false\nusePeriodic = false\nqValues = true\nuseObstacle = true\nfixHeight = true\nuseRefine = true Mesh Generation Before starting your simulation you have to set up a mesh again.\nAgain we involve Seeder to generate the required data structures for the\nsolver.\nIt is very advisable to define a variable for the most important variables.\nLater on you will be able to easily change the resolution of your simulation\nor some aspect ratio.\nOne very important parameter for setting the resolution of the simulation\nis a reference tree level that is done in tem_LevelOf . In our case this will be the tree level of the channel region. Let's name it level and set it based on the computed dx . In our default setting this\nresults in a level of 8. In addition to that, we define the folder (create it\nvia mkdir mesh ), the refinement level and the resulting level for the\nrefinement box. The region around and behind the cylinder is defined by a refinement box.\nLet's define first, by how many levels we want to refine the elements\ninside this refined area. For simplicity, let's say that all elements should\nbe on one level higher than the rest of the channel ( refinementLevel ). It is also good to have the information about the maximum level in your\nsimulation available as a parameter ( maxlevel ). You will later on see why. if useRefine then refinementLevel = refinementLevel + 1 -- Refinement level 2 can only be one larger than 1, otherwise level jump is -- too big. refinementLevel2 = refinementLevel + 1 end [...] maxLevel = level + math.max ( refinementLevel , refinementLevel2 ) [...] folder = 'mesh/' Note: For a description of levels and the layout of the tree have\na look at the octree page . height = 1.0 -- Height of the channel [m] l_h = 8.0 -- Length to height ratio length = l_h * height -- Length of the channel [m] depth = length -- Depth of the channel [m] level = 8 -- General level of mesh refinement The bounding box, which is the universe in which all elements of the tree will live in,\nis defined as bounding_cube = { origin = { - 0.5 * length_bnd , - 0.5 * length_bnd , - 0.5 * length_bnd + 0.5 * dx }, length = length_bnd } The region around the channel is set to the desired tree level of 9 and 10. spatial_object = { [...] { attribute = { kind = 'refinement' , level = refinementLevel + level , label = 'box1' }, geometry = { kind = 'canoND' , object = { origin = { start_x , start_y , start_z }, vec = { { size_x , 0.0 , 0.0 }, { 0.0 , size_y , 0.0 }, { 0.0 , 0.0 , size_z } } } } }, { attribute = { kind = 'refinement' , level = refinementLevel2 + level , label = 'box2' }, geometry = { kind = 'canoND' , object = { origin = { start2_x , start2_y , start2_z }, vec = { { size2_x , 0.0 , 0.0 }, { 0.0 , size2_y , 0.0 }, { 0.0 , 0.0 , size2_z } } } } }, [....] } --! [Refinement box 1 & 2] The rest of the bounding cubic domain is not of interest and hence the\ndiscretization level is not of interest. Defining Geometry We need to specify the walls, the inlet, outlet and the cylinder.\nLet's start with the walls at the north, south position.\nThe walls at east and west direction will later on become the in- and outlet. [...] { attribute = { kind = 'boundary' , label = 'north' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , 0.5 * height + dx_eps , - 0.5 * depth - dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, { attribute = { kind = 'boundary' , label = 'south' }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { length + 2 * dx_eps , 0.0 , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, [...] { attribute = { kind = 'boundary' , label = 'east' -- outlet }, geometry = { kind = 'canoND' , object = { origin = { 0.5 * length + dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { 0.0 , height + 2 * dx_eps , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, { attribute = { kind = 'boundary' , label = 'west' -- inlet }, geometry = { kind = 'canoND' , object = { origin = { - 0.5 * length - dx_eps , - 0.5 * height - dx_eps , - 0.5 * depth - dx_eps }, vec = { { 0.0 , height + 2 * dx_eps , 0.0 }, { 0.0 , 0.0 , depth + 2 * dx_eps } } } } }, For defining the cylinder or sphere, we use an STL file. This file was before\ngenerated by Blender, but you can basically use any software you like for\ngenerating such geometry data. The files are located in the test case directory: stl/*.stl .\nLet's include the sphere STL file with: stlfile = 'stl/sphere.stl' stlLabel = 'sphere' then add is to spatiatl_object tabel. table.insert ( spatial_object , { attribute = { kind = 'boundary' , level = maxLevel , label = stlLabel , calc_dist = qValues , }, geometry = { kind = 'stl' , object = { filename = stlfile , } }, transformation = { -- Deformation factor to scale the obstacle. Here: 1 --> remains the same. deformation = 1 , -- In this case, we do not have to move the geometry. translation = { 0.0 , 0.0 , 0.0 } } } ) One very important action is the placement of the seed.\nThe seed determines the contiguous flow domain. It basically\ndefines for the shapes, what is inside and what is outside.\nWe palce it right in the middle of the channel, which is simply spatial_object = { { attribute = { kind = 'seed' }, geometry = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , dx_half * 0.5 }, } } }, [...] Ok. Now we have defined all geometric constraints.\nLet's continue with refining some parts of the simulation domain. Defining Refined Regions You first need to specify the origin of this box and its extents.\nAgain, we use some variables depending on the total bounding cube. --! [Refinement box 1] -- Size of refinement box 1 in x-direction size_x = 0.75 * length -- Start of refinement box 1 (x)  based on length start_x = - 0.425 * length -- Size of refinement box 1 in y-direction size_y = 0.5 * height -- Start of refinement box 1 (y)  based on height start_y = - 0.25 * height -- Size of refinement box 1 in y-direction size_z = 0.5 * height -- Start of refinement box 1 (z)  based on height start_z = - 0.25 * height --! [Refinement box 1] --! [Refinement box 2] -- Size of refinement box 2 in x-direction and start of it start2_x = - 0.375 * length size2_x = 0.5 * size_x -- Size of refinement box 2 in y-direction and start of it size2_y = 0.5 * size_y start2_y = - 0.5 * size2_y -- Size of refinement box 2 in z-direction and start of it size2_z = size2_y - dx_half start2_z = start2_y + dx_half / 2.0 --! [Refinement box 2] The patch will then lie around and behind the cylinder. spatial_object = { [...] --! [Refinement box 1 & 2] { attribute = { kind = 'refinement' , level = refinementLevel + level , label = 'box1' }, geometry = { kind = 'canoND' , object = { origin = { start_x , start_y , start_z }, vec = { { size_x , 0.0 , 0.0 }, { 0.0 , size_y , 0.0 }, { 0.0 , 0.0 , size_z } } } } }, { attribute = { kind = 'refinement' , level = refinementLevel2 + level , label = 'box2' }, geometry = { kind = 'canoND' , object = { origin = { start2_x , start2_y , start2_z }, vec = { { size2_x , 0.0 , 0.0 }, { 0.0 , size2_y , 0.0 }, { 0.0 , 0.0 , size2_z } } } } }, --! [Refinement box 1 & 2] [...] } Once you followed through the above explanations, you can visualize the\ngenerated mesh. Therefore use Seeder Harvesting . First, we prepare the config file, defining the folder of the mesh files,\nthe output folder for the vtk file (create the folder first) and the output\nitself. We name the file sdr_harvester.lua . mesh = 'mesh/' output_folder = 'mesh/' output = { format = 'vtk' , dataform = 'binary' , write_pvd = false } Then we can run Seeder Harvesting with: ~/apes/seeder/build/sdr_harvesting harvester.lua Setting up the Musubi Configuration After generating the mesh above, we need to tell Musubi that it\nshould use the above generated mesh. The mesh was stored in the\nfolder mesh . Let's define that along with a name for the simulation mesh = './mesh/' -- Mesh information simulation_name = 'channelRefine' Initial and Boundary Conditions Initial conditions are set to a medium with constant pressure and velocity ic_velX . --! [Initial conditions] initial_condition = { pressure = ic_pressure , velocityX = ic_velX , velocityY = 0.0 , velocityZ = 0.0 , Sxx = ic_Sxx , Syy = ic_Syy , Sxy = ic_Sxy } --! [Initial conditions] Next, we define the variable table for the boundary conditions: --! [User defined variables] -- Mainly used for tracking. -- This variable can be refered to as variable in boundary condition and source variable = { -- Reference pressure dependent on physicsModel { name = 'pressureRef' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureRef }, -- Pressure at inlet { name = 'pressureIn' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureIn }, -- Pressure at outlet { name = 'pressureOut' , ncomponents = 1 , vartype = 'st_fun' , st_fun = pressureOut }, -- Reference shear stress { name = 'stressRef' , ncomponents = 1 , vartype = 'st_fun' , st_fun = stressRef }, -- Difference between numerical pressure and reference pressure { name = 'press_diff' , ncomponents = 1 , vartype = 'operation' , operation = { kind = 'difference' , input_varname = { 'pressure_phy' , 'pressureRef' ,}, }, }, } --! [User defined variables] The boundary conditions are a little bit more complex, as we have\nsolid walls, the cylinder, and also an inlet and an outlet.\nLet's start with the wall boundaries. These include among the walls, which we named\naccording to the directions and the cylinder, which we simply called obs .\nThey all get the property of a simple wall. --! [Boundary conditions] -- Label is a boundary identifier and it should be same as in seeder -- configuration. boundary_condition = { { label = 'north' , kind = 'wall' }, { label = 'south' , kind = 'wall' }, [...] For the outlet, we would like to have a mus_bc_fluid_module \"simple pressure\" boundary\ncondition, with pressure set to pressureOut a variable we defined in\nthe variable table above. [...] { label = 'east' , kind = 'pressure_expol' , pressure = 'pressureOut' } [...] For the inlet we also use pressure_expol boundary condition. [...] { label = 'west' , kind = 'pressure_expol' , pressure = 'pressureIn' }, [...] If we set usePeriodic=false we need to define top and bottom as wall.\nIf we use periodic Seeder will handle the periodic relationship for these\nplanes. -- If we deactivated usePeriodic in seeder.lua, we have to add boundaries for -- top and bottom. if usePeriodic == false then table.insert ( boundary_condition , { label = 'top' , kind = 'wall' } ) table.insert ( boundary_condition , { label = 'bottom' , kind = 'wall' } end Other Simulation Parameters tmax_phy = 10.0 tmax_iter = math.ceil ( tmax_phy / dt ) interval_phy = tmax_phy / 10.0 trac_start = 0.0 rest_start = tmax_phy / 4.0 sim_control = { time_control = { max = { sim = tmax_phy }, interval = { sim = interval_phy }, clock = 3600 --s }, [...] } Tracking We have several different trackers defined. These can be found inside the tracking table. Tracking has been explained in [chapter 03] tracking = { -- Track pressure at the center of the channel over time. { label = 'probeAtCenter' , --label = 'probePressure', folder = 'tracking/' , variable = { 'pressure_phy' }, shape = { kind = 'canoND' , object = { origin = { 0.0 , 0.0 , 0.0 } } }, time_control = { min = { iter = 1 }, interval = { iter = 1 } }, output = { format = 'ascii' }, }, [...] Visualize the Results For visualisation of ascii or ascii-spatial format files you can use for example\nGnuplot or matplotlib module of python. An example script for postprocessing\n( plot_track.py ) can be found inside the example directory. Navigate: Overview","tags":"","loc":"page/examples/tutorials/tut_09_mus_multilevel.html"},{"title":"Prerequisites – Musubi","text":"Warning WORK IN PROGRESS Navigate: Overview Changes in Musubi 2.0 Musubi 2.0 comes with several changes. Old config files will not work any more \nsince some layout and names have been changes. Here is a list of important changes:\n* Added lattice Mach number and lattice velocity check\n* Changed layout names\n* Renamed boundary routine names\n* fluid table: we don't specify omega anymore, now we need kinematic_viscosity \nand bulk_viscosity Bc Names Boundary routine names changed: old name --> new name inlet_bfl                   --> velocity_bfl\ninlet_bfl_incomp            --> velocity_bfl_incomp\ninlet_eq                    --> velocity_eq\ninlet_mfr                   --> mfr_bounceback\ninlet_mfr_eq                --> mfr_eq\ninlet_ubb                   --> velocity_bounceback\ninlet_ubb_incomp            --> velocity_bounceback_incomp moleDens_dirichlet_curved   --> moleDens_nonEqExpol_curved\nmoleDens_dirichlet_straight --> moleDens_nonEqExpol\nmoleDens_neumann_straight   --> moleDens_neumann moments_press               --> pressure_momentsbased\nmoments_press_incomp        --> pressure_momentsbased_incomp\nmoments_vel                 --> velocity_momentsbased\nmoments_vel_incomp          --> velocity_momentsbased_incomp outlet_eq                   --> pressure_eq\noutlet_expol                --> pressure_expol\noutlet_expol_slow           --> pressure_expol_slow\noutlet_pab                  --> pressure_antiBounceBack potential_dirichlet         --> potential_nonEqExpol\npotential_dirichlet_curved  --> potential_nonEqExpol_curved Layout Names lbm  --> fluid\nlbm_incomp --> fluid_incompressible Lattice velocity check When running musubi we check if Lattice velocity exceed the default stability\nthreshold of 0.15. If this happens we abort the simulation and end the code in\na propper way. This theshold can be modified inside the config file via: latv_max = 0.2","tags":"","loc":"page/examples/tutorials/tut_10_Musubi2.html"},{"title":"Feature Overview – Musubi","text":"In this section we introduce a few features of Musubi . Data Structures Scheme Implementation Description of the Multi-Level Algorithm Interpolation methods Multispecies Non-Newtonian Vectorization Musubi-Harvesting Boundary Conditions (module) mus_bc_header_module Tutorial - Boundary Conditions Space-Dependent Definitions tem_load_spatial Transient Definitions tem_load_temporal Space-Time Definitions tem_load_spacetime_single","tags":"","loc":"page/features/index.html"},{"title":"Description of the Multi-Level Algorithm – Musubi","text":"Introductory Comments Here we describe the recursive processing of the level-wise sorted list of\nelements through the kernels.\nFrom the mesh on disk, which was stored as treeIDs, a level-wise collection\nof element lists are created before the computation can be started. These\nlists include ghost and halo cells to account for elements which are missing\nlocally but are calculated on a remote partition as well as missing neighbor\nelements due to level interfaces.\nA detailed description of the mesh generation process and the employed data\nstructures can be found here . All levels are updated starting from the coarsest, updating all schemes. For\neach scheme the following procedure is performed. First, the double buffer index\nis swapped and the boundaries are set. Then the flow field is computed for the\ncurrent timestep (for this level and this scheme). Next, communication with\nadjacent partitions for current level is performed. If multiple levels are\npresent, a recursive part is entered. On a level n, 2*(n-1) times the\ntimesteps of the coarsest level have to be computed. Therefore, the compute\nroutine is called twice for the next finer level. Afterwards, the ghost elements\nhave to be updated again to provide valid values for the fluid elements. First,\nthe coarse ghost elements are updated from fluid elements on the finer level,\nthen they have to be communicated. Same applies for the finer ghost elements.\nAfter all schemes and levels are done, a routine handling output, check and\nrestart is called and the timestep is updated. recursive subroutine compute ( iLevel ) compute_kernel if ( iLevel < maxLevel ) recursive call compute ( iLevel + 1 ) comm FromCoarser recursive call compute ( iLevel + 1 ) fillFromFiner endif comm FromFiner comm if ( iLevel < maxLevel ) fillFromCoarser ( iLevel + 1 ) comm FromCoarser ( iLevel + 1 ) endif end subroutine compute","tags":"","loc":"page/features/comp_proc.html"},{"title":"Data Structures – Musubi","text":"The Octree data structure is mapped to a one-dimensional array in order to have\nan efficient data structure on which the solver can act on in a performant way.\nAn efficient representation of the elements and their neighbor relations is\nchosen. The fluid elements are mapped to a one-dimensional array and the\nneighboring relations are introduced by an additional connectivity array. The\naccess of a neighbor element is performed by looking up the correct position of\nan element's link neighbor in the connectivity array, thus constituting an\nindirect access. The different dependencies of each link in an element require a thorough\ntreatment, when data is exchanged at domain boundaries. Only the links, which\npoint outside the domain have to be sent to neighbor partitions, and the\nlinks pointing inwards have to be filled with valid values from these.","tags":"","loc":"page/features/data_struc.html"},{"title":"Interpolation Methods – Musubi","text":"Multi-Level The idea of multi-level meshes is to increase the resolution only in regions of\nspecial interest. By means of the local refinement only where it is really\nnecessary, a lot of memory and compute time can be saved. To maintain physics,\nthe macroscopic quantities have to be constant across the different levels.\nTherefore the pdf has to be scaled for space and time separately, in order to\ntransfer it from one level to other. This can be achieved by linear or\nquadratic interpolation of the PDF and the use of so called ghost elements.\nFor a better understanding is it visualized in the following figure: The ghost elements are introduced at the level interface, which is the\nintersecting line between two elements of different size. They aim to imitate\nthe neighbor elements that are missing on the same level and obtain their\nvalues from the aforementioned interpolation from coarser to finer element and\nvice versa. Note Target elements are the ghost elements, which have to be filled with\nvalid values. Source elements are the fluid elements from other levels. Interpolation When using multi-level we need to interpolate between the different level of\nour mesh. When we fill the coarser from finer elements we can use an average\noverall elements. To fill the finer elements from coarser is a bit more\ncomplicated. We use different methods to compute the finer elements. By\ndefault, we use the most accurate method: quadratic interpolation. If we do\nnot have enough elements for a quadratic interpolation, we fall back to linear interpolation. Here again, if not enough elements are provided we drop down to weighted average . By changing the interpolation method inside the Musubi config file you can restrict the toplevel interpolation to your chosen\ninterpolation method. Quadratic Interpolation Quadratic interpolation based on the compute stencil. Linear Interpolation Linear interpolation of the first two moments (density and momentum) and\nseparation of equilibrium and non-equilibrium part to account for correct\nshear stress calculation. This fine->coarse interpolation method is based on\nDazhi Yu et. al. (2002): \"A multi-block lattice Boltzmann method for viscous\nfluid flows\". The basic idea is to split up the source pdfs into equilibrium-\nand non-equilibrum- parts, then interpolate both parts with average\ninterpolation, and apply a corrective scaling factor to the non-equilibrium part\nbefore adding both parts up and writing it to the target element. Values are\ninterpolated in a linear fashion by multiplying the quantities of the source\nelements by weighting factors, which were determined in mus_interpolate_module completing the fromCoarser\ndependencies in terms of the distance of the source element's barycenters from\nthe target element's barycenters. Weighted Average Simple averaging of all quantities with weighted summation.\nDefault is linear_distance . The weights can be computed by: linear_distance inverse_distance modified_shepards with: Note Only one weighting method can be chosen at runtime. Config File If one want to specify a special interpolation method, or special\nconfigurations for a special method you can do so by adding the interpolation_method table to your config file. If no table is given,\ndefaults are: method = 'quadratic' weights_method = 'linear_distance' inverse_distance_powerfac = 6 interpolation_method = { -- Supported methods: -- weighted_average, linear, quadratic, compact method = 'quadratic' , -- Supported weights method: -- inverse_distance, linear_distance, modified_shepards weights_method = 'inverse_distance' , -- for inverse_distance: inverse_distance_powerfac = 6 }","tags":"","loc":"page/features/intp_methods.html"},{"title":"Multispecies – Musubi","text":"Navigate: ← Features | Multispecies test case tutorial Multispecies approach implemented in the code is based on the paper\n\"Multi-species Lattice Boltzmann Model and Practical Examples. Short Course\nmaterial Pietro Asinari PhD.\" Equlibrium distribution function for multispecies is given in the paper as where, for and , is molecular weight for species . is given as Relaxation time is given as Multispecies: Variable Transformation A semi-implicit Lattice Boltzmann equation is given as, Variable transformation presented in above paper involves three steps Step 1. Transforming f -> g Step 2. Stream and Collide i.e g -> g&#94;+ Step 3. Back Transormation to f i.e g&#94;+ -> f&#94;+ In back tranformation, to compute feq we need and can be computed directly from g where as the computed by solving the linear\nsystem of equation given below where, is, Todo use for optimized routine fortran\n       !West\n       u_n(1) = - uxstar(s)\n       !south\n       u_n(2) =             - uystar(s)\n       !bottom\n       u_n(3) =                         - uzstar(s)\n       !east\n       u_n(4) =   uxstar(s)\n       !north\n       u_n(5) =               uystar(s)\n       !top\n       u_n(6) =                           uzstar(s)\n       !bottom south\n       u_n(7)\n       !top south\n       u_n(7)\n       !bottom north\n       u_n(7)\n       !top north\n       u_n(7)\n       !bottom west\n       u_n(7)\n       !bo\n       u_n(7)\n       u_n(7)\n       u_n(7)\n       u_n(7) Navigate: ← Features | Multispecies test case tutorial","tags":"","loc":"page/features/multispecies.html"},{"title":"Musubi-Harvesting – Musubi","text":"The former Harvester as a post-processing tool is not existing anymore.\nInstead, there is a new implementation of its functions inside Musubi itself.\nThis one is called Musubi-Harvesting or shortly mus_harvesting. This is why a few things in the handling of post-processing have changed. Inside\nthe Musubi main folder is a sample script that can be used as a template. One\ncan find it normally here: ~/apes/musubi/harvester.lua . In the following, the usage of this tool will be explained. At first, one can define the name of the simulation that will be a part of the\nfilename of the produced files. simulation_name = 'channel2D' This basic information is read with the subroutine tem_load_general .\nIt is stored inside params%solver%simName . The subroutine is called from mus_hvs_config_load . After that, one provide the restart file that one would like to visualize: restart = { read = 'restart/channel2D_lastHeader.lua' } This character is stored inside tem_restartControl_type as 'readFileName'. Then, one defines the verbosity of logging. tem_logging_load_primary is\nlooking for the 'level'. Default is level = 1 in this case. logging = { level = 1 } Then one defines what shall be post-processed with mus_harvesting.\nTherefore the tracking table is needed. tracking = { { -- opens sub table for one tracking element To give the resulting files a useful name one can use the label . Moreover one\ncan provide a special output folder . For both there are default values. label = 'useful_name' , folder = 'here_is_your_output/' , But one must provide the output format of the files. There, one can choose\nbetween vtk , ascii and ascii_spatial . To visualize the data with\nParaview one needs vtk : output = { format = 'vtk' }, Then one can post-process every variable that is defined in the variable\nsystem as a default variable or 'special' ones like a difference that is\nused in the variable table of the Musubi config file. For more information\none can have a look at this page . variable = { 'treeid' , 'solidsphere' , 'density' , 'momentum' }, It is possible to define a region from where one can get the data. Therefore\nthe shape table is used. In this example one gets the data for the whole\ndomain.\nAnother example of defining the shape can be found in tem_load_shape_single . shape = { kind = 'all' }, } -- close tracking sub table } -- close tracking table One should not forget to close the tracking table. But after that the required\nsetting is done. One can run the post-processor from the location of the config\nfile: ~/apes/musubi/build/mus_harvesting harvester.lua After that, one can visualise the output with Paraview. There is a tutorial for\nthis software that one can find easily at Youtube. The next part will be the tutorial for creating a dataset over all time steps. Therefore one needs two files, the config file template harvest_series.template and the config file for the python script series.config . The template file looks quite similar to the previously introduced harvester.lua .\nThe first step is to make the use of data from the Musubi config file possible.\nWith require one can provide the lua config file. Remember that the filename\nwithout the lua extension is needed here. Next, one needs the restart input files. Here one makes use of the $!...!$ writing that indicates a placeholder that is configured inside the python\nscript. $!file!$ is the placeholder for the input files. After that, one defines the tracking in the same way like mentioned before.\nBut for the output folder one can use the placeholder $!out!$ . require 'musubi' restart . read = '$!file!$' tracking = { { label = 'useful_name' , variable = { 'density' }, shape = { kind = 'all' }, -- same as: shape = { kind = 'global' } folder = '$!out!$' , output = { format = 'vtk' }, } } After that, one configures the python input file that is called series.config .\nIn this case one must define the input files, the output folder, the path to\npost-processor executable, the location of the template file, and the path to\nthe lua executable. # input files: files : * _header_ *. lua # for all header files # Lua path: lua : ~/ apes / musubi / build / treelm / aotus / lua # post processor: harvester : ~/ apes / musubi / build / mus_harvesting # template file: template : harvest_series . template # output folder: out : ./ output / One can run this script with: ~/apes/musubi/treelm/peons/harvest_series.py -c series.config Another example of how to configure the harvester.lua file: variable = { { name = 'velX' , ncomponents = 1 , vartype = 'operation' , operation = { kind = 'extract' , input_varname = { 'velocity' }, input_varindex = { 1 } } } }, tracking = { { label = 'vtk' , variable = { 'velX' }, shape = { kind = 'all' }, output = { format = 'vtk' } } }","tags":"","loc":"page/features/mus_hvs_scheme_impl.html"},{"title":"Non-Newtonian Fluid Simulations – Musubi","text":"Theory For this type of fluid, its viscosity is not constant anymore, but dependent on\nthe strain rate. So the relaxation parameter in LBM needs to be adjusted at\nevery timestep, bacause viscosity is related to relaxation. In the following two common models are described, namely the Casson and the\nCarreau-Yasuda model. A detailed description can be found in \\cite Boyd2007 . Common Basis First, the strain rate tensor needs to be calculated: where is approxiamated by . Then, the second invariant of the strain rate tensor is defined as where in the case of 3D and the shear rate ( ) as The Casson Model The Casson model is one of those used to describe the shear thinning behavior\nof blood. Its viscosity updating rule is: where and are functions of the hematocrit.\nOne set of these two parameters can be: The Carreau-Yasuda Model After getting shear rate, a non-Newtonian model can be applied to update local\ndynamic viscosity. The most common one used in hemodynamics is called\nCarreau-Yasuda model, which models for the shear thinning behavior of blood.\nThe equation is following, where and are empirically\ndetermined constant parameters. and are dimensionless; has units of s. one set of parameters is: Next, convert dynamic viscosity to kinematic viscosity: As the viscosity is in physical units, it has to be convert into LB units: Finally, the relaxation parameter - can be obtained from :","tags":"","loc":"page/features/mus_nonNewtonianTheory.html"},{"title":"Vectorization – Musubi","text":"Vectorization Introduction Today’s CPUs are highly parallel processors with different levels of parallelism.\nWe find parallelism everywhere from the parallel execution units in a CPU core,\nup to the SIMD (Single Instruction, Multiple Data) instruction set and the\nparallel execution of multiple threads. The use of the Intel SIMD instruction\nset (e.g. SSE, AVX), which is an extension to the x86 architecture, is called\nvectorization. An easy way to vectorize a Fortran code is to let compiler perform\nauto-vectorization. Afterwards, one can examine the compiler report and make\nsure that the compiler really does the correct vectorization. In Musubi , one must use the Structure of Array (SOA) data layout and the\ncomputer kernel must be implemented in a Block Loop pattern. Such an example can\nbe found in mus_d3q19_module . Modern CPU often equipped with a cache structure. The data transfer between CPU\nand memory has to go through the cache. Normally, when the CPU wants to write\ndata to the memory, if the data is not in the cache at that moment, the CPU will\nfirst load the data from memory to cache, then modify its value and finally\ntransfer data from cache to memory back. During this writing process, data were \ntransfer through memory interface twice. Non-temporal stores (also called \" streaming stores \")\ndo not require a prior cache line read for ownership (RFO) but write to memory\n\"directly\". In this way the writing process requires data transfer only once !\nUnder such situation, the memory transfer requirement per element in LBM becomes , for the D3Q19 stencil. How to Enable Streaming Stores On machines with Intel CPU, one needs to use Intel Fortran compiler and fulfill\nthe following key points: Instruct the compiler to align the state array which can not reside with a\n    derived data type. real ( kind = rk ), allocatable :: state (:,:) !IBM* align(32, state) !dir$ attributes align : 32 :: state Padding is needed to insure the size of the array to be a factor of 4. remainder = mod( me%nElems_local, 4 )\nme%nSize  = me%nElems_local + mod(4 - remainder, 4)\nallocate( state( me%nSize, 2 ) ) Use compiler directive before the loop to perform streaming store. !DIR$ IVDEP !DIR$ VECTOR aligned nontemporal (outState) do iLink = 1 , ... outState ( iLink ) = ... end do Finally, one has to check the compiler report to make sure that the compiler\nreally generate streaming stores. LOOP BEGIN at / zhome / academic / HLRS / pri / iprjiaqi / apes / musubi / build / source / compute / mus_compute_d3q19_module . f90 ( 213 , 7 ) remark #15388: vectorization support: reference outstate has aligned access remark #15388: vectorization support: reference f000 has aligned access remark #15388: vectorization support: reference usqn_o1 has aligned access remark #15412: vectorization support: streaming store was generated for outstate remark #15300: LOOP WAS VECTORIZED remark #15448: unmasked aligned unit stride loads: 2 remark #15449: unmasked aligned unit stride stores: 1 remark #15467: unmasked aligned streaming stores: 1 remark #15475: --- begin vector loop cost summary --- remark #15476: scalar loop cost: 10 remark #15477: vector loop cost: 2.250 remark #15478: estimated potential speedup: 4.430 remark #15479: lightweight vector operations: 9 remark #15488: --- end vector loop cost summary --- LOOP END LOOP BEGIN at / zhome / academic / HLRS / pri / iprjiaqi / apes / musubi / build / source / compute / mus_compute_d3q19_module . f90 ( 223 , 7 ) remark #15388: vectorization support: reference u_x has aligned access remark #15388: vectorization support: reference u_y has aligned access remark #15388: vectorization support: reference rho has aligned access remark #15388: vectorization support: reference outstate has aligned access remark #15388: vectorization support: reference f110 has aligned access remark #15388: vectorization support: reference usqn_o1 has aligned access remark #15412: vectorization support: streaming store was generated for outstate remark #15300: LOOP WAS VECTORIZED remark #15448: unmasked aligned unit stride loads: 5 remark #15449: unmasked aligned unit stride stores: 1 remark #15467: unmasked aligned streaming stores: 1 remark #15475: --- begin vector loop cost summary --- remark #15476: scalar loop cost: 28 remark #15477: vector loop cost: 6.750 remark #15478: estimated potential speedup: 4.130 remark #15479: lightweight vector operations: 27 remark #15488: --- end vector loop cost summary --- LOOP END","tags":"","loc":"page/features/mus_vectorization.html"},{"title":"Scheme Implementation – Musubi","text":"The concept of schemes provides the user with a bigger flexibility. It is now\npossible to run multiple simulations with different layouts on the same mesh.\nThis is the basis for LBM passive scalar transport simulations in Musubi . Scheme Definition The scheme is part of the individual solvers and contains all information about\ninitial conditions, boundary conditions, the mus_scheme_layout_module , fluid\nand flow properties. Usage To start a flow simulation one can add the table species with the following\nquantities: the scheme header which includes kind, relaxation, layout:\n  take a look at mus_scheme_header_module the initial conditions, take a look at mus_set_ic_states for a list of variables that are supported for the different schemes the boundary conditions, take a look at mus_bc_header_module for the different cases of possible boundary conditions in Musubi the fluid quantities. For all supported input variables check mus_load_fluid --! [Scheme identifier] identify = { layout = stencil , relaxation = relaxationModel , kind = physicsModel } --! [Scheme identifier] --! [Initial conditions] initial_condition = { pressure = ic_pressure , velocityX = ic_velX , velocityY = 0.0 , velocityZ = 0.0 , Sxx = ic_Sxx , Syy = ic_Syy , Sxy = ic_Sxy } --! [Initial conditions] --! [Boundary conditions] -- Label is a boundary identifier and it should be same as in seeder -- configuration. boundary_condition = { { label = 'north' , kind = 'wall' }, { label = 'south' , kind = 'wall' }, { label = 'west' , kind = 'pressure_expol' , pressure = pressureIn }, { label = 'east' , kind = 'pressure_expol' , pressure = pressureOut } } --! [Boundary conditions] --! [Fluid] -- For both, incompressible and compressible kinematic viscosity has to be -- defined. While for the first one, default values are stored for bulk -- viscosity,, the user has to explicitly give them for compr. fluid. if ( physicsModel == 'fluid' ) then fluid = { kinematic_viscosity = nu_phy , bulk_viscosity = bulk_visc } else fluid = { kinematic_viscosity = nu_phy , } end --! [Fluid]","tags":"","loc":"page/features/scheme.html"},{"title":"Build and run Musubi – Musubi","text":"Subsequently is a short explanation on how to use Musubi: Checkout: git clone --recurse-submodules git@github.com:apes-suite/musubi.git then you have the repository with sub-repos aotus and treelm in the folder musubi .\n- Note: You need MPI in order to compile the code. Set environment variables export CC=mpicc export FC=mpif90 Configure bin/waf configure Build bin/waf build Change settings in musubi.lua Run build/musubi You will get .vtk files, if you have activated the output in musubi.lua .  The current test case is a Gaussian Pulse with a wall in\norder to test the correct behavior of the bounce back boundaries. Configuration options There are several configuration options available to influence the build.\nYou can obtain a list of those with ./waf --help . It is possible to choose between the \"PULL\" (default) and \"PUSH\" streaming\napproach via the --stream=PULL or --stream=PUSH option. Build variants Aside from the default build , there is also a debug target\nwhich creates an executable with debugging information.\nOther variants, for example for performance profiling can be found in the output\nof bin/waf --help Coco preprocessing Musubi utilizes the CoCo preprocessor to modify code at compile time.\nIts behavior can be modified by changing the default.coco file, and\nby setting the COCOFLAGS environment variable. Limiting what is build It is possible to restrict to build to individual targets with the --targets option.\nFor example to only build the musubi and mus_harvesting executables, add the option --targets=musubi,mus_harvesting to the waf\ncommand. Generate a geometry A different geometry can be generated with the tree-based Mesh generator Seeder. Build and run Seeder Checkout: git clone --recurse-submodules git@github.com:apes-suite/seeder.git then you have the repository with sub-repos aotus and treelm in the folder seeder . Note: You need MPI in order to compile the code (though seeder does not make\n  use of the MPI parallelism right now). Set environment variables export CC=mpicc export FC=mpif90 Configure bin/waf configure Build bin/waf build Generate mesh folder in current folder: mkdir ./mesh Change settings in input/config.lua . Specify the STL file(s) and set\n  the min and max tree levels.\n  Note: In the current version, Musubi only supports uniform grids, which can be\n  generated by setting maxrefine = minrefine . Run ./build/seeder input/config.lua Generated mesh is in the mesh/ folder Copy all files from mesh to the musubi mesh folder ../musubi/mesh You will receive a VTK file, in order to check the fluid domain. The fluid is\nidentified by placing the seed in the correct position in seeder.f90, which\nwill be changed later. A good start is in the first position, just make sure\nthat it is part of the continuous fluid domain. The parallel version has not been tackled yet but has a high priority on our\ntask-list.\nThe next step will be parallel functionality and inlet/outlet boundaries. Please make sure to check out musubi and start a few runs.\nPlease also report any bugs here in the tickets. Note After updating a new version of Musubi you better do ./waf configure build .\nSometimes you need to clean the coco macro files.\nThen you do ./waf clean build .\nTo remove the source and the configuration files you type ./waf distclean configure build .\nAnd if you want to remove the coco executables itself you will type ./waf cleanall configure build .","tags":"","loc":"page/usage/index.html"}]}